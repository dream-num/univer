"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __decorateClass = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
    for (var i4 = decorators.length - 1, decorator; i4 >= 0; i4--)
      if (decorator = decorators[i4])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result)
      __defProp(target, key, result);
    return result;
  };
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // ../../node_modules/.pnpm/dayjs@1.11.7/node_modules/dayjs/dayjs.min.js
  var require_dayjs_min = __commonJS({
    "../../node_modules/.pnpm/dayjs@1.11.7/node_modules/dayjs/dayjs.min.js"(exports, module) {
      !function(t4, e4) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = e4() : "function" == typeof define && define.amd ? define(e4) : (t4 = "undefined" != typeof globalThis ? globalThis : t4 || self).dayjs = e4();
      }(exports, function() {
        "use strict";
        var t4 = 1e3, e4 = 6e4, n3 = 36e5, r4 = "millisecond", i4 = "second", s4 = "minute", u4 = "hour", a4 = "day", o4 = "week", f4 = "month", h4 = "quarter", c4 = "year", d4 = "date", l4 = "Invalid Date", $3 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y4 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t5) {
          var e5 = ["th", "st", "nd", "rd"], n4 = t5 % 100;
          return "[" + t5 + (e5[(n4 - 20) % 10] || e5[n4] || e5[0]) + "]";
        } }, m4 = function(t5, e5, n4) {
          var r5 = String(t5);
          return !r5 || r5.length >= e5 ? t5 : "" + Array(e5 + 1 - r5.length).join(n4) + t5;
        }, v4 = { s: m4, z: function(t5) {
          var e5 = -t5.utcOffset(), n4 = Math.abs(e5), r5 = Math.floor(n4 / 60), i5 = n4 % 60;
          return (e5 <= 0 ? "+" : "-") + m4(r5, 2, "0") + ":" + m4(i5, 2, "0");
        }, m: function t5(e5, n4) {
          if (e5.date() < n4.date())
            return -t5(n4, e5);
          var r5 = 12 * (n4.year() - e5.year()) + (n4.month() - e5.month()), i5 = e5.clone().add(r5, f4), s5 = n4 - i5 < 0, u5 = e5.clone().add(r5 + (s5 ? -1 : 1), f4);
          return +(-(r5 + (n4 - i5) / (s5 ? i5 - u5 : u5 - i5)) || 0);
        }, a: function(t5) {
          return t5 < 0 ? Math.ceil(t5) || 0 : Math.floor(t5);
        }, p: function(t5) {
          return { M: f4, y: c4, w: o4, d: a4, D: d4, h: u4, m: s4, s: i4, ms: r4, Q: h4 }[t5] || String(t5 || "").toLowerCase().replace(/s$/, "");
        }, u: function(t5) {
          return void 0 === t5;
        } }, g5 = "en", D3 = {};
        D3[g5] = M2;
        var p4 = function(t5) {
          return t5 instanceof _4;
        }, S3 = function t5(e5, n4, r5) {
          var i5;
          if (!e5)
            return g5;
          if ("string" == typeof e5) {
            var s5 = e5.toLowerCase();
            D3[s5] && (i5 = s5), n4 && (D3[s5] = n4, i5 = s5);
            var u5 = e5.split("-");
            if (!i5 && u5.length > 1)
              return t5(u5[0]);
          } else {
            var a5 = e5.name;
            D3[a5] = e5, i5 = a5;
          }
          return !r5 && i5 && (g5 = i5), i5 || !r5 && g5;
        }, w4 = function(t5, e5) {
          if (p4(t5))
            return t5.clone();
          var n4 = "object" == typeof e5 ? e5 : {};
          return n4.date = t5, n4.args = arguments, new _4(n4);
        }, O2 = v4;
        O2.l = S3, O2.i = p4, O2.w = function(t5, e5) {
          return w4(t5, { locale: e5.$L, utc: e5.$u, x: e5.$x, $offset: e5.$offset });
        };
        var _4 = function() {
          function M3(t5) {
            this.$L = S3(t5.locale, null, true), this.parse(t5);
          }
          var m5 = M3.prototype;
          return m5.parse = function(t5) {
            this.$d = function(t6) {
              var e5 = t6.date, n4 = t6.utc;
              if (null === e5)
                return /* @__PURE__ */ new Date(NaN);
              if (O2.u(e5))
                return /* @__PURE__ */ new Date();
              if (e5 instanceof Date)
                return new Date(e5);
              if ("string" == typeof e5 && !/Z$/i.test(e5)) {
                var r5 = e5.match($3);
                if (r5) {
                  var i5 = r5[2] - 1 || 0, s5 = (r5[7] || "0").substring(0, 3);
                  return n4 ? new Date(Date.UTC(r5[1], i5, r5[3] || 1, r5[4] || 0, r5[5] || 0, r5[6] || 0, s5)) : new Date(r5[1], i5, r5[3] || 1, r5[4] || 0, r5[5] || 0, r5[6] || 0, s5);
                }
              }
              return new Date(e5);
            }(t5), this.$x = t5.x || {}, this.init();
          }, m5.init = function() {
            var t5 = this.$d;
            this.$y = t5.getFullYear(), this.$M = t5.getMonth(), this.$D = t5.getDate(), this.$W = t5.getDay(), this.$H = t5.getHours(), this.$m = t5.getMinutes(), this.$s = t5.getSeconds(), this.$ms = t5.getMilliseconds();
          }, m5.$utils = function() {
            return O2;
          }, m5.isValid = function() {
            return !(this.$d.toString() === l4);
          }, m5.isSame = function(t5, e5) {
            var n4 = w4(t5);
            return this.startOf(e5) <= n4 && n4 <= this.endOf(e5);
          }, m5.isAfter = function(t5, e5) {
            return w4(t5) < this.startOf(e5);
          }, m5.isBefore = function(t5, e5) {
            return this.endOf(e5) < w4(t5);
          }, m5.$g = function(t5, e5, n4) {
            return O2.u(t5) ? this[e5] : this.set(n4, t5);
          }, m5.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, m5.valueOf = function() {
            return this.$d.getTime();
          }, m5.startOf = function(t5, e5) {
            var n4 = this, r5 = !!O2.u(e5) || e5, h5 = O2.p(t5), l5 = function(t6, e6) {
              var i5 = O2.w(n4.$u ? Date.UTC(n4.$y, e6, t6) : new Date(n4.$y, e6, t6), n4);
              return r5 ? i5 : i5.endOf(a4);
            }, $4 = function(t6, e6) {
              return O2.w(n4.toDate()[t6].apply(n4.toDate("s"), (r5 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e6)), n4);
            }, y5 = this.$W, M4 = this.$M, m6 = this.$D, v5 = "set" + (this.$u ? "UTC" : "");
            switch (h5) {
              case c4:
                return r5 ? l5(1, 0) : l5(31, 11);
              case f4:
                return r5 ? l5(1, M4) : l5(0, M4 + 1);
              case o4:
                var g6 = this.$locale().weekStart || 0, D4 = (y5 < g6 ? y5 + 7 : y5) - g6;
                return l5(r5 ? m6 - D4 : m6 + (6 - D4), M4);
              case a4:
              case d4:
                return $4(v5 + "Hours", 0);
              case u4:
                return $4(v5 + "Minutes", 1);
              case s4:
                return $4(v5 + "Seconds", 2);
              case i4:
                return $4(v5 + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, m5.endOf = function(t5) {
            return this.startOf(t5, false);
          }, m5.$set = function(t5, e5) {
            var n4, o5 = O2.p(t5), h5 = "set" + (this.$u ? "UTC" : ""), l5 = (n4 = {}, n4[a4] = h5 + "Date", n4[d4] = h5 + "Date", n4[f4] = h5 + "Month", n4[c4] = h5 + "FullYear", n4[u4] = h5 + "Hours", n4[s4] = h5 + "Minutes", n4[i4] = h5 + "Seconds", n4[r4] = h5 + "Milliseconds", n4)[o5], $4 = o5 === a4 ? this.$D + (e5 - this.$W) : e5;
            if (o5 === f4 || o5 === c4) {
              var y5 = this.clone().set(d4, 1);
              y5.$d[l5]($4), y5.init(), this.$d = y5.set(d4, Math.min(this.$D, y5.daysInMonth())).$d;
            } else
              l5 && this.$d[l5]($4);
            return this.init(), this;
          }, m5.set = function(t5, e5) {
            return this.clone().$set(t5, e5);
          }, m5.get = function(t5) {
            return this[O2.p(t5)]();
          }, m5.add = function(r5, h5) {
            var d5, l5 = this;
            r5 = Number(r5);
            var $4 = O2.p(h5), y5 = function(t5) {
              var e5 = w4(l5);
              return O2.w(e5.date(e5.date() + Math.round(t5 * r5)), l5);
            };
            if ($4 === f4)
              return this.set(f4, this.$M + r5);
            if ($4 === c4)
              return this.set(c4, this.$y + r5);
            if ($4 === a4)
              return y5(1);
            if ($4 === o4)
              return y5(7);
            var M4 = (d5 = {}, d5[s4] = e4, d5[u4] = n3, d5[i4] = t4, d5)[$4] || 1, m6 = this.$d.getTime() + r5 * M4;
            return O2.w(m6, this);
          }, m5.subtract = function(t5, e5) {
            return this.add(-1 * t5, e5);
          }, m5.format = function(t5) {
            var e5 = this, n4 = this.$locale();
            if (!this.isValid())
              return n4.invalidDate || l4;
            var r5 = t5 || "YYYY-MM-DDTHH:mm:ssZ", i5 = O2.z(this), s5 = this.$H, u5 = this.$m, a5 = this.$M, o5 = n4.weekdays, f5 = n4.months, h5 = function(t6, n5, i6, s6) {
              return t6 && (t6[n5] || t6(e5, r5)) || i6[n5].slice(0, s6);
            }, c5 = function(t6) {
              return O2.s(s5 % 12 || 12, t6, "0");
            }, d5 = n4.meridiem || function(t6, e6, n5) {
              var r6 = t6 < 12 ? "AM" : "PM";
              return n5 ? r6.toLowerCase() : r6;
            }, $4 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a5 + 1, MM: O2.s(a5 + 1, 2, "0"), MMM: h5(n4.monthsShort, a5, f5, 3), MMMM: h5(f5, a5), D: this.$D, DD: O2.s(this.$D, 2, "0"), d: String(this.$W), dd: h5(n4.weekdaysMin, this.$W, o5, 2), ddd: h5(n4.weekdaysShort, this.$W, o5, 3), dddd: o5[this.$W], H: String(s5), HH: O2.s(s5, 2, "0"), h: c5(1), hh: c5(2), a: d5(s5, u5, true), A: d5(s5, u5, false), m: String(u5), mm: O2.s(u5, 2, "0"), s: String(this.$s), ss: O2.s(this.$s, 2, "0"), SSS: O2.s(this.$ms, 3, "0"), Z: i5 };
            return r5.replace(y4, function(t6, e6) {
              return e6 || $4[t6] || i5.replace(":", "");
            });
          }, m5.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, m5.diff = function(r5, d5, l5) {
            var $4, y5 = O2.p(d5), M4 = w4(r5), m6 = (M4.utcOffset() - this.utcOffset()) * e4, v5 = this - M4, g6 = O2.m(this, M4);
            return g6 = ($4 = {}, $4[c4] = g6 / 12, $4[f4] = g6, $4[h4] = g6 / 3, $4[o4] = (v5 - m6) / 6048e5, $4[a4] = (v5 - m6) / 864e5, $4[u4] = v5 / n3, $4[s4] = v5 / e4, $4[i4] = v5 / t4, $4)[y5] || v5, l5 ? g6 : O2.a(g6);
          }, m5.daysInMonth = function() {
            return this.endOf(f4).$D;
          }, m5.$locale = function() {
            return D3[this.$L];
          }, m5.locale = function(t5, e5) {
            if (!t5)
              return this.$L;
            var n4 = this.clone(), r5 = S3(t5, e5, true);
            return r5 && (n4.$L = r5), n4;
          }, m5.clone = function() {
            return O2.w(this.$d, this);
          }, m5.toDate = function() {
            return new Date(this.valueOf());
          }, m5.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, m5.toISOString = function() {
            return this.$d.toISOString();
          }, m5.toString = function() {
            return this.$d.toUTCString();
          }, M3;
        }(), T5 = _4.prototype;
        return w4.prototype = T5, [["$ms", r4], ["$s", i4], ["$m", s4], ["$H", u4], ["$W", a4], ["$M", f4], ["$y", c4], ["$D", d4]].forEach(function(t5) {
          T5[t5[1]] = function(e5) {
            return this.$g(e5, t5[0], t5[1]);
          };
        }), w4.extend = function(t5, e5) {
          return t5.$i || (t5(e5, _4, w4), t5.$i = true), w4;
        }, w4.locale = S3, w4.isDayjs = p4, w4.unix = function(t5) {
          return w4(1e3 * t5);
        }, w4.en = D3[g5], w4.Ls = D3, w4.p = {}, w4;
      });
    }
  });

  // ../../node_modules/.pnpm/numeral@2.0.6/node_modules/numeral/numeral.js
  var require_numeral = __commonJS({
    "../../node_modules/.pnpm/numeral@2.0.6/node_modules/numeral/numeral.js"(exports, module) {
      (function(global2, factory) {
        if (typeof define === "function" && define.amd) {
          define(factory);
        } else if (typeof module === "object" && module.exports) {
          module.exports = factory();
        } else {
          global2.numeral = factory();
        }
      })(exports, function() {
        var numeral2, _4, VERSION = "2.0.6", formats = {}, locales = {}, defaults2 = {
          currentLocale: "en",
          zeroFormat: null,
          nullFormat: null,
          defaultFormat: "0,0",
          scalePercentBy100: true
        }, options = {
          currentLocale: defaults2.currentLocale,
          zeroFormat: defaults2.zeroFormat,
          nullFormat: defaults2.nullFormat,
          defaultFormat: defaults2.defaultFormat,
          scalePercentBy100: defaults2.scalePercentBy100
        };
        function Numeral(input, number) {
          this._input = input;
          this._value = number;
        }
        numeral2 = function(input) {
          var value, kind, unformatFunction, regexp;
          if (numeral2.isNumeral(input)) {
            value = input.value();
          } else if (input === 0 || typeof input === "undefined") {
            value = 0;
          } else if (input === null || _4.isNaN(input)) {
            value = null;
          } else if (typeof input === "string") {
            if (options.zeroFormat && input === options.zeroFormat) {
              value = 0;
            } else if (options.nullFormat && input === options.nullFormat || !input.replace(/[^0-9]+/g, "").length) {
              value = null;
            } else {
              for (kind in formats) {
                regexp = typeof formats[kind].regexps.unformat === "function" ? formats[kind].regexps.unformat() : formats[kind].regexps.unformat;
                if (regexp && input.match(regexp)) {
                  unformatFunction = formats[kind].unformat;
                  break;
                }
              }
              unformatFunction = unformatFunction || numeral2._.stringToNumber;
              value = unformatFunction(input);
            }
          } else {
            value = Number(input) || null;
          }
          return new Numeral(input, value);
        };
        numeral2.version = VERSION;
        numeral2.isNumeral = function(obj) {
          return obj instanceof Numeral;
        };
        numeral2._ = _4 = {
          // formats numbers separators, decimals places, signs, abbreviations
          numberToFormat: function(value, format, roundingFunction) {
            var locale = locales[numeral2.options.currentLocale], negP = false, optDec = false, leadingCount = 0, abbr = "", trillion = 1e12, billion = 1e9, million = 1e6, thousand = 1e3, decimal2 = "", neg = false, abbrForce, abs, min, max, power, int, precision, signed, thousands, output;
            value = value || 0;
            abs = Math.abs(value);
            if (numeral2._.includes(format, "(")) {
              negP = true;
              format = format.replace(/[\(|\)]/g, "");
            } else if (numeral2._.includes(format, "+") || numeral2._.includes(format, "-")) {
              signed = numeral2._.includes(format, "+") ? format.indexOf("+") : value < 0 ? format.indexOf("-") : -1;
              format = format.replace(/[\+|\-]/g, "");
            }
            if (numeral2._.includes(format, "a")) {
              abbrForce = format.match(/a(k|m|b|t)?/);
              abbrForce = abbrForce ? abbrForce[1] : false;
              if (numeral2._.includes(format, " a")) {
                abbr = " ";
              }
              format = format.replace(new RegExp(abbr + "a[kmbt]?"), "");
              if (abs >= trillion && !abbrForce || abbrForce === "t") {
                abbr += locale.abbreviations.trillion;
                value = value / trillion;
              } else if (abs < trillion && abs >= billion && !abbrForce || abbrForce === "b") {
                abbr += locale.abbreviations.billion;
                value = value / billion;
              } else if (abs < billion && abs >= million && !abbrForce || abbrForce === "m") {
                abbr += locale.abbreviations.million;
                value = value / million;
              } else if (abs < million && abs >= thousand && !abbrForce || abbrForce === "k") {
                abbr += locale.abbreviations.thousand;
                value = value / thousand;
              }
            }
            if (numeral2._.includes(format, "[.]")) {
              optDec = true;
              format = format.replace("[.]", ".");
            }
            int = value.toString().split(".")[0];
            precision = format.split(".")[1];
            thousands = format.indexOf(",");
            leadingCount = (format.split(".")[0].split(",")[0].match(/0/g) || []).length;
            if (precision) {
              if (numeral2._.includes(precision, "[")) {
                precision = precision.replace("]", "");
                precision = precision.split("[");
                decimal2 = numeral2._.toFixed(value, precision[0].length + precision[1].length, roundingFunction, precision[1].length);
              } else {
                decimal2 = numeral2._.toFixed(value, precision.length, roundingFunction);
              }
              int = decimal2.split(".")[0];
              if (numeral2._.includes(decimal2, ".")) {
                decimal2 = locale.delimiters.decimal + decimal2.split(".")[1];
              } else {
                decimal2 = "";
              }
              if (optDec && Number(decimal2.slice(1)) === 0) {
                decimal2 = "";
              }
            } else {
              int = numeral2._.toFixed(value, 0, roundingFunction);
            }
            if (abbr && !abbrForce && Number(int) >= 1e3 && abbr !== locale.abbreviations.trillion) {
              int = String(Number(int) / 1e3);
              switch (abbr) {
                case locale.abbreviations.thousand:
                  abbr = locale.abbreviations.million;
                  break;
                case locale.abbreviations.million:
                  abbr = locale.abbreviations.billion;
                  break;
                case locale.abbreviations.billion:
                  abbr = locale.abbreviations.trillion;
                  break;
              }
            }
            if (numeral2._.includes(int, "-")) {
              int = int.slice(1);
              neg = true;
            }
            if (int.length < leadingCount) {
              for (var i4 = leadingCount - int.length; i4 > 0; i4--) {
                int = "0" + int;
              }
            }
            if (thousands > -1) {
              int = int.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1" + locale.delimiters.thousands);
            }
            if (format.indexOf(".") === 0) {
              int = "";
            }
            output = int + decimal2 + (abbr ? abbr : "");
            if (negP) {
              output = (negP && neg ? "(" : "") + output + (negP && neg ? ")" : "");
            } else {
              if (signed >= 0) {
                output = signed === 0 ? (neg ? "-" : "+") + output : output + (neg ? "-" : "+");
              } else if (neg) {
                output = "-" + output;
              }
            }
            return output;
          },
          // unformats numbers separators, decimals places, signs, abbreviations
          stringToNumber: function(string) {
            var locale = locales[options.currentLocale], stringOriginal = string, abbreviations = {
              thousand: 3,
              million: 6,
              billion: 9,
              trillion: 12
            }, abbreviation, value, i4, regexp;
            if (options.zeroFormat && string === options.zeroFormat) {
              value = 0;
            } else if (options.nullFormat && string === options.nullFormat || !string.replace(/[^0-9]+/g, "").length) {
              value = null;
            } else {
              value = 1;
              if (locale.delimiters.decimal !== ".") {
                string = string.replace(/\./g, "").replace(locale.delimiters.decimal, ".");
              }
              for (abbreviation in abbreviations) {
                regexp = new RegExp("[^a-zA-Z]" + locale.abbreviations[abbreviation] + "(?:\\)|(\\" + locale.currency.symbol + ")?(?:\\))?)?$");
                if (stringOriginal.match(regexp)) {
                  value *= Math.pow(10, abbreviations[abbreviation]);
                  break;
                }
              }
              value *= (string.split("-").length + Math.min(string.split("(").length - 1, string.split(")").length - 1)) % 2 ? 1 : -1;
              string = string.replace(/[^0-9\.]+/g, "");
              value *= Number(string);
            }
            return value;
          },
          isNaN: function(value) {
            return typeof value === "number" && isNaN(value);
          },
          includes: function(string, search) {
            return string.indexOf(search) !== -1;
          },
          insert: function(string, subString, start) {
            return string.slice(0, start) + subString + string.slice(start);
          },
          reduce: function(array, callback) {
            if (this === null) {
              throw new TypeError("Array.prototype.reduce called on null or undefined");
            }
            if (typeof callback !== "function") {
              throw new TypeError(callback + " is not a function");
            }
            var t4 = Object(array), len = t4.length >>> 0, k5 = 0, value;
            if (arguments.length === 3) {
              value = arguments[2];
            } else {
              while (k5 < len && !(k5 in t4)) {
                k5++;
              }
              if (k5 >= len) {
                throw new TypeError("Reduce of empty array with no initial value");
              }
              value = t4[k5++];
            }
            for (; k5 < len; k5++) {
              if (k5 in t4) {
                value = callback(value, t4[k5], k5, t4);
              }
            }
            return value;
          },
          /**
           * Computes the multiplier necessary to make x >= 1,
           * effectively eliminating miscalculations caused by
           * finite precision.
           */
          multiplier: function(x4) {
            var parts = x4.toString().split(".");
            return parts.length < 2 ? 1 : Math.pow(10, parts[1].length);
          },
          /**
           * Given a variable number of arguments, returns the maximum
           * multiplier that must be used to normalize an operation involving
           * all of them.
           */
          correctionFactor: function() {
            var args = Array.prototype.slice.call(arguments);
            return args.reduce(function(accum, next) {
              var mn = _4.multiplier(next);
              return accum > mn ? accum : mn;
            }, 1);
          },
          /**
           * Implementation of toFixed() that treats floats more like decimals
           *
           * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
           * problems for accounting- and finance-related software.
           */
          toFixed: function(value, maxDecimals, roundingFunction, optionals) {
            var splitValue = value.toString().split("."), minDecimals = maxDecimals - (optionals || 0), boundedPrecision, optionalsRegExp, power, output;
            if (splitValue.length === 2) {
              boundedPrecision = Math.min(Math.max(splitValue[1].length, minDecimals), maxDecimals);
            } else {
              boundedPrecision = minDecimals;
            }
            power = Math.pow(10, boundedPrecision);
            output = (roundingFunction(value + "e+" + boundedPrecision) / power).toFixed(boundedPrecision);
            if (optionals > maxDecimals - boundedPrecision) {
              optionalsRegExp = new RegExp("\\.?0{1," + (optionals - (maxDecimals - boundedPrecision)) + "}$");
              output = output.replace(optionalsRegExp, "");
            }
            return output;
          }
        };
        numeral2.options = options;
        numeral2.formats = formats;
        numeral2.locales = locales;
        numeral2.locale = function(key) {
          if (key) {
            options.currentLocale = key.toLowerCase();
          }
          return options.currentLocale;
        };
        numeral2.localeData = function(key) {
          if (!key) {
            return locales[options.currentLocale];
          }
          key = key.toLowerCase();
          if (!locales[key]) {
            throw new Error("Unknown locale : " + key);
          }
          return locales[key];
        };
        numeral2.reset = function() {
          for (var property in defaults2) {
            options[property] = defaults2[property];
          }
        };
        numeral2.zeroFormat = function(format) {
          options.zeroFormat = typeof format === "string" ? format : null;
        };
        numeral2.nullFormat = function(format) {
          options.nullFormat = typeof format === "string" ? format : null;
        };
        numeral2.defaultFormat = function(format) {
          options.defaultFormat = typeof format === "string" ? format : "0.0";
        };
        numeral2.register = function(type, name, format) {
          name = name.toLowerCase();
          if (this[type + "s"][name]) {
            throw new TypeError(name + " " + type + " already registered.");
          }
          this[type + "s"][name] = format;
          return format;
        };
        numeral2.validate = function(val, culture) {
          var _decimalSep, _thousandSep, _currSymbol, _valArray, _abbrObj, _thousandRegEx, localeData, temp;
          if (typeof val !== "string") {
            val += "";
            if (console.warn) {
              console.warn("Numeral.js: Value is not string. It has been co-erced to: ", val);
            }
          }
          val = val.trim();
          if (!!val.match(/^\d+$/)) {
            return true;
          }
          if (val === "") {
            return false;
          }
          try {
            localeData = numeral2.localeData(culture);
          } catch (e4) {
            localeData = numeral2.localeData(numeral2.locale());
          }
          _currSymbol = localeData.currency.symbol;
          _abbrObj = localeData.abbreviations;
          _decimalSep = localeData.delimiters.decimal;
          if (localeData.delimiters.thousands === ".") {
            _thousandSep = "\\.";
          } else {
            _thousandSep = localeData.delimiters.thousands;
          }
          temp = val.match(/^[^\d]+/);
          if (temp !== null) {
            val = val.substr(1);
            if (temp[0] !== _currSymbol) {
              return false;
            }
          }
          temp = val.match(/[^\d]+$/);
          if (temp !== null) {
            val = val.slice(0, -1);
            if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million && temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {
              return false;
            }
          }
          _thousandRegEx = new RegExp(_thousandSep + "{2}");
          if (!val.match(/[^\d.,]/g)) {
            _valArray = val.split(_decimalSep);
            if (_valArray.length > 2) {
              return false;
            } else {
              if (_valArray.length < 2) {
                return !!_valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx);
              } else {
                if (_valArray[0].length === 1) {
                  return !!_valArray[0].match(/^\d+$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\d+$/);
                } else {
                  return !!_valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\d+$/);
                }
              }
            }
          }
          return false;
        };
        numeral2.fn = Numeral.prototype = {
          clone: function() {
            return numeral2(this);
          },
          format: function(inputString, roundingFunction) {
            var value = this._value, format = inputString || options.defaultFormat, kind, output, formatFunction;
            roundingFunction = roundingFunction || Math.round;
            if (value === 0 && options.zeroFormat !== null) {
              output = options.zeroFormat;
            } else if (value === null && options.nullFormat !== null) {
              output = options.nullFormat;
            } else {
              for (kind in formats) {
                if (format.match(formats[kind].regexps.format)) {
                  formatFunction = formats[kind].format;
                  break;
                }
              }
              formatFunction = formatFunction || numeral2._.numberToFormat;
              output = formatFunction(value, format, roundingFunction);
            }
            return output;
          },
          value: function() {
            return this._value;
          },
          input: function() {
            return this._input;
          },
          set: function(value) {
            this._value = Number(value);
            return this;
          },
          add: function(value) {
            var corrFactor = _4.correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O2) {
              return accum + Math.round(corrFactor * curr);
            }
            this._value = _4.reduce([this._value, value], cback, 0) / corrFactor;
            return this;
          },
          subtract: function(value) {
            var corrFactor = _4.correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O2) {
              return accum - Math.round(corrFactor * curr);
            }
            this._value = _4.reduce([value], cback, Math.round(this._value * corrFactor)) / corrFactor;
            return this;
          },
          multiply: function(value) {
            function cback(accum, curr, currI, O2) {
              var corrFactor = _4.correctionFactor(accum, curr);
              return Math.round(accum * corrFactor) * Math.round(curr * corrFactor) / Math.round(corrFactor * corrFactor);
            }
            this._value = _4.reduce([this._value, value], cback, 1);
            return this;
          },
          divide: function(value) {
            function cback(accum, curr, currI, O2) {
              var corrFactor = _4.correctionFactor(accum, curr);
              return Math.round(accum * corrFactor) / Math.round(curr * corrFactor);
            }
            this._value = _4.reduce([this._value, value], cback);
            return this;
          },
          difference: function(value) {
            return Math.abs(numeral2(this._value).subtract(value).value());
          }
        };
        numeral2.register("locale", "en", {
          delimiters: {
            thousands: ",",
            decimal: "."
          },
          abbreviations: {
            thousand: "k",
            million: "m",
            billion: "b",
            trillion: "t"
          },
          ordinal: function(number) {
            var b4 = number % 10;
            return ~~(number % 100 / 10) === 1 ? "th" : b4 === 1 ? "st" : b4 === 2 ? "nd" : b4 === 3 ? "rd" : "th";
          },
          currency: {
            symbol: "$"
          }
        });
        (function() {
          numeral2.register("format", "bps", {
            regexps: {
              format: /(BPS)/,
              unformat: /(BPS)/
            },
            format: function(value, format, roundingFunction) {
              var space = numeral2._.includes(format, " BPS") ? " " : "", output;
              value = value * 1e4;
              format = format.replace(/\s?BPS/, "");
              output = numeral2._.numberToFormat(value, format, roundingFunction);
              if (numeral2._.includes(output, ")")) {
                output = output.split("");
                output.splice(-1, 0, space + "BPS");
                output = output.join("");
              } else {
                output = output + space + "BPS";
              }
              return output;
            },
            unformat: function(string) {
              return +(numeral2._.stringToNumber(string) * 1e-4).toFixed(15);
            }
          });
        })();
        (function() {
          var decimal2 = {
            base: 1e3,
            suffixes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
          }, binary = {
            base: 1024,
            suffixes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"]
          };
          var allSuffixes = decimal2.suffixes.concat(binary.suffixes.filter(function(item) {
            return decimal2.suffixes.indexOf(item) < 0;
          }));
          var unformatRegex = allSuffixes.join("|");
          unformatRegex = "(" + unformatRegex.replace("B", "B(?!PS)") + ")";
          numeral2.register("format", "bytes", {
            regexps: {
              format: /([0\s]i?b)/,
              unformat: new RegExp(unformatRegex)
            },
            format: function(value, format, roundingFunction) {
              var output, bytes = numeral2._.includes(format, "ib") ? binary : decimal2, suffix = numeral2._.includes(format, " b") || numeral2._.includes(format, " ib") ? " " : "", power, min, max;
              format = format.replace(/\s?i?b/, "");
              for (power = 0; power <= bytes.suffixes.length; power++) {
                min = Math.pow(bytes.base, power);
                max = Math.pow(bytes.base, power + 1);
                if (value === null || value === 0 || value >= min && value < max) {
                  suffix += bytes.suffixes[power];
                  if (min > 0) {
                    value = value / min;
                  }
                  break;
                }
              }
              output = numeral2._.numberToFormat(value, format, roundingFunction);
              return output + suffix;
            },
            unformat: function(string) {
              var value = numeral2._.stringToNumber(string), power, bytesMultiplier;
              if (value) {
                for (power = decimal2.suffixes.length - 1; power >= 0; power--) {
                  if (numeral2._.includes(string, decimal2.suffixes[power])) {
                    bytesMultiplier = Math.pow(decimal2.base, power);
                    break;
                  }
                  if (numeral2._.includes(string, binary.suffixes[power])) {
                    bytesMultiplier = Math.pow(binary.base, power);
                    break;
                  }
                }
                value *= bytesMultiplier || 1;
              }
              return value;
            }
          });
        })();
        (function() {
          numeral2.register("format", "currency", {
            regexps: {
              format: /(\$)/
            },
            format: function(value, format, roundingFunction) {
              var locale = numeral2.locales[numeral2.options.currentLocale], symbols = {
                before: format.match(/^([\+|\-|\(|\s|\$]*)/)[0],
                after: format.match(/([\+|\-|\)|\s|\$]*)$/)[0]
              }, output, symbol, i4;
              format = format.replace(/\s?\$\s?/, "");
              output = numeral2._.numberToFormat(value, format, roundingFunction);
              if (value >= 0) {
                symbols.before = symbols.before.replace(/[\-\(]/, "");
                symbols.after = symbols.after.replace(/[\-\)]/, "");
              } else if (value < 0 && (!numeral2._.includes(symbols.before, "-") && !numeral2._.includes(symbols.before, "("))) {
                symbols.before = "-" + symbols.before;
              }
              for (i4 = 0; i4 < symbols.before.length; i4++) {
                symbol = symbols.before[i4];
                switch (symbol) {
                  case "$":
                    output = numeral2._.insert(output, locale.currency.symbol, i4);
                    break;
                  case " ":
                    output = numeral2._.insert(output, " ", i4 + locale.currency.symbol.length - 1);
                    break;
                }
              }
              for (i4 = symbols.after.length - 1; i4 >= 0; i4--) {
                symbol = symbols.after[i4];
                switch (symbol) {
                  case "$":
                    output = i4 === symbols.after.length - 1 ? output + locale.currency.symbol : numeral2._.insert(output, locale.currency.symbol, -(symbols.after.length - (1 + i4)));
                    break;
                  case " ":
                    output = i4 === symbols.after.length - 1 ? output + " " : numeral2._.insert(output, " ", -(symbols.after.length - (1 + i4) + locale.currency.symbol.length - 1));
                    break;
                }
              }
              return output;
            }
          });
        })();
        (function() {
          numeral2.register("format", "exponential", {
            regexps: {
              format: /(e\+|e-)/,
              unformat: /(e\+|e-)/
            },
            format: function(value, format, roundingFunction) {
              var output, exponential = typeof value === "number" && !numeral2._.isNaN(value) ? value.toExponential() : "0e+0", parts = exponential.split("e");
              format = format.replace(/e[\+|\-]{1}0/, "");
              output = numeral2._.numberToFormat(Number(parts[0]), format, roundingFunction);
              return output + "e" + parts[1];
            },
            unformat: function(string) {
              var parts = numeral2._.includes(string, "e+") ? string.split("e+") : string.split("e-"), value = Number(parts[0]), power = Number(parts[1]);
              power = numeral2._.includes(string, "e-") ? power *= -1 : power;
              function cback(accum, curr, currI, O2) {
                var corrFactor = numeral2._.correctionFactor(accum, curr), num = accum * corrFactor * (curr * corrFactor) / (corrFactor * corrFactor);
                return num;
              }
              return numeral2._.reduce([value, Math.pow(10, power)], cback, 1);
            }
          });
        })();
        (function() {
          numeral2.register("format", "ordinal", {
            regexps: {
              format: /(o)/
            },
            format: function(value, format, roundingFunction) {
              var locale = numeral2.locales[numeral2.options.currentLocale], output, ordinal = numeral2._.includes(format, " o") ? " " : "";
              format = format.replace(/\s?o/, "");
              ordinal += locale.ordinal(value);
              output = numeral2._.numberToFormat(value, format, roundingFunction);
              return output + ordinal;
            }
          });
        })();
        (function() {
          numeral2.register("format", "percentage", {
            regexps: {
              format: /(%)/,
              unformat: /(%)/
            },
            format: function(value, format, roundingFunction) {
              var space = numeral2._.includes(format, " %") ? " " : "", output;
              if (numeral2.options.scalePercentBy100) {
                value = value * 100;
              }
              format = format.replace(/\s?\%/, "");
              output = numeral2._.numberToFormat(value, format, roundingFunction);
              if (numeral2._.includes(output, ")")) {
                output = output.split("");
                output.splice(-1, 0, space + "%");
                output = output.join("");
              } else {
                output = output + space + "%";
              }
              return output;
            },
            unformat: function(string) {
              var number = numeral2._.stringToNumber(string);
              if (numeral2.options.scalePercentBy100) {
                return number * 0.01;
              }
              return number;
            }
          });
        })();
        (function() {
          numeral2.register("format", "time", {
            regexps: {
              format: /(:)/,
              unformat: /(:)/
            },
            format: function(value, format, roundingFunction) {
              var hours = Math.floor(value / 60 / 60), minutes = Math.floor((value - hours * 60 * 60) / 60), seconds = Math.round(value - hours * 60 * 60 - minutes * 60);
              return hours + ":" + (minutes < 10 ? "0" + minutes : minutes) + ":" + (seconds < 10 ? "0" + seconds : seconds);
            },
            unformat: function(string) {
              var timeArray = string.split(":"), seconds = 0;
              if (timeArray.length === 3) {
                seconds = seconds + Number(timeArray[0]) * 60 * 60;
                seconds = seconds + Number(timeArray[1]) * 60;
                seconds = seconds + Number(timeArray[2]);
              } else if (timeArray.length === 2) {
                seconds = seconds + Number(timeArray[0]) * 60;
                seconds = seconds + Number(timeArray[1]);
              }
              return Number(seconds);
            }
          });
        })();
        return numeral2;
      });
    }
  });

  // ../../node_modules/.pnpm/react@18.2.0/node_modules/react/cjs/react.development.js
  var require_react_development = __commonJS({
    "../../node_modules/.pnpm/react@18.2.0/node_modules/react/cjs/react.development.js"(exports, module) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var ReactVersion = "18.2.0";
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var ReactCurrentDispatcher = {
            /**
             * @internal
             * @type {ReactComponent}
             */
            current: null
          };
          var ReactCurrentBatchConfig = {
            transition: null
          };
          var ReactCurrentActQueue = {
            current: null,
            // Used to reproduce behavior of `batchedUpdates` in legacy mode.
            isBatchingLegacy: false,
            didScheduleLegacyUpdate: false
          };
          var ReactCurrentOwner = {
            /**
             * @internal
             * @type {ReactComponent}
             */
            current: null
          };
          var ReactDebugCurrentFrame = {};
          var currentExtraStackFrame = null;
          function setExtraStackFrame(stack) {
            {
              currentExtraStackFrame = stack;
            }
          }
          {
            ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
              {
                currentExtraStackFrame = stack;
              }
            };
            ReactDebugCurrentFrame.getCurrentStack = null;
            ReactDebugCurrentFrame.getStackAddendum = function() {
              var stack = "";
              if (currentExtraStackFrame) {
                stack += currentExtraStackFrame;
              }
              var impl = ReactDebugCurrentFrame.getCurrentStack;
              if (impl) {
                stack += impl() || "";
              }
              return stack;
            };
          }
          var enableScopeAPI = false;
          var enableCacheElement = false;
          var enableTransitionTracing = false;
          var enableLegacyHidden = false;
          var enableDebugTracing = false;
          var ReactSharedInternals = {
            ReactCurrentDispatcher,
            ReactCurrentBatchConfig,
            ReactCurrentOwner
          };
          {
            ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
            ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
          }
          function warn(format) {
            {
              {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                printWarning("warn", format, args);
              }
            }
          }
          function error2(format) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format, args);
              }
            }
          }
          function printWarning(level, format, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var didWarnStateUpdateForUnmountedComponent = {};
          function warnNoop(publicInstance, callerName) {
            {
              var _constructor = publicInstance.constructor;
              var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
              var warningKey = componentName + "." + callerName;
              if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
                return;
              }
              error2("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
              didWarnStateUpdateForUnmountedComponent[warningKey] = true;
            }
          }
          var ReactNoopUpdateQueue = {
            /**
             * Checks whether or not this composite component is mounted.
             * @param {ReactClass} publicInstance The instance we want to test.
             * @return {boolean} True if mounted, false otherwise.
             * @protected
             * @final
             */
            isMounted: function(publicInstance) {
              return false;
            },
            /**
             * Forces an update. This should only be invoked when it is known with
             * certainty that we are **not** in a DOM transaction.
             *
             * You may want to call this when you know that some deeper aspect of the
             * component's state has changed but `setState` was not called.
             *
             * This will not invoke `shouldComponentUpdate`, but it will invoke
             * `componentWillUpdate` and `componentDidUpdate`.
             *
             * @param {ReactClass} publicInstance The instance that should rerender.
             * @param {?function} callback Called after component is updated.
             * @param {?string} callerName name of the calling function in the public API.
             * @internal
             */
            enqueueForceUpdate: function(publicInstance, callback, callerName) {
              warnNoop(publicInstance, "forceUpdate");
            },
            /**
             * Replaces all of the state. Always use this or `setState` to mutate state.
             * You should treat `this.state` as immutable.
             *
             * There is no guarantee that `this.state` will be immediately updated, so
             * accessing `this.state` after calling this method may return the old value.
             *
             * @param {ReactClass} publicInstance The instance that should rerender.
             * @param {object} completeState Next state.
             * @param {?function} callback Called after component is updated.
             * @param {?string} callerName name of the calling function in the public API.
             * @internal
             */
            enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
              warnNoop(publicInstance, "replaceState");
            },
            /**
             * Sets a subset of the state. This only exists because _pendingState is
             * internal. This provides a merging strategy that is not available to deep
             * properties which is confusing. TODO: Expose pendingState or don't use it
             * during the merge.
             *
             * @param {ReactClass} publicInstance The instance that should rerender.
             * @param {object} partialState Next partial state to be merged with state.
             * @param {?function} callback Called after component is updated.
             * @param {?string} Name of the calling function in the public API.
             * @internal
             */
            enqueueSetState: function(publicInstance, partialState, callback, callerName) {
              warnNoop(publicInstance, "setState");
            }
          };
          var assign = Object.assign;
          var emptyObject = {};
          {
            Object.freeze(emptyObject);
          }
          function Component2(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          Component2.prototype.isReactComponent = {};
          Component2.prototype.setState = function(partialState, callback) {
            if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
              throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            }
            this.updater.enqueueSetState(this, partialState, callback, "setState");
          };
          Component2.prototype.forceUpdate = function(callback) {
            this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
          };
          {
            var deprecatedAPIs = {
              isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
              replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
            };
            var defineDeprecationWarning = function(methodName, info) {
              Object.defineProperty(Component2.prototype, methodName, {
                get: function() {
                  warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                  return void 0;
                }
              });
            };
            for (var fnName in deprecatedAPIs) {
              if (deprecatedAPIs.hasOwnProperty(fnName)) {
                defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
              }
            }
          }
          function ComponentDummy() {
          }
          ComponentDummy.prototype = Component2.prototype;
          function PureComponent2(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          var pureComponentPrototype = PureComponent2.prototype = new ComponentDummy();
          pureComponentPrototype.constructor = PureComponent2;
          assign(pureComponentPrototype, Component2.prototype);
          pureComponentPrototype.isPureReactComponent = true;
          function createRef() {
            var refObject = {
              current: null
            };
            {
              Object.seal(refObject);
            }
            return refObject;
          }
          var isArrayImpl = Array.isArray;
          function isArray2(a4) {
            return isArrayImpl(a4);
          }
          function typeName(value) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
              return type;
            }
          }
          function willCoercionThrow(value) {
            {
              try {
                testStringCoercion(value);
                return false;
              } catch (e4) {
                return true;
              }
            }
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function checkKeyStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error2("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromType(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init(payload));
                  } catch (x4) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
          };
          var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
          {
            didWarnAboutStringRefs = {};
          }
          function hasValidRef(config) {
            {
              if (hasOwnProperty.call(config, "ref")) {
                var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config.ref !== void 0;
          }
          function hasValidKey(config) {
            {
              if (hasOwnProperty.call(config, "key")) {
                var getter = Object.getOwnPropertyDescriptor(config, "key").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config.key !== void 0;
          }
          function defineKeyPropWarningGetter(props, displayName) {
            var warnAboutAccessingKey = function() {
              {
                if (!specialPropKeyWarningShown) {
                  specialPropKeyWarningShown = true;
                  error2("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
          function defineRefPropWarningGetter(props, displayName) {
            var warnAboutAccessingRef = function() {
              {
                if (!specialPropRefWarningShown) {
                  specialPropRefWarningShown = true;
                  error2("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
          function warnIfStringRefCannotBeAutoConverted(config) {
            {
              if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
                var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
                if (!didWarnAboutStringRefs[componentName]) {
                  error2('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
          }
          var ReactElement = function(type, key, ref, self2, source, owner, props) {
            var element = {
              // This tag allows us to uniquely identify this as a React Element
              $$typeof: REACT_ELEMENT_TYPE,
              // Built-in properties that belong on the element
              type,
              key,
              ref,
              props,
              // Record the component responsible for creating this element.
              _owner: owner
            };
            {
              element._store = {};
              Object.defineProperty(element._store, "validated", {
                configurable: false,
                enumerable: false,
                writable: true,
                value: false
              });
              Object.defineProperty(element, "_self", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: self2
              });
              Object.defineProperty(element, "_source", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: source
              });
              if (Object.freeze) {
                Object.freeze(element.props);
                Object.freeze(element);
              }
            }
            return element;
          };
          function createElement(type, config, children) {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            var self2 = null;
            var source = null;
            if (config != null) {
              if (hasValidRef(config)) {
                ref = config.ref;
                {
                  warnIfStringRefCannotBeAutoConverted(config);
                }
              }
              if (hasValidKey(config)) {
                {
                  checkKeyStringCoercion(config.key);
                }
                key = "" + config.key;
              }
              self2 = config.__self === void 0 ? null : config.__self;
              source = config.__source === void 0 ? null : config.__source;
              for (propName in config) {
                if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  props[propName] = config[propName];
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i4 = 0; i4 < childrenLength; i4++) {
                childArray[i4] = arguments[i4 + 2];
              }
              {
                if (Object.freeze) {
                  Object.freeze(childArray);
                }
              }
              props.children = childArray;
            }
            if (type && type.defaultProps) {
              var defaultProps = type.defaultProps;
              for (propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
            }
            {
              if (key || ref) {
                var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
                if (key) {
                  defineKeyPropWarningGetter(props, displayName);
                }
                if (ref) {
                  defineRefPropWarningGetter(props, displayName);
                }
              }
            }
            return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
          }
          function cloneAndReplaceKey(oldElement, newKey) {
            var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
            return newElement;
          }
          function cloneElement(element, config, children) {
            if (element === null || element === void 0) {
              throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
            var propName;
            var props = assign({}, element.props);
            var key = element.key;
            var ref = element.ref;
            var self2 = element._self;
            var source = element._source;
            var owner = element._owner;
            if (config != null) {
              if (hasValidRef(config)) {
                ref = config.ref;
                owner = ReactCurrentOwner.current;
              }
              if (hasValidKey(config)) {
                {
                  checkKeyStringCoercion(config.key);
                }
                key = "" + config.key;
              }
              var defaultProps;
              if (element.type && element.type.defaultProps) {
                defaultProps = element.type.defaultProps;
              }
              for (propName in config) {
                if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  if (config[propName] === void 0 && defaultProps !== void 0) {
                    props[propName] = defaultProps[propName];
                  } else {
                    props[propName] = config[propName];
                  }
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i4 = 0; i4 < childrenLength; i4++) {
                childArray[i4] = arguments[i4 + 2];
              }
              props.children = childArray;
            }
            return ReactElement(element.type, key, ref, self2, source, owner, props);
          }
          function isValidElement(object) {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          var SEPARATOR = ".";
          var SUBSEPARATOR = ":";
          function escape(key) {
            var escapeRegex = /[=:]/g;
            var escaperLookup = {
              "=": "=0",
              ":": "=2"
            };
            var escapedString = key.replace(escapeRegex, function(match) {
              return escaperLookup[match];
            });
            return "$" + escapedString;
          }
          var didWarnAboutMaps = false;
          var userProvidedKeyEscapeRegex = /\/+/g;
          function escapeUserProvidedKey(text) {
            return text.replace(userProvidedKeyEscapeRegex, "$&/");
          }
          function getElementKey(element, index) {
            if (typeof element === "object" && element !== null && element.key != null) {
              {
                checkKeyStringCoercion(element.key);
              }
              return escape("" + element.key);
            }
            return index.toString(36);
          }
          function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
            var type = typeof children;
            if (type === "undefined" || type === "boolean") {
              children = null;
            }
            var invokeCallback = false;
            if (children === null) {
              invokeCallback = true;
            } else {
              switch (type) {
                case "string":
                case "number":
                  invokeCallback = true;
                  break;
                case "object":
                  switch (children.$$typeof) {
                    case REACT_ELEMENT_TYPE:
                    case REACT_PORTAL_TYPE:
                      invokeCallback = true;
                  }
              }
            }
            if (invokeCallback) {
              var _child = children;
              var mappedChild = callback(_child);
              var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
              if (isArray2(mappedChild)) {
                var escapedChildKey = "";
                if (childKey != null) {
                  escapedChildKey = escapeUserProvidedKey(childKey) + "/";
                }
                mapIntoArray(mappedChild, array, escapedChildKey, "", function(c4) {
                  return c4;
                });
              } else if (mappedChild != null) {
                if (isValidElement(mappedChild)) {
                  {
                    if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                      checkKeyStringCoercion(mappedChild.key);
                    }
                  }
                  mappedChild = cloneAndReplaceKey(
                    mappedChild,
                    // Keep both the (mapped) and old keys if they differ, just as
                    // traverseAllChildren used to do for objects as children
                    escapedPrefix + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
                    (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? (
                      // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                      // eslint-disable-next-line react-internal/safe-string-coercion
                      escapeUserProvidedKey("" + mappedChild.key) + "/"
                    ) : "") + childKey
                  );
                }
                array.push(mappedChild);
              }
              return 1;
            }
            var child;
            var nextName;
            var subtreeCount = 0;
            var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
            if (isArray2(children)) {
              for (var i4 = 0; i4 < children.length; i4++) {
                child = children[i4];
                nextName = nextNamePrefix + getElementKey(child, i4);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else {
              var iteratorFn = getIteratorFn(children);
              if (typeof iteratorFn === "function") {
                var iterableChildren = children;
                {
                  if (iteratorFn === iterableChildren.entries) {
                    if (!didWarnAboutMaps) {
                      warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                    }
                    didWarnAboutMaps = true;
                  }
                }
                var iterator = iteratorFn.call(iterableChildren);
                var step;
                var ii = 0;
                while (!(step = iterator.next()).done) {
                  child = step.value;
                  nextName = nextNamePrefix + getElementKey(child, ii++);
                  subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
                }
              } else if (type === "object") {
                var childrenString = String(children);
                throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
              }
            }
            return subtreeCount;
          }
          function mapChildren(children, func, context) {
            if (children == null) {
              return children;
            }
            var result = [];
            var count = 0;
            mapIntoArray(children, result, "", "", function(child) {
              return func.call(context, child, count++);
            });
            return result;
          }
          function countChildren(children) {
            var n3 = 0;
            mapChildren(children, function() {
              n3++;
            });
            return n3;
          }
          function forEachChildren(children, forEachFunc, forEachContext) {
            mapChildren(children, function() {
              forEachFunc.apply(this, arguments);
            }, forEachContext);
          }
          function toArray(children) {
            return mapChildren(children, function(child) {
              return child;
            }) || [];
          }
          function onlyChild(children) {
            if (!isValidElement(children)) {
              throw new Error("React.Children.only expected to receive a single React element child.");
            }
            return children;
          }
          function createContext(defaultValue) {
            var context = {
              $$typeof: REACT_CONTEXT_TYPE,
              // As a workaround to support multiple concurrent renderers, we categorize
              // some renderers as primary and others as secondary. We only expect
              // there to be two concurrent renderers at most: React Native (primary) and
              // Fabric (secondary); React DOM (primary) and React ART (secondary).
              // Secondary renderers store their context values on separate fields.
              _currentValue: defaultValue,
              _currentValue2: defaultValue,
              // Used to track how many concurrent renderers this context currently
              // supports within in a single renderer. Such as parallel server rendering.
              _threadCount: 0,
              // These are circular
              Provider: null,
              Consumer: null,
              // Add these to use same hidden class in VM as ServerContext
              _defaultValue: null,
              _globalName: null
            };
            context.Provider = {
              $$typeof: REACT_PROVIDER_TYPE,
              _context: context
            };
            var hasWarnedAboutUsingNestedContextConsumers = false;
            var hasWarnedAboutUsingConsumerProvider = false;
            var hasWarnedAboutDisplayNameOnConsumer = false;
            {
              var Consumer = {
                $$typeof: REACT_CONTEXT_TYPE,
                _context: context
              };
              Object.defineProperties(Consumer, {
                Provider: {
                  get: function() {
                    if (!hasWarnedAboutUsingConsumerProvider) {
                      hasWarnedAboutUsingConsumerProvider = true;
                      error2("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                    }
                    return context.Provider;
                  },
                  set: function(_Provider) {
                    context.Provider = _Provider;
                  }
                },
                _currentValue: {
                  get: function() {
                    return context._currentValue;
                  },
                  set: function(_currentValue) {
                    context._currentValue = _currentValue;
                  }
                },
                _currentValue2: {
                  get: function() {
                    return context._currentValue2;
                  },
                  set: function(_currentValue2) {
                    context._currentValue2 = _currentValue2;
                  }
                },
                _threadCount: {
                  get: function() {
                    return context._threadCount;
                  },
                  set: function(_threadCount) {
                    context._threadCount = _threadCount;
                  }
                },
                Consumer: {
                  get: function() {
                    if (!hasWarnedAboutUsingNestedContextConsumers) {
                      hasWarnedAboutUsingNestedContextConsumers = true;
                      error2("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                    }
                    return context.Consumer;
                  }
                },
                displayName: {
                  get: function() {
                    return context.displayName;
                  },
                  set: function(displayName) {
                    if (!hasWarnedAboutDisplayNameOnConsumer) {
                      warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                      hasWarnedAboutDisplayNameOnConsumer = true;
                    }
                  }
                }
              });
              context.Consumer = Consumer;
            }
            {
              context._currentRenderer = null;
              context._currentRenderer2 = null;
            }
            return context;
          }
          var Uninitialized = -1;
          var Pending = 0;
          var Resolved = 1;
          var Rejected = 2;
          function lazyInitializer(payload) {
            if (payload._status === Uninitialized) {
              var ctor = payload._result;
              var thenable = ctor();
              thenable.then(function(moduleObject2) {
                if (payload._status === Pending || payload._status === Uninitialized) {
                  var resolved = payload;
                  resolved._status = Resolved;
                  resolved._result = moduleObject2;
                }
              }, function(error3) {
                if (payload._status === Pending || payload._status === Uninitialized) {
                  var rejected = payload;
                  rejected._status = Rejected;
                  rejected._result = error3;
                }
              });
              if (payload._status === Uninitialized) {
                var pending = payload;
                pending._status = Pending;
                pending._result = thenable;
              }
            }
            if (payload._status === Resolved) {
              var moduleObject = payload._result;
              {
                if (moduleObject === void 0) {
                  error2("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
                }
              }
              {
                if (!("default" in moduleObject)) {
                  error2("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                }
              }
              return moduleObject.default;
            } else {
              throw payload._result;
            }
          }
          function lazy(ctor) {
            var payload = {
              // We use these fields to store the result.
              _status: Uninitialized,
              _result: ctor
            };
            var lazyType = {
              $$typeof: REACT_LAZY_TYPE,
              _payload: payload,
              _init: lazyInitializer
            };
            {
              var defaultProps;
              var propTypes;
              Object.defineProperties(lazyType, {
                defaultProps: {
                  configurable: true,
                  get: function() {
                    return defaultProps;
                  },
                  set: function(newDefaultProps) {
                    error2("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    defaultProps = newDefaultProps;
                    Object.defineProperty(lazyType, "defaultProps", {
                      enumerable: true
                    });
                  }
                },
                propTypes: {
                  configurable: true,
                  get: function() {
                    return propTypes;
                  },
                  set: function(newPropTypes) {
                    error2("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    propTypes = newPropTypes;
                    Object.defineProperty(lazyType, "propTypes", {
                      enumerable: true
                    });
                  }
                }
              });
            }
            return lazyType;
          }
          function forwardRef(render) {
            {
              if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
                error2("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
              } else if (typeof render !== "function") {
                error2("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
              } else {
                if (render.length !== 0 && render.length !== 2) {
                  error2("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
                }
              }
              if (render != null) {
                if (render.defaultProps != null || render.propTypes != null) {
                  error2("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
                }
              }
            }
            var elementType = {
              $$typeof: REACT_FORWARD_REF_TYPE,
              render
            };
            {
              var ownName;
              Object.defineProperty(elementType, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name) {
                  ownName = name;
                  if (!render.name && !render.displayName) {
                    render.displayName = name;
                  }
                }
              });
            }
            return elementType;
          }
          var REACT_MODULE_REFERENCE;
          {
            REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
          }
          function isValidElementType(type) {
            if (typeof type === "string" || typeof type === "function") {
              return true;
            }
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
              return true;
            }
            if (typeof type === "object" && type !== null) {
              if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
              // types supported by any Flight configuration anywhere since
              // we don't know which Flight build this will end up being used
              // with.
              type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
                return true;
              }
            }
            return false;
          }
          function memo(type, compare) {
            {
              if (!isValidElementType(type)) {
                error2("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
              }
            }
            var elementType = {
              $$typeof: REACT_MEMO_TYPE,
              type,
              compare: compare === void 0 ? null : compare
            };
            {
              var ownName;
              Object.defineProperty(elementType, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name) {
                  ownName = name;
                  if (!type.name && !type.displayName) {
                    type.displayName = name;
                  }
                }
              });
            }
            return elementType;
          }
          function resolveDispatcher() {
            var dispatcher = ReactCurrentDispatcher.current;
            {
              if (dispatcher === null) {
                error2("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
              }
            }
            return dispatcher;
          }
          function useContext(Context2) {
            var dispatcher = resolveDispatcher();
            {
              if (Context2._context !== void 0) {
                var realContext = Context2._context;
                if (realContext.Consumer === Context2) {
                  error2("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
                } else if (realContext.Provider === Context2) {
                  error2("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
                }
              }
            }
            return dispatcher.useContext(Context2);
          }
          function useState(initialState) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useState(initialState);
          }
          function useReducer(reducer, initialArg, init) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useReducer(reducer, initialArg, init);
          }
          function useRef(initialValue) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useRef(initialValue);
          }
          function useEffect(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useEffect(create, deps);
          }
          function useInsertionEffect(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useInsertionEffect(create, deps);
          }
          function useLayoutEffect(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useLayoutEffect(create, deps);
          }
          function useCallback(callback, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useCallback(callback, deps);
          }
          function useMemo(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useMemo(create, deps);
          }
          function useImperativeHandle(ref, create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useImperativeHandle(ref, create, deps);
          }
          function useDebugValue(value, formatterFn) {
            {
              var dispatcher = resolveDispatcher();
              return dispatcher.useDebugValue(value, formatterFn);
            }
          }
          function useTransition() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useTransition();
          }
          function useDeferredValue(value) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDeferredValue(value);
          }
          function useId() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useId();
          }
          function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
          }
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign({}, props, {
                    value: prevLog
                  }),
                  info: assign({}, props, {
                    value: prevInfo
                  }),
                  warn: assign({}, props, {
                    value: prevWarn
                  }),
                  error: assign({}, props, {
                    value: prevError
                  }),
                  group: assign({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix;
          function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
              if (prefix === void 0) {
                try {
                  throw Error();
                } catch (x4) {
                  var match = x4.stack.trim().match(/\n( *(at )?)/);
                  prefix = match && match[1] || "";
                }
              }
              return "\n" + prefix + name;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
              return "";
            }
            {
              var frame = componentFrameCache.get(fn);
              if (frame !== void 0) {
                return frame;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x4) {
                    control = x4;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x4) {
                    control = x4;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x4) {
                  control = x4;
                }
                fn();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s4 = sampleLines.length - 1;
                var c4 = controlLines.length - 1;
                while (s4 >= 1 && c4 >= 0 && sampleLines[s4] !== controlLines[c4]) {
                  c4--;
                }
                for (; s4 >= 1 && c4 >= 0; s4--, c4--) {
                  if (sampleLines[s4] !== controlLines[c4]) {
                    if (s4 !== 1 || c4 !== 1) {
                      do {
                        s4--;
                        c4--;
                        if (c4 < 0 || sampleLines[s4] !== controlLines[c4]) {
                          var _frame = "\n" + sampleLines[s4].replace(" at new ", " at ");
                          if (fn.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn.displayName);
                          }
                          {
                            if (typeof fn === "function") {
                              componentFrameCache.set(fn, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s4 >= 1 && c4 >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher$1.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn ? fn.displayName || fn.name : "";
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
            {
              if (typeof fn === "function") {
                componentFrameCache.set(fn, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn, false);
            }
          }
          function shouldConstruct(Component3) {
            var prototype = Component3.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                  } catch (x4) {
                  }
                }
              }
            }
            return "";
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values, location2, componentName, element) {
            {
              var has = Function.call.bind(hasOwnProperty);
              for (var typeSpecName in typeSpecs) {
                if (has(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error2("Failed %s type: %s", location2, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          function setCurrentlyValidatingElement$1(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                setExtraStackFrame(stack);
              } else {
                setExtraStackFrame(null);
              }
            }
          }
          var propTypesMisspellWarningShown;
          {
            propTypesMisspellWarningShown = false;
          }
          function getDeclarationErrorAddendum() {
            if (ReactCurrentOwner.current) {
              var name = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (name) {
                return "\n\nCheck the render method of `" + name + "`.";
              }
            }
            return "";
          }
          function getSourceInfoErrorAddendum(source) {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
          function getSourceInfoErrorAddendumForProps(elementProps) {
            if (elementProps !== null && elementProps !== void 0) {
              return getSourceInfoErrorAddendum(elementProps.__source);
            }
            return "";
          }
          var ownerHasKeyUseWarning = {};
          function getCurrentComponentErrorInfo(parentType) {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
          function validateExplicitKey(element, parentType) {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
              childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            {
              setCurrentlyValidatingElement$1(element);
              error2('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
              setCurrentlyValidatingElement$1(null);
            }
          }
          function validateChildKeys(node, parentType) {
            if (typeof node !== "object") {
              return;
            }
            if (isArray2(node)) {
              for (var i4 = 0; i4 < node.length; i4++) {
                var child = node[i4];
                if (isValidElement(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement(node)) {
              if (node._store) {
                node._store.validated = true;
              }
            } else if (node) {
              var iteratorFn = getIteratorFn(node);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node.entries) {
                  var iterator = iteratorFn.call(node);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
          function validatePropTypes(element) {
            {
              var type = element.type;
              if (type === null || type === void 0 || typeof type === "string") {
                return;
              }
              var propTypes;
              if (typeof type === "function") {
                propTypes = type.propTypes;
              } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
              // Inner props are checked in the reconciler.
              type.$$typeof === REACT_MEMO_TYPE)) {
                propTypes = type.propTypes;
              } else {
                return;
              }
              if (propTypes) {
                var name = getComponentNameFromType(type);
                checkPropTypes(propTypes, element.props, "prop", name, element);
              } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
                propTypesMisspellWarningShown = true;
                var _name = getComponentNameFromType(type);
                error2("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
              }
              if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
                error2("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
              }
            }
          }
          function validateFragmentProps(fragment) {
            {
              var keys = Object.keys(fragment.props);
              for (var i4 = 0; i4 < keys.length; i4++) {
                var key = keys[i4];
                if (key !== "children" && key !== "key") {
                  setCurrentlyValidatingElement$1(fragment);
                  error2("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                  setCurrentlyValidatingElement$1(null);
                  break;
                }
              }
              if (fragment.ref !== null) {
                setCurrentlyValidatingElement$1(fragment);
                error2("Invalid attribute `ref` supplied to `React.Fragment`.");
                setCurrentlyValidatingElement$1(null);
              }
            }
          }
          function createElementWithValidation(type, props, children) {
            var validType = isValidElementType(type);
            if (!validType) {
              var info = "";
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendumForProps(props);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type === null) {
                typeString = "null";
              } else if (isArray2(type)) {
                typeString = "array";
              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type;
              }
              {
                error2("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
              }
            }
            var element = createElement.apply(this, arguments);
            if (element == null) {
              return element;
            }
            if (validType) {
              for (var i4 = 2; i4 < arguments.length; i4++) {
                validateChildKeys(arguments[i4], type);
              }
            }
            if (type === REACT_FRAGMENT_TYPE) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
          var didWarnAboutDeprecatedCreateFactory = false;
          function createFactoryWithValidation(type) {
            var validatedFactory = createElementWithValidation.bind(null, type);
            validatedFactory.type = type;
            {
              if (!didWarnAboutDeprecatedCreateFactory) {
                didWarnAboutDeprecatedCreateFactory = true;
                warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
              }
              Object.defineProperty(validatedFactory, "type", {
                enumerable: false,
                get: function() {
                  warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                  Object.defineProperty(this, "type", {
                    value: type
                  });
                  return type;
                }
              });
            }
            return validatedFactory;
          }
          function cloneElementWithValidation(element, props, children) {
            var newElement = cloneElement.apply(this, arguments);
            for (var i4 = 2; i4 < arguments.length; i4++) {
              validateChildKeys(arguments[i4], newElement.type);
            }
            validatePropTypes(newElement);
            return newElement;
          }
          function startTransition(scope, options) {
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = {};
            var currentTransition = ReactCurrentBatchConfig.transition;
            {
              ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
            }
            try {
              scope();
            } finally {
              ReactCurrentBatchConfig.transition = prevTransition;
              {
                if (prevTransition === null && currentTransition._updatedFibers) {
                  var updatedFibersCount = currentTransition._updatedFibers.size;
                  if (updatedFibersCount > 10) {
                    warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                  }
                  currentTransition._updatedFibers.clear();
                }
              }
            }
          }
          var didWarnAboutMessageChannel = false;
          var enqueueTaskImpl = null;
          function enqueueTask(task) {
            if (enqueueTaskImpl === null) {
              try {
                var requireString = ("require" + Math.random()).slice(0, 7);
                var nodeRequire = module && module[requireString];
                enqueueTaskImpl = nodeRequire.call(module, "timers").setImmediate;
              } catch (_err) {
                enqueueTaskImpl = function(callback) {
                  {
                    if (didWarnAboutMessageChannel === false) {
                      didWarnAboutMessageChannel = true;
                      if (typeof MessageChannel === "undefined") {
                        error2("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                      }
                    }
                  }
                  var channel = new MessageChannel();
                  channel.port1.onmessage = callback;
                  channel.port2.postMessage(void 0);
                };
              }
            }
            return enqueueTaskImpl(task);
          }
          var actScopeDepth = 0;
          var didWarnNoAwaitAct = false;
          function act(callback) {
            {
              var prevActScopeDepth = actScopeDepth;
              actScopeDepth++;
              if (ReactCurrentActQueue.current === null) {
                ReactCurrentActQueue.current = [];
              }
              var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
              var result;
              try {
                ReactCurrentActQueue.isBatchingLegacy = true;
                result = callback();
                if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                  var queue = ReactCurrentActQueue.current;
                  if (queue !== null) {
                    ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                    flushActQueue(queue);
                  }
                }
              } catch (error3) {
                popActScope(prevActScopeDepth);
                throw error3;
              } finally {
                ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
              }
              if (result !== null && typeof result === "object" && typeof result.then === "function") {
                var thenableResult = result;
                var wasAwaited = false;
                var thenable = {
                  then: function(resolve, reject) {
                    wasAwaited = true;
                    thenableResult.then(function(returnValue2) {
                      popActScope(prevActScopeDepth);
                      if (actScopeDepth === 0) {
                        recursivelyFlushAsyncActWork(returnValue2, resolve, reject);
                      } else {
                        resolve(returnValue2);
                      }
                    }, function(error3) {
                      popActScope(prevActScopeDepth);
                      reject(error3);
                    });
                  }
                };
                {
                  if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                    Promise.resolve().then(function() {
                    }).then(function() {
                      if (!wasAwaited) {
                        didWarnNoAwaitAct = true;
                        error2("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                      }
                    });
                  }
                }
                return thenable;
              } else {
                var returnValue = result;
                popActScope(prevActScopeDepth);
                if (actScopeDepth === 0) {
                  var _queue = ReactCurrentActQueue.current;
                  if (_queue !== null) {
                    flushActQueue(_queue);
                    ReactCurrentActQueue.current = null;
                  }
                  var _thenable = {
                    then: function(resolve, reject) {
                      if (ReactCurrentActQueue.current === null) {
                        ReactCurrentActQueue.current = [];
                        recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                      } else {
                        resolve(returnValue);
                      }
                    }
                  };
                  return _thenable;
                } else {
                  var _thenable2 = {
                    then: function(resolve, reject) {
                      resolve(returnValue);
                    }
                  };
                  return _thenable2;
                }
              }
            }
          }
          function popActScope(prevActScopeDepth) {
            {
              if (prevActScopeDepth !== actScopeDepth - 1) {
                error2("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
              }
              actScopeDepth = prevActScopeDepth;
            }
          }
          function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
            {
              var queue = ReactCurrentActQueue.current;
              if (queue !== null) {
                try {
                  flushActQueue(queue);
                  enqueueTask(function() {
                    if (queue.length === 0) {
                      ReactCurrentActQueue.current = null;
                      resolve(returnValue);
                    } else {
                      recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                    }
                  });
                } catch (error3) {
                  reject(error3);
                }
              } else {
                resolve(returnValue);
              }
            }
          }
          var isFlushing = false;
          function flushActQueue(queue) {
            {
              if (!isFlushing) {
                isFlushing = true;
                var i4 = 0;
                try {
                  for (; i4 < queue.length; i4++) {
                    var callback = queue[i4];
                    do {
                      callback = callback(true);
                    } while (callback !== null);
                  }
                  queue.length = 0;
                } catch (error3) {
                  queue = queue.slice(i4 + 1);
                  throw error3;
                } finally {
                  isFlushing = false;
                }
              }
            }
          }
          var createElement$1 = createElementWithValidation;
          var cloneElement$1 = cloneElementWithValidation;
          var createFactory = createFactoryWithValidation;
          var Children = {
            map: mapChildren,
            forEach: forEachChildren,
            count: countChildren,
            toArray,
            only: onlyChild
          };
          exports.Children = Children;
          exports.Component = Component2;
          exports.Fragment = REACT_FRAGMENT_TYPE;
          exports.Profiler = REACT_PROFILER_TYPE;
          exports.PureComponent = PureComponent2;
          exports.StrictMode = REACT_STRICT_MODE_TYPE;
          exports.Suspense = REACT_SUSPENSE_TYPE;
          exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
          exports.cloneElement = cloneElement$1;
          exports.createContext = createContext;
          exports.createElement = createElement$1;
          exports.createFactory = createFactory;
          exports.createRef = createRef;
          exports.forwardRef = forwardRef;
          exports.isValidElement = isValidElement;
          exports.lazy = lazy;
          exports.memo = memo;
          exports.startTransition = startTransition;
          exports.unstable_act = act;
          exports.useCallback = useCallback;
          exports.useContext = useContext;
          exports.useDebugValue = useDebugValue;
          exports.useDeferredValue = useDeferredValue;
          exports.useEffect = useEffect;
          exports.useId = useId;
          exports.useImperativeHandle = useImperativeHandle;
          exports.useInsertionEffect = useInsertionEffect;
          exports.useLayoutEffect = useLayoutEffect;
          exports.useMemo = useMemo;
          exports.useReducer = useReducer;
          exports.useRef = useRef;
          exports.useState = useState;
          exports.useSyncExternalStore = useSyncExternalStore;
          exports.useTransition = useTransition;
          exports.version = ReactVersion;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // ../../node_modules/.pnpm/react@18.2.0/node_modules/react/index.js
  var require_react = __commonJS({
    "../../node_modules/.pnpm/react@18.2.0/node_modules/react/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_development();
      }
    }
  });

  // ../../packages/core/src/Command/ActionBase.ts
  var ActionBase = class {
    _observers;
    _doActionData;
    _oldActionData;
    _operation;
    constructor(actionData, observers) {
      this._doActionData = actionData;
      this._observers = observers;
      this._operation = 1 /* OBSERVER_ACTION */;
    }
    getDoActionData() {
      return this._doActionData;
    }
    getOldActionDaa() {
      return this._oldActionData;
    }
    hasOperation(operation) {
      return (this._operation & operation) === operation;
    }
    addOperation(operation) {
      this._operation |= operation;
    }
    removeOperation(operation) {
      this._operation &= ~operation;
    }
  };

  // ../../packages/core/src/Observer/Observable.ts
  var EventState = class {
    /**
     * An WorkBookObserver can set this property to true to prevent subsequent observers of being notified
     */
    skipNextObservers;
    /**
     * This will be populated with the return value of the last function that was executed.
     * If it is the first function in the callback chain it will be the event data.
     */
    lastReturnValue;
    isStopPropagation = false;
    /**
     * Create a new EventState
     * @param skipNextObservers defines a flag which will instruct the observable to skip following observers when set to true
     * @param target defines the original target of the state
     * @param currentTarget defines the current target of the state
     */
    constructor(skipNextObservers = false) {
      this.initialize(skipNextObservers);
    }
    /**
     * Initialize the current event state
     * @param skipNextObservers defines a flag which will instruct the observable to skip following observers when set to true
     * @param target defines the original target of the state
     * @param currentTarget defines the current target of the state
     * @returns the current event state
     */
    initialize(skipNextObservers = false) {
      this.skipNextObservers = skipNextObservers;
      return this;
    }
    stopPropagation() {
      this.isStopPropagation = true;
    }
  };
  var Observer = class {
    /**
     * Creates a new observer
     * @param callback defines the callback to call when the observer is notified
     */
    constructor(callback) {
      this.callback = callback;
    }
    /** @hidden */
    _willBeUnregistered = false;
    /**
     * Gets or sets a property defining that the observer as to be unregistered after the next notification
     */
    unregisterOnNextCall = false;
  };
  var Observable = class {
    _observers = new Array();
    _eventState;
    _onObserverAdded;
    /**
     * Creates a new observable
     * @param onObserverAdded defines a callback to call when a new observer is added
     */
    constructor(onObserverAdded) {
      this._eventState = new EventState();
      if (onObserverAdded) {
        this._onObserverAdded = onObserverAdded;
      }
    }
    /**
     * Gets the list of observers
     */
    get observers() {
      return this._observers;
    }
    /**
     * Create a new WorkBookObserver with the specified callback
     * @param callback the callback that will be executed for that WorkBookObserver
     * @param insertFirst if true the callback will be inserted at the first position, hence executed before the others ones. If false (default behavior) the callback will be inserted at the last position, executed after all the others already present.
     * @param unregisterOnFirstCall defines if the observer as to be unregistered after the next notification
     * @returns the new observer created for the callback
     */
    add(callback, insertFirst = false, unregisterOnFirstCall = false) {
      if (!callback) {
        return null;
      }
      const observer = new Observer(callback);
      observer.unregisterOnNextCall = unregisterOnFirstCall;
      if (insertFirst) {
        this._observers.unshift(observer);
      } else {
        this._observers.push(observer);
      }
      if (this._onObserverAdded) {
        this._onObserverAdded(observer);
      }
      return observer;
    }
    /**
     * Create a new WorkBookObserver with the specified callback and unregisters after the next notification
     * @param callback the callback that will be executed for that WorkBookObserver
     * @returns the new observer created for the callback
     */
    addOnce(callback) {
      return this.add(callback, void 0, true);
    }
    /**
     * Remove an WorkBookObserver from the Observable object
     * @param observer the instance of the WorkBookObserver to remove
     * @returns false if it doesn't belong to this Observable
     */
    remove(observer) {
      if (!observer) {
        return false;
      }
      const index = this._observers.indexOf(observer);
      if (index !== -1) {
        this._deferUnregister(observer);
        return true;
      }
      return false;
    }
    /**
     * Remove a callback from the Observable object
     * @param callback the callback to remove
     * @returns false if it doesn't belong to this Observable
     */
    removeCallback(callback) {
      for (let index = 0; index < this._observers.length; index++) {
        const observer = this._observers[index];
        if (observer._willBeUnregistered) {
          continue;
        }
        if (observer.callback === callback) {
          this._deferUnregister(observer);
          return true;
        }
      }
      return false;
    }
    /**
     * Moves the observable to the top of the observer list making it get called first when notified
     * @param observer the observer to move
     */
    makeObserverTopPriority(observer) {
      this._remove(observer);
      this._observers.unshift(observer);
    }
    /**
     * Moves the observable to the bottom of the observer list making it get called last when notified
     * @param observer the observer to move
     */
    makeObserverBottomPriority(observer) {
      this._remove(observer);
      this._observers.push(observer);
    }
    /**
     * Notify all Observers by calling their respective callback with the given data
     * Will return true if all observers were executed, false if an observer set skipNextObservers to true, then prevent the subsequent ones to execute
     * @param eventData defines the data to send to all observers
     * @returns false if the complete observer chain was not processed (because one observer set the skipNextObservers to true)
     */
    notifyObservers(eventData) {
      if (!this._observers.length) {
        return null;
      }
      const state = this._eventState;
      state.skipNextObservers = false;
      state.lastReturnValue = eventData;
      state.isStopPropagation = false;
      let _isStopPropagation = false;
      for (let index = 0; index < this._observers.length; index++) {
        const obs = this._observers[index];
        if (obs._willBeUnregistered) {
          continue;
        }
        state.lastReturnValue = obs.callback(eventData, state);
        if (obs.unregisterOnNextCall) {
          this._deferUnregister(obs);
        }
        if (state.isStopPropagation) {
          _isStopPropagation = true;
        }
        if (state.skipNextObservers) {
          return {
            lastReturnValue: state.lastReturnValue,
            stopPropagation: _isStopPropagation
          };
        }
      }
      return {
        lastReturnValue: state.lastReturnValue,
        stopPropagation: _isStopPropagation
      };
    }
    /**
     * Calling this will execute each callback, expecting it to be a promise or return a value.
     * If at any point in the chain one function fails, the promise will fail and the execution will not continue.
     * This is useful when a chain of Events (sometimes async Events) is needed to initialize a certain object
     * and it is crucial that all callbacks will be executed.
     * The order of the callbacks is kept, callbacks are not executed parallel.
     *
     * @param eventData The data to be sent to each callback
     * @returns {Promise<T>} will return a Promise than resolves when all callbacks executed successfully.
     */
    notifyObserversWithPromise(eventData) {
      let p4 = Promise.resolve(eventData);
      if (!this._observers.length) {
        return p4;
      }
      const state = this._eventState;
      state.skipNextObservers = false;
      for (let index = 0; index < this._observers.length; index++) {
        const obs = this._observers[index];
        if (state.skipNextObservers) {
          continue;
        }
        if (obs._willBeUnregistered) {
          continue;
        }
        p4 = p4.then(() => obs.callback(eventData, state));
        if (obs.unregisterOnNextCall) {
          this._deferUnregister(obs);
        }
      }
      return p4.then(() => eventData);
    }
    /**
     * Notify a specific observer
     * @param observer defines the observer to notify
     * @param eventData defines the data to be sent to each callback
     */
    notifyObserver(observer, eventData) {
      if (observer._willBeUnregistered) {
        return;
      }
      const state = this._eventState;
      state.skipNextObservers = false;
      observer.callback(eventData, state);
      if (observer.unregisterOnNextCall) {
        this._deferUnregister(observer);
      }
      return {
        lastReturnValue: state.lastReturnValue,
        stopPropagation: state.isStopPropagation
      };
    }
    /**
     * Gets a boolean indicating if the observable has at least one observer
     * @returns true is the Observable has at least one WorkBookObserver registered
     */
    hasObservers() {
      return this._observers.length > 0;
    }
    /**
     * Clear the list of observers
     */
    clear() {
      this._observers = new Array();
      this._onObserverAdded = null;
    }
    /**
     * Clone the current observable
     * @returns a new observable
     */
    clone() {
      const result = new Observable();
      result._observers = this._observers.slice(0);
      return result;
    }
    _deferUnregister(observer) {
      observer.unregisterOnNextCall = false;
      observer._willBeUnregistered = true;
      setTimeout(() => {
        this._remove(observer);
      }, 0);
    }
    // This should only be called when not iterating over _observers to avoid callback skipping.
    // Removes an observer from the _observer Array.
    _remove(observer) {
      if (!observer) {
        return false;
      }
      const index = this._observers.indexOf(observer);
      if (index !== -1) {
        this._observers.splice(index, 1);
        return true;
      }
      return false;
    }
  };

  // ../../packages/core/src/Observer/HooksManager.ts
  var PathObservableHooks = class {
    namespace;
    name;
    observableHooks;
    constructor(name, hooks) {
      this.name = name;
      this.observableHooks = hooks;
    }
  };
  var HooksManager = class {
    _observableHooksArray;
    constructor() {
      this._observableHooksArray = new Array();
    }
    addHooks(name, hooks) {
      this._observableHooksArray.push(new PathObservableHooks(name, hooks));
    }
    getHooks(name) {
      const item = this._observableHooksArray.find((hook) => hook.name === name);
      return item ? item.observableHooks : null;
    }
  };

  // ../../packages/core/src/Shared/ArraySearch.ts
  function binarySearchArray(arr, pos) {
    let low = 0;
    let high = arr.length - 1;
    while (low <= high) {
      let mid = Math.floor((high + low) / 2);
      if (pos < arr[mid] && (mid === 0 || pos >= arr[mid - 1])) {
        return mid;
      }
      if (pos >= arr[mid]) {
        low = mid + 1;
      } else if (pos < arr[mid]) {
        high = mid - 1;
      } else {
        return -1;
      }
    }
    return -1;
  }
  function orderSearchArray(arr, pos) {
    let i4 = 0;
    let cur = 0;
    let cur_pre = 0;
    let cur_index = -1;
    let i_ed = arr.length - 1;
    while (i4 < arr.length && i_ed >= 0 && i_ed >= i4) {
      cur = arr[i_ed];
      if (i_ed === 0) {
        cur_pre = 0;
      } else {
        cur_pre = arr[i_ed - 1];
      }
      if (pos >= cur_pre && pos < cur) {
        cur_index = i_ed;
        break;
      }
      cur = arr[i4];
      if (i4 === 0) {
        cur_pre = 0;
      } else {
        cur_pre = arr[i4 - 1];
      }
      if (pos >= cur_pre && pos < cur) {
        cur_index = i4;
        break;
      }
      i4++;
      i_ed--;
    }
    return cur_index;
  }
  function searchArray(arr, num) {
    let index = arr.length - 1;
    if (arr.length < 40 || num <= arr[20] || num >= arr[index - 20]) {
      index = orderSearchArray(arr, num);
    } else {
      index = binarySearchArray(arr, num);
    }
    return index;
  }

  // ../../node_modules/.pnpm/nanoid@4.0.0/node_modules/nanoid/index.browser.js
  var nanoid = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
    byte &= 63;
    if (byte < 36) {
      id += byte.toString(36);
    } else if (byte < 62) {
      id += (byte - 26).toString(36).toUpperCase();
    } else if (byte > 62) {
      id += "-";
    } else {
      id += "_";
    }
    return id;
  }, "");

  // ../../packages/core/src/Shared/ObjectArray.ts
  var define2 = (value) => value !== void 0 && value !== null;
  var ObjectArray = class {
    _array;
    _length;
    constructor(...argument) {
      if (Tools.hasLength(argument, 1)) {
        if (Tools.isObject(argument[0])) {
          this._array = argument[0];
          this._length = ObjectArray.getMaxLength(this._array);
          return;
        }
        if (Tools.isNumber(argument[0])) {
          this._array = {};
          this._length = argument[0];
          return;
        }
      }
      if (Tools.hasLength(argument, 2)) {
        const array = argument[0];
        const size = argument[1];
        this._array = array;
        this._length = size;
        return;
      }
      if (Tools.hasLength(argument, 0)) {
        this._array = {};
        this._length = 0;
      }
    }
    static objectKeys(array) {
      if (array) {
        const keys = Object.keys(array);
        const index = keys.indexOf("length");
        if (index > -1) {
          keys.splice(index, 1);
        }
        return keys;
      }
      return [];
    }
    static getMaxLength(array) {
      if (array) {
        if (array.length) {
          return array.length;
        }
        const keys = ObjectArray.objectKeys(array);
        if (keys.length) {
          return Math.max(...keys) + 1;
        }
      }
      return 0;
    }
    obtain(index, defaultValue) {
      return this._array[index] ?? defaultValue;
    }
    getKeys() {
      return ObjectArray.objectKeys(this._array);
    }
    get(index) {
      return this._array[index];
    }
    set(index, value) {
      if (define2(value)) {
        const length = this._length;
        this._array[index] = value;
        if (index >= length) {
          this._length = index + 1;
        }
      }
    }
    pop() {
      const length = this._length;
      const array = this._array;
      if (length > 0) {
        const lastIndex = length - 1;
        const lastValue = array[lastIndex];
        if (lastIndex > 0) {
          delete array[lastIndex];
          this._length--;
        }
        return lastValue;
      }
      return null;
    }
    push(value) {
      if (define2(value)) {
        let length = this._length;
        const array = this._array;
        array[length++] = value;
        this._length = length;
      }
    }
    first() {
      return this._array[0];
    }
    last() {
      const length = this._length - 1;
      return this._array[length];
    }
    shift() {
      const length = this._length;
      if (length > 0) {
        const first = this._array[0];
        const sizeOf = length - 1;
        let next;
        for (let i4 = 0; i4 < sizeOf; i4++) {
          next = this._array[i4 + 1];
          if (define2(next)) {
            this._array[i4] = next;
          }
        }
        this._length--;
        delete this._array[sizeOf];
        return first;
      }
      return null;
    }
    unshift(topValue) {
      if (define2(topValue)) {
        const length = this._length;
        const array = this._array;
        const sizeOf = length + 1;
        let last = array[0];
        for (let i4 = 1; i4 < sizeOf; i4++) {
          const temp = this._array[i4];
          if (define2(last)) {
            array[i4] = last;
          }
          last = temp;
        }
        array[0] = topValue;
        this._length = sizeOf;
      }
    }
    clear() {
      this._array = {};
      this._length = 0;
    }
    getLength() {
      return this._length;
    }
    getSizeOf() {
      const array = this._array;
      const keys = Object.keys(array);
      return keys.length;
    }
    toJSON() {
      return { ...this._array, length: this._length };
    }
    toArray() {
      const native = new Array();
      const array = this._array;
      const keys = Object.keys(array);
      const length = keys.length;
      for (let i4 = 0; i4 < length; i4++) {
        const key = +keys[i4];
        native[key] = array[key];
      }
      return native;
    }
    forEach(callback) {
      const array = this._array;
      const keys = Object.keys(array);
      const length = keys.length;
      for (let i4 = 0; i4 < length; i4++) {
        const key = +keys[i4];
        const result = callback(key, array[key]);
        if (result === false) {
          return this;
        }
      }
      return this;
    }
    clone(callback) {
      const instance = new ObjectArray();
      if (callback) {
        this.forEach((idx, val) => {
          instance.set(idx, callback(val));
        });
      } else {
        this.forEach((idx, val) => {
          instance.set(idx, val);
        });
      }
      return instance;
    }
    isEmpty() {
      const array = this._array;
      const keys = Object.keys(array);
      return keys.length === 0;
    }
    delete(index) {
      this.splice(index, 1);
    }
    includes(target) {
      const array = this._array;
      const keys = Object.keys(array);
      const length = keys.length;
      for (let i4 = 0; i4 < length; i4++) {
        const key = +keys[i4];
        const value = array[key];
        if (value === target) {
          return true;
        }
      }
      return false;
    }
    slice(start, end) {
      const array = this._array;
      const length = this._length;
      if (length > 0) {
        const fragment = {};
        let effective = 0;
        for (let i4 = start; i4 < end; i4++) {
          const item = array[i4];
          if (define2(item)) {
            fragment[effective] = array[i4];
            effective++;
          }
        }
        return new ObjectArray(fragment, effective);
      }
      return new ObjectArray();
    }
    concat(target) {
      const srcArray = this._array;
      const srcKeys = Object.keys(srcArray);
      const srcLength = srcKeys.length;
      const targetArray = target._array;
      const targetKeys = Object.keys(targetArray);
      const targetLength = targetKeys.length;
      const container = new ObjectArray(srcLength + targetLength);
      const containerArray = container._array;
      let master = 0;
      for (let i4 = 0; i4 < srcLength; i4++, master++) {
        const key = srcKeys[i4];
        containerArray[master] = srcArray[key];
      }
      for (let i4 = 0; i4 < targetLength; i4++, master++) {
        const key = targetKeys[i4];
        containerArray[master] = targetArray[key];
      }
      return container;
    }
    find(callback) {
      const array = this._array;
      const keys = Object.keys(array);
      const length = keys.length;
      for (let i4 = 0; i4 < length; i4++) {
        const key = +keys[i4];
        const value = array[key];
        const result = callback(key, value);
        if (result === true) {
          return value;
        }
      }
      return null;
    }
    splice(start, count) {
      const length = this._length;
      if (length > 0) {
        const end = start + count;
        const array = this._array;
        let effective = 0;
        const splice = {};
        for (let i4 = start; i4 < end; i4++) {
          const item = array[i4];
          if (define2(item)) {
            delete array[i4];
            splice[effective] = item;
            effective++;
          }
        }
        const diff = end - start;
        const last = length;
        this._length -= diff;
        if (this._length <= 0) {
          this._array = {};
          this._length = 0;
        } else {
          for (let i4 = end; i4 < last; i4++) {
            const item = array[i4];
            if (define2(item)) {
              array[i4 - diff] = array[i4];
              delete array[i4];
            }
          }
        }
        return new ObjectArray(splice, effective);
      }
      return new ObjectArray();
    }
    findIndex(callback) {
      const array = this._array;
      const keys = Object.keys(array);
      const length = keys.length;
      for (let i4 = 0; i4 < length; i4++) {
        const key = +keys[i4];
        const result = callback(key, array[key]);
        if (result === true) {
          return i4;
        }
      }
      return -1;
    }
    map(callback) {
      const array = this._array;
      const keys = Object.keys(array);
      const length = keys.length;
      const result = {};
      for (let i4 = 0; i4 < length; i4++) {
        const key = +keys[i4];
        const value = array[key];
        result[i4] = callback(value);
      }
      return new ObjectArray(result);
    }
    filter(callback) {
      const array = this._array;
      const keys = Object.keys(array);
      const length = keys.length;
      const filter = {};
      let master = 0;
      for (let i4 = 0; i4 < length; i4++) {
        const key = +keys[i4];
        const value = array[key];
        if (callback(key, value)) {
          filter[master] = value;
          master++;
        }
      }
      return new ObjectArray(filter, master);
    }
    insert(index, value) {
      const length = this._length;
      const array = this._array;
      for (let i4 = length - 1; i4 >= index; i4--) {
        array[i4 + 1] = array[i4];
      }
      array[index] = value;
      this._length = length + 1;
      return this;
    }
    inserts(index, target) {
      const targetArray = target._array;
      const targetLength = target._length;
      const srcArray = this._array;
      const srcLength = this._length;
      const lastIndex = srcLength - 1;
      for (let i4 = lastIndex; i4 >= index; i4--) {
        const item = srcArray[i4];
        if (define2(item)) {
          delete srcArray[i4];
          srcArray[i4 + targetLength] = item;
        }
      }
      for (let i4 = 0; i4 < targetLength; i4++) {
        const item = targetArray[i4];
        if (define2(item)) {
          srcArray[i4 + index] = targetArray[i4];
        }
      }
      this._length += targetLength;
      return this;
    }
    [Symbol.iterator]() {
      return new ObjectArrayIterableIterator(this);
    }
  };
  var ObjectArrayIterableIterator = class {
    _array;
    _keys;
    _cursor;
    constructor(objectArray) {
      this._array = objectArray;
      this._keys = objectArray.getKeys();
      this._cursor = 0;
    }
    next() {
      const array = this._array;
      const keys = this._keys;
      const cursor = this._cursor;
      if (cursor < keys.length) {
        const key = keys[cursor];
        const value = array.get(+key);
        this._cursor++;
        return { value, done: false };
      }
      return { value: null, done: true };
    }
    [Symbol.iterator]() {
      return new ObjectArrayIterableIterator(this._array);
    }
  };

  // ../../packages/core/src/Shared/ObjectMatrix.ts
  var ObjectMatrix = class {
    _matrix;
    constructor(objectArray = {}) {
      if (Tools.isAssignableFrom(objectArray, ObjectMatrix)) {
        this._matrix = objectArray._matrix;
        return;
      }
      if (Tools.isAssignableFrom(objectArray, ObjectArray)) {
        this._matrix = objectArray;
        return;
      }
      if (Tools.isPlainObject(objectArray)) {
        this._matrix = new ObjectArray(objectArray);
      }
    }
    getMatrix() {
      return this._matrix;
    }
    forEach(callback) {
      const array = this._matrix;
      const keys = array.getKeys();
      const length = keys.length;
      for (let i4 = 0; i4 < length; i4++) {
        const key = +keys[i4];
        const value = this.getRow(key);
        const result = callback(key, value);
        if (result === false) {
          return this;
        }
      }
      return this;
    }
    forValue(callback) {
      const rowArray = this._matrix;
      const rowKeys = rowArray.getKeys();
      const rowLength = rowKeys.length;
      for (let i4 = 0; i4 < rowLength; i4++) {
        const rowNumber = +rowKeys[i4];
        const colArray = this.getRow(rowNumber);
        const colKeys = colArray.getKeys();
        const colLength = colKeys.length;
        for (let j3 = 0; j3 < colLength; j3++) {
          const colNumber = +colKeys[j3];
          const value = colArray.get(colNumber);
          const result = callback(rowNumber, colNumber, value);
          if (result === false) {
            return this;
          }
        }
      }
      return this;
    }
    swapRow(src, target) {
      const srcRow = this._matrix.get(src);
      const targetRow = this._matrix.get(target);
      this._matrix.set(target, srcRow);
      this._matrix.set(src, targetRow);
    }
    getRow(rowIndex) {
      const { _matrix } = this;
      let element = _matrix.get(rowIndex);
      if (Tools.isAssignableFrom(element, ObjectArray)) {
        return element;
      }
      if (Tools.isPlainObject(element)) {
        element = new ObjectArray(element);
        _matrix.set(rowIndex, element);
        return element;
      }
    }
    getRowOrCreate(rowIndex) {
      const objectArray = this.getRow(rowIndex);
      if (objectArray) {
        return objectArray;
      }
      const createArray = new ObjectArray();
      this._matrix.set(rowIndex, createArray);
      return createArray;
    }
    reset() {
      this._matrix = new ObjectArray({});
    }
    hasValue() {
      const matrix = this._matrix;
      for (const row of matrix) {
        if (!row.isEmpty()) {
          return true;
        }
      }
      return false;
    }
    getValue(row, column) {
      const objectArray = this.getRow(row);
      if (objectArray) {
        return objectArray.get(column);
      }
      return null;
    }
    setValue(row, column, value) {
      const objectArray = this.getRowOrCreate(row);
      objectArray.set(column, value);
    }
    deleteValue(row, column) {
      const objectArray = this.getRow(row);
      if (objectArray) {
        objectArray.delete(column);
      }
    }
    spliceRows(start, count) {
      const splice = this._matrix.splice(start, count);
      return new ObjectMatrix(splice);
    }
    pushRow(row) {
      this._matrix.push(row);
    }
    insertRow(rowIndex, row) {
      this._matrix.insert(rowIndex, row);
    }
    insertRows(rowIndex, matrix) {
      this._matrix.inserts(rowIndex, matrix._matrix);
    }
    spliceColumns(start, count) {
      const columnData = new ObjectMatrix();
      this._matrix.forEach((index, value) => {
        for (let i4 = start; i4 < start + count; i4++) {
          columnData.setValue(index, i4 - start, this.getValue(index, i4));
        }
        this._matrix.get(index)?.splice(start, count);
      });
      return columnData;
    }
    // insertColumn(columnIndex: number, columnData: T) {
    //     this._matrix.forEach((index, value) => {
    //         value.insert(columnIndex, columnData[index]);
    //     });
    // }
    insertColumns(columnIndex, columnData) {
      const count = columnData.getRow(0).getLength();
      this.forEach((index, value) => {
        for (let i4 = columnIndex; i4 < columnIndex + count; i4++) {
          const data = columnData.getRow(index)?.get(i4 - columnIndex);
          value.insert(i4, columnData.getRow(index)?.get(i4 - columnIndex));
        }
      });
    }
    getFragments(startRow, endRow, startColumn, endColumn) {
      const objectMatrix = new ObjectMatrix();
      for (let r4 = startRow; r4 <= endRow; r4++) {
        const row = new ObjectArray();
        for (let c4 = startColumn; c4 <= endColumn; c4++) {
          const value = this.getValue(r4, c4);
          row.push(value);
        }
        objectMatrix.pushRow(row);
      }
      return objectMatrix;
    }
    getSizeOf() {
      return this._matrix.getSizeOf();
    }
    getLength() {
      return this._matrix.getLength();
    }
    getRange() {
      const startRow = 0;
      const startColumn = 0;
      const endRow = this.getSizeOf();
      let endColumn = 0;
      const length = this.getLength();
      for (let i4 = 0; i4 < length; i4++) {
        const row = this.getRow(i4);
        if (row) {
          const sizeof = row.getSizeOf();
          if (row.getSizeOf() > endColumn) {
            endColumn = sizeof - 1;
          }
        }
      }
      return {
        startRow,
        startColumn,
        endRow,
        endColumn
      };
    }
    toArray() {
      return this._matrix.toArray().map((item) => item.toArray());
    }
    toJSON() {
      const { _matrix } = this;
      return _matrix.toJSON();
    }
    getData() {
      const json = JSON.stringify(this);
      return JSON.parse(json);
    }
    getArrayData() {
      let startRow = 0;
      let startColumn = 0;
      let initRow = false;
      let initColumn = false;
      const objectMatrix = new ObjectMatrix();
      this.forEach((rowIndex, row) => {
        if (!initRow) {
          initRow = true;
          startRow = rowIndex;
        }
        row.forEach((columnIndex, column) => {
          if (!initColumn) {
            initColumn = true;
            startColumn = columnIndex;
          } else if (columnIndex < startColumn) {
            startColumn = columnIndex;
          }
          const value = this.getValue(rowIndex, columnIndex);
          objectMatrix.setValue(
            rowIndex - startRow,
            columnIndex - startColumn,
            value
          );
        });
      });
      return objectMatrix.getData();
    }
    getDataRange() {
      let startRow = 0;
      let startColumn = 0;
      let endColumn = 0;
      let initRow = false;
      let initColumn = false;
      this.forEach((rowIndex, row) => {
        if (!initRow) {
          initRow = true;
          startRow = rowIndex;
        }
        const rowSize = row.getLength() - 1;
        if (rowSize > endColumn) {
          endColumn = rowSize;
        }
        row.forEach((columnIndex, column) => {
          if (!initColumn) {
            initColumn = true;
            startColumn = columnIndex;
          } else if (columnIndex < startColumn) {
            startColumn = columnIndex;
          }
        });
      });
      const endRow = startRow + this.getSizeOf() - 1;
      return {
        startRow,
        startColumn,
        endRow,
        endColumn
      };
    }
  };

  // ../../packages/core/src/Shared/Tools.ts
  var rmsPrefix = /^-ms-/;
  var rDashAlpha = /-([a-z])/g;
  var alphabets = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z"
  ];
  var Tools = class {
    static stringAt(index) {
      let str = "";
      let idx = index;
      while (idx >= alphabets.length) {
        idx /= alphabets.length;
        idx -= 1;
        str += alphabets[idx % alphabets.length];
      }
      const last = index % alphabets.length;
      str += alphabets[last];
      return str;
    }
    static getEnvironment() {
      const { appVersion } = navigator;
      const system = this.getSystemType();
      return {
        app_version: appVersion,
        os: system,
        os_version: system,
        device_id: "",
        platform: "web"
      };
    }
    static indexAt(code) {
      let ret = 0;
      for (let i4 = 0; i4 < code.length - 1; i4 += 1) {
        const idx = code.charCodeAt(i4) - 65;
        const expoNet = code.length - 1 - i4;
        ret += alphabets.length ** expoNet + alphabets.length * idx;
      }
      ret += code.charCodeAt(code.length - 1) - 65;
      return ret;
    }
    static deleteBlank(value) {
      if (Tools.isString(value)) {
        return value.replace(/\s/g, "");
      }
      return value;
    }
    static getSystemType() {
      const sUserAgent = navigator.userAgent;
      const isWin = navigator.platform === "Win32" || navigator.platform === "Windows";
      const isMac = navigator.platform === "Mac68K" || navigator.platform === "MacPPC" || navigator.platform === "Macintosh" || navigator.platform === "MacIntel";
      if (isMac)
        return "Mac";
      const isUnix = navigator.platform === "X11" && !isWin && !isMac;
      if (isUnix)
        return "Unix";
      const isLinux = String(navigator.platform).indexOf("Linux") > -1;
      if (isLinux)
        return "Linux";
      if (isWin) {
        const isWin2K = sUserAgent.indexOf("Windows NT 5.0") > -1 || sUserAgent.indexOf("Windows 2000") > -1;
        if (isWin2K)
          return "Windows 2000";
        const isWinXP = sUserAgent.indexOf("Windows NT 5.1") > -1 || sUserAgent.indexOf("Windows XP") > -1;
        if (isWinXP)
          return "Windows XP";
        const isWin2003 = sUserAgent.indexOf("Windows NT 5.2") > -1 || sUserAgent.indexOf("Windows 2003") > -1;
        if (isWin2003)
          return "Windows 2003";
        const isWinVista = sUserAgent.indexOf("Windows NT 6.0") > -1 || sUserAgent.indexOf("Windows Vista") > -1;
        if (isWinVista)
          return "Windows Vista";
        const isWin7 = sUserAgent.indexOf("Windows NT 6.1") > -1 || sUserAgent.indexOf("Windows 7") > -1;
        if (isWin7)
          return "Windows 7";
        const isWin10 = sUserAgent.indexOf("Windows NT 10") > -1 || sUserAgent.indexOf("Windows 10") > -1;
        if (isWin10)
          return "Windows 10";
        const isWin11 = sUserAgent.indexOf("Windows NT 11") > -1 || sUserAgent.indexOf("Windows 11") > -1;
        if (isWin11)
          return "Windows 11";
      }
      return "Unknown system";
    }
    static getBrowserType() {
      const userAgent = navigator.userAgent;
      const isOpera = userAgent.indexOf("Opera") > -1;
      const isIE = userAgent.indexOf("compatible") > -1 && userAgent.indexOf("MSIE") > -1 && !isOpera;
      const isIE11 = userAgent.indexOf("Trident") > -1 && userAgent.indexOf("rv:11.0") > -1;
      const isEdge = userAgent.indexOf("Edge") > -1;
      const isFF = userAgent.indexOf("Firefox") > -1;
      const isSafari = userAgent.indexOf("Safari") > -1 && userAgent.indexOf("Chrome") === -1;
      const isChrome = userAgent.indexOf("Chrome") > -1 && userAgent.indexOf("Safari") > -1;
      if (isIE) {
        const reIE = new RegExp("MSIE (\\d+\\.\\d+);");
        reIE.test(userAgent);
        const fIEVersion = parseFloat(RegExp.$1);
        if (fIEVersion === 7) {
          return "IE7";
        }
        if (fIEVersion === 8) {
          return "IE8";
        }
        if (fIEVersion === 9) {
          return "IE9";
        }
        if (fIEVersion === 10) {
          return "IE10";
        }
        return "0";
      }
      if (isFF) {
        return "FF";
      }
      if (isOpera) {
        return "Opera";
      }
      if (isSafari) {
        return "Safari";
      }
      if (isChrome) {
        return "Chrome";
      }
      if (isEdge) {
        return "Edge";
      }
      if (isIE11) {
        return "IE11";
      }
      return "Unknown browser";
    }
    static generateRandomId(n3 = 21) {
      return nanoid(n3);
    }
    static getClassName(instance) {
      return instance.constructor.name;
    }
    static deepMerge(target, ...sources) {
      sources.forEach((item) => item && deepItem(item));
      function deepArray(array, to) {
        array.forEach((value, key) => {
          if (Tools.isArray(value)) {
            const origin = to[key] ?? [];
            to[key] = origin;
            deepArray(value, origin);
            return;
          }
          if (Tools.isObject(value)) {
            const origin = to[key] ?? {};
            to[key] = origin;
            deepObject(value, origin);
            return;
          }
          to[key] = value;
        });
      }
      function deepObject(object, to) {
        Object.keys(object).forEach((key) => {
          const value = object[key];
          if (Tools.isObject(value)) {
            const origin = to[key] ?? {};
            to[key] = origin;
            deepObject(value, origin);
            return;
          }
          if (Tools.isArray(value)) {
            const origin = to[key] ?? [];
            to[key] = origin;
            deepArray(value, origin);
            return;
          }
          to[key] = value;
        });
      }
      function deepItem(item) {
        Object.keys(item).forEach((key) => {
          const value = item[key];
          if (Tools.isArray(value)) {
            const origin = target[key] ?? [];
            target[key] = origin;
            deepArray(value, origin);
            return;
          }
          if (Tools.isObject(value)) {
            const origin = target[key] ?? {};
            target[key] = origin;
            deepObject(value, origin);
            return;
          }
          target[key] = value;
        });
      }
      return target;
    }
    static numberFixed(value, digit) {
      return Number(Number(value).toFixed(digit));
    }
    static diffValue(one, tow) {
      function diffValue(oneValue, towValue) {
        const oneType = Tools.getValueType(oneValue);
        const towType = Tools.getValueType(towValue);
        if (oneType !== towType) {
          return false;
        }
        if (Tools.isArray(oneValue)) {
          return diffArrays(oneValue, towValue);
        }
        if (Tools.isObject(oneValue)) {
          return diffObject(oneValue, towValue);
        }
        if (Tools.isDate(oneValue)) {
          return oneValue.getTime() === towValue.getTime();
        }
        if (Tools.isRegExp(oneValue)) {
          return oneValue.toString() === towValue.toString();
        }
        return oneValue === towValue;
      }
      function diffArrays(oneArray, towArray) {
        if (one.length !== tow.length) {
          return false;
        }
        for (let i4 = 0, len = oneArray.length; i4 < len; i4++) {
          const oneValue = oneArray[i4];
          const towValue = towArray[i4];
          if (!diffValue(oneValue, towValue)) {
            return false;
          }
        }
        return true;
      }
      function diffObject(oneObject, towObject) {
        const oneKeys = Object.keys(oneObject);
        const towKeys = Object.keys(towObject);
        if (oneKeys.length !== towKeys.length) {
          return false;
        }
        for (const key of oneKeys) {
          if (!towKeys.includes(key)) {
            return false;
          }
          const oneValue = oneObject[key];
          const towValue = towObject[key];
          if (!diffValue(oneValue, towValue)) {
            return false;
          }
        }
        return true;
      }
      return diffValue(one, tow);
    }
    static deepClone(value) {
      if (!this.isDefine(value)) {
        return value;
      }
      if (this.isRegExp(value)) {
        return new RegExp(value);
      }
      if (this.isDate(value)) {
        return new Date(value);
      }
      if (this.isArray(value)) {
        const clone = [];
        value.forEach((item, index) => {
          clone[index] = Tools.deepClone(item);
        });
        return clone;
      }
      if (this.isObject(value)) {
        const clone = {};
        Object.keys(value).forEach((key) => {
          const item = value[key];
          clone[key] = Tools.deepClone(item);
        });
        Object.setPrototypeOf(clone, Object.getPrototypeOf(value));
        return clone;
      }
      return value;
    }
    static getLanguage() {
      const defaultValue = "en-US";
      if (globalThis.navigator) {
        return navigator.languages && navigator.languages[0] || navigator.language || defaultValue;
      }
      return defaultValue;
    }
    static getValueType(value) {
      return Object.prototype.toString.apply(value);
    }
    static isDefine(value) {
      return value !== void 0 && value !== null;
    }
    static isBlank(value) {
      if (!this.isDefine(value)) {
        return true;
      }
      if (this.isString(value)) {
        return value.trim() === "";
      }
      return false;
    }
    static isAssignableFrom(object, clazz) {
      return object instanceof clazz;
    }
    static isBoolean(value) {
      return this.getValueType(value) === "[object Boolean]";
    }
    static isPlainObject(value) {
      if (!this.isDefine(value)) {
        return false;
      }
      return Object.getPrototypeOf(value) === Object.getPrototypeOf({});
    }
    static isFunction(value) {
      return this.getValueType(value) === "[object Function]";
    }
    static isDate(value) {
      return this.getValueType(value) === "[object Date]";
    }
    static isRegExp(value) {
      return this.getValueType(value) === "[object RegExp]";
    }
    static isArray(value) {
      return this.getValueType(value) === "[object Array]";
    }
    static isString(value) {
      return this.getValueType(value) === "[object String]";
    }
    static isNumber(value) {
      return this.getValueType(value) === "[object Number]";
    }
    static isStringNumber(value) {
      return !isNaN(parseFloat(value)) && isFinite(value);
    }
    static isObject(value) {
      return this.getValueType(value) === "[object Object]";
    }
    static isEmptyObject(value) {
      for (const key in value) {
        return false;
      }
      return true;
    }
    static isMobile() {
      let clientWidth = 0;
      let clientHeight = 0;
      if (document.body.clientWidth) {
        clientWidth = document.body.clientWidth;
      }
      if (document.body.clientHeight) {
        clientHeight = document.body.clientHeight;
      }
      return this.isAndroid() || this.isIPhone() || this.isTablet() || clientWidth < 350 && clientHeight < 500;
    }
    static isTablet() {
      return /ipad|android|android 3.0|xoom|sch-i800|playbook|tablet|kindle/i.test(
        navigator.userAgent.toLowerCase()
      );
    }
    static isWeChat() {
      const userAgent = navigator.userAgent.toLowerCase();
      return String(userAgent.match(/MicroMessenger/i)) === "micromessenger" ? true : false;
    }
    static isAndroid() {
      const userAgent = navigator.userAgent;
      return userAgent.indexOf("Android") > -1 || userAgent.indexOf("Linux") > -1;
    }
    static isIPhone() {
      return /iPhone/i.test(navigator.userAgent);
    }
    static isIEBrowser() {
      return this.getBrowserType().startsWith("IE");
    }
    static itCount(count) {
      return (callback) => {
        for (let i4 = 0; i4 < count; i4++) {
          callback && callback();
        }
      };
    }
    static hasLength(target, length) {
      if (Tools.isDefine(target)) {
        if (Tools.isDefine(length)) {
          return target.length === length;
        }
        return target.length > 0;
      }
      return false;
    }
    static capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }
    // Used by camelCase as callback to replace()
    static fCamelCase(_all, letter) {
      return letter.toUpperCase();
    }
    // Convert dashed to camelCase; used by the css and data modules
    // Support: IE <=9 - 11, Edge 12 - 15
    // Microsoft forgot to hump their vendor prefix (#9572)
    static camelCase(str) {
      return str.replace(rmsPrefix, "ms-").replace(rDashAlpha, this.fCamelCase);
    }
    /**
     * remove all null from object
     * @param obj
     * @returns
     */
    static removeNull(value) {
      if (this.isObject(value)) {
        const clone = {};
        Object.keys(value).forEach((key) => {
          const item = value[key];
          if (item == null) {
            delete value[key];
          } else {
            Tools.removeNull(item);
          }
        });
        return clone;
      }
      return value;
    }
    /**
     * Generate a two-dimensional array with the specified number of rows and columns, and fill in the values
     * @param rows row length
     * @param columns column length
     * @param value value to be set
     * @returns
     */
    static fillTwoDimensionalArray(rows, columns, value) {
      return new Array(rows).fill(value).map((item) => new Array(columns).fill(value));
    }
    /**
     * Generate a two-dimensional array with the specified number of rows and columns, and fill in the values
     * @param rows row length
     * @param columns column length
     * @param value value to be set
     * @returns
     */
    static fillObjectMatrix(rows, columns, value) {
      const matrix = new ObjectMatrix();
      for (let r4 = 0; r4 < rows; r4++) {
        for (let c4 = 0; c4 < columns; c4++) {
          matrix.setValue(r4, c4, value);
        }
      }
      return matrix.getData();
    }
    static numToWord(x4) {
      let s4 = "";
      while (x4 > 0) {
        let m4 = x4 % 26;
        m4 = m4 === 0 ? m4 = 26 : m4;
        s4 = String.fromCharCode(96 + m4) + s4;
        x4 = (x4 - m4) / 26;
      }
      return s4.toLocaleUpperCase();
    }
    /**
     *
     * Column subscript letter to number
     *
     * @privateRemarks
     * zh:   
     *
     * @param a - Column subscript letter,e.g.,"A1"
     * @returns Column subscript number,e.g.,0
     *
     */
    static ABCatNum(a4) {
      if (a4 == null || a4.length === 0) {
        return NaN;
      }
      const str = a4.toLowerCase().split("");
      const al = str.length;
      let numOut = 0;
      let charnum = 0;
      for (let i4 = 0; i4 < al; i4++) {
        charnum = str[i4].charCodeAt(0) - 96;
        numOut += charnum * 26 ** (al - i4 - 1);
      }
      if (numOut === 0) {
        return NaN;
      }
      return numOut - 1;
    }
    /**
     * en: Column subscript number to letter
     *
     * zh:   
     *
     * @param n Column subscript number,e.g.,0
     * @returns Column subscript letter,e.g.,"A1"
     */
    static chatAtABC(n3) {
      const ord_a = "a".charCodeAt(0);
      const ord_z = "z".charCodeAt(0);
      const len = ord_z - ord_a + 1;
      let s4 = "";
      while (n3 >= 0) {
        s4 = String.fromCharCode(n3 % len + ord_a) + s4;
        n3 = Math.floor(n3 / len) - 1;
      }
      return s4.toUpperCase();
    }
    static randSort(arr) {
      for (let i4 = 0, len = arr.length; i4 < len; i4++) {
        const rand = parseInt((Math.random() * len).toString());
        const temp = arr[rand];
        arr[rand] = arr[i4];
        arr[i4] = temp;
      }
      return arr;
    }
    /**
     * extend two objects
     * @param originJson
     * @param extendJson
     * @returns
     */
    static commonExtend(originJson, extendJson) {
      let resultJsonObject = {};
      for (let attr in originJson) {
        resultJsonObject[attr] = originJson[attr];
      }
      for (let attr in extendJson) {
        if (extendJson[attr] == null) {
          continue;
        }
        resultJsonObject[attr] = extendJson[attr];
      }
      return resultJsonObject;
    }
    static commonExtend1(originJson, extendJson) {
      for (let attr in originJson) {
        if (extendJson[attr] == null) {
          extendJson[attr] = originJson[attr];
        }
      }
      return extendJson;
    }
    static arrayToObject(array) {
      const obj = {};
      array.forEach((row, i4) => {
        obj[i4] = {};
        row.forEach((column, j3) => {
          obj[i4][j3] = column;
        });
      });
      return obj;
    }
  };

  // ../../packages/core/src/Interfaces/IDocumentData.ts
  var GlyphType = /* @__PURE__ */ ((GlyphType2) => {
    GlyphType2[GlyphType2["GLYPH_TYPE_UNSPECIFIED"] = 0] = "GLYPH_TYPE_UNSPECIFIED";
    GlyphType2[GlyphType2["NONE"] = 1] = "NONE";
    GlyphType2[GlyphType2["DECIMAL"] = 2] = "DECIMAL";
    GlyphType2[GlyphType2["ZERO_DECIMAL"] = 3] = "ZERO_DECIMAL";
    GlyphType2[GlyphType2["UPPER_ALPHA"] = 4] = "UPPER_ALPHA";
    GlyphType2[GlyphType2["ALPHA"] = 5] = "ALPHA";
    GlyphType2[GlyphType2["UPPER_ROMAN"] = 6] = "UPPER_ROMAN";
    GlyphType2[GlyphType2["ROMAN"] = 7] = "ROMAN";
    return GlyphType2;
  })(GlyphType || {});

  // ../../packages/core/src/Const/CONST.ts
  var DEFAULT_RANGE_ARRAY = {
    sheetId: "",
    rangeData: {
      startRow: -1,
      endRow: -1,
      startColumn: -1,
      endColumn: -1
    }
  };
  var DEFAULT_RANGE = {
    startRow: -1,
    startColumn: -1,
    endRow: -1,
    endColumn: -1
  };
  var DEFAULT_SELECTION = {
    startRow: 0,
    startColumn: 0,
    endRow: 0,
    endColumn: 0
  };
  var DEFAULT_WORKBOOK = {
    extensions: [],
    id: "",
    sheetOrder: [],
    socketEnable: 0 /* FALSE */,
    socketUrl: "",
    name: "",
    timeZone: "",
    appVersion: "",
    theme: "",
    skin: "",
    locale: "en" /* EN */,
    creator: "",
    styles: {},
    sheets: {},
    lastModifiedBy: "",
    createdTime: "",
    modifiedTime: "",
    pluginMeta: {},
    namedRanges: []
  };
  var DEFAULT_WORKSHEET = {
    type: 0 /* GRID */,
    name: "Sheet1",
    id: "sheet-01",
    tabColor: "",
    hidden: 0 /* FALSE */,
    freezeColumn: -1,
    rowCount: 1e3,
    columnCount: 100,
    freezeRow: -1,
    zoomRatio: 1,
    scrollTop: 0,
    scrollLeft: 0,
    defaultColumnWidth: 73,
    defaultRowHeight: 19,
    mergeData: [],
    hideRow: [],
    hideColumn: [],
    cellData: {},
    rowData: {},
    columnData: {},
    status: 0 /* FALSE */,
    showGridlines: 1 /* TRUE */,
    rowTitle: {
      width: 46,
      hidden: 0 /* FALSE */
    },
    columnTitle: {
      height: 20,
      hidden: 0 /* FALSE */
    },
    selections: ["A1"],
    rightToLeft: 0 /* FALSE */,
    pluginMeta: {}
  };
  var DEFAULT_STYLES = {
    /**
     * fontFamily
     */
    ff: "Times New Roman",
    /**
     * fontSize
     */
    fs: 14,
    /**
     * italic
     * 0: false
     * 1: true
     */
    it: 0 /* FALSE */,
    /**
     * bold
     * 0: false
     * 1: true
     */
    bl: 0 /* FALSE */,
    /**
     * underline
     */
    ul: {
      s: 0 /* FALSE */
    },
    /**
     * strikethrough
     */
    st: {
      s: 0 /* FALSE */
    },
    /**
     * overline
     */
    ol: {
      s: 0 /* FALSE */
    },
    /**
     * textRotation
     */
    tr: {
      a: 0,
      /**
       * true : 1
       * false : 0
       */
      v: 0 /* FALSE */
    },
    /** *
     * textDirection
     */
    td: 0 /* UNSPECIFIED */,
    /**
     * color
     */
    cl: {
      rgb: "#000"
    },
    /**
     * background
     */
    bg: {
      rgb: "#fff"
    },
    /**
     * horizontalAlignment
     */
    ht: 0 /* UNSPECIFIED */,
    /**
     * verticalAlignment
     */
    vt: 0 /* UNSPECIFIED */,
    /**
     * wrapStrategy
     */
    tb: 0 /* UNSPECIFIED */,
    /**
     * padding
     */
    pd: {
      t: 0,
      r: 0,
      b: 0,
      l: 0
    }
  };

  // ../../packages/core/src/Const/KEYBOARD_KEYS.ts
  var KEYBOARD_KEYS = {
    modifier: [
      "Alt",
      //The Alt (Alternative) key. This key enables the alternate modifier function for interpreting concurrent or subsequent keyboard input. .This key value is also used for the Apple Option key.
      "AltGraph",
      //The Alternate Graphics (AltGr or AltGraph) key.	This key is used enable the ISO Level 3 shift modifier (the standard Shift key is the level 2 modifier). See  [ISO9995-1].
      "CapsLock",
      //The Caps Lock (Capital) key.	Toggle capital character lock function for interpreting subsequent keyboard input event.
      "Control",
      //The Control or Ctrl key, to enable control modifier function for interpreting concurrent or subsequent keyboard input.
      "Fn",
      //The Function switch Fn key. Activating this key simultaneously with another key changes that keys value to an alternate character or function. This key is often handled directly in the keyboard hardware and does not usually generate key events.
      "FnLock",
      //The Function-Lock (FnLock or F-Lock) key.	Activating this key switches the mode of the keyboard to changes some keys' values to an alternate character or function. This key is often handled directly in the keyboard hardware and does not usually generate key events.
      "Meta",
      //The Meta key, to enable meta modifier function for interpreting concurrent or subsequent keyboard input.	This key value is used for the Windows Logo key and the Apple Command or  key.
      "NumLock",
      //The NumLock or Number Lock key, to toggle numpad mode function for interpreting subsequent keyboard input.
      "ScrollLock",
      //The Scroll Lock key, to toggle between scrolling and cursor movement modes.
      "Shift",
      //The Shift key, to enable shift modifier function for interpreting concurrent or subsequent keyboard input.
      "Symbol",
      //The Symbol modifier key (used on some virtual keyboards).
      "SymbolLock"
      //The Symbol Lock key.
    ],
    legacyModifier: [
      "Hyper",
      //The Hyper key.
      "Super"
      //The Super key.
    ],
    whiteSpace: [
      "Enter",
      //The Enter or  key, to activate current selection or accept current input. This key value is also used for the Return (Macintosh numpad) key. This key value is also used for the Android KEYCODE_DPAD_CENTER.
      "Tab"
      //The Horizontal Tabulation Tab key. The space or spacebar key is encoded as " ".
    ],
    navigation: [
      "ArrowDown",
      //The down arrow key, to navigate or traverse downward. (KEYCODE_DPAD_DOWN)
      "ArrowLeft",
      //The left arrow key, to navigate or traverse leftward. (KEYCODE_DPAD_LEFT)
      "ArrowRight",
      //The right arrow key, to navigate or traverse rightward. (KEYCODE_DPAD_RIGHT)
      "ArrowUp",
      //The up arrow key, to navigate or traverse upward. (KEYCODE_DPAD_UP)
      "End",
      //The End key, used with keyboard entry to go to the end of content (KEYCODE_MOVE_END).
      "Home",
      //The Home key, used with keyboard entry, to go to start of content (KEYCODE_MOVE_HOME). For the mobile phone Home key (which goes to the phones main screen), use "GoHome".
      "PageDown",
      //The Page Down key, to scroll down or display next page of content.
      "PageUp"
      //The Page Up key, to scroll up or display previous page of content.
    ],
    editing: [
      "Backspace",
      //The Backspace key. This key value is also used for the key labeled Delete on MacOS keyboards.
      "Clear",
      //Remove the currently selected input.
      "Copy",
      //Copy the current selection. (APPCOMMAND_COPY)
      "CrSel",
      //The Cursor Select (Crsel) key.
      "Cut",
      //Cut the current selection. (APPCOMMAND_CUT)
      "Delete",
      //The Delete (Del) Key.	This key value is also used for the key labeled Delete on MacOS keyboards when modified by the Fn key.
      "EraseEof",
      //The Erase to End of Field key. This key deletes all characters from the current cursor position to the end of the current field.
      "ExSel",
      //The Extend Selection (Exsel) key.
      "Insert",
      //The Insert (Ins) key, to toggle between text modes for insertion or overtyping. (KEYCODE_INSERT)
      "Paste",
      //The Paste key. (APPCOMMAND_PASTE)
      "Redo",
      //Redo the last action. (APPCOMMAND_REDO)
      "Undo"
      //Undo the last action. (APPCOMMAND_UNDO)
    ],
    ui: [
      "Accept",
      //The Accept (Commit, OK) key. Accept current option or input method sequence conversion.
      "Again",
      //The Again key, to redo or repeat an action.
      "Attn",
      //The Attention (Attn) key.
      "Cancel",
      //The Cancel key.
      "ContextMenu",
      //Show the applications context menu.	This key is commonly found between the right Meta key and the right Control key.
      "Escape",
      //The Esc key. This key was originally used to initiate an escape sequence, but is now more generally used to exit or "escape" the current context, such as closing a dialog or exiting full screen mode.
      "Execute",
      //The Execute key.
      "Find",
      //Open the Find dialog. (APPCOMMAND_FIND)
      "Help",
      //Open a help dialog or toggle display of help information. (APPCOMMAND_HELP, KEYCODE_HELP)
      "Pause",
      //Pause the current state or application (as appropriate). Do not use this value for the Pause button on media controllers. Use "MediaPause" instead.
      "Play",
      //Play or resume the current state or application (as appropriate). Do not use this value for the Play button on media controllers. Use "MediaPlay" instead.
      "Props",
      //The properties (Props) key.
      "Select",
      //The Select key.
      "ZoomIn",
      //The ZoomIn key. (KEYCODE_ZOOM_IN)
      "ZoomOut"
      //The ZoomOut key. (KEYCODE_ZOOM_OUT)
    ],
    device: [
      "BrightnessDown",
      //The Brightness Down key. Typically controls the display brightness. (KEYCODE_BRIGHTNESS_DOWN)
      "BrightnessUp",
      //The Brightness Up key. Typically controls the display brightness. (KEYCODE_BRIGHTNESS_UP)
      "Eject",
      //Toggle removable media to eject (open) and insert (close) state. (KEYCODE_MEDIA_EJECT)
      "LogOff",
      //The LogOff key.
      "Power",
      //Toggle power state. (KEYCODE_POWER) Note: Some devices might not expose this key to the operating environment.
      "PowerOff",
      //The PowerOff key. Sometime called PowerDown.
      "PrintScreen",
      //The Print Screen or SnapShot key, to initiate print-screen function.
      "Hibernate",
      //The Hibernate key.	This key saves the current state of the computer to disk so that it can be restored. The computer will then shutdown.
      "Standby",
      //The Standby key.	This key turns off the display and places the computer into a low-power mode without completely shutting down. It is sometimes labelled Suspend or Sleep key. (KEYCODE_SLEEP)
      "WakeUp"
      //The WakeUp key. (KEYCODE_WAKEUP)
    ],
    imeCompositionKeys: [
      "AllCandidates",
      //The All Candidates key, to initate the multi-candidate mode.
      "Alphanumeric",
      //The Alphanumeric key.
      "CodeInput",
      //The Code Input key, to initiate the Code Input mode to allow characters to be entered by their code points.
      "Compose",
      //The Compose key, also known as Multi_key on the X Window System. This key acts in a manner similar to a	dead key, triggering a mode where subsequent key presses are combined to produce a different character.
      "Convert",
      //The Convert key, to convert the current input method sequence.
      "Dead",
      //A dead key combining key. It may be any combining key from any keyboard layout. For example, on a	PC/AT French keyboard, using a French mapping and without any modifier activiated, this is the key value U+0302 COMBINING CIRCUMFLEX ACCENT. In another layout this might be a different unicode combining key. For applications that need to differentiate between specific combining characters, the associated compositionupdate events data attribute provides the specific key value.
      "FinalMode",
      //The Final Mode Final key used on some Asian keyboards, to enable the final mode for IMEs.
      "GroupFirst",
      //Switch to the first character group. (ISO/IEC 9995)
      "GroupLast",
      //Switch to the last character group. (ISO/IEC 9995)
      "GroupNext",
      //Switch to the next character group. (ISO/IEC 9995)
      "GroupPrevious",
      //Switch to the previous character group. (ISO/IEC 9995)
      "ModeChange",
      //The Mode Change key, to toggle between or cycle through input modes of IMEs.
      "NextCandidate",
      //The Next Candidate function key.
      "NonConvert",
      //The NonConvert ("Dont Convert") key, to accept current input method sequence without conversion in IMEs.
      "PreviousCandidate",
      //The Previous Candidate function key.
      "Process",
      //The Process key.
      "SingleCandidate"
      //The Single Candidate function key.
    ],
    koreanSpecific: [
      "HangulMode",
      //The Hangul (Korean characters) Mode key, to toggle between Hangul and English modes.
      "HanjaMode",
      //The Hanja (Korean characters) Mode key.
      "JunjaMode"
      //The Junja (Korean characters) Mode key.
    ],
    japaneseSpecific: [
      "Eisu",
      //The Eisu key. This key may close the IME, but its purpose	is defined by the current IME. (KEYCODE_EISU)
      "Hankaku",
      //The (Half-Width) Characters key.
      "Hiragana",
      //The Hiragana (Japanese Kana characters) key.
      "HiraganaKatakana",
      //The Hiragana/Katakana toggle key. (KEYCODE_KATAKANA_HIRAGANA)
      "KanaMode",
      //The Kana Mode (Kana Lock) key. This key is used to enter	hiragana mode (typically from romaji mode).
      "KanjiMode",
      //The Kanji (Japanese name for ideographic characters of Chinese origin) Mode key.	This key is typically used to switch to a hiragana keyboard for the purpose of converting input into kanji. (KEYCODE_KANA)
      "Katakana",
      //The Katakana (Japanese Kana characters) key.
      "Romaji",
      //The Roman characters function key.
      "Zenkaku",
      //The Zenkaku (Full-Width) Characters key.
      "ZenkakuHankaku"
      //The Zenkaku/Hankaku (full-width/half-width) toggle key. (KEYCODE_ZENKAKU_HANKAKU)
    ],
    // The exact number of these general purpose function keys varies on different platforms, and only the first few are defined explicitly here. Additional function key names are implicitly defined by incrementing the base-10 index at the end of the function key name. Thus, "F24" and "Soft8" are all valid key values.
    commonFunction: [
      "F1",
      //The F1 key, a general purpose function key, as index 1.
      "F2",
      //The F2 key, a general purpose function key, as index 2.
      "F3",
      //The F3 key, a general purpose function key, as index 3.
      "F4",
      //The F4 key, a general purpose function key, as index 4.
      "F5",
      //The F5 key, a general purpose function key, as index 5.
      "F6",
      //The F6 key, a general purpose function key, as index 6.
      "F7",
      //The F7 key, a general purpose function key, as index 7.
      "F8",
      //The F8 key, a general purpose function key, as index 8.
      "F9",
      //The F9 key, a general purpose function key, as index 9.
      "F10",
      //The F10 key, a general purpose function key, as index 10.
      "F11",
      //The F11 key, a general purpose function key, as index 11.
      "F12",
      //The F12 key, a general purpose function key, as index 12.
      "Soft1",
      //General purpose virtual function key, as index 1.
      "Soft2",
      //General purpose virtual function key, as index 2.
      "Soft3",
      //General purpose virtual function key, as index 3.
      "Soft4"
      //General purpose virtual function key, as index 4.
    ],
    // These are extra keys found on "multimedia" keyboards.
    multimedia: [
      "ChannelDown",
      //Select next (numerically or logically) lower channel. (APPCOMMAND_MEDIA_CHANNEL_DOWN, KEYCODE_CHANNEL_DOWN)
      "ChannelUp",
      //Select next (numerically or logically) higher channel. (APPCOMMAND_MEDIA_CHANNEL_UP, KEYCODE_CHANNEL_UP)
      "Close",
      //Close the current document or message (Note: This doesnt close the application). (APPCOMMAND_CLOSE)
      "MailForward",
      //Open an editor to forward the current message. (APPCOMMAND_FORWARD_MAIL)
      "MailReply",
      //Open an editor to reply to the current message. (APPCOMMAND_REPLY_TO_MAIL)
      "MailSend",
      //Send the current message. (APPCOMMAND_SEND_MAIL)
      "MediaClose",
      //Close the current media, for example to close a CD or DVD tray. (KEYCODE_MEDIA_CLOSE)
      "MediaFastForward",
      //Initiate or continue forward playback at faster than normal speed, or increase speed if already fast forwarding. (APPCOMMAND_MEDIA_FAST_FORWARD, KEYCODE_MEDIA_FAST_FORWARD)
      "MediaPause",
      //Pause the currently playing media. (APPCOMMAND_MEDIA_PAUSE, KEYCODE_MEDIA_PAUSE) Media controller devices should use this value rather than "Pause" for their pause keys.
      "MediaPlay",
      //Initiate or continue media playback at normal speed, if not currently playing at normal speed. (APPCOMMAND_MEDIA_PLAY, KEYCODE_MEDIA_PLAY)
      "MediaPlayPause",
      //Toggle media between play and pause states. (APPCOMMAND_MEDIA_PLAY_PAUSE, KEYCODE_MEDIA_PLAY_PAUSE)
      "MediaRecord",
      //Initiate or resume recording of currently selected media. (APPCOMMAND_MEDIA_RECORD, KEYCODE_MEDIA_RECORD)
      "MediaRewind",
      //Initiate or continue reverse playback at faster than normal speed, or increase speed if already rewinding. (APPCOMMAND_MEDIA_REWIND, KEYCODE_MEDIA_REWIND)
      "MediaStop",
      //Stop media playing, pausing, forwarding, rewinding, or recording, if not already stopped. (APPCOMMAND_MEDIA_STOP, KEYCODE_MEDIA_STOP)
      "MediaTrackNext",
      //Seek to next media or program track. (APPCOMMAND_MEDIA_NEXTTRACK, KEYCODE_MEDIA_NEXT)
      "MediaTrackPrevious",
      //Seek to previous media or program track. (APPCOMMAND_MEDIA_PREVIOUSTRACK, KEYCODE_MEDIA_PREVIOUS)
      "New",
      //Open a new document or message. (APPCOMMAND_NEW)
      "Open",
      //Open an existing document or message. (APPCOMMAND_OPEN)
      "Print",
      //Print the current document or message. (APPCOMMAND_PRINT)
      "Save",
      //Save the current document or message. (APPCOMMAND_SAVE)
      "SpellCheck"
      //Spellcheck the current document or selection. (APPCOMMAND_SPELL_CHECK)
    ],
    // The normal 0 ... 9 numpad keys are encoded as "0" ... "9", but some multimedia keypads have buttons numbered from 1 ... 12. In these instances, the 10 key is often labeled 10 /0. Note: The 10 or 10 /0 key MUST be assigned a key value of "0".
    multimediaNumpad: [
      "Key11",
      //The 11 key found on media numpads that	have buttons from 1 ... 12.
      "Key12"
      //The 12 key found on media numpads that	have buttons from 1 ... 12.
    ],
    // Multimedia keys related to audio.
    audio: [
      "AudioBalanceLeft",
      //Adjust audio balance leftward. (VK_AUDIO_BALANCE_LEFT)
      "AudioBalanceRight",
      //Adjust audio balance rightward. (VK_AUDIO_BALANCE_RIGHT)
      "AudioBassBoostDown",
      //Decrease audio bass boost or cycle down through bass boost states. (APPCOMMAND_BASS_DOWN, VK_BASS_BOOST_DOWN)
      "AudioBassBoostToggle",
      //Toggle bass boost on/off. (APPCOMMAND_BASS_BOOST)
      "AudioBassBoostUp",
      //Increase audio bass boost or cycle up through bass boost states. (APPCOMMAND_BASS_UP, VK_BASS_BOOST_UP)
      "AudioFaderFront",
      //Adjust audio fader towards front. (VK_FADER_FRONT)
      "AudioFaderRear",
      //Adjust audio fader towards rear. (VK_FADER_REAR)
      "AudioSurroundModeNext",
      //Advance surround audio mode to next available mode. (VK_SURROUND_MODE_NEXT)
      "AudioTrebleDown",
      //Decrease treble. (APPCOMMAND_TREBLE_DOWN)
      "AudioTrebleUp",
      //Increase treble. (APPCOMMAND_TREBLE_UP)
      "AudioVolumeDown",
      //Decrease audio volume. (APPCOMMAND_VOLUME_DOWN, KEYCODE_VOLUME_DOWN)
      "AudioVolumeUp",
      //Increase audio volume. (APPCOMMAND_VOLUME_UP, KEYCODE_VOLUME_UP)
      "AudioVolumeMute",
      //Toggle between muted state and prior volume level. (APPCOMMAND_VOLUME_MUTE, KEYCODE_VOLUME_MUTE)
      "MicrophoneToggle",
      //Toggle the microphone on/off. (APPCOMMAND_MIC_ON_OFF_TOGGLE)
      "MicrophoneVolumeDown",
      //Decrease microphone volume. (APPCOMMAND_MICROPHONE_VOLUME_DOWN)
      "MicrophoneVolumeUp",
      //Increase microphone volume. (APPCOMMAND_MICROPHONE_VOLUME_UP)
      "MicrophoneVolumeMute"
      //Mute the microphone. (APPCOMMAND_MICROPHONE_VOLUME_MUTE, KEYCODE_MUTE)
    ],
    // Multimedia keys related to speech recognition.
    speech: [
      "SpeechCorrectionList",
      //Show correction list when a word is incorrectly identified. (APPCOMMAND_CORRECTION_LIST)
      "SpeechInputToggle"
      //Toggle between dictation mode and command/control mode. (APPCOMMAND_DICTATE_OR_COMMAND_CONTROL_TOGGLE)
    ],
    // The Application Keys are special keys that are assigned to launch a particular application. Additional application key names can be defined by concatenating "Launch" with the name of the application.
    application: [
      "LaunchApplication1",
      //The first generic "LaunchApplication" key. This is commonly associated with launching "My Computer", and may have a computer symbol on the key. (APPCOMMAND_LAUNCH_APP1)
      "LaunchApplication2",
      //The second generic "LaunchApplication" key. This is commonly associated with launching "Calculator", and may have a calculator symbol on the key. (APPCOMMAND_LAUNCH_APP2, KEYCODE_CALCULATOR)
      "LaunchCalendar",
      //The "Calendar" key. (KEYCODE_CALENDAR)
      "LaunchContacts",
      //The "Contacts" key. (KEYCODE_CONTACTS)
      "LaunchMail",
      //The "Mail" key. (APPCOMMAND_LAUNCH_MAIL)
      "LaunchMediaPlayer",
      //The "Media Player" key. (APPCOMMAND_LAUNCH_MEDIA_SELECT)
      "LaunchMusicPlayer",
      //The "Music Player" key.
      "LaunchPhone",
      //The "Phone" key.
      "LaunchScreenSaver",
      //The "Screen Saver" key.
      "LaunchSpreadsheet",
      //The "Sheets" key.
      "LaunchWebBrowser",
      //The "Web Browser" key.
      "LaunchWebCam",
      //The "WebCam" key.
      "LaunchWordProcessor"
      //The "Word Processor" key.
    ],
    browser: [
      "BrowserBack",
      //Navigate to previous content or page in current history. (APPCOMMAND_BROWSER_BACKWARD)
      "BrowserFavorites",
      //Open the list of browser favorites. (APPCOMMAND_BROWSER_FAVORITES)
      "BrowserForward",
      //Navigate to next content or page in current history. (APPCOMMAND_BROWSER_FORWARD)
      "BrowserHome",
      //Go to the users preferred home page. (APPCOMMAND_BROWSER_HOME)
      "BrowserRefresh",
      //Refresh the current page or content. (APPCOMMAND_BROWSER_REFRESH)
      "BrowserSearch",
      //Call up the users preferred search page. (APPCOMMAND_BROWSER_SEARCH)
      "BrowserStop"
      //Stop loading the current page or content. (APPCOMMAND_BROWSER_STOP)
    ],
    mobilePhone: [
      "AppSwitch",
      //The Application switch key, which provides a list of recent apps to switch between. (KEYCODE_APP_SWITCH)
      "Call",
      //The Call key. (KEYCODE_CALL)
      "Camera",
      //The Camera key. (KEYCODE_CAMERA)
      "CameraFocus",
      //The Camera focus key. (KEYCODE_FOCUS)
      "EndCall",
      //The End Call key. (KEYCODE_ENDCALL)
      "GoBack",
      //The Back key. (KEYCODE_BACK)
      "GoHome",
      //The Home key, which goes to the phones main screen. (KEYCODE_HOME)
      "HeadsetHook",
      //The Headset Hook key. (KEYCODE_HEADSETHOOK)
      "LastNumberRedial",
      //The Last Number Redial key.
      "Notification",
      //The Notification key. (KEYCODE_NOTIFICATION)
      "MannerMode",
      //Toggle between manner mode state: silent, vibrate, ring, ... (KEYCODE_MANNER_MODE)
      "VoiceDial"
      //The Voice Dial key.
    ],
    tv: [
      "TV",
      //Switch to viewing TV. (KEYCODE_TV)
      "TV3DMode",
      //TV 3D Mode. (KEYCODE_3D_MODE)
      "TVAntennaCable",
      //Toggle between antenna and cable input. (KEYCODE_TV_ANTENNA_CABLE)
      "TVAudioDescription",
      //Audio description. (KEYCODE_TV_AUDIO_DESCRIPTION)
      "TVAudioDescriptionMixDown",
      //Audio description mixing volume down. (KEYCODE_TV_AUDIO_DESCRIPTION_MIX_DOWN)
      "TVAudioDescriptionMixUp",
      //Audio description mixing volume up. (KEYCODE_TV_AUDIO_DESCRIPTION_MIX_UP)
      "TVContentsMenu",
      //Contents menu. (KEYCODE_TV_CONTENTS_MENU)
      "TVDataService",
      //Contents menu. (KEYCODE_TV_DATA_SERVICE)
      "TVInput",
      //Switch the input mode on an external TV. (KEYCODE_TV_INPUT)
      "TVInputComponent1",
      //Switch to component input #1. (KEYCODE_TV_INPUT_COMPONENT_1)
      "TVInputComponent2",
      //Switch to component input #2. (KEYCODE_TV_INPUT_COMPONENT_2)
      "TVInputComposite1",
      //Switch to composite input #1. (KEYCODE_TV_INPUT_COMPOSITE_1)
      "TVInputComposite2",
      //Switch to composite input #2. (KEYCODE_TV_INPUT_COMPOSITE_2)
      "TVInputHDMI1",
      //Switch to HDMI input #1. (KEYCODE_TV_INPUT_HDMI_1)
      "TVInputHDMI2",
      //Switch to HDMI input #2. (KEYCODE_TV_INPUT_HDMI_2)
      "TVInputHDMI3",
      //Switch to HDMI input #3. (KEYCODE_TV_INPUT_HDMI_3)
      "TVInputHDMI4",
      //Switch to HDMI input #4. (KEYCODE_TV_INPUT_HDMI_4)
      "TVInputVGA1",
      //Switch to VGA input #1. (KEYCODE_TV_INPUT_VGA_1)
      "TVMediaContext",
      //Media context menu. (KEYCODE_TV_MEDIA_CONTEXT_MENU)
      "TVNetwork",
      //Toggle network. (KEYCODE_TV_NETWORK)
      "TVNumberEntry",
      //Number entry. (KEYCODE_TV_NUMBER_ENTRY)
      "TVPower",
      //Toggle the power on an external TV. (KEYCODE_TV_POWER)
      "TVRadioService",
      //Radio. (KEYCODE_TV_RADIO_SERVICE)
      "TVSatellite",
      //Satellite. (KEYCODE_TV_SATELLITE)
      "TVSatelliteBS",
      //Broadcast Satellite. (KEYCODE_TV_SATELLITE_BS)
      "TVSatelliteCS",
      //Communication Satellite. (KEYCODE_TV_SATELLITE_CS)
      "TVSatelliteToggle",
      //Toggle between available satellites. (KEYCODE_TV_SATELLITE_SERVICE)
      "TVTerrestrialAnalog",
      //Analog Terrestrial. (KEYCODE_TV_TERRESTRIAL_ANALOG)
      "TVTerrestrialDigital",
      //Digital Terrestrial. (KEYCODE_TV_TERRESTRIAL_DIGITAL)
      "TVTimer"
      //Timer programming. (KEYCODE_TV_TIMER_PROGRAMMING)
    ],
    // The key attribute values for media controllers (e.g. remote controls for television, audio systems, and set-top boxes) are derived in part from the consumer electronics technical specifications:
    mediaControls: [
      "AVRInput",
      //Switch the input mode on an external AVR (audio/video receiver). (KEYCODE_AVR_INPUT)
      "AVRPower",
      //Toggle the power on an external AVR (audio/video receiver). (KEYCODE_AVR_POWER)
      "ColorF0Red",
      //General purpose color-coded media function key, as index 0 (red). (VK_COLORED_KEY_0, KEYCODE_PROG_RED)
      "ColorF1Green",
      //General purpose color-coded media function key, as index 1 (green). (VK_COLORED_KEY_1, KEYCODE_PROG_GREEN)
      "ColorF2Yellow",
      //General purpose color-coded media function key, as index 2 (yellow). (VK_COLORED_KEY_2, KEYCODE_PROG_YELLOW)
      "ColorF3Blue",
      //General purpose color-coded media function key, as index 3 (blue). (VK_COLORED_KEY_3, KEYCODE_PROG_BLUE)
      "ColorF4Grey",
      //General purpose color-coded media function key, as index 4 (grey). (VK_COLORED_KEY_4)
      "ColorF5Brown",
      //General purpose color-coded media function key, as index 5 (brown). (VK_COLORED_KEY_5)
      "ClosedCaptionToggle",
      //Toggle the display of Closed Captions. (VK_CC, KEYCODE_CAPTIONS)
      "Dimmer",
      //Adjust brightness of device, by toggling between or cycling through states. (VK_DIMMER)
      "DisplaySwap",
      //Swap video sources. (VK_DISPLAY_SWAP)
      "DVR",
      //Select Digital Video Rrecorder. (KEYCODE_DVR)
      "Exit",
      //Exit the current application. (VK_EXIT)
      "FavoriteClear0",
      //Clear program or content stored as favorite 0. (VK_CLEAR_FAVORITE_0)
      "FavoriteClear1",
      //Clear program or content stored as favorite 1. (VK_CLEAR_FAVORITE_1)
      "FavoriteClear2",
      //Clear program or content stored as favorite 2. (VK_CLEAR_FAVORITE_2)
      "FavoriteClear3",
      //Clear program or content stored as favorite 3. (VK_CLEAR_FAVORITE_3)
      "FavoriteRecall0",
      //Select (recall) program or content stored as favorite 0. (VK_RECALL_FAVORITE_0)
      "FavoriteRecall1",
      //Select (recall) program or content stored as favorite 1. (VK_RECALL_FAVORITE_1)
      "FavoriteRecall2",
      //Select (recall) program or content stored as favorite 2. (VK_RECALL_FAVORITE_2)
      "FavoriteRecall3",
      //Select (recall) program or content stored as favorite 3. (VK_RECALL_FAVORITE_3)
      "FavoriteStore0",
      //Store current program or content as favorite 0. (VK_STORE_FAVORITE_0)
      "FavoriteStore1",
      //Store current program or content as favorite 1. (VK_STORE_FAVORITE_1)
      "FavoriteStore2",
      //Store current program or content as favorite 2. (VK_STORE_FAVORITE_2)
      "FavoriteStore3",
      //Store current program or content as favorite 3. (VK_STORE_FAVORITE_3)
      "Guide",
      //Toggle display of program or content guide. (VK_GUIDE, KEYCODE_GUIDE)
      "GuideNextDay",
      //If guide is active and displayed, then display next days content. (VK_NEXT_DAY)
      "GuidePreviousDay",
      //If guide is active and displayed, then display previous days content. (VK_PREV_DAY)
      "Info",
      //Toggle display of information about currently selected context or media. (VK_INFO, KEYCODE_INFO)
      "InstantReplay",
      //Toggle instant replay. (VK_INSTANT_REPLAY)
      "Link",
      //Launch linked content, if available and appropriate. (VK_LINK)
      "ListProgram",
      //List the current program. (VK_LIST)
      "LiveContent",
      //Toggle display listing of currently available live content or programs. (VK_LIVE)
      "Lock",
      //Lock or unlock current content or program. (VK_LOCK)
      "MediaApps",
      //Show a list of media applications: audio/video players and image viewers. (VK_APPS) Do not confuse this key value with the Windows' VK_APPS / VK_CONTEXT_MENU key, which is encoded as "ContextMenu".
      "MediaAudioTrack",
      //Audio track key. (KEYCODE_MEDIA_AUDIO_TRACK)
      "MediaLast",
      //Select previously selected channel or media. (VK_LAST, KEYCODE_LAST_CHANNEL)
      "MediaSkipBackward",
      //Skip backward to next content or program. (KEYCODE_MEDIA_SKIP_BACKWARD)
      "MediaSkipForward",
      //Skip forward to next content or program. (VK_SKIP, KEYCODE_MEDIA_SKIP_FORWARD)
      "MediaStepBackward",
      //Step backward to next content or program. (KEYCODE_MEDIA_STEP_BACKWARD)
      "MediaStepForward",
      //Step forward to next content or program. (KEYCODE_MEDIA_STEP_FORWARD)
      "MediaTopMenu",
      //Media top menu. (KEYCODE_MEDIA_TOP_MENU)
      "NavigateIn",
      //Navigate in. (KEYCODE_NAVIGATE_IN)
      "NavigateNext",
      //Navigate to next key. (KEYCODE_NAVIGATE_NEXT)
      "NavigateOut",
      //Navigate out. (KEYCODE_NAVIGATE_OUT)
      "NavigatePrevious",
      //Navigate to previous key. (KEYCODE_NAVIGATE_PREVIOUS)
      "NextFavoriteChannel",
      //Cycle to next favorite channel (in favorites list). (VK_NEXT_FAVORITE_CHANNEL)
      "NextUserProfile",
      //Cycle to next user profile (if there are multiple user profiles). (VK_USER)
      "OnDemand",
      //Access on-demand content or programs. (VK_ON_DEMAND)
      "Pairing",
      //Pairing key to pair devices. (KEYCODE_PAIRING)
      "PinPDown",
      //Move picture-in-picture window down. (VK_PINP_DOWN)
      "PinPMove",
      //Move picture-in-picture window. (VK_PINP_MOVE)
      "PinPToggle",
      //Toggle display of picture-in-picture window. (VK_PINP_TOGGLE)
      "PinPUp",
      //Move picture-in-picture window up. (VK_PINP_UP)
      "PlaySpeedDown",
      //Decrease media playback speed. (VK_PLAY_SPEED_DOWN)
      "PlaySpeedReset",
      //Reset playback to normal speed. (VK_PLAY_SPEED_RESET)
      "PlaySpeedUp",
      //Increase media playback speed. (VK_PLAY_SPEED_UP)
      "RandomToggle",
      //Toggle random media or content shuffle mode. (VK_RANDOM_TOGGLE)
      "RcLowBattery",
      //Not a physical key, but this key code is sent when the remote control battery is low. (VK_RC_LOW_BATTERY)
      "RecordSpeedNext",
      //Toggle or cycle between media recording speeds. (VK_RECORD_SPEED_NEXT)
      "RfBypass",
      //Toggle RF (radio frequency) input bypass mode (pass RF input directly to the RF output). (VK_RF_BYPASS)
      "ScanChannelsToggle",
      //Toggle scan channels mode. (VK_SCAN_CHANNELS_TOGGLE)
      "ScreenModeNext",
      //Advance display screen mode to next available mode. (VK_SCREEN_MODE_NEXT)
      "Settings",
      //Toggle display of device settings screen. (VK_SETTINGS, KEYCODE_SETTINGS)
      "SplitScreenToggle",
      //Toggle split screen mode. (VK_SPLIT_SCREEN_TOGGLE)
      "STBInput",
      //Switch the input mode on an external STB (set top box). (KEYCODE_STB_INPUT)
      "STBPower",
      //Toggle the power on an external STB (set top box). (KEYCODE_STB_POWER)
      "Subtitle",
      //Toggle display of subtitles, if available. (VK_SUBTITLE)
      "Teletext",
      //Toggle display of teletext, if available (VK_TELETEXT, KEYCODE_TV_TELETEXT).
      "VideoModeNext",
      //Advance video mode to next available mode. (VK_VIDEO_MODE_NEXT)
      "Wink",
      //Cause device to identify itself in some manner, e.g., audibly or visibly. (VK_WINK)
      "ZoomToggle"
      //Toggle between full-screen and scaled content, or alter magnification level. (VK_ZOOM, KEYCODE_TV_ZOOM_MODE)
    ]
  };

  // ../../packages/core/src/Const/THEME_COLOR_MAP.ts
  var THEME_COLORS = {
    ["Office" /* OFFICE */]: {
      [4 /* ACCENT1 */]: "#4472C4",
      [5 /* ACCENT2 */]: "#ED7D31",
      [6 /* ACCENT3 */]: "#A5A5A5",
      [7 /* ACCENT4 */]: "#70AD47",
      [8 /* ACCENT5 */]: "#5B9BD5",
      [9 /* ACCENT6 */]: "#70AD47",
      [0 /* DARK1 */]: "#000000",
      [2 /* DARK2 */]: "#44546A",
      [1 /* LIGHT1 */]: "#FFFFFF",
      [3 /* LIGHT2 */]: "#E7E6E6",
      [10 /* HYPERLINK */]: "#0563C1",
      [11 /* FOLLOWED_HYPERLINK */]: "#954F72"
    }
  };

  // ../../packages/core/src/Sheets/Domain/ColorBuilder.ts
  var ColorBuilder = class {
    _themeValue;
    _themeColors;
    _themeTint;
    _rgbValue;
    _colorType;
    constructor() {
      this._colorType = 0 /* UNSUPPORTED */;
      this._themeColors = "Office" /* OFFICE */;
      this._themeTint = 0;
    }
    asRgbColor() {
      return new RgbColor(this._rgbValue, this);
    }
    asThemeColor() {
      return new ThemeColor(
        this._themeValue,
        this._themeTint,
        this._themeColors,
        this
      );
    }
    build() {
      switch (this._colorType) {
        case 3 /* THEME */: {
          return this.asThemeColor();
        }
        case 1 /* RGB */: {
          return this.asRgbColor();
        }
        case 0 /* UNSUPPORTED */: {
          throw Error("unsupported color type");
        }
      }
    }
    setRgbColor(cssString) {
      this._colorType = 1 /* RGB */;
      this._rgbValue = cssString;
      return this;
    }
    setThemeColors(value) {
      this._colorType = 3 /* THEME */;
      this._themeColors = value;
    }
    setThemeTint(value) {
      this._colorType = 3 /* THEME */;
      this._themeTint = value;
    }
    setThemeColor(theme) {
      this._colorType = 3 /* THEME */;
      this._themeValue = theme;
      return this;
    }
    getColorType() {
      return this._colorType;
    }
  };

  // ../../packages/core/src/Sheets/Domain/Color.ts
  var Color2 = class {
    _builder;
    constructor(builder) {
      this._builder = builder;
    }
    static rgbColorToHexValue(color) {
      return `#${((1 << 24) + (color.getRed() << 16) + (color.getGreen() << 8) + color.getBlue()).toString(16).slice(1)}`;
    }
    static hexValueToRgbColor(hexValue) {
      if (hexValue) {
        if (hexValue.indexOf("#") > -1) {
          hexValue = hexValue.substring(1);
        }
      } else {
        hexValue = "#000000";
      }
      let r4 = +`0x${hexValue[0]}${hexValue[1]}`;
      let g5 = +`0x${hexValue[2]}${hexValue[3]}`;
      let b4 = +`0x${hexValue[4]}${hexValue[5]}`;
      return new ColorBuilder().setRgbColor(`rgb(${r4},${g5},${b4})`).asRgbColor();
    }
    static hexToRgbString(hex) {
      const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
      hex = hex.replace(shorthandRegex, (m4, r4, g5, b4) => r4 + r4 + g5 + g5 + b4 + b4);
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      let string = null;
      if (result) {
        const r4 = parseInt(result[1], 16);
        const g5 = parseInt(result[2], 16);
        const b4 = parseInt(result[3], 16);
        string = `rgba(${r4},${g5},${b4})`;
      }
      return string;
    }
    asRgbColor() {
      return this._builder.asRgbColor();
    }
    asThemeColor() {
      return this._builder.asThemeColor();
    }
    getColorType() {
      return this._builder.getColorType();
    }
    clone() {
      return new Color2(this._builder);
    }
    equals(color) {
      return false;
    }
  };
  var HLSColor = class {
    _saturation;
    _hue;
    _lightness;
    _alpha;
    constructor(rgbColor) {
      const red = rgbColor.getRed() / 255;
      const green = rgbColor.getGreen() / 255;
      const blue = rgbColor.getBlue() / 255;
      const alpha2 = rgbColor.getAlpha() / 255;
      const min = Math.min(red, Math.min(green, blue));
      const max = Math.max(red, Math.max(green, blue));
      const delta = max - min;
      if (max === min) {
        this._hue = 0;
        this._saturation = 0;
        this._lightness = max;
        return;
      }
      this._lightness = (min + max) / 2;
      if (this._lightness < 0.5) {
        this._saturation = delta / (max + min);
      } else {
        this._saturation = delta / (2 - max - min);
      }
      if (red === max) {
        this._hue = (green - blue) / delta;
      }
      if (green === max) {
        this._hue = 2 + (blue - red) / delta;
      }
      if (blue === max) {
        this._hue = 4 + (red - green) / delta;
      }
      this._hue *= 60;
      if (this._hue < 0) {
        this._hue += 360;
      }
      this._alpha = alpha2;
    }
    asRgbColor() {
      const builder = new ColorBuilder();
      if (this._saturation === 0) {
        builder.setRgbColor(
          `rgba(${this._lightness * 255},${this._lightness * 255},${this._lightness * 255},${this._alpha * 255})`
        );
        return builder.asRgbColor();
      }
      let t1;
      if (this._lightness < 0.5) {
        t1 = this._lightness * (1 + this._saturation);
      } else {
        t1 = this._lightness + this._saturation - this._lightness * this._saturation;
      }
      const t22 = 2 * this._lightness - t1;
      const hue = this._hue / 360;
      const tR = hue + 1 / 3;
      const red = this.setColor(t1, t22, tR);
      const green = this.setColor(t1, t22, hue);
      const tB = hue - 1 / 3;
      const blue = this.setColor(t1, t22, tB);
      builder.setRgbColor(
        `rgba(${Math.round(red * 255)},${Math.round(green * 255)},${Math.round(
          blue * 255
        )},${this._alpha * 255})`
      );
      return builder.asRgbColor();
    }
    getLightness() {
      return this._lightness;
    }
    getHue() {
      return this._hue;
    }
    getSaturation() {
      return this._saturation;
    }
    getAlpha() {
      return this._alpha;
    }
    setColor(t1, t22, t32) {
      if (t32 < 0) {
        t32 += 1;
      }
      if (t32 > 1) {
        t32 -= 1;
      }
      let color;
      if (6 * t32 < 1) {
        color = t22 + (t1 - t22) * 6 * t32;
      } else if (2 * t32 < 1) {
        color = t1;
      } else if (3 * t32 < 2) {
        color = t22 + (t1 - t22) * (2 / 3 - t32) * 6;
      } else {
        color = t22;
      }
      return color;
    }
    setLightness(lightness) {
      this._lightness = lightness;
    }
  };
  var _RgbColor = class extends Color2 {
    _cssString;
    _red;
    _green;
    _blue;
    _alpha;
    constructor(cssString, builder) {
      super(builder);
      let match = cssString.match(_RgbColor.RGBA_EXTRACT);
      if (match) {
        const red = +match[1];
        const green = +match[2];
        const blue = +match[3];
        const alpha2 = +match[4];
        this._cssString = cssString;
        this._red = red;
        this._green = green;
        this._blue = blue;
        this._alpha = alpha2;
        return;
      }
      match = cssString.match(_RgbColor.RGB_EXTRACT);
      if (match) {
        const red = +match[1];
        const green = +match[2];
        const blue = +match[3];
        this._cssString = cssString;
        this._red = red;
        this._green = green;
        this._blue = blue;
        this._alpha = 1;
        return;
      }
      throw new Error("Invalid rgba or rgb color");
    }
    asHexString() {
      return Color2.rgbColorToHexValue(this);
    }
    getRed() {
      let r4 = this._red + _RgbColor.RGB_COLOR_AMT;
      if (r4 > 255) {
        r4 = 255;
      } else if (r4 < 0) {
        r4 = 0;
      }
      return r4;
    }
    getGreen() {
      let g5 = this._green + _RgbColor.RGB_COLOR_AMT;
      if (g5 > 255) {
        g5 = 255;
      } else if (g5 < 0) {
        g5 = 0;
      }
      return g5;
    }
    getBlue() {
      let b4 = this._blue + _RgbColor.RGB_COLOR_AMT;
      if (b4 > 255) {
        b4 = 255;
      } else if (b4 < 0) {
        b4 = 0;
      }
      return b4;
    }
    getAlpha() {
      return this._alpha;
    }
    getColorType() {
      return 1 /* RGB */;
    }
    clone() {
      return new _RgbColor(this._cssString, this._builder);
    }
    asThemeColor() {
      throw new Error("rgb color not support to themeColor");
    }
    equals(color) {
      if (color instanceof _RgbColor) {
        return color._red === this._red && color._blue === this._blue && color._green === this._green && color._alpha === this._alpha;
      }
      return false;
    }
    getCssString() {
      return this._cssString;
    }
  };
  var RgbColor = _RgbColor;
  __publicField(RgbColor, "RGB_COLOR_AMT", 0);
  __publicField(RgbColor, "RGBA_EXTRACT", new RegExp(
    `\\s*rgba\\s*\\((\\s*\\d+\\s*),(\\s*\\d+\\s*),(\\s*\\d+\\s*),(\\s*\\d.\\d|\\d\\s*)\\)\\s*`
  ));
  __publicField(RgbColor, "RGB_EXTRACT", new RegExp(
    `\\s*rgb\\s*\\((\\s*\\d+\\s*),(\\s*\\d+\\s*),(\\s*\\d+\\s*)\\)\\s*`
  ));
  var _ThemeColor = class extends Color2 {
    _themeColorType;
    _themeTint;
    _themeColors;
    constructor(theme, themeTint, themeColors, builder) {
      super(builder);
      this._themeColorType = theme;
      this._themeTint = themeTint;
      this._themeColors = themeColors;
    }
    lumValue(tint, lum) {
      if (tint == null) {
        return lum;
      }
      let value;
      if (tint < 0) {
        value = lum * (1 + tint);
      } else {
        value = lum * (1 - tint) + (255 - 255 * (1 - tint));
      }
      return value;
    }
    asRgbColor() {
      const themeColors = THEME_COLORS[this._themeColors];
      if (themeColors == null) {
        throw new Error("not find themeColors type");
      }
      const hexValue = themeColors.get(this._themeColorType);
      if (hexValue == null) {
        throw new Error("not find themeColors value");
      }
      let themeCache;
      if (_ThemeColor._cacheThemeColor.has(this._themeColors)) {
        themeCache = _ThemeColor._cacheThemeColor.get(this._themeColors);
        if (themeCache.has(this._themeColorType)) {
          return themeCache.get(this._themeColorType);
        }
      } else {
        themeCache = /* @__PURE__ */ new Map();
        _ThemeColor._cacheThemeColor.set(this._themeColors, themeCache);
      }
      const hlsColor = new HLSColor(Color2.hexValueToRgbColor(hexValue));
      hlsColor.setLightness(
        this.lumValue(this._themeTint, hlsColor.getLightness() * 255) / 255
      );
      const rgbColor = hlsColor.asRgbColor();
      themeCache.set(this._themeColorType, rgbColor);
      return rgbColor;
    }
    clone() {
      return new _ThemeColor(
        this._themeColorType,
        this._themeTint,
        this._themeColors,
        this._builder
      );
    }
    equals(color) {
      if (color instanceof _ThemeColor) {
        return color._themeColorType === this._themeColorType;
      }
      return false;
    }
    getColorType() {
      return 3 /* THEME */;
    }
    getThemeColorType() {
      return this._themeColorType;
    }
  };
  var ThemeColor = _ThemeColor;
  __publicField(ThemeColor, "_cacheThemeColor", /* @__PURE__ */ new Map());

  // ../../packages/core/src/Sheets/Domain/ColumnManager.ts
  var ColumnManager = class {
    _columnData;
    _workSheet;
    constructor(workSheet, data) {
      this._workSheet = workSheet;
      this._columnData = new ObjectArray(data);
    }
    /**
     * Get width and hidden status of columns in the sheet
     * @returns
     */
    getColumnData() {
      return this._columnData;
    }
    getColumnDatas(columnPos, numColumns) {
      const columnData = new ObjectArray();
      for (let i4 = columnPos; i4 < columnPos + numColumns; i4++) {
        const data = this.getColumnOrCreate(i4);
        columnData.push(data);
      }
      return columnData;
    }
    /**
     * Get count of column in the sheet
     * @returns
     */
    getSize() {
      return this._columnData.getLength();
    }
    getColumnWidth(...argument) {
      const { _workSheet } = this;
      const { _columnData } = this;
      const config = _workSheet.getConfig();
      let width = 0;
      if (argument.length === 1) {
        const column = _columnData.obtain(argument[0], {
          hd: 0 /* FALSE */,
          w: config.defaultColumnWidth
        });
        width = column.w;
      } else if (argument.length === 2) {
        for (let i4 = argument[0]; i4 < argument[0] + argument[1]; i4++) {
          const column = _columnData.obtain(i4, {
            hd: 0 /* FALSE */,
            w: config.defaultColumnWidth
          });
          width += column.w;
        }
      }
      return width;
    }
    /**
     * set one or more column width
     * @param columnIndex column index
     * @param columnWidth column width Array
     * @returns
     */
    setColumnWidth(columnIndex, columnWidth) {
      const _context = this._workSheet.getContext();
      const _commandManager = this._workSheet.getCommandManager();
      const setColumnWidth = {
        sheetId: this._workSheet.getSheetId(),
        actionName: "SetColumnWidthAction" /* SET_COLUMN_WIDTH_ACTION */,
        columnIndex,
        columnWidth
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setColumnWidth
      );
      _commandManager.invoke(command);
    }
    /**
     * get given column data
     * @param columnPos column index
     * @returns
     */
    getColumn(columnPos) {
      const column = this._columnData.get(columnPos);
      if (column) {
        return column;
      }
    }
    /**
     * get given column data or create a column data when it's null
     * @param columnPos column index
     * @returns
     */
    getColumnOrCreate(columnPos) {
      const { _workSheet } = this;
      const { _columnData } = this;
      const config = _workSheet.getConfig();
      const column = _columnData.get(columnPos);
      if (column) {
        return column;
      }
      const create = {
        w: config.defaultColumnWidth,
        hd: 0 /* FALSE */
      };
      this._columnData.set(columnPos, create);
      return create;
    }
  };

  // ../../packages/core/src/Sheets/Domain/Merges.ts
  var Merges = class {
    _rectangleList;
    _worksheet;
    constructor(worksheet, mergeData) {
      this._worksheet = worksheet;
      this._rectangleList = mergeData;
      CommandManager.getCommandObservers().add(({ actions }) => {
        if (!actions || actions.length === 0)
          return;
        const action = actions[0];
        const currentUnitId = worksheet.getContext().getWorkBook().getUnitId();
        const actionUnitId = action.getWorkBook().getUnitId();
        if (currentUnitId !== actionUnitId)
          return;
        let insertRowAction = actions.find(
          (action2) => action2 instanceof InsertRowAction
        );
        let insertColumnAction = actions.find(
          (action2) => action2 instanceof InsertColumnAction
        );
        let deleteRowAction = actions.find(
          (action2) => action2 instanceof RemoveRowAction
        );
        let deleteColumnAction = actions.find(
          (action2) => action2 instanceof RemoveColumnAction
        );
        let deleteRangeAction = actions.find(
          (action2) => action2 instanceof DeleteRangeAction
        );
        if (insertRowAction) {
          const data = insertRowAction.getDoActionData();
          if (data.sheetId === this._worksheet.getSheetId()) {
            const rectangleList = Tools.deepClone(this._rectangleList);
            for (let i4 = 0; i4 < rectangleList.length; i4++) {
              const merge = rectangleList[i4];
              const count = data.rowCount;
              if (data.rowIndex > merge.endRow) {
                continue;
              } else if (data.rowIndex >= merge.startRow && data.rowIndex <= merge.endRow) {
                merge.endRow += count;
              } else {
                merge.startRow += count;
                merge.endRow += count;
              }
            }
            this.modifyMerge(this._rectangleList, rectangleList);
          }
        }
        if (insertColumnAction) {
          const data = insertColumnAction.getDoActionData();
          if (data.sheetId === this._worksheet.getSheetId()) {
            const rectangleList = Tools.deepClone(this._rectangleList);
            for (let i4 = 0; i4 < rectangleList.length; i4++) {
              const merge = rectangleList[i4];
              const count = data.columnCount;
              if (data.columnIndex > merge.endColumn) {
                continue;
              } else if (data.columnIndex >= merge.startColumn && data.columnIndex <= merge.endColumn) {
                merge.endColumn += count;
              } else {
                merge.startColumn += count;
                merge.endColumn += count;
              }
            }
            this.modifyMerge(this._rectangleList, rectangleList);
          }
        }
        if (deleteRowAction) {
          const data = deleteRowAction.getDoActionData();
          if (data.sheetId === this._worksheet.getSheetId()) {
            if (data.sheetId === this._worksheet.getSheetId()) {
              const rectangleList = Tools.deepClone(this._rectangleList);
              for (let i4 = 0; i4 < rectangleList.length; i4++) {
                const merge = rectangleList[i4];
                const count = data.rowCount;
                if (data.rowIndex > merge.endRow) {
                  continue;
                } else if (data.rowIndex >= merge.startRow && data.rowIndex <= merge.endRow) {
                  merge.endRow -= count;
                } else {
                  merge.startRow -= count;
                  merge.endRow -= count;
                }
              }
              this.modifyMerge(this._rectangleList, rectangleList);
            }
          }
        }
        if (deleteColumnAction) {
          const data = deleteColumnAction.getDoActionData();
          if (data.sheetId === this._worksheet.getSheetId()) {
            if (data.sheetId === this._worksheet.getSheetId()) {
              const rectangleList = Tools.deepClone(this._rectangleList);
              for (let i4 = 0; i4 < rectangleList.length; i4++) {
                const merge = rectangleList[i4];
                const count = data.columnCount;
                if (data.columnIndex > merge.endColumn) {
                  continue;
                } else if (data.columnIndex >= merge.startColumn && data.columnIndex <= merge.endColumn) {
                  merge.endColumn -= count;
                } else {
                  merge.startColumn -= count;
                  merge.endColumn -= count;
                }
              }
              this.modifyMerge(this._rectangleList, rectangleList);
            }
          }
        }
        if (deleteRangeAction) {
          const data = deleteRangeAction.getDoActionData();
          if (data.sheetId === this._worksheet.getSheetId()) {
            const rectangleList = Tools.deepClone(this._rectangleList);
            const hasMerge = this.getByRowColumn(
              data.rangeData.startRow,
              data.rangeData.endRow,
              data.rangeData.startColumn,
              data.rangeData.endColumn
            );
            if (hasMerge) {
              hasMerge.forEach((item) => {
                const target = new Rectangle(item);
                for (let i4 = 0; i4 < rectangleList.length; i4++) {
                  const current = rectangleList[i4];
                  if (target.intersects(new Rectangle(current))) {
                    rectangleList.splice(i4, 1);
                  }
                }
              });
            }
            if (data.shiftDimension) {
              for (let i4 = 0; i4 < rectangleList.length; i4++) {
                const merge = rectangleList[i4];
                if (merge.endRow >= data.rangeData.startRow) {
                  if (merge.endColumn < data.rangeData.startColumn) {
                    continue;
                  } else if (merge.startColumn > data.rangeData.endColumn) {
                    continue;
                  } else if (merge.startColumn >= data.rangeData.startColumn && merge.endColumn <= data.rangeData.endColumn) {
                    const count = data.rangeData.endRow - data.rangeData.startRow;
                    merge.startRow -= count;
                    merge.endRow -= count;
                  } else {
                    return;
                  }
                }
              }
            } else {
              for (let i4 = 0; i4 < rectangleList.length; i4++) {
                const merge = rectangleList[i4];
                if (merge.startColumn > data.rangeData.endColumn) {
                  if (merge.endRow < data.rangeData.startRow) {
                    continue;
                  } else if (merge.startRow > data.rangeData.endRow) {
                    continue;
                  } else if (merge.startRow >= data.rangeData.startRow && merge.endRow <= data.rangeData.endRow) {
                    const count = data.rangeData.endColumn - data.rangeData.startColumn;
                    merge.startColumn -= count;
                    merge.endColumn -= count;
                  } else {
                    return;
                  }
                }
              }
            }
            this.modifyMerge(this._rectangleList, rectangleList);
          }
        }
      });
    }
    getMergeData() {
      return this._rectangleList;
    }
    getByRowColumn(...argument) {
      const { _rectangleList } = this;
      let target;
      if (Tuples.checkup(
        argument,
        Tuples.NUMBER_TYPE,
        Tuples.NUMBER_TYPE,
        Tuples.NUMBER_TYPE,
        Tuples.NUMBER_TYPE
      )) {
        target = new Rectangle(
          argument[0],
          argument[2],
          argument[1],
          argument[3]
        );
      } else if (Tuples.checkup(argument, Tuples.NUMBER_TYPE, Tuples.NUMBER_TYPE)) {
        target = new Rectangle(
          argument[0],
          argument[1],
          argument[0],
          argument[1]
        );
      }
      const rectList = [];
      for (let i4 = 0; i4 < _rectangleList.length; i4++) {
        const rectangle = _rectangleList[i4];
        if (target.intersects(new Rectangle(rectangle))) {
          rectList.push(rectangle);
        }
      }
      return rectList.length ? rectList : null;
    }
    remove(rectangle) {
      const { _rectangleList } = this;
      const { length } = _rectangleList;
      const target = new Rectangle(rectangle);
      const result = [];
      const remove = [];
      for (let i4 = 0; i4 < length; i4++) {
        const current = _rectangleList[i4];
        if (target.intersects(new Rectangle(current))) {
          remove.push(current);
          continue;
        }
        result.push(current);
      }
      this._rectangleList.length = 0;
      for (let i4 = 0; i4 < result.length; i4++) {
        this._rectangleList.push(result[i4]);
      }
      return remove;
    }
    // remove(rectangle: IRangeData): Merges {
    //     const { _rectangleList } = this;
    //     const target = new Rectangle(rectangle);
    //
    //     let index = _rectangleList.findIndex((current) => {
    //         if (target.intersects(new Rectangle(current))) {
    //             return true;
    //         }
    //         return false;
    //     });
    //     if (index !== -1) {
    //         _rectangleList.splice(index, 1);
    //     }
    //     return this;
    // }
    size() {
      return this._rectangleList.length;
    }
    add(rectangle) {
      const result = this.remove(rectangle);
      this._rectangleList.push(rectangle);
      return result;
    }
    // add(rectangle: IRangeData): Merges {
    //     const { _rectangleList } = this;
    //     const target = new Rectangle(rectangle);
    //
    //     let index = _rectangleList.findIndex((current) => {
    //         if (target.intersects(new Rectangle(current))) {
    //             return true;
    //         }
    //         return false;
    //     });
    //
    //     if (index === -1) {
    //         this._rectangleList.push(rectangle);
    //     }
    //
    //     return this;
    // }
    union(rectangle) {
      const { _rectangleList } = this;
      const { length } = _rectangleList;
      let target = new Rectangle(rectangle);
      for (let i4 = 0; i4 < length; i4++) {
        const element = _rectangleList[i4];
        target = target.union(new Rectangle(element));
      }
      return target.getData();
    }
    getMergedRanges(rectangle) {
      const { _rectangleList } = this;
      const { length } = _rectangleList;
      const result = [];
      for (let i4 = 0; i4 < length; i4++) {
        const item = _rectangleList[i4];
        const target = new Rectangle(rectangle);
        if (target.intersects(new Rectangle(item))) {
          result.push(item);
        }
      }
      return result;
    }
    modifyMerge(originMerge, currentMerge) {
      const commandManager = this._worksheet.getCommandManager();
      const context = this._worksheet.getContext();
      const removeMerge = {
        actionName: RemoveMergeAction.NAME,
        sheetId: this._worksheet.getSheetId(),
        rectangles: originMerge
      };
      const addMerge = {
        actionName: "AddMergeAction" /* ADD_MERGE_ACTION */,
        sheetId: this._worksheet.getSheetId(),
        rectangles: currentMerge
      };
      const command = new Command(
        {
          WorkBookUnit: context.getWorkBook()
        },
        removeMerge,
        addMerge
      );
      commandManager.invoke(command);
    }
  };

  // ../../packages/core/src/Shared/DropCell.ts
  var import_dayjs = __toESM(require_dayjs_min());

  // ../../packages/core/src/Shared/Generate.ts
  var import_numeral = __toESM(require_numeral());
  var error = {
    v: "#VALUE!",
    // 
    n: "#NAME?",
    // 
    na: "#N/A",
    // 
    r: "#REF!",
    // 
    d: "#DIV/0!",
    // 0
    nm: "#NUM!",
    // 
    nl: "#NULL!",
    // 
    sp: "#SPILL!"
    // 
  };
  function valueIsError(value) {
    let isError = false;
    for (const x4 in error) {
      if (value === error[x4]) {
        isError = true;
        break;
      }
    }
    return isError;
  }
  function isRealNum(val) {
    if (val === null || val.toString().replace(/\s/g, "") === "") {
      return false;
    }
    if (typeof val === "boolean") {
      return false;
    }
    if (!Number.isNaN(val)) {
      return true;
    }
    return false;
  }
  function isdatetime(s4) {
    if (s4 === null || s4.toString().length < 5) {
      return false;
    }
    if (checkDateTime(s4)) {
      return true;
    }
    return false;
    function checkDateTime(str) {
      const reg1 = /^(\d{4})-(\d{1,2})-(\d{1,2})(\s(\d{1,2}):(\d{1,2})(:(\d{1,2}))?)?$/;
      const reg2 = /^(\d{4})\/(\d{1,2})\/(\d{1,2})(\s(\d{1,2}):(\d{1,2})(:(\d{1,2}))?)?$/;
      if (!reg1.test(str) && !reg2.test(str)) {
        return false;
      }
      const year = RegExp.$1;
      const month = RegExp.$2;
      const day = RegExp.$3;
      if (year < 1900) {
        return false;
      }
      if (month > 12) {
        return false;
      }
      if (day > 31) {
        return false;
      }
      if (month === 2) {
        if (new Date(year, 1, 29).getDate() === 29 && day > 29) {
          return false;
        }
        if (new Date(year, 1, 29).getDate() !== 29 && day > 28) {
          return false;
        }
      }
      return true;
    }
  }
  var good_pd_date = /* @__PURE__ */ new Date("2017-02-19T19:06:09.000Z");
  if (Number.isNaN(good_pd_date.getFullYear()))
    good_pd_date = /* @__PURE__ */ new Date("2/19/17");
  var good_pd = good_pd_date.getFullYear() === 2017;
  function parseDate(str, fixdate) {
    const d4 = new Date(str);
    if (good_pd) {
      if (fixdate > 0) {
        d4.setTime(d4.getTime() + d4.getTimezoneOffset() * 60 * 1e3);
      } else if (fixdate < 0) {
        d4.setTime(d4.getTime() - d4.getTimezoneOffset() * 60 * 1e3);
      }
      return d4;
    }
    if (str instanceof Date)
      return str;
    if (good_pd_date.getFullYear() === 1917 && !Number.isNaN(d4.getFullYear())) {
      const s4 = d4.getFullYear();
      if (str.indexOf(`${s4}`) > -1)
        return d4;
      d4.setFullYear(d4.getFullYear() + 100);
      return d4;
    }
    const n3 = str.match(/\d+/g) || ["2017", "2", "19", "0", "0", "0"];
    let out = new Date(+n3[0], +n3[1] - 1, +n3[2], +n3[3] || 0, +n3[4] || 0, +n3[5] || 0);
    if (str.indexOf("Z") > -1)
      out = new Date(out.getTime() - out.getTimezoneOffset() * 60 * 1e3);
    return out;
  }
  var base1904 = new Date(1900, 2, 1, 0, 0, 0);
  function datenum_local(v4, date1904) {
    let epoch = Date.UTC(
      v4.getFullYear(),
      v4.getMonth(),
      v4.getDate(),
      v4.getHours(),
      v4.getMinutes(),
      v4.getSeconds()
    );
    const dnthresh_utc = Date.UTC(1899, 11, 31, 0, 0, 0);
    if (date1904)
      epoch -= 1461 * 24 * 60 * 60 * 1e3;
    else if (v4 >= base1904)
      epoch += 24 * 60 * 60 * 1e3;
    return (epoch - dnthresh_utc) / (24 * 60 * 60 * 1e3);
  }
  function generate(value) {
    const ret = [];
    let m4 = null;
    let ct = {};
    let v4 = value;
    if (value === null) {
      return null;
    }
    if (/^-?[0-9]{1,}[,][0-9]{3}(.[0-9]{1,2})?$/.test(value)) {
      m4 = value;
      v4 = Number(value.split(".")[0].replace(",", ""));
      let fa = "#,##0";
      if (value.split(".")[1]) {
        fa = "#,##0.";
        for (let i4 = 0; i4 < value.split(".")[1].length; i4++) {
          fa += 0;
        }
      }
      ct = { fa, t: "n" };
    } else if (value.toString().substr(0, 1) === "'") {
      m4 = value.toString().substr(1);
      ct = { fa: "@", t: "s" };
    } else if (value.toString().toUpperCase() === "TRUE") {
      m4 = "TRUE";
      ct = { fa: "General", t: "b" };
      v4 = true;
    } else if (value.toString().toUpperCase() === "FALSE") {
      m4 = "FALSE";
      ct = { fa: "General", t: "b" };
      v4 = false;
    } else if (valueIsError(value)) {
      m4 = value.toString();
      ct = { fa: "General", t: "e" };
    } else if (/^\d{6}(18|19|20)?\d{2}(0[1-9]|1[12])(0[1-9]|[12]\d|3[01])\d{3}(\d|X)$/i.test(
      value
    )) {
      m4 = value.toString();
      ct = { fa: "@", t: "s" };
    } else if (isRealNum(value) && Math.abs(parseFloat(value)) > 0 && (Math.abs(parseFloat(value)) >= 1e11 || Math.abs(parseFloat(value)) < 1e-9)) {
      v4 = (0, import_numeral.default)(value).value();
      const str = v4.toExponential();
      if (str.indexOf(".") > -1) {
        let strlen = str.split(".")[1].split("e")[0].length;
        if (strlen > 5) {
          strlen = 5;
        }
        ct = { fa: `#0.${new Array(strlen + 1).join("0")}E+00`, t: "n" };
      } else {
        ct = { fa: "#0.E+00", t: "n" };
      }
      m4 = SSF.format(ct.fa, v4);
    } else if (value.toString().indexOf("%") > -1) {
      const index = value.toString().indexOf("%");
      let value2 = value.toString().substr(0, index);
      const value3 = value2.replace(/,/g, "");
      if (index === value.toString().length - 1 && isRealNum(value3)) {
        if (value2.indexOf(".") > -1) {
          if (value2.indexOf(".") === value2.lastIndexOf(".")) {
            const value4 = value2.split(".")[0];
            const value5 = value2.split(".")[1];
            let len = value5.length;
            if (len > 9) {
              len = 9;
            }
            if (value4.indexOf(",") > -1) {
              let isThousands = true;
              let ThousandsArr = value4.split(",");
              for (let i4 = 1; i4 < ThousandsArr.length; i4++) {
                if (ThousandsArr[i4].length < 3) {
                  isThousands = false;
                  break;
                }
              }
              if (isThousands) {
                ct = {
                  fa: `#,##0.${new Array(len + 1).join("0")}%`,
                  t: "n"
                };
                v4 = (0, import_numeral.default)(value).value();
                m4 = SSF.format(ct.fa, v4);
              } else {
                m4 = value.toString();
                ct = { fa: "@", t: "s" };
              }
            } else {
              ct = {
                fa: `0.${new Array(len + 1).join("0")}%`,
                t: "n"
              };
              v4 = (0, import_numeral.default)(value).value();
              m4 = SSF.format(ct.fa, v4);
            }
          } else {
            m4 = value.toString();
            ct = { fa: "@", t: "s" };
          }
        } else if (value2.indexOf(",") > -1) {
          let isThousands = true;
          let ThousandsArr = value2.split(",");
          for (let i4 = 1; i4 < ThousandsArr.length; i4++) {
            if (ThousandsArr[i4].length < 3) {
              isThousands = false;
              break;
            }
          }
          if (isThousands) {
            ct = { fa: "#,##0%", t: "n" };
            v4 = (0, import_numeral.default)(value).value();
            m4 = SSF.format(ct.fa, v4);
          } else {
            m4 = value.toString();
            ct = { fa: "@", t: "s" };
          }
        } else {
          ct = { fa: "0%", t: "n" };
          v4 = (0, import_numeral.default)(value).value();
          m4 = SSF.format(ct.fa, v4);
        }
      } else {
        m4 = value.toString();
        ct = { fa: "@", t: "s" };
      }
    } else if (value.toString().indexOf(".") > -1) {
      if (value.toString().indexOf(".") === value.toString().lastIndexOf(".")) {
        const value1 = value.toString().split(".")[0];
        let value2 = value.toString().split(".")[1];
        let len = value2.length;
        if (len > 9) {
          len = 9;
        }
        if (value1.indexOf(",") > -1) {
          let isThousands = true;
          let ThousandsArr = value1.split(",");
          for (let i4 = 1; i4 < ThousandsArr.length; i4++) {
            if (!isRealNum(ThousandsArr[i4]) || ThousandsArr[i4].length < 3) {
              isThousands = false;
              break;
            }
          }
          if (isThousands) {
            ct = { fa: `#,##0.${new Array(len + 1).join("0")}`, t: "n" };
            v4 = (0, import_numeral.default)(value).value();
            m4 = SSF.format(ct.fa, v4);
          } else {
            m4 = value.toString();
            ct = { fa: "@", t: "s" };
          }
        } else if (isRealNum(value1) && isRealNum(value2)) {
          ct = { fa: `0.${new Array(len + 1).join("0")}`, t: "n" };
          v4 = (0, import_numeral.default)(value).value();
          m4 = SSF.format(ct.fa, v4);
        } else {
          m4 = value.toString();
          ct = { fa: "@", t: "s" };
        }
      } else {
        m4 = value.toString();
        ct = { fa: "@", t: "s" };
      }
    } else if (isRealNum(value)) {
      m4 = value.toString();
      ct = { fa: "General", t: "n" };
      v4 = parseFloat(value);
    } else if (isdatetime(value) && (value.toString().indexOf(".") > -1 || value.toString().indexOf(":") > -1 || value.toString().length < 16)) {
      v4 = datenum_local(parseDate(value.toString().replace(/-/g, "/")));
      if (v4.toString().indexOf(".") > -1) {
        if (value.toString().length > 18) {
          ct.fa = "yyyy-MM-dd hh:mm:ss";
        } else if (value.toString().length > 11) {
          ct.fa = "yyyy-MM-dd hh:mm";
        } else {
          ct.fa = "yyyy-MM-dd";
        }
      } else {
        ct.fa = "yyyy-MM-dd";
      }
      ct.t = "d";
      m4 = SSF.format(ct.fa, v4);
    } else {
      m4 = value;
      ct.fa = "General";
      ct.t = "g";
    }
    return [m4, ct, v4];
  }
  var SSF = {
    format(a4, b4) {
    }
  };
  var update = (a4, b4) => {
  };

  // ../../packages/core/src/Shared/DropCell.ts
  var DropCell = class {
    // constructor() {}
    static getApplyData(copyD, csLen, asLen, type, direction) {
      const _this = this;
      const applyData = [];
      _this.applyType = type;
      _this.direction = direction;
      const num = Math.floor(asLen / csLen);
      const rsd = asLen % csLen;
      const copyD_number = copyD.number;
      const applyD_number = [];
      if (copyD_number) {
        for (let i4 = 0; i4 < copyD_number.length; i4++) {
          const s4 = _this.getLenS(copyD_number[i4].index, rsd);
          const len = copyD_number[i4].index.length * num + s4;
          let arrData;
          if (type === 1) {
            arrData = _this.getDataByType(
              copyD_number[i4].data,
              len,
              direction,
              type,
              "number"
            );
          } else if (type === "2") {
            arrData = _this.getDataByType(
              copyD_number[i4].data,
              len,
              direction,
              type
            );
          } else {
            arrData = _this.getDataByType(
              copyD_number[i4].data,
              len,
              direction,
              "0"
            );
          }
          const arrIndex = _this.getDataIndex(
            csLen,
            asLen,
            copyD_number[i4].index
          );
          applyD_number.push({ data: arrData, index: arrIndex });
        }
      }
      const copyD_extendNumber = copyD.extendNumber;
      const applyD_extendNumber = [];
      if (copyD_extendNumber) {
        for (let i4 = 0; i4 < copyD_extendNumber.length; i4++) {
          const s4 = _this.getLenS(copyD_extendNumber[i4].index, rsd);
          const len = copyD_extendNumber[i4].index.length * num + s4;
          let arrData;
          if (type === "1" || type === "3") {
            arrData = _this.getDataByType(
              copyD_extendNumber[i4].data,
              len,
              direction,
              type,
              "extendNumber"
            );
          } else if (type === "2") {
            arrData = _this.getDataByType(
              copyD_extendNumber[i4].data,
              len,
              direction,
              type
            );
          } else {
            arrData = _this.getDataByType(
              copyD_extendNumber[i4].data,
              len,
              direction,
              "0"
            );
          }
          const arrIndex = _this.getDataIndex(
            csLen,
            asLen,
            copyD_extendNumber[i4].index
          );
          applyD_extendNumber.push({ data: arrData, index: arrIndex });
        }
      }
      const copyD_date = copyD.date;
      const applyD_date = [];
      if (copyD_date) {
        for (let i4 = 0; i4 < copyD_date.length; i4++) {
          const s4 = _this.getLenS(copyD_date[i4].index, rsd);
          const len = copyD_date[i4].index.length * num + s4;
          let arrData;
          if (type === "1" || type === "3") {
            arrData = _this.getDataByType(
              copyD_date[i4].data,
              len,
              direction,
              type,
              "date"
            );
          } else if (type === "8") {
            arrData = _this.getDataByType(
              copyD_date[i4].data,
              len,
              direction,
              "0"
            );
          } else {
            arrData = _this.getDataByType(
              copyD_date[i4].data,
              len,
              direction,
              type
            );
          }
          const arrIndex = _this.getDataIndex(
            csLen,
            asLen,
            copyD_date[i4].index
          );
          applyD_date.push({ data: arrData, index: arrIndex });
        }
      }
      const copyD_chnNumber = copyD.chnNumber;
      const applyD_chnNumber = [];
      if (copyD_chnNumber) {
        for (let i4 = 0; i4 < copyD_chnNumber.length; i4++) {
          const s4 = _this.getLenS(copyD_chnNumber[i4].index, rsd);
          const len = copyD_chnNumber[i4].index.length * num + s4;
          let arrData;
          if (type === "1" || type === "3") {
            arrData = _this.getDataByType(
              copyD_chnNumber[i4].data,
              len,
              direction,
              type,
              "chnNumber"
            );
          } else if (type === "2" || type === "8") {
            arrData = _this.getDataByType(
              copyD_chnNumber[i4].data,
              len,
              direction,
              type
            );
          } else {
            arrData = _this.getDataByType(
              copyD_chnNumber[i4].data,
              len,
              direction,
              "0"
            );
          }
          const arrIndex = _this.getDataIndex(
            csLen,
            asLen,
            copyD_chnNumber[i4].index
          );
          applyD_chnNumber.push({ data: arrData, index: arrIndex });
        }
      }
      const copyD_chnWeek2 = copyD.chnWeek2;
      const applyD_chnWeek2 = [];
      if (copyD_chnWeek2) {
        for (let i4 = 0; i4 < copyD_chnWeek2.length; i4++) {
          const s4 = _this.getLenS(copyD_chnWeek2[i4].index, rsd);
          const len = copyD_chnWeek2[i4].index.length * num + s4;
          let arrData;
          if (type === "1" || type === "3") {
            arrData = _this.getDataByType(
              copyD_chnWeek2[i4].data,
              len,
              direction,
              type,
              "chnWeek2"
            );
          } else if (type === "2") {
            arrData = _this.getDataByType(
              copyD_chnWeek2[i4].data,
              len,
              direction,
              type
            );
          } else {
            arrData = _this.getDataByType(
              copyD_chnWeek2[i4].data,
              len,
              direction,
              "0"
            );
          }
          const arrIndex = _this.getDataIndex(
            csLen,
            asLen,
            copyD_chnWeek2[i4].index
          );
          applyD_chnWeek2.push({ data: arrData, index: arrIndex });
        }
      }
      const copyD_chnWeek3 = copyD.chnWeek3;
      const applyD_chnWeek3 = [];
      if (copyD_chnWeek3) {
        for (let i4 = 0; i4 < copyD_chnWeek3.length; i4++) {
          const s4 = _this.getLenS(copyD_chnWeek3[i4].index, rsd);
          const len = copyD_chnWeek3[i4].index.length * num + s4;
          let arrData;
          if (type === "1" || type === "3") {
            arrData = _this.getDataByType(
              copyD_chnWeek3[i4].data,
              len,
              direction,
              type,
              "chnWeek3"
            );
          } else if (type === "2") {
            arrData = _this.getDataByType(
              copyD_chnWeek3[i4].data,
              len,
              direction,
              type
            );
          } else {
            arrData = _this.getDataByType(
              copyD_chnWeek3[i4].data,
              len,
              direction,
              "0"
            );
          }
          const arrIndex = _this.getDataIndex(
            csLen,
            asLen,
            copyD_chnWeek3[i4].index
          );
          applyD_chnWeek3.push({ data: arrData, index: arrIndex });
        }
      }
      const copyD_other = copyD.other;
      const applyD_other = [];
      if (copyD_other) {
        for (let i4 = 0; i4 < copyD_other.length; i4++) {
          const s4 = _this.getLenS(copyD_other[i4].index, rsd);
          const len = copyD_other[i4].index.length * num + s4;
          let arrData;
          if (type === "2" || type === "3") {
            arrData = _this.getDataByType(
              copyD_other[i4].data,
              len,
              direction,
              type
            );
          } else {
            arrData = _this.getDataByType(
              copyD_other[i4].data,
              len,
              direction,
              "0"
            );
          }
          const arrIndex = _this.getDataIndex(
            csLen,
            asLen,
            copyD_other[i4].index
          );
          applyD_other.push({ data: arrData, index: arrIndex });
        }
      }
      for (let x4 = 1; x4 <= asLen; x4++) {
        if (applyD_number.length > 0) {
          for (let y4 = 0; y4 < applyD_number.length; y4++) {
            if (x4 in applyD_number[y4].index) {
              applyData.push(
                applyD_number[y4].data[applyD_number[y4].index[x4]]
              );
            }
          }
        }
        if (applyD_extendNumber.length > 0) {
          for (let y4 = 0; y4 < applyD_extendNumber.length; y4++) {
            if (x4 in applyD_extendNumber[y4].index) {
              applyData.push(
                applyD_extendNumber[y4].data[applyD_extendNumber[y4].index[x4]]
              );
            }
          }
        }
        if (applyD_date.length > 0) {
          for (let y4 = 0; y4 < applyD_date.length; y4++) {
            if (x4 in applyD_date[y4].index) {
              applyData.push(applyD_date[y4].data[applyD_date[y4].index[x4]]);
            }
          }
        }
        if (applyD_chnNumber.length > 0) {
          for (let y4 = 0; y4 < applyD_chnNumber.length; y4++) {
            if (x4 in applyD_chnNumber[y4].index) {
              applyData.push(
                applyD_chnNumber[y4].data[applyD_chnNumber[y4].index[x4]]
              );
            }
          }
        }
        if (applyD_chnWeek2.length > 0) {
          for (let y4 = 0; y4 < applyD_chnWeek2.length; y4++) {
            if (x4 in applyD_chnWeek2[y4].index) {
              applyData.push(
                applyD_chnWeek2[y4].data[applyD_chnWeek2[y4].index[x4]]
              );
            }
          }
        }
        if (applyD_chnWeek3.length > 0) {
          for (let y4 = 0; y4 < applyD_chnWeek3.length; y4++) {
            if (x4 in applyD_chnWeek3[y4].index) {
              applyData.push(
                applyD_chnWeek3[y4].data[applyD_chnWeek3[y4].index[x4]]
              );
            }
          }
        }
        if (applyD_other.length > 0) {
          for (let y4 = 0; y4 < applyD_other.length; y4++) {
            if (x4 in applyD_other[y4].index) {
              applyData.push(
                applyD_other[y4].data[applyD_other[y4].index[x4]]
              );
            }
          }
        }
      }
      return applyData;
    }
    static getCopyData(d4, r1, r22, c1, c22, direction) {
      const _this = this;
      const copyData = [];
      let a1 = 0;
      let a22 = 0;
      let b1 = 0;
      let b22 = 0;
      if (direction === 3 /* BOTTOM */ || direction === 2 /* TOP */) {
        a1 = c1;
        a22 = c22;
        b1 = r1;
        b22 = r22;
      } else if (direction === 1 /* RIGHT */ || direction === 0 /* LEFT */) {
        a1 = r1;
        a22 = r22;
        b1 = c1;
        b22 = c22;
      }
      for (let a4 = a1; a4 <= a22; a4++) {
        const obj = {};
        let arrData = [];
        let arrIndex = [];
        let text = "";
        let extendNumberBeforeStr = null;
        let extendNumberAfterStr = null;
        let isSameStr = true;
        for (let b4 = b1, i4 = 0; b4 <= b22; b4++, i4++) {
          const data = d4[i4];
          let str;
          if (!!data && !!data.v && !data.f) {
            if (!!data.fm && data.fm.t === 2 /* NUMBER */) {
              str = "number";
              extendNumberBeforeStr = null;
              extendNumberAfterStr = null;
            } else if (!!data.fm && data.fm.t === 5 /* DATE */) {
              str = "date";
              extendNumberBeforeStr = null;
              extendNumberAfterStr = null;
            } else if (_this.isExtendNumber(data.m)[0]) {
              str = "extendNumber";
              const isExtendNumber = _this.isExtendNumber(data.m);
              if (extendNumberBeforeStr === null || extendNumberAfterStr === null) {
                isSameStr = true;
                extendNumberBeforeStr = isExtendNumber[2];
                extendNumberAfterStr = isExtendNumber[3];
              } else if (isExtendNumber[2] !== extendNumberBeforeStr || isExtendNumber[3] !== extendNumberAfterStr) {
                isSameStr = false;
                extendNumberBeforeStr = isExtendNumber[2];
                extendNumberAfterStr = isExtendNumber[3];
              } else {
                isSameStr = true;
              }
            } else if (_this.isChnNumber(data.m)) {
              str = "chnNumber";
              extendNumberBeforeStr = null;
              extendNumberAfterStr = null;
            } else if (_this.isChnWeek2(data.m)) {
              str = "chnWeek2";
              extendNumberBeforeStr = null;
              extendNumberAfterStr = null;
            } else if (_this.isChnWeek3(data.m)) {
              str = "chnWeek3";
              extendNumberBeforeStr = null;
              extendNumberAfterStr = null;
            } else {
              str = "other";
              extendNumberBeforeStr = null;
              extendNumberAfterStr = null;
            }
          } else {
            str = "other";
            extendNumberBeforeStr = null;
            extendNumberAfterStr = null;
          }
          if (str === "extendNumber") {
            if (b4 === b1) {
              if (b1 === b22) {
                text = str;
                arrData.push(data);
                arrIndex.push(b4 - b1 + 1);
                obj[text] = [];
                obj[text].push({ data: arrData, index: arrIndex });
              } else {
                text = str;
                arrData.push(data);
                arrIndex.push(b4 - b1 + 1);
              }
            } else if (b4 === b22) {
              if (text === str && isSameStr) {
                arrData.push(data);
                arrIndex.push(b4 - b1 + 1);
                if (text in obj) {
                } else {
                  obj[text] = [];
                  obj[text].push({ data: arrData, index: arrIndex });
                }
              } else {
                if (text in obj) {
                  obj[text].push({ data: arrData, index: arrIndex });
                } else {
                  obj[text] = [];
                  obj[text].push({ data: arrData, index: arrIndex });
                }
                text = str;
                arrData = [];
                arrData.push(data);
                arrIndex = [];
                arrIndex.push(b4 - b1 + 1);
                if (text in obj) {
                  obj[text].push({ data: arrData, index: arrIndex });
                } else {
                  obj[text] = [];
                  obj[text].push({ data: arrData, index: arrIndex });
                }
              }
            } else if (text === str && isSameStr) {
              arrData.push(data);
              arrIndex.push(b4 - b1 + 1);
            } else {
              if (text in obj) {
                obj[text].push({ data: arrData, index: arrIndex });
              } else {
                obj[text] = [];
                obj[text].push({ data: arrData, index: arrIndex });
              }
              text = str;
              arrData = [];
              arrData.push(data);
              arrIndex = [];
              arrIndex.push(b4 - b1 + 1);
            }
          } else if (b4 === b1) {
            if (b1 === b22) {
              text = str;
              arrData.push(data);
              arrIndex.push(b4 - b1 + 1);
              obj[text] = [];
              obj[text].push({ data: arrData, index: arrIndex });
            } else {
              text = str;
              arrData.push(data);
              arrIndex.push(b4 - b1 + 1);
            }
          } else if (b4 === b22) {
            if (text === str) {
              arrData.push(data);
              arrIndex.push(b4 - b1 + 1);
              if (text in obj) {
                obj[text].push({ data: arrData, index: arrIndex });
              } else {
                obj[text] = [];
                obj[text].push({ data: arrData, index: arrIndex });
              }
            } else {
              if (text in obj) {
                obj[text].push({ data: arrData, index: arrIndex });
              } else {
                obj[text] = [];
                obj[text].push({ data: arrData, index: arrIndex });
              }
              text = str;
              arrData = [];
              arrData.push(data);
              arrIndex = [];
              arrIndex.push(b4 - b1 + 1);
              if (text in obj) {
                obj[text].push({ data: arrData, index: arrIndex });
              } else {
                obj[text] = [];
                obj[text].push({ data: arrData, index: arrIndex });
              }
            }
          } else if (text === str) {
            arrData.push(data);
            arrIndex.push(b4 - b1 + 1);
          } else {
            if (text in obj) {
              obj[text].push({ data: arrData, index: arrIndex });
            } else {
              obj[text] = [];
              obj[text].push({ data: arrData, index: arrIndex });
            }
            text = str;
            arrData = [];
            arrData.push(data);
            arrIndex = [];
            arrIndex.push(b4 - b1 + 1);
          }
        }
        copyData.push(obj);
      }
      return copyData;
    }
    static ChineseToNumber(chnStr) {
      const _this = this;
      let rtn = 0;
      let section = 0;
      let number = 0;
      let secUnit = false;
      const str = chnStr.split("");
      for (let i4 = 0; i4 < str.length; i4++) {
        const num = _this.chnNumChar[str[i4]];
        if (typeof num !== "undefined") {
          number = num;
          if (i4 === str.length - 1) {
            section += number;
          }
        } else {
          const unit = _this.chnNameValue[str[i4]].value;
          secUnit = _this.chnNameValue[str[i4]].secUnit;
          if (secUnit) {
            section = (section + number) * unit;
            rtn += section;
            section = 0;
          } else {
            section += number * unit;
          }
          number = 0;
        }
      }
      return rtn + section;
    }
    static NumberToChinese(num) {
      const _this = this;
      let unitPos = 0;
      let strIns = "";
      let chnStr = "";
      let needZero = false;
      if (num === 0) {
        return _this.chnNumChar2[0];
      }
      while (num > 0) {
        const section = num % 1e4;
        if (needZero) {
          chnStr = _this.chnNumChar2[0] + chnStr;
        }
        strIns = _this.SectionToChinese(section);
        strIns += section !== 0 ? _this.chnUnitSection[unitPos] : _this.chnUnitSection[0];
        chnStr = strIns + chnStr;
        needZero = section < 1e3 && section > 0;
        num = Math.floor(num / 1e4);
        unitPos++;
      }
      return chnStr;
    }
    static SectionToChinese(section) {
      const _this = this;
      let strIns = "";
      let chnStr = "";
      let unitPos = 0;
      let zero = true;
      while (section > 0) {
        const v4 = section % 10;
        if (v4 === 0) {
          if (!zero) {
            zero = true;
            chnStr = _this.chnNumChar2[v4] + chnStr;
          }
        } else {
          zero = false;
          strIns = _this.chnNumChar2[v4];
          strIns += _this.chnUnitChar[unitPos];
          chnStr = strIns + chnStr;
        }
        unitPos++;
        section = Math.floor(section / 10);
      }
      return chnStr;
    }
    static getLenS(indexArr, rsd) {
      let s4 = 0;
      for (let j3 = 0; j3 < indexArr.length; j3++) {
        if (indexArr[j3] <= rsd) {
          s4++;
        } else {
          break;
        }
      }
      return s4;
    }
    static getDataByType(data, len, direction, type, dataType) {
      const _this = this;
      let applyData = [];
      if (type === 1 /* ALTERNATE_SERIES */) {
        if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
          data.reverse();
        }
        applyData = _this.FillCopy(data, len);
      } else if (type === 0 /* DEFAULT_SERIES */) {
        if (dataType === "number") {
          applyData = _this.FillSeries(data, len, direction);
        } else if (dataType === "extendNumber") {
          if (data.length === 1) {
            let step = 0;
            if (direction === 3 /* BOTTOM */ || direction === 1 /* RIGHT */) {
              step = 1;
            } else if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
              step = -1;
            }
            applyData = _this.FillExtendNumber(data, len, step);
          } else {
            const dataNumArr = [];
            for (let i4 = 0; i4 < data.length; i4++) {
              const txt = data[i4].m;
              dataNumArr.push(Number(_this.isExtendNumber(txt)[1]));
            }
            if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
              data.reverse();
              dataNumArr.reverse();
            }
            if (_this.isEqualDiff(dataNumArr)) {
              const step = dataNumArr[1] - dataNumArr[0];
              applyData = _this.FillExtendNumber(data, len, step);
            } else {
              applyData = _this.FillCopy(data, len);
            }
          }
        } else if (dataType === "date") {
          if (data.length === 1) {
            let step = 0;
            if (direction === 3 /* BOTTOM */ || direction === 1 /* RIGHT */) {
              step = 1;
            } else if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
              step = -1;
            }
            applyData = _this.FillDays(data, len, step);
          } else {
            if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
              data.reverse();
            }
            const judgeDate = _this.judgeDate(data);
            if (judgeDate[0] && judgeDate[3]) {
              const step = (0, import_dayjs.default)(data[1].m).diff(
                (0, import_dayjs.default)(data[0].m),
                "months"
              );
              applyData = _this.FillMonths(data, len, step);
            } else if (!judgeDate[0] && judgeDate[2]) {
              const step = (0, import_dayjs.default)(data[1].m).diff((0, import_dayjs.default)(data[0].m), "days");
              applyData = _this.FillDays(data, len, step);
            } else {
              applyData = _this.FillCopy(data, len);
            }
          }
        } else if (dataType === "chnNumber") {
          if (data.length === 1) {
            if (data[0].m === "\u65E5" || _this.ChineseToNumber(data[0].m) < 7) {
              let step = 0;
              if (direction === 3 /* BOTTOM */ || direction === 1 /* RIGHT */) {
                step = 1;
              } else if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
                step = -1;
              }
              applyData = _this.FillChnWeek(data, len, step);
            } else {
              let step = 0;
              if (direction === 3 /* BOTTOM */ || direction === 1 /* RIGHT */) {
                step = 1;
              } else if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
                step = -1;
              }
              applyData = _this.FillChnNumber(data, len, step);
            }
          } else {
            let hasweek = false;
            for (let i4 = 0; i4 < data.length; i4++) {
              if (data[i4].m === "\u65E5") {
                hasweek = true;
                break;
              }
            }
            const dataNumArr = [];
            let weekIndex = 0;
            for (let i4 = 0; i4 < data.length; i4++) {
              if (data[i4].m === "\u65E5") {
                if (i4 === 0) {
                  dataNumArr.push(0);
                } else {
                  weekIndex++;
                  dataNumArr.push(weekIndex * 7);
                }
              } else if (hasweek && _this.ChineseToNumber(data[i4].m) > 0 && _this.ChineseToNumber(data[i4].m) < 7) {
                dataNumArr.push(
                  _this.ChineseToNumber(data[i4].m) + weekIndex * 7
                );
              } else {
                dataNumArr.push(_this.ChineseToNumber(data[i4].m));
              }
            }
            if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
              data.reverse();
              dataNumArr.reverse();
            }
            if (_this.isEqualDiff(dataNumArr)) {
              if (hasweek || dataNumArr[dataNumArr.length - 1] < 6 && dataNumArr[0] > 0 || dataNumArr[0] < 6 && dataNumArr[dataNumArr.length - 1] > 0) {
                const step = dataNumArr[1] - dataNumArr[0];
                applyData = _this.FillChnWeek(data, len, step);
              } else {
                const step = dataNumArr[1] - dataNumArr[0];
                applyData = _this.FillChnNumber(data, len, step);
              }
            } else {
              applyData = _this.FillCopy(data, len);
            }
          }
        } else if (dataType === "chnWeek2") {
          if (data.length === 1) {
            let step = 0;
            if (direction === 3 /* BOTTOM */ || direction === 1 /* RIGHT */) {
              step = 1;
            } else if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
              step = -1;
            }
            applyData = _this.FillChnWeek2(data, len, step);
          } else {
            const dataNumArr = [];
            let weekIndex = 0;
            for (let i4 = 0; i4 < data.length; i4++) {
              const lastTxt = data[i4].m.substr(data[i4].m.length - 1, 1);
              if (data[i4].m === "\u5468\u65E5") {
                if (i4 === 0) {
                  dataNumArr.push(0);
                } else {
                  weekIndex++;
                  dataNumArr.push(weekIndex * 7);
                }
              } else {
                dataNumArr.push(
                  _this.ChineseToNumber(lastTxt) + weekIndex * 7
                );
              }
            }
            if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
              data.reverse();
              dataNumArr.reverse();
            }
            if (_this.isEqualDiff(dataNumArr)) {
              const step = dataNumArr[1] - dataNumArr[0];
              applyData = _this.FillChnWeek2(data, len, step);
            } else {
              applyData = _this.FillCopy(data, len);
            }
          }
        } else if (dataType === "chnWeek3") {
          if (data.length === 1) {
            let step = 0;
            if (direction === 3 /* BOTTOM */ || direction === 1 /* RIGHT */) {
              step = 1;
            } else if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
              step = -1;
            }
            applyData = _this.FillChnWeek3(data, len, step);
          } else {
            const dataNumArr = [];
            let weekIndex = 0;
            for (let i4 = 0; i4 < data.length; i4++) {
              const lastTxt = data[i4].m.substr(data[i4].m.length - 1, 1);
              if (data[i4].m === "\u661F\u671F\u65E5") {
                if (i4 === 0) {
                  dataNumArr.push(0);
                } else {
                  weekIndex++;
                  dataNumArr.push(weekIndex * 7);
                }
              } else {
                dataNumArr.push(
                  _this.ChineseToNumber(lastTxt) + weekIndex * 7
                );
              }
            }
            if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
              data.reverse();
              dataNumArr.reverse();
            }
            if (_this.isEqualDiff(dataNumArr)) {
              const step = dataNumArr[1] - dataNumArr[0];
              applyData = _this.FillChnWeek3(data, len, step);
            } else {
              applyData = _this.FillCopy(data, len);
            }
          }
        } else {
          if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
            data.reverse();
          }
          applyData = _this.FillCopy(data, len);
        }
      } else if (type === "2") {
        if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
          data.reverse();
        }
        applyData = _this.FillOnlyFormat(data, len);
      } else if (type === "3") {
        const dataArr = _this.getDataByType(data, len, direction, "1", dataType);
        applyData = _this.FillWithoutFormat(dataArr);
      } else if (type === "4") {
        if (data.length === 1) {
          let step = 0;
          if (direction === 3 /* BOTTOM */ || direction === 1 /* RIGHT */) {
            step = 1;
          } else if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
            step = -1;
          }
          applyData = _this.FillDays(data, len, step);
        } else if (data.length === 2) {
          if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
            data.reverse();
          }
          const step = (0, import_dayjs.default)(data[1].m).diff((0, import_dayjs.default)(data[0].m), "days");
          applyData = _this.FillDays(data, len, step);
        } else {
          if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
            data.reverse();
          }
          const judgeDate = _this.judgeDate(data);
          if (judgeDate[0] && judgeDate[3]) {
            const step = (0, import_dayjs.default)(data[1].m).diff((0, import_dayjs.default)(data[0].m), "months");
            applyData = _this.FillMonths(data, len, step);
          } else if (!judgeDate[0] && judgeDate[2]) {
            const step = (0, import_dayjs.default)(data[1].m).diff((0, import_dayjs.default)(data[0].m), "days");
            applyData = _this.FillDays(data, len, step);
          } else {
            applyData = _this.FillCopy(data, len);
          }
        }
      } else if (type === "5") {
        if (data.length === 1) {
          let step = 0;
          if (direction === 3 /* BOTTOM */ || direction === 1 /* RIGHT */) {
            step = 1;
          } else if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
            step = -1;
          }
          const newLen = Math.round(len * 1.5);
          for (let i4 = 1; i4 <= newLen; i4++) {
            const d4 = { ...data[i4] };
            const day = (0, import_dayjs.default)(d4.m).add(i4, "days").day();
            if (day === 0 || day === 6) {
              continue;
            }
            const date = (0, import_dayjs.default)(d4.m).add(step * i4, "days").format("YYYY-MM-DD");
            d4.m = date;
            d4.v = generate(date)[2];
            applyData.push(d4);
            if (applyData.length === len) {
              break;
            }
          }
        } else if (data.length === 2) {
          if ((0, import_dayjs.default)(data[1].m).date() === (0, import_dayjs.default)(data[0].m).date() && (0, import_dayjs.default)(data[1].m).diff((0, import_dayjs.default)(data[0].m), "months") !== 0) {
            if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
              data.reverse();
            }
            const step = (0, import_dayjs.default)(data[1].m).diff((0, import_dayjs.default)(data[0].m), "months");
            for (let i4 = 1; i4 <= len; i4++) {
              const index = (i4 - 1) % data.length;
              const d4 = { ...data[index] };
              const day = (0, import_dayjs.default)(data[data.length - 1]).add(step * i4, "months").day();
              let date;
              if (day === 0) {
                date = (0, import_dayjs.default)(data[data.length - 1]).add(step * i4, "months").subtract(2, "days").format("YYYY-MM-DD");
              } else if (day === 6) {
                date = (0, import_dayjs.default)(data[data.length - 1]).add(step * i4, "months").subtract(1, "days").format("YYYY-MM-DD");
              } else {
                date = (0, import_dayjs.default)(data[data.length - 1]).add(step * i4, "months").format("YYYY-MM-DD");
              }
              d4.m = date;
              d4.v = generate(date)[2];
              applyData.push(d4);
            }
          } else {
            if (Math.abs((0, import_dayjs.default)(data[1].m).diff((0, import_dayjs.default)(data[0].m))) > 7) {
              let step_month = 0;
              if (direction === 3 /* BOTTOM */ || direction === 1 /* RIGHT */) {
                step_month = 1;
              } else if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
                step_month = -1;
                data.reverse();
              }
              let step = 0;
              for (let i4 = 1; i4 <= len; i4++) {
                const index = (i4 - 1) % data.length;
                const d4 = { ...data[index] };
                const num = Math.ceil(i4 / data.length);
                if (index === 0) {
                  step = (0, import_dayjs.default)(d4.m).add(step_month * num, "months").diff((0, import_dayjs.default)(d4.m), "days");
                }
                const day = (0, import_dayjs.default)(d4.m).add(step, "days").day();
                let date;
                if (day === 0) {
                  date = (0, import_dayjs.default)(d4.m).add(step, "days").subtract(2, "days").format("YYYY-MM-DD");
                } else if (day === 6) {
                  date = (0, import_dayjs.default)(d4.m).add(step, "days").subtract(1, "days").format("YYYY-MM-DD");
                } else {
                  date = (0, import_dayjs.default)(d4.m).add(step, "days").format("YYYY-MM-DD");
                }
                d4.m = date;
                d4.v = generate(date)[2];
                applyData.push(d4);
              }
            } else {
              let step_day = 0;
              if (direction === 3 /* BOTTOM */ || direction === 1 /* RIGHT */) {
                step_day = 7;
              } else if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
                step_day = -7;
                data.reverse();
              }
              let step = 0;
              for (let i4 = 1; i4 <= len; i4++) {
                const index = (i4 - 1) % data.length;
                const d4 = { ...data[index] };
                const num = Math.ceil(i4 / data.length);
                if (index === 0) {
                  step = (0, import_dayjs.default)(d4.m).add(step_day * num, "days").diff((0, import_dayjs.default)(d4.m), "days");
                }
                const day = (0, import_dayjs.default)(d4.m).add(step, "days").day();
                let date;
                if (day === 0) {
                  date = (0, import_dayjs.default)(d4.m).add(step, "days").subtract(2, "days").format("YYYY-MM-DD");
                } else if (day === 6) {
                  date = (0, import_dayjs.default)(d4.m).add(step, "days").subtract(1, "days").format("YYYY-MM-DD");
                } else {
                  date = (0, import_dayjs.default)(d4.m).add(step, "days").format("YYYY-MM-DD");
                }
                d4.m = date;
                d4.v = generate(date)[2];
                applyData.push(d4);
              }
            }
          }
        } else {
          const judgeDate = _this.judgeDate(data);
          if (judgeDate[0] && judgeDate[3]) {
            if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
              data.reverse();
            }
            const step = (0, import_dayjs.default)(data[1].m).diff((0, import_dayjs.default)(data[0].m), "months");
            for (let i4 = 1; i4 <= len; i4++) {
              const index = (i4 - 1) % data.length;
              const d4 = { ...data[index] };
              const day = (0, import_dayjs.default)(data[data.length - 1].m).add(step * i4, "months").day();
              let date;
              if (day === 0) {
                date = (0, import_dayjs.default)(data[data.length - 1].m).add(step * i4, "months").subtract(2, "days").format("YYYY-MM-DD");
              } else if (day === 6) {
                date = (0, import_dayjs.default)(data[data.length - 1].m).add(step * i4, "months").subtract(1, "days").format("YYYY-MM-DD");
              } else {
                date = (0, import_dayjs.default)(data[data.length - 1].m).add(step * i4, "months").format("YYYY-MM-DD");
              }
              d4.m = date;
              d4.v = generate(date)[2];
              applyData.push(d4);
            }
          } else if (!judgeDate[0] && judgeDate[2]) {
            if (Math.abs((0, import_dayjs.default)(data[1].m).diff((0, import_dayjs.default)(data[0].m))) > 7) {
              let step_month = 0;
              if (direction === 3 /* BOTTOM */ || direction === 1 /* RIGHT */) {
                step_month = 1;
              } else if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
                step_month = -1;
                data.reverse();
              }
              let step = 0;
              for (let i4 = 1; i4 <= len; i4++) {
                const index = (i4 - 1) % data.length;
                const d4 = { ...data[index] };
                const num = Math.ceil(i4 / data.length);
                if (index === 0) {
                  step = (0, import_dayjs.default)(d4.m).add(step_month * num, "months").diff((0, import_dayjs.default)(d4.m), "days");
                }
                const day = (0, import_dayjs.default)(d4.m).add(step, "days").day();
                let date;
                if (day === 0) {
                  date = (0, import_dayjs.default)(d4.m).add(step, "days").subtract(2, "days").format("YYYY-MM-DD");
                } else if (day === 6) {
                  date = (0, import_dayjs.default)(d4.m).add(step, "days").subtract(1, "days").format("YYYY-MM-DD");
                } else {
                  date = (0, import_dayjs.default)(d4.m).add(step, "days").format("YYYY-MM-DD");
                }
                d4.m = date;
                d4.v = generate(date)[2];
                applyData.push(d4);
              }
            } else {
              let step_day = 0;
              if (direction === 3 /* BOTTOM */ || direction === 1 /* RIGHT */) {
                step_day = 7;
              } else if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
                step_day = -7;
                data.reverse();
              }
              let step = 0;
              for (let i4 = 1; i4 <= len; i4++) {
                const index = (i4 - 1) % data.length;
                const d4 = { ...data[index] };
                const num = Math.ceil(i4 / data.length);
                if (index === 0) {
                  step = (0, import_dayjs.default)(d4.m).add(step_day * num, "days").diff((0, import_dayjs.default)(d4.m), "days");
                }
                const day = (0, import_dayjs.default)(d4.m).add(step, "days").day();
                let date;
                if (day === 0) {
                  date = (0, import_dayjs.default)(d4.m).add(step, "days").subtract(2, "days").format("YYYY-MM-DD");
                } else if (day === 6) {
                  date = (0, import_dayjs.default)(d4.m).add(step, "days").subtract(1, "days").format("YYYY-MM-DD");
                } else {
                  date = (0, import_dayjs.default)(d4.m).add(step, "days").format("YYYY-MM-DD");
                }
                d4.m = date;
                d4.v = generate(date)[2];
                applyData.push(d4);
              }
            }
          } else {
            if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
              data.reverse();
            }
            applyData = _this.FillCopy(data, len);
          }
        }
      } else if (type === "6") {
        if (data.length === 1) {
          let step = 0;
          if (direction === 3 /* BOTTOM */ || direction === 1 /* RIGHT */) {
            step = 1;
          } else if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
            step = -1;
          }
          applyData = _this.FillMonths(data, len, step);
        } else if (data.length === 2) {
          if ((0, import_dayjs.default)(data[1].m).date() === (0, import_dayjs.default)(data[0].m).date() && (0, import_dayjs.default)(data[1].m).diff((0, import_dayjs.default)(data[0].m), "months") !== 0) {
            if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
              data.reverse();
            }
            const step = (0, import_dayjs.default)(data[1].m).diff((0, import_dayjs.default)(data[0].m), "months");
            applyData = _this.FillMonths(data, len, step);
          } else {
            let step_month = 0;
            if (direction === 3 /* BOTTOM */ || direction === 1 /* RIGHT */) {
              step_month = 1;
            } else if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
              step_month = -1;
              data.reverse();
            }
            let step = 0;
            for (let i4 = 1; i4 <= len; i4++) {
              const index = (i4 - 1) % data.length;
              const d4 = { ...data[index] };
              const num = Math.ceil(i4 / data.length);
              if (index === 0) {
                step = (0, import_dayjs.default)(d4.m).add(step_month * num, "months").diff((0, import_dayjs.default)(d4.m), "days");
              }
              const date = (0, import_dayjs.default)(d4.m).add(step, "days").format("YYYY-MM-DD");
              d4.m = date;
              d4.v = generate(date)[2];
              applyData.push(d4);
            }
          }
        } else {
          const judgeDate = _this.judgeDate(data);
          if (judgeDate[0] && judgeDate[3]) {
            if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
              data.reverse();
            }
            const step = (0, import_dayjs.default)(data[1].m).diff((0, import_dayjs.default)(data[0].m), "months");
            applyData = _this.FillMonths(data, len, step);
          } else if (!judgeDate[0] && judgeDate[2]) {
            let step_month = 0;
            if (direction === 3 /* BOTTOM */ || direction === 1 /* RIGHT */) {
              step_month = 1;
            } else if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
              step_month = -1;
              data.reverse();
            }
            let step = 0;
            for (let i4 = 1; i4 <= len; i4++) {
              const index = (i4 - 1) % data.length;
              const d4 = { ...data[index] };
              const num = Math.ceil(i4 / data.length);
              if (index === 0) {
                step = (0, import_dayjs.default)(d4.m).add(step_month * num, "months").diff((0, import_dayjs.default)(d4.m), "days");
              }
              const date = (0, import_dayjs.default)(d4.m).add(step, "days").format("YYYY-MM-DD");
              d4.m = date;
              d4.v = generate(date)[2];
              applyData.push(d4);
            }
          } else {
            if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
              data.reverse();
            }
            applyData = _this.FillCopy(data, len);
          }
        }
      } else if (type === "7") {
        if (data.length === 1) {
          let step = 0;
          if (direction === 3 /* BOTTOM */ || direction === 1 /* RIGHT */) {
            step = 1;
          } else if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
            step = -1;
          }
          applyData = _this.FillYears(data, len, step);
        } else if (data.length === 2) {
          if ((0, import_dayjs.default)(data[1].m).date() === (0, import_dayjs.default)(data[0].m).date() && (0, import_dayjs.default)(data[1].m).month() === (0, import_dayjs.default)(data[0].m).month() && (0, import_dayjs.default)(data[1].m).diff((0, import_dayjs.default)(data[0].m), "years") !== 0) {
            if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
              data.reverse();
            }
            const step = (0, import_dayjs.default)(data[1].m).diff((0, import_dayjs.default)(data[0].m), "years");
            applyData = _this.FillYears(data, len, step);
          } else {
            let step_year = 0;
            if (direction === 3 /* BOTTOM */ || direction === 1 /* RIGHT */) {
              step_year = 1;
            } else if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
              step_year = -1;
              data.reverse();
            }
            let step = 0;
            for (let i4 = 1; i4 <= len; i4++) {
              const index = (i4 - 1) % data.length;
              const d4 = { ...data[index] };
              const num = Math.ceil(i4 / data.length);
              if (index === 0) {
                step = (0, import_dayjs.default)(d4.m).add(step_year * num, "years").diff((0, import_dayjs.default)(d4.m), "days");
              }
              const date = (0, import_dayjs.default)(d4.m).add(step, "days").format("YYYY-MM-DD");
              d4.m = date;
              d4.v = generate(date)[2];
              applyData.push(d4);
            }
          }
        } else {
          const judgeDate = _this.judgeDate(data);
          if (judgeDate[0] && judgeDate[1] && judgeDate[4]) {
            if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
              data.reverse();
            }
            const step = (0, import_dayjs.default)(data[1].m).diff((0, import_dayjs.default)(data[0].m), "years");
            applyData = _this.FillYears(data, len, step);
          } else if (judgeDate[0] && judgeDate[3] || judgeDate[2]) {
            let step_year = 0;
            if (direction === 3 /* BOTTOM */ || direction === 1 /* RIGHT */) {
              step_year = 1;
            } else if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
              step_year = -1;
              data.reverse();
            }
            let step = 0;
            for (let i4 = 1; i4 <= len; i4++) {
              const index = (i4 - 1) % data.length;
              const d4 = { ...data[index] };
              const num = Math.ceil(i4 / data.length);
              if (index === 0) {
                step = (0, import_dayjs.default)(d4.m).add(step_year * num, "years").diff((0, import_dayjs.default)(d4.m), "days");
              }
              const date = (0, import_dayjs.default)(d4.m).add(step, "days").format("YYYY-MM-DD");
              d4.m = date;
              d4.v = generate(date)[2];
              applyData.push(d4);
            }
          } else {
            if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
              data.reverse();
            }
            applyData = _this.FillCopy(data, len);
          }
        }
      } else if (type === "8") {
        if (data.length === 1) {
          let step = 0;
          if (direction === 3 /* BOTTOM */ || direction === 1 /* RIGHT */) {
            step = 1;
          } else if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
            step = -1;
          }
          applyData = _this.FillChnNumber(data, len, step);
        } else {
          const dataNumArr = [];
          for (let i4 = 0; i4 < data.length; i4++) {
            dataNumArr.push(_this.ChineseToNumber(data[i4].m));
          }
          if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
            data.reverse();
            dataNumArr.reverse();
          }
          if (_this.isEqualDiff(dataNumArr)) {
            const step = dataNumArr[1] - dataNumArr[0];
            applyData = _this.FillChnNumber(data, len, step);
          } else {
            applyData = _this.FillCopy(data, len);
          }
        }
      }
      return applyData;
    }
    static getDataIndex(csLen, asLen, indexArr) {
      const obj = {};
      const num = Math.floor(asLen / csLen);
      const rsd = asLen % csLen;
      let sum = 0;
      if (num > 0) {
        for (let i4 = 1; i4 <= num; i4++) {
          for (let j3 = 0; j3 < indexArr.length; j3++) {
            obj[indexArr[j3] + (i4 - 1) * csLen] = sum;
            sum++;
          }
        }
        for (let a4 = 0; a4 < indexArr.length; a4++) {
          if (indexArr[a4] <= rsd) {
            obj[indexArr[a4] + csLen * num] = sum;
            sum++;
          } else {
            break;
          }
        }
      } else {
        for (let a4 = 0; a4 < indexArr.length; a4++) {
          if (indexArr[a4] <= rsd) {
            obj[indexArr[a4]] = sum;
            sum++;
          } else {
            break;
          }
        }
      }
      return obj;
    }
    static FillCopy(data, len) {
      const applyData = [];
      for (let i4 = 1; i4 <= len; i4++) {
        const index = (i4 - 1) % data.length;
        const d4 = { ...data[index] };
        applyData.push(d4);
      }
      return applyData;
    }
    static FillSeries(data, len, direction) {
      const _this = this;
      const applyData = [];
      const dataNumArr = [];
      for (let j3 = 0; j3 < data.length; j3++) {
        dataNumArr.push(Number(data[j3].v));
      }
      if (data.length > 2 && _this.isEqualRatio(dataNumArr)) {
        for (let i4 = 1; i4 <= len; i4++) {
          const index = (i4 - 1) % data.length;
          const d4 = { ...data[index] };
          let num;
          if (direction === 3 /* BOTTOM */ || direction === 1 /* RIGHT */) {
            num = Number(data[data.length - 1].v) * (Number(data[1].v) / Number(data[0].v)) ** i4;
          } else if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
            num = Number(data[0].v) / (Number(data[1].v) / Number(data[0].v)) ** i4;
          }
          d4.v = num;
          d4.m = num;
          applyData.push(d4);
        }
      } else {
        const xArr = _this.getXArr(data.length);
        for (let i4 = 1; i4 <= len; i4++) {
          const index = (i4 - 1) % data.length;
          const d4 = { ...data[index] };
          let y4;
          if (direction === 3 /* BOTTOM */ || direction === 1 /* RIGHT */) {
            y4 = _this.forecast(data.length + i4, dataNumArr, xArr);
          } else if (direction === 2 /* TOP */ || direction === 0 /* LEFT */) {
            y4 = _this.forecast(1 - i4, dataNumArr, xArr);
          }
          d4.v = y4;
          d4.m = y4;
          applyData.push(d4);
        }
      }
      return applyData;
    }
    static FillExtendNumber(data, len, step) {
      const _this = this;
      const applyData = [];
      const reg = /0|([1-9]+[0-9]*)/g;
      for (let i4 = 1; i4 <= len; i4++) {
        const index = (i4 - 1) % data.length;
        const d4 = { ...data[index] };
        const last = data[data.length - 1].m;
        const match = last.match(reg);
        const lastTxt = match[match.length - 1];
        const num = Math.abs(Number(lastTxt) + step * i4);
        const lastIndex = last.lastIndexOf(lastTxt);
        const valueTxt = last.substr(0, lastIndex) + num.toString() + last.substr(lastIndex + lastTxt.length);
        d4.v = valueTxt;
        d4.m = valueTxt;
        applyData.push(d4);
      }
      return applyData;
    }
    static FillOnlyFormat(data, len) {
      const applyData = [];
      for (let i4 = 1; i4 <= len; i4++) {
        const index = (i4 - 1) % data.length;
        const d4 = { ...data[index] };
        delete d4.f;
        delete d4.m;
        delete d4.v;
        applyData.push(d4);
      }
      return applyData;
    }
    static FillWithoutFormat(dataArr) {
      const applyData = [];
      for (let i4 = 0; i4 < dataArr.length; i4++) {
        const d4 = { ...dataArr[i4] };
        let obj;
        if (d4.f === null) {
          obj = { m: d4.v.toString(), v: d4.v };
        } else {
          obj = { f: d4.f, m: d4.v.toString(), v: d4.v };
        }
        applyData.push(obj);
      }
      return applyData;
    }
    static FillDays(data, len, step) {
      const applyData = [];
      for (let i4 = 1; i4 <= len; i4++) {
        const index = (i4 - 1) % data.length;
        const d4 = { ...data[index] };
        let date = update("yyyy-MM-dd", d4.v);
        date = (0, import_dayjs.default)(date).add(step * i4, "days").format("YYYY-MM-DD");
        d4.v = generate(date)[2];
        d4.m = update(d4.fm.f, d4.v);
        applyData.push(d4);
      }
      return applyData;
    }
    static FillMonths(data, len, step) {
      const applyData = [];
      for (let i4 = 1; i4 <= len; i4++) {
        const index = (i4 - 1) % data.length;
        const d4 = { ...data[index] };
        let date = update("yyyy-MM-dd", d4.v);
        date = (0, import_dayjs.default)(date).add(step * i4, "months").format("YYYY-MM-DD");
        d4.v = generate(date)[2];
        d4.m = update(d4.fm.f, d4.v);
        applyData.push(d4);
      }
      return applyData;
    }
    static FillYears(data, len, step) {
      const applyData = [];
      for (let i4 = 1; i4 <= len; i4++) {
        const index = (i4 - 1) % data.length;
        const d4 = { ...data[index] };
        let date = update("yyyy-MM-dd", d4.v);
        date = (0, import_dayjs.default)(date).add(step * i4, "years").format("YYYY-MM-DD");
        d4.v = generate(date)[2];
        d4.m = update(d4.fm.t, d4.v);
        applyData.push(d4);
      }
      return applyData;
    }
    static FillChnWeek(data, len, step) {
      const _this = this;
      const applyData = [];
      for (let i4 = 1; i4 <= len; i4++) {
        const index = (i4 - 1) % data.length;
        const d4 = { ...data[index] };
        let num;
        if (data[data.length - 1].m === "\u65E5") {
          num = 7 + step * i4;
        } else {
          num = _this.ChineseToNumber(data[data.length - 1].m) + step * i4;
        }
        if (num < 0) {
          num = Math.ceil(Math.abs(num) / 7) * 7 + num;
        }
        const rsd = num % 7;
        if (rsd === 0) {
          d4.m = "\u65E5";
          d4.v = "\u65E5";
        } else if (rsd === 1) {
          d4.m = "\u4E00";
          d4.v = "\u4E00";
        } else if (rsd === 2) {
          d4.m = "\u4E8C";
          d4.v = "\u4E8C";
        } else if (rsd === 3) {
          d4.m = "\u4E09";
          d4.v = "\u4E09";
        } else if (rsd === 4) {
          d4.m = "\u56DB";
          d4.v = "\u56DB";
        } else if (rsd === 5) {
          d4.m = "\u4E94";
          d4.v = "\u4E94";
        } else if (rsd === 6) {
          d4.m = "\u516D";
          d4.v = "\u516D";
        }
        applyData.push(d4);
      }
      return applyData;
    }
    static FillChnWeek2(data, len, step) {
      const _this = this;
      const applyData = [];
      for (let i4 = 1; i4 <= len; i4++) {
        const index = (i4 - 1) % data.length;
        const d4 = { ...data[index] };
        let num;
        if (data[data.length - 1].m === "\u5468\u65E5") {
          num = 7 + step * i4;
        } else {
          const last = data[data.length - 1].m;
          const txt = last.substr(last.length - 1, 1);
          num = _this.ChineseToNumber(txt) + step * i4;
        }
        if (num < 0) {
          num = Math.ceil(Math.abs(num) / 7) * 7 + num;
        }
        const rsd = num % 7;
        if (rsd === 0) {
          d4.m = "\u5468\u65E5";
          d4.v = "\u5468\u65E5";
        } else if (rsd === 1) {
          d4.m = "\u5468\u4E00";
          d4.v = "\u5468\u4E00";
        } else if (rsd === 2) {
          d4.m = "\u5468\u4E8C";
          d4.v = "\u5468\u4E8C";
        } else if (rsd === 3) {
          d4.m = "\u5468\u4E09";
          d4.v = "\u5468\u4E09";
        } else if (rsd === 4) {
          d4.m = "\u5468\u56DB";
          d4.v = "\u5468\u56DB";
        } else if (rsd === 5) {
          d4.m = "\u5468\u4E94";
          d4.v = "\u5468\u4E94";
        } else if (rsd === 6) {
          d4.m = "\u5468\u516D";
          d4.v = "\u5468\u516D";
        }
        applyData.push(d4);
      }
      return applyData;
    }
    static FillChnWeek3(data, len, step) {
      const _this = this;
      const applyData = [];
      for (let i4 = 1; i4 <= len; i4++) {
        const index = (i4 - 1) % data.length;
        const d4 = { ...data[index] };
        let num;
        if (data[data.length - 1].m === "\u661F\u671F\u65E5") {
          num = 7 + step * i4;
        } else {
          const last = data[data.length - 1].m;
          const txt = last.substr(last.length - 1, 1);
          num = _this.ChineseToNumber(txt) + step * i4;
        }
        if (num < 0) {
          num = Math.ceil(Math.abs(num) / 7) * 7 + num;
        }
        const rsd = num % 7;
        if (rsd === 0) {
          d4.m = "\u661F\u671F\u65E5";
          d4.v = "\u661F\u671F\u65E5";
        } else if (rsd === 1) {
          d4.m = "\u661F\u671F\u4E00";
          d4.v = "\u661F\u671F\u4E00";
        } else if (rsd === 2) {
          d4.m = "\u661F\u671F\u4E8C";
          d4.v = "\u661F\u671F\u4E8C";
        } else if (rsd === 3) {
          d4.m = "\u661F\u671F\u4E09";
          d4.v = "\u661F\u671F\u4E09";
        } else if (rsd === 4) {
          d4.m = "\u661F\u671F\u56DB";
          d4.v = "\u661F\u671F\u56DB";
        } else if (rsd === 5) {
          d4.m = "\u661F\u671F\u4E94";
          d4.v = "\u661F\u671F\u4E94";
        } else if (rsd === 6) {
          d4.m = "\u661F\u671F\u516D";
          d4.v = "\u661F\u671F\u516D";
        }
        applyData.push(d4);
      }
      return applyData;
    }
    static FillChnNumber(data, len, step) {
      const _this = this;
      const applyData = [];
      for (let i4 = 1; i4 <= len; i4++) {
        const index = (i4 - 1) % data.length;
        const d4 = { ...data[index] };
        const num = _this.ChineseToNumber(data[data.length - 1].m) + step * i4;
        let txt;
        if (num <= 0) {
          txt = "\u96F6";
        } else {
          txt = _this.NumberToChinese(num);
        }
        d4.v = txt;
        d4.m = txt.toString();
        applyData.push(d4);
      }
      return applyData;
    }
    static isEqualDiff(arr) {
      let diff = true;
      const step = arr[1] - arr[0];
      for (let i4 = 1; i4 < arr.length; i4++) {
        if (arr[i4] - arr[i4 - 1] !== step) {
          diff = false;
          break;
        }
      }
      return diff;
    }
    static isChnNumber(txt) {
      const _this = this;
      let isChnNumber = true;
      if (txt.length === 1) {
        if (txt === "\u65E5" || txt in _this.chnNumChar) {
          isChnNumber = true;
        } else {
          isChnNumber = false;
        }
      } else {
        const str = txt.split("");
        for (let i4 = 0; i4 < str.length; i4++) {
          if (!(str[i4] in _this.chnNumChar || str[i4] in _this.chnNameValue)) {
            isChnNumber = false;
            break;
          }
        }
      }
      return isChnNumber;
    }
    static isExtendNumber(txt) {
      const reg = /0|([1-9]+[0-9]*)/g;
      const isExtendNumber = reg.test(txt);
      if (isExtendNumber) {
        const match = txt.match(reg);
        const matchTxt = match[match.length - 1];
        const matchIndex = txt.lastIndexOf(matchTxt);
        const beforeTxt = txt.substr(0, matchIndex);
        const afterTxt = txt.substr(matchIndex + matchTxt.length);
        return [isExtendNumber, Number(matchTxt), beforeTxt, afterTxt];
      }
      return [isExtendNumber];
    }
    static isChnWeek1(txt) {
      const _this = this;
      let isChnWeek1;
      if (txt.length === 1) {
        if (txt === "\u65E5" || _this.ChineseToNumber(txt) < 7) {
          isChnWeek1 = true;
        } else {
          isChnWeek1 = false;
        }
      } else {
        isChnWeek1 = false;
      }
      return isChnWeek1;
    }
    static isChnWeek2(txt) {
      let isChnWeek2;
      if (txt.length === 2) {
        if (txt === "\u5468\u4E00" || txt === "\u5468\u4E8C" || txt === "\u5468\u4E09" || txt === "\u5468\u56DB" || txt === "\u5468\u4E94" || txt === "\u5468\u516D" || txt === "\u5468\u65E5") {
          isChnWeek2 = true;
        } else {
          isChnWeek2 = false;
        }
      } else {
        isChnWeek2 = false;
      }
      return isChnWeek2;
    }
    static isChnWeek3(txt) {
      let isChnWeek3;
      if (txt.length === 3) {
        if (txt === "\u661F\u671F\u4E00" || txt === "\u661F\u671F\u4E8C" || txt === "\u661F\u671F\u4E09" || txt === "\u661F\u671F\u56DB" || txt === "\u661F\u671F\u4E94" || txt === "\u661F\u671F\u516D" || txt === "\u661F\u671F\u65E5") {
          isChnWeek3 = true;
        } else {
          isChnWeek3 = false;
        }
      } else {
        isChnWeek3 = false;
      }
      return isChnWeek3;
    }
    static isEqualRatio(arr) {
      let ratio = true;
      const step = arr[1] / arr[0];
      for (let i4 = 1; i4 < arr.length; i4++) {
        if (arr[i4] / arr[i4 - 1] !== step) {
          ratio = false;
          break;
        }
      }
      return ratio;
    }
    static getXArr(len) {
      const xArr = [];
      for (let i4 = 1; i4 <= len; i4++) {
        xArr.push(i4);
      }
      return xArr;
    }
    static forecast(x4, yArr, xArr) {
      function getAverage(arr) {
        let sum = 0;
        for (let i4 = 0; i4 < arr.length; i4++) {
          sum += arr[i4];
        }
        return sum / arr.length;
      }
      const ax = getAverage(xArr);
      const ay = getAverage(yArr);
      let sum_d = 0;
      let sum_n = 0;
      for (let j3 = 0; j3 < xArr.length; j3++) {
        sum_d += (xArr[j3] - ax) * (yArr[j3] - ay);
        sum_n += (xArr[j3] - ax) * (xArr[j3] - ax);
      }
      let b4;
      if (sum_n === 0) {
        b4 = 1;
      } else {
        b4 = sum_d / sum_n;
      }
      const a4 = ay - b4 * ax;
      return Math.round((a4 + b4 * x4) * 1e5) / 1e5;
    }
    static judgeDate(data) {
      let isSameDay = true;
      let isSameMonth = true;
      let isEqualDiffDays = true;
      let isEqualDiffMonths = true;
      let isEqualDiffYears = true;
      const sameDay = (0, import_dayjs.default)(data[0].m).date();
      const sameMonth = (0, import_dayjs.default)(data[0].m).month();
      const equalDiffDays = (0, import_dayjs.default)(data[1].m).diff((0, import_dayjs.default)(data[0].m), "days");
      const equalDiffMonths = (0, import_dayjs.default)(data[1].m).diff((0, import_dayjs.default)(data[0].m), "months");
      const equalDiffYears = (0, import_dayjs.default)(data[1].m).diff((0, import_dayjs.default)(data[0].m), "years");
      for (let i4 = 1; i4 < data.length; i4++) {
        if ((0, import_dayjs.default)(data[i4].m).date() !== sameDay) {
          isSameDay = false;
        }
        if ((0, import_dayjs.default)(data[i4].m).month() !== sameMonth) {
          isSameMonth = false;
        }
        if ((0, import_dayjs.default)(data[i4].m).diff((0, import_dayjs.default)(data[i4 - 1].m), "days") !== equalDiffDays) {
          isEqualDiffDays = false;
        }
        if ((0, import_dayjs.default)(data[i4].m).diff((0, import_dayjs.default)(data[i4 - 1].m), "months") !== equalDiffMonths) {
          isEqualDiffMonths = false;
        }
        if ((0, import_dayjs.default)(data[i4].m).diff((0, import_dayjs.default)(data[i4 - 1].m), "years") !== equalDiffYears) {
          isEqualDiffYears = false;
        }
      }
      if (equalDiffDays === 0) {
        isEqualDiffDays = false;
      }
      if (equalDiffMonths === 0) {
        isEqualDiffMonths = false;
      }
      if (equalDiffYears === 0) {
        isEqualDiffYears = false;
      }
      return [
        isSameDay,
        isSameMonth,
        isEqualDiffDays,
        isEqualDiffMonths,
        isEqualDiffYears
      ];
    }
  };
  __publicField(DropCell, "applyType");
  // 012345678
  __publicField(DropCell, "direction");
  // down-right-up-left-
  __publicField(DropCell, "chnNumChar");
  __publicField(DropCell, "chnNameValue");
  __publicField(DropCell, "chnNumChar2");
  __publicField(DropCell, "chnUnitChar");
  __publicField(DropCell, "chnUnitSection");

  // ../../packages/core/src/Sheets/Domain/RangeList.ts
  var RangeList = class {
    _rangeListId;
    _commandManager;
    _workbook;
    _context;
    _worksheet;
    _rangeList;
    constructor(worksheet, rangeList) {
      this._context = worksheet.getContext();
      this._workbook = this._context.getWorkBook();
      this._commandManager = this._context.getCommandManager();
      this._worksheet = worksheet;
      this._rangeList = [];
      rangeList.forEach((range2) => {
        this._rangeList.push(
          this._context.getWorkBook().transformRangeType(range2).rangeData
        );
      });
      if (this._rangeList[0].startRow === -1) {
        console.error("Invalid range,default set startRow -1");
      }
    }
    getRangeList() {
      return this._rangeList;
    }
    /**
     * Selects the list of Range instances.
     *
     * @returns The list of active ranges, for chaining.
     */
    activate() {
      const { _context, _commandManager } = this;
      if (this._rangeList[0].startRow === -1) {
        console.error("Invalid range,default set startRow -1");
        return this;
      }
      this._worksheet.getSelection().setSelection({ selection: this._rangeList });
      return this;
    }
    /**
     * Break all horizontally- or vertically-merged cells contained within the range list into individual cells again.
     */
    // TODO
    // breakApart() {}
    /**
     * Sets the value for each Range in the range list. The value can be numeric, string, boolean or date. If it begins with '=' it is interpreted as a formula.
     *
     * @param value  The value for the range list.
     * @returns This range list, for chaining.
     */
    setValue(value) {
      let { _rangeList, _context, _commandManager, _worksheet } = this;
      const setList = _rangeList.map((range2) => {
        let { startRow, startColumn, endRow, endColumn } = range2;
        let cellValue = new ObjectMatrix();
        for (let r4 = startRow; r4 <= endRow; r4++) {
          for (let c4 = startColumn; c4 <= endColumn; c4++) {
            cellValue.setValue(startRow, startColumn, {
              m: `${value}`,
              v: value
            });
          }
        }
        let setValue = {
          sheetId: _worksheet.getSheetId(),
          actionName: SetRangeDataAction.NAME,
          cellValue: cellValue.getData()
        };
        return setValue;
      });
      let command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        ...setList
      );
      _commandManager.invoke(command);
      return this;
    }
    clear(...argument) {
      const { _context, _worksheet, _commandManager, _rangeList } = this;
      let options = {
        formatOnly: true,
        contentsOnly: true,
        commentsOnly: true,
        validationsOnly: true,
        skipFilteredRows: true
      };
      if (Tuples.checkup(argument, Tuples.OBJECT_TYPE)) {
        options = argument[0];
      }
      const clearList = _rangeList.map((range2) => {
        let clearRange = {
          sheetId: _worksheet.getSheetId(),
          actionName: ClearRangeAction.NAME,
          options,
          rangeData: range2
        };
        return clearRange;
      });
      let command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        ...clearList
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Clears text formatting for each Range in the range list.
     *
     * This clears text formatting for each range, but does not reset any number formatting rules.
     * @returns  This range list, for chaining.
     */
    clearFormat() {
      return this.clear({ formatOnly: true });
    }
    /**
     * Clears the content of each Range in the range list, leaving the formatting intact.
     *
     * @returns  This range list, for chaining.
     */
    clearContent() {
      return this.clear({ contentsOnly: true });
    }
    /**
     * Clears the note for each Range in the range list.
     *
     *  @returns  This range list, for chaining.
     */
    clearNote() {
      return this.clear({ commentsOnly: true });
    }
    /**
     * Sets the background color for each Range in the range list.
     *
     * @param color  The background color code in CSS notation such as '#ffffff' or 'white'; a null value resets the color.
     * @returns This range list, for chaining.
     */
    setBackground(color) {
      let { _rangeList, _context, _commandManager, _worksheet } = this;
      const setList = _rangeList.map((range2) => {
        let { startRow, startColumn, endRow, endColumn } = range2;
        const styleObj = {
          bg: {
            rgb: color
          }
        };
        const stylesMatrix = Tools.fillObjectMatrix(
          endRow - startRow + 1,
          endColumn - startColumn + 1,
          styleObj
        );
        const setStyle = {
          sheetId: _worksheet.getSheetId(),
          actionName: "SetRangeStyleAction" /* SET_RANGE_STYLE_ACTION */,
          value: stylesMatrix,
          rangeData: range2
        };
        return setStyle;
      });
      let command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        ...setList
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Sets the background to the given RGB color.
     *
     * @param red  	The red value in RGB notation.
     * @param green  The green value in RGB notation.
     * @param blue  The blue value in RGB notation.
     * @returns This range list, for chaining.
     */
    setBackgroundRGB(red, green, blue) {
      const rgbString = `RGB(${red},${green},${blue})`;
      let { _rangeList, _context, _commandManager, _worksheet } = this;
      const setList = _rangeList.map((range2) => {
        let { startRow, startColumn, endRow, endColumn } = range2;
        const styleObj = {
          bg: {
            rgb: rgbString
          }
        };
        const stylesMatrix = Tools.fillObjectMatrix(
          endRow - startRow + 1,
          endColumn - startColumn + 1,
          styleObj
        );
        const setStyle = {
          sheetId: _worksheet.getSheetId(),
          actionName: "SetRangeStyleAction" /* SET_RANGE_STYLE_ACTION */,
          value: stylesMatrix,
          rangeData: range2
        };
        return setStyle;
      });
      let command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        ...setList
      );
      _commandManager.invoke(command);
      return this;
    }
    // TODO
    // setBorder(top, left, bottom, right, vertical, horizontal) {}
    // setBorder(top, left, bottom, right, vertical, horizontal, color, style) {}
    /**
     * Sets the font color for each Range in the range list. Color is represented in in CSS notation;
     *
     * @param color  The font color in CSS notation such as '#ffffff' or 'white'; a null value resets the color.
     * @returns This range list, for chaining.
     */
    setFontColor(color) {
      let { _rangeList, _context, _commandManager, _worksheet } = this;
      const setList = _rangeList.map((range2) => {
        let { startRow, startColumn, endRow, endColumn } = range2;
        const styleObj = {
          cl: {
            rgb: color
          }
        };
        const stylesMatrix = Tools.fillObjectMatrix(
          endRow - startRow + 1,
          endColumn - startColumn + 1,
          styleObj
        );
        const setStyle = {
          sheetId: _worksheet.getSheetId(),
          actionName: "SetRangeStyleAction" /* SET_RANGE_STYLE_ACTION */,
          value: stylesMatrix,
          rangeData: range2
        };
        return setStyle;
      });
      let command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        ...setList
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Sets the font family for each Range in the range list.
     *
     * @param fontFamily  The font family to set; a null value resets the font family.
     * @returns This range list, for chaining.
     */
    setFontFamily(fontFamily) {
      return this._setStyle(fontFamily, "ff");
    }
    // setFontLine(fontLine) {}
    /**
     * Sets the underline for each Range in the range list.
     *
     * @param fontLine  The underline to set; a null value resets the underline.
     * @returns This range list, for chaining.
     */
    setUnderline(fontLine) {
      const textDecoration = {
        s: fontLine ? 1 /* TRUE */ : 0 /* FALSE */
      };
      return this._setStyle(textDecoration, "ul");
    }
    /**
     * Sets the Overline for each Range in the range list.
     *
     * @param fontLine  The Overline to set; a null value resets the Overline.
     * @returns This range list, for chaining.
     */
    setOverline(fontLine) {
      const textDecoration = {
        s: fontLine ? 1 /* TRUE */ : 0 /* FALSE */
      };
      return this._setStyle(textDecoration, "ol");
    }
    /**
     * Sets the StrikeThrough for each Range in the range list.
     *
     * @param fontLine  The StrikeThrough to set; a null value resets the StrikeThrough.
     * @returns This range list, for chaining.
     */
    setStrikeThrough(fontLine) {
      const textDecoration = {
        s: fontLine ? 1 /* TRUE */ : 0 /* FALSE */
      };
      return this._setStyle(textDecoration, "st");
    }
    /**
     * Sets the font size (in points) for each Range in the range list.
     *
     * @param size A font point size.
     * @returns This range list, for chaining.
     */
    setFontSize(size) {
      return this._setStyle(size, "fs");
    }
    /**
     * Set the font style for each Range in the range list
     *
     * @param fontStyle  The font style, either 'italic' or 'normal'; a null value resets the font style.
     * @returns This range list, for chaining.
     */
    setFontStyle(fontStyle) {
      const fontBoolean = fontStyle ? 1 /* TRUE */ : 0 /* FALSE */;
      return this._setStyle(fontBoolean, "it");
    }
    /**
     * Set the font style for each Range in the range list.
     *
     * @param fontWeight The font weight, either 'bold' or 'normal'; a null value resets the font weight.
     * @returns This range list, for chaining.
     */
    setFontWeight(fontWeight) {
      const fontBoolean = fontWeight ? 1 /* TRUE */ : 0 /* FALSE */;
      return this._setStyle(fontBoolean, "bl");
    }
    /**
     * Updates the formula for each Range in the range list.
     *
     * @param formula A string representing the formula to set.
     * @returns This range list, for chaining.
     */
    setFormula(formula) {
      let { _rangeList, _context, _commandManager, _worksheet } = this;
      const setList = _rangeList.map((range2) => {
        let { startRow, startColumn, endRow, endColumn } = range2;
        let cellValue = new ObjectMatrix();
        for (let r4 = startRow; r4 <= endRow; r4++) {
          for (let c4 = startColumn; c4 <= endColumn; c4++) {
            cellValue.setValue(r4, c4, formula);
          }
        }
        let setValue = {
          sheetId: _worksheet.getSheetId(),
          actionName: "SetRangeFormulaAction" /* SET_RANGE_FORMULA_ACTION */,
          cellFormula: cellValue.getData(),
          rangeData: range2
        };
        return setValue;
      });
      let command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        ...setList
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Set the horizontal alignment for each Range in the range list.
     *
     * @param alignment The alignment, either 'left', 'center' or 'right'; a null value resets the alignment.
     * @returns This range list, for chaining.
     */
    setHorizontalAlignment(alignment) {
      return this._setStyle(alignment, "ht");
    }
    /**
     * Sets the note text for each Range in the range list.
     *
     * @param note 	The note text to set; a null value removes the note.
     * @returns This range list, for chaining.
     */
    // setNote(note: Nullable<string>): RangeList {
    //     let { _rangeList, _context, _commandManager, _worksheet } = this;
    //     const setList = _rangeList.map((range) => {
    //         let { startRow, startColumn, endRow, endColumn } = range;
    //         let cellValue = new ObjectMatrix<string>();
    //         for (let r = startRow; r <= endRow; r++) {
    //             for (let c = startColumn; c <= endColumn; c++) {
    //                 cellValue.setValue(r, c, note);
    //             }
    //         }
    //         let setValue: ISetRangeNoteActionData = {
    //             sheetId: _worksheet.getSheetId(),
    //             actionName: ACTION_NAMES.SET_RANGE_NOTE_ACTION,
    //             cellNote: cellValue.getData(),
    //             rangeData: range,
    //         };
    //         return setValue;
    //     });
    //     let command = new Command(_context.getWorkBook(), ...setList);
    //     _commandManager.invoke(command);
    //     return this;
    // }
    /**
     * Sets the note text for each Range in the range list.
     *
     * @param numberFormat A number format string.
     * @returns This range list, for chaining.
     */
    // setNumberFormat(numberFormat: string): RangeList {
    //     let { _rangeList, _context, _commandManager, _worksheet } = this;
    //     const setList = _rangeList.map((range) => {
    //         let { startRow, startColumn, endRow, endColumn } = range;
    //         let cellValue = new ObjectMatrix<string>();
    //         for (let r = 0; r <= endRow - startRow; r++) {
    //             for (let c = 0; c <= endColumn - startColumn; c++) {
    //                 const fm = {
    //                     f: numberFormat,
    //                     t: FormatType.NUMBER,
    //                 };
    //                 cellValue.setValue(r + startRow, c + startColumn, JSON.stringify(fm));
    //             }
    //         }
    //         let setValue: ISetRangeFormatActionData = {
    //             sheetId: _worksheet.getSheetId(),
    //             actionName: ACTION_NAMES.SET_RANGE_FORMAT_ACTION,
    //             cellFormat: cellValue.getData(),
    //             rangeData: range,
    //         };
    //         return setValue;
    //     });
    //     let command = new Command(_context.getWorkBook(), ...setList);
    //     _commandManager.invoke(command);
    //     return this;
    // }
    /**
     * Sets the note text for each Range in the range list.
     */
    // TODO
    // setShowHyperlink(showHyperlink) {}
    /**
     * Sets the text direction for the cells in each Range in the range list.
     *
     * @param direction The desired text direction; if null the direction is inferred before setting.
     * @returns This range list, for chaining.
     */
    setTextDirection(direction) {
      return this._setStyle(direction, "td");
    }
    /**
     * Sets the text rotation settings for the cells in each Range in the range list.
     *
     * @param degrees The desired angle between the standard orientation and the desired orientation. For left to right text, positive angles are in the counterclockwise direction.
     * @returns This range list, for chaining.
     */
    setTextRotation(degrees) {
      let { _rangeList, _context, _commandManager, _worksheet } = this;
      const setList = _rangeList.map((range2) => {
        let { startRow, startColumn, endRow, endColumn } = range2;
        const styleObj = {
          tr: {
            v: 0,
            a: Number(degrees)
          }
        };
        const stylesMatrix = Tools.fillObjectMatrix(
          endRow - startRow + 1,
          endColumn - startColumn + 1,
          styleObj
        );
        const setStyle = {
          sheetId: _worksheet.getSheetId(),
          actionName: "SetRangeStyleAction" /* SET_RANGE_STYLE_ACTION */,
          value: stylesMatrix,
          rangeData: range2
        };
        return setStyle;
      });
      let command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        ...setList
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Set the vertical alignment for each Range in the range list.
     *
     * @param alignment The alignment, either 'top', 'middle' or 'bottom'; a null value resets the alignment.
     * @returns This range list, for chaining.
     */
    setVerticalAlignment(alignment) {
      this._setStyle(alignment, "vt");
      return this;
    }
    /**
     * Sets whether or not to stack the text for the cells for each Range in the range list.
     *
     * @param isVertical  Whether or not to stack the text.
     * @returns This range list, for chaining.
     */
    setVerticalText(isVertical) {
      let { _rangeList, _context, _commandManager, _worksheet } = this;
      const setList = _rangeList.map((range2) => {
        let { startRow, startColumn, endRow, endColumn } = range2;
        const styleObj = {
          tr: {
            v: isVertical,
            a: 0
          }
        };
        const stylesMatrix = Tools.fillObjectMatrix(
          endRow - startRow + 1,
          endColumn - startColumn + 1,
          styleObj
        );
        const setStyle = {
          sheetId: _worksheet.getSheetId(),
          actionName: "SetRangeStyleAction" /* SET_RANGE_STYLE_ACTION */,
          value: stylesMatrix,
          rangeData: range2
        };
        return setStyle;
      });
      let command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        ...setList
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Set text wrapping for each Range in the range list.
     *
     * @param isWrapEnabled  Whether to wrap text or not.
     * @returns This range list, for chaining.
     */
    setWrap(isWrapEnabled) {
      return this._setStyle(isWrapEnabled, "tb");
    }
    /**
     * Sets the text wrapping strategy for each Range in the range list.
     *
     * @param strategy 	The desired wrapping strategy.
     * @returns This range list, for chaining.
     */
    setWrapStrategy(strategy) {
      return this._setStyle(strategy, "tb");
    }
    /**
     * Trims the whitespace (such as spaces, tabs, or new lines) in every cell in this range list.
     *
     * @returns This range list, for chaining.
     */
    trimWhitespace() {
      let { _rangeList, _context, _commandManager, _worksheet } = this;
      const setList = _rangeList.map((range2) => {
        let { startRow, startColumn, endRow, endColumn } = range2;
        const sheetMatrix = this._worksheet.getCellMatrix();
        const regx = /\s+/g;
        let cellValue = new ObjectMatrix();
        for (let r4 = startRow; r4 < endRow + 1; r4++) {
          for (let c4 = startColumn; c4 < endColumn + 1; c4++) {
            let m4 = sheetMatrix.getValue(r4, c4).m;
            const value = m4.replace(regx, "");
            cellValue.setValue(r4, c4, value || "");
          }
        }
        let setValue = {
          sheetId: _worksheet.getSheetId(),
          actionName: "SetRangeFormattedValueAction" /* SET_RANGE_FORMATTED_VALUE_ACTION */,
          cellValue: cellValue.getData(),
          rangeData: range2
        };
        return setValue;
      });
      let command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        ...setList
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * set style
     *
     * @param value style value
     * @param type style type
     * @returns  This range list, for chaining.
     * @internal @preapproved
     */
    _setStyle(value, type) {
      let { _rangeList, _context, _commandManager, _worksheet } = this;
      const setList = _rangeList.map((range2) => {
        let { startRow, startColumn, endRow, endColumn } = range2;
        const styleObj = { [type]: value };
        const stylesMatrix = Tools.fillObjectMatrix(
          endRow - startRow + 1,
          endColumn - startColumn + 1,
          styleObj
        );
        const setStyle = {
          sheetId: _worksheet.getSheetId(),
          value: stylesMatrix,
          rangeData: range2,
          actionName: SetRangeStyleAction.NAME
        };
        return setStyle;
      });
      let command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        ...setList
      );
      _commandManager.invoke(command);
      return this;
    }
  };

  // ../../packages/core/src/Sheets/Domain/RowManager.ts
  var RowManager = class {
    _rowData;
    _workSheet;
    constructor(workSheet, data) {
      this._workSheet = workSheet;
      this._rowData = new ObjectArray(data);
    }
    /**
     * Get height and hidden status of columns in the sheet
     * @returns
     */
    getRowData() {
      return this._rowData;
    }
    getRowDatas(rowPos, numRows) {
      const rowData = new ObjectArray();
      for (let i4 = rowPos; i4 < rowPos + numRows; i4++) {
        const data = this.getRowOrCreate(i4);
        rowData.push(data);
      }
      return rowData;
    }
    getRowHeight(...argument) {
      const { _workSheet } = this;
      const { _rowData } = this;
      const config = _workSheet.getConfig();
      let height = 0;
      if (argument.length === 1) {
        const row = _rowData.obtain(argument[0], {
          hd: 0 /* FALSE */,
          h: config.defaultRowHeight
        });
        height = row.h;
      } else if (argument.length === 2) {
        for (let i4 = argument[0]; i4 < argument[0] + argument[1]; i4++) {
          const row = _rowData.obtain(i4, {
            hd: 0 /* FALSE */,
            h: config.defaultRowHeight
          });
          height += row.h;
        }
      }
      return height;
    }
    /**
     * Set height of one or more rows
     * @param rowIndex row index
     * @param rowHeight row height array
     * @returns
     */
    setRowHeight(rowIndex, rowHeight) {
      const _context = this._workSheet.getContext();
      const _commandManager = this._workSheet.getCommandManager();
      const setRowHeight = {
        sheetId: this._workSheet.getSheetId(),
        actionName: SetRowHeightAction.NAME,
        rowIndex,
        rowHeight
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setRowHeight
      );
      _commandManager.invoke(command);
    }
    /**
     * Get row data of given row
     * @param rowPos row index
     * @returns
     */
    getRow(rowPos) {
      const { _rowData } = this;
      return _rowData.get(rowPos);
    }
    /**
     * Get count of column in the sheet
     * @returns
     */
    getSize() {
      return this._rowData.getLength();
    }
    /**
     * Get given row data or create a row data when it's null
     * @param rowPos row index
     * @returns
     */
    getRowOrCreate(rowPos) {
      const { _workSheet } = this;
      const { _rowData } = this;
      const row = _rowData.get(rowPos);
      if (row) {
        return row;
      }
      const config = _workSheet.getConfig();
      const create = { hd: 0 /* FALSE */, h: config.defaultRowHeight };
      _rowData.set(rowPos, create);
      return create;
    }
  };

  // ../../packages/core/src/Sheets/Domain/Worksheet.ts
  var Worksheet = class {
    _commandManager;
    _selection;
    _context;
    _config;
    _initialized;
    _merges;
    // protected _borderStyles: BorderStyles;
    _sheetId;
    _cellData;
    _rowManager;
    // protected _protection: Protection;
    _columnManager;
    constructor(...argument) {
      if (Tools.hasLength(argument, 1)) {
        const context = argument[0];
        const config = {
          ...DEFAULT_WORKSHEET,
          mergeData: [],
          hideRow: [],
          hideColumn: [],
          cellData: {},
          rowData: {},
          columnData: {},
          rowTitle: {
            width: 46,
            hidden: 0 /* FALSE */
          },
          columnTitle: {
            height: 20,
            hidden: 0 /* FALSE */
          },
          selections: ["A1"],
          rightToLeft: 0 /* FALSE */,
          pluginMeta: {}
        };
        argument = [context, config];
      }
      if (Tools.hasLength(argument, 2)) {
        this._context = argument[0];
        this._config = Object.assign(argument[1], {
          ...DEFAULT_WORKSHEET,
          mergeData: [],
          hideRow: [],
          hideColumn: [],
          cellData: {},
          rowData: {},
          columnData: {},
          rowTitle: {
            width: 46,
            hidden: 0 /* FALSE */
          },
          columnTitle: {
            height: 20,
            hidden: 0 /* FALSE */
          },
          selections: ["A1"],
          rightToLeft: 0 /* FALSE */,
          pluginMeta: {},
          ...argument[1]
        });
        const { columnData, rowData, cellData } = this._config;
        this._sheetId = this._config.id ?? Tools.generateRandomId(6);
        this._initialized = false;
        this._cellData = new ObjectMatrix(cellData);
        this._commandManager = this._context.getCommandManager();
        this._rowManager = new RowManager(this, rowData);
        this._columnManager = new ColumnManager(this, columnData);
        this._initialize();
      }
    }
    /**
     * Returns WorkSheet Cell Data Matrix
     * @returns
     */
    getCellMatrix() {
      return this._cellData;
    }
    /**
     * Activates this sheet. Does not alter the sheet itself, only the parent's notion of the active sheet.
     * @returns Sheet  The newly active sheet.
     */
    activate() {
      if (this._config.status === 1 /* TRUE */) {
        return this;
      }
      const { _context, _commandManager } = this;
      const before = _context.getContextObserver(
        "onBeforeChangeActiveSheetObservable"
      );
      const after = _context.getContextObserver(
        "onAfterChangeActiveSheetObservable"
      );
      const setActive = {
        sheetId: this._sheetId,
        actionName: SetWorkSheetActivateAction.NAME,
        status: 1 /* TRUE */
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setActive
      );
      before.notifyObservers({ sheet: this });
      _commandManager.invoke(command);
      after.notifyObservers({ sheet: this });
      return this;
    }
    /**
     * Sets Update WorkSheet Configure
     * @param config config of worksheet
     * @returns current worksheet instance
     */
    setConfig(config) {
      this._config = Tools.commonExtend(DEFAULT_WORKSHEET, config);
      return this;
    }
    /**
     * Returns Row Manager
     * @returns Row Manager
     */
    getRowManager() {
      return this._rowManager;
    }
    /**
     * Returns the ID of the sheet represented by this object.
     * @returns ID of the sheet
     */
    getSheetId() {
      return this._sheetId;
    }
    /**
     * Returns Column Manager
     * @returns Column Manager
     */
    getColumnManager() {
      return this._columnManager;
    }
    /**
     * Set the sheet name.
     *
     * @example
     * Set new name:
     * ```
     * worksheet.setName('NewSheet')
     * ```
     *
     * @param name - new sheet name
     * @returns current worksheet instance
     *
     * @alpha
     */
    setName(name) {
      const { _context, _commandManager, _sheetId } = this;
      const before = _context.getContextObserver(
        "onBeforeChangeSheetNameObservable"
      );
      const after = _context.getContextObserver(
        "onAfterChangeSheetNameObservable"
      );
      const configure = {
        actionName: SetWorkSheetNameAction.NAME,
        sheetName: name,
        sheetId: _sheetId
      };
      const workbook = _context.getWorkBook();
      const sheets = workbook.getSheets();
      for (let i4 = 0; i4 < sheets.length; i4++) {
        const sheet = sheets[i4];
        if (sheet !== this && sheet.getName() === name) {
          console.warn("Duplicate name");
          return this;
        }
      }
      before.notifyObservers();
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        configure
      );
      _commandManager.invoke(command);
      after.notifyObservers({ name, sheet: this });
      return this;
    }
    /**
     * Returns the name of the sheet.
     * @returns name of the sheet
     */
    getName() {
      return this._config.name;
    }
    /**
     * Returns WorkSheet Clone Object
     * @returns WorkSheet Clone Object
     */
    clone() {
      const { _config, _context } = this;
      const copy = Tools.deepClone(_config);
      return new Worksheet(_context, copy);
    }
    /**
     * Returns Application Global SheetContext
     * @returns Global SheetContext
     */
    getContext() {
      return this._context;
    }
    /**
     * Returns WorkSheet Merges Manage
     *
     * @returns merge instance
     */
    getMerges() {
      return this._merges;
    }
    /**
     * Returns WorkSheet Command Manager
     * @returns
     */
    getCommandManager() {
      return this._commandManager;
    }
    /**
     * Returns Sheet Data To Array
     * @remarks {@link ICellData}  data type of cell.
     * @returns Sheet Data To Array
     */
    getSheetData() {
      return [];
    }
    getRange(...argument) {
      if (Tools.hasLength(argument, 1)) {
        return new Range(this, argument[0]);
      }
      if (Tools.hasLength(argument, 2)) {
        return new Range(this, {
          row: [argument[0], argument[0]],
          column: [argument[1], argument[1]]
        });
      }
      if (Tools.hasLength(argument, 3)) {
        return new Range(this, {
          row: [argument[0], argument[2]],
          column: [argument[1], argument[1]]
        });
      }
      if (Tools.hasLength(argument, 4)) {
        return new Range(this, {
          row: [argument[0], argument[2]],
          column: [argument[1], argument[3]]
        });
      }
    }
    /**
     * Returns User Multiple Selection Range List
     * @param rangeList range types array
     * @returns RangeList Instance
     */
    getRangeList(rangeList) {
      return new RangeList(this, rangeList);
    }
    /**
     * Returns WorkSheet Status
     * @returns WorkSheet Status
     */
    getStatus() {
      const { _config } = this;
      return _config.status;
    }
    // /**
    //  * Returns Protection
    //  * @returns User Pretection
    //  */
    // getProtection(): Protection {
    //     return this._protection;
    // }
    /**
     * Sets WorkSheet Status
     * @param status type of sheet status
     * @returns WorkSheet Instance
     */
    setStatus(status) {
      const { _context, _commandManager, _sheetId } = this;
      const configure = {
        actionName: SetWorkSheetStatusAction.NAME,
        sheetId: _sheetId,
        sheetStatus: status
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        configure
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Return WorkSheetZoomRatio
     * @return zoomRatio
     */
    getZoomRatio() {
      return this._config.zoomRatio || 1;
    }
    /**
     * Sets WorkSheetZoomRatio
     * @param zoomRatio
     */
    setZoomRatio(zoomRatio) {
      const { _context, _sheetId, _commandManager } = this;
      const zoomRation = {
        actionName: SetZoomRatioAction.NAME,
        zoom: zoomRatio,
        sheetId: _sheetId
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        zoomRation
      );
      _commandManager.invoke(command);
      const observer = _context.getContextObserver("onZoomRatioSheetObservable");
      observer.notifyObservers({ zoomRatio });
    }
    /**
     * Returns User Selection
     * @returns User Selection
     */
    getSelection() {
      return this._selection;
    }
    // /**
    //  * Returns Row StructGroup
    //  * @returns Row StructGroup
    //  */
    // getRowStructGroup(): StructGroup {
    //     return this._rowStatusGroup;
    // }
    // /**
    //  * Returns Column StructGroup
    //  * @returns Column StructGroup
    //  */
    // getColumnStructGroup(): StructGroup {
    //     return this._columnStatusGroup;
    // }
    /**
     * Returns Copy WorkSheet
     * @param name sheet name
     * @returns Copy WorkSheet
     */
    copy(name) {
      const { _config, _context } = this;
      const copy = Tools.deepClone(_config);
      copy.name = name;
      copy.status = 0 /* FALSE */;
      copy.id = Tools.generateRandomId();
      return new Worksheet(_context, copy);
    }
    /**
     * Returns WorkSheet Configures
     * @returns WorkSheet Configures
     */
    getConfig() {
      return this._config;
    }
    insertRows(...argument) {
      let rowIndex = 0;
      let numRows = 1;
      if (Tools.hasLength(argument, 1)) {
        rowIndex = argument[0];
      }
      if (Tools.hasLength(argument, 2)) {
        rowIndex = argument[0];
        numRows = argument[1];
      }
      const { _context, _commandManager, _sheetId } = this;
      const insertRowData = {
        actionName: InsertRowDataAction.NAME,
        sheetId: _sheetId,
        rowIndex,
        rowData: new ObjectMatrix(new ObjectArray(numRows)).toJSON()
      };
      const insertRow = {
        actionName: InsertRowAction.NAME,
        sheetId: _sheetId,
        rowIndex,
        rowCount: numRows
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        insertRowData,
        insertRow
      );
      _commandManager.invoke(command);
      return this;
    }
    insertRowAfter(...argument) {
      let rowIndex = 0;
      let numRows = 1;
      if (Tools.hasLength(argument, 1)) {
        rowIndex = argument[0] + 1;
      }
      if (Tools.hasLength(argument, 2)) {
        rowIndex = argument[0] + 1;
        numRows = argument[1];
      }
      const { _context, _commandManager, _sheetId } = this;
      const insertRowData = {
        actionName: InsertRowDataAction.NAME,
        sheetId: _sheetId,
        rowIndex,
        rowData: new ObjectMatrix(new ObjectArray(numRows)).toJSON()
      };
      const insertRow = {
        actionName: InsertRowAction.NAME,
        sheetId: _sheetId,
        rowIndex,
        rowCount: numRows
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        insertRowData,
        insertRow
      );
      _commandManager.invoke(command);
      return this;
    }
    insertRowBefore(...argument) {
      let rowIndex = 0;
      let numRows = 1;
      if (Tools.hasLength(argument, 1)) {
        rowIndex = argument[0] - 1;
      }
      if (Tools.hasLength(argument, 2)) {
        rowIndex = argument[0] - 1;
        numRows = argument[1];
      }
      if (rowIndex < 0) {
        rowIndex = 0;
      }
      const { _context, _commandManager, _sheetId } = this;
      const insertRowData = {
        actionName: InsertRowDataAction.NAME,
        sheetId: _sheetId,
        rowIndex,
        rowData: new ObjectMatrix(new ObjectArray(numRows)).toJSON()
      };
      const insertRow = {
        actionName: InsertRowAction.NAME,
        sheetId: _sheetId,
        rowIndex,
        rowCount: numRows
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        insertRowData,
        insertRow
      );
      _commandManager.invoke(command);
      return this;
    }
    insertColumns(...argument) {
      let columnIndex = 0;
      let numColumns = 1;
      if (Tools.hasLength(argument, 1)) {
        columnIndex = argument[0];
      }
      if (Tools.hasLength(argument, 2)) {
        columnIndex = argument[0];
        numColumns = argument[1];
      }
      const { _context, _commandManager, _sheetId } = this;
      const columnData = new ObjectMatrix();
      this._cellData.forEach((index) => {
        for (let i4 = columnIndex; i4 < columnIndex + numColumns; i4++) {
          columnData.setValue(index, i4 - columnIndex, {});
        }
      });
      const insertColumnData = {
        actionName: InsertColumnDataAction.NAME,
        sheetId: _sheetId,
        columnIndex,
        columnData: columnData.toJSON()
      };
      const insertColumn = {
        actionName: InsertColumnAction.NAME,
        sheetId: _sheetId,
        columnIndex,
        columnCount: numColumns
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        insertColumn,
        insertColumnData
      );
      _commandManager.invoke(command);
      return this;
    }
    insertColumnBefore(...argument) {
      let columnIndex = 0;
      let numColumns = 1;
      if (Tools.hasLength(argument, 1)) {
        columnIndex = argument[0] - 1;
      }
      if (Tools.hasLength(argument, 2)) {
        columnIndex = argument[0] - 1;
        numColumns = argument[1];
      }
      if (columnIndex < 0) {
        columnIndex = 0;
      }
      const { _context, _commandManager, _sheetId } = this;
      const columnData = new ObjectMatrix();
      this._cellData.forEach((index) => {
        for (let i4 = columnIndex; i4 < columnIndex + numColumns; i4++) {
          columnData.setValue(index, i4 - columnIndex, {});
        }
      });
      const insertColumnData = {
        actionName: InsertColumnDataAction.NAME,
        sheetId: _sheetId,
        columnIndex,
        columnData: columnData.toJSON()
      };
      const insertColumn = {
        actionName: InsertColumnAction.NAME,
        sheetId: _sheetId,
        columnIndex,
        columnCount: numColumns
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        insertColumn,
        insertColumnData
      );
      _commandManager.invoke(command);
      return this;
    }
    insertColumnAfter(...argument) {
      let columnIndex = 0;
      let numColumns = 1;
      if (Tools.hasLength(argument, 1)) {
        columnIndex = argument[0] + 1;
      }
      if (Tools.hasLength(argument, 2)) {
        columnIndex = argument[0] + 1;
        numColumns = argument[1];
      }
      const { _context, _commandManager, _sheetId } = this;
      const columnData = new ObjectMatrix();
      this._cellData.forEach((index) => {
        for (let i4 = columnIndex; i4 < columnIndex + numColumns; i4++) {
          columnData.setValue(index, i4 - columnIndex, {});
        }
      });
      const insertColumnData = {
        actionName: InsertColumnDataAction.NAME,
        sheetId: _sheetId,
        columnIndex,
        columnData: columnData.toJSON()
      };
      const insertColumn = {
        actionName: InsertColumnAction.NAME,
        sheetId: _sheetId,
        columnIndex,
        columnCount: numColumns
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        insertColumnData,
        insertColumn
      );
      _commandManager.invoke(command);
      return this;
    }
    clear(...argument) {
      const { _context, _commandManager } = this;
      const _range = {
        startRow: 0,
        endRow: this.getConfig().rowCount - 1,
        startColumn: 0,
        endColumn: this.getConfig().columnCount - 1
      };
      let options = {
        formatOnly: true,
        contentsOnly: true
      };
      if (Tuples.checkup(argument, Tuples.OBJECT_TYPE)) {
        options = argument[0];
      }
      const setValue = {
        sheetId: this._sheetId,
        actionName: ClearRangeAction.NAME,
        options,
        rangeData: _range
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setValue
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Sets the sheet tab color.
     * @param color A color code in CSS notation (like '#ffffff' or 'white'), or null to reset the tab color.
     * @returns WorkSheet This sheet, for chaining.
     */
    setTabColor(color) {
      const { _context, _commandManager } = this;
      const observer = _context.getContextObserver(
        "onSheetTabColorChangeObservable"
      );
      const setTabColor = {
        sheetId: this._sheetId,
        actionName: SetTabColorAction.NAME,
        color
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setTabColor
      );
      _commandManager.invoke(command);
      observer.notifyObservers();
      return this;
    }
    /**
     * Hides this sheet. Has no effect if the sheet is already hidden. If this method is called on the only visible sheet, it throws an exception.
     * @returns Sheet  The current sheet.
     */
    hideSheet() {
      const { _context, _commandManager } = this;
      const _workbook = _context.getWorkBook();
      if (!this._config.hidden) {
        const observer = _context.getContextObserver("onHideSheetObservable");
        const setHiddenAction = {
          hidden: 1 /* TRUE */,
          sheetId: this._sheetId,
          actionName: SetWorkSheetHideAction.NAME
        };
        const command = new Command(
          {
            WorkBookUnit: _context.getWorkBook()
          },
          setHiddenAction
        );
        _commandManager.invoke(command);
        observer.notifyObservers({ sheet: this });
        const index = _workbook.getSheetIndex(this);
        if (index) {
          _workbook.activateSheetByIndex(index);
        }
      }
      return this;
    }
    /**
     *  Makes the sheet visible. Has no effect if the sheet is already visible.
     * @returns WorkSheet Instance
     */
    showSheet() {
      if (!this._config.hidden) {
        return this;
      }
      const { _context, _commandManager } = this;
      const setHidden = {
        hidden: 0 /* FALSE */,
        sheetId: this._sheetId,
        actionName: SetWorkSheetHideAction.NAME
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setHidden
      );
      _commandManager.invoke(command);
      _context.getContextObserver("onShowSheetObservable").notifyObservers({ sheet: this });
      return this;
    }
    /**
     * Sets commandManager
     * @param commandManager Command Manager
     * @returns commandManager
     */
    setCommandManager(commandManager) {
      this._commandManager = commandManager;
      return this;
    }
    setActiveSelection(...argument) {
      const range2 = argument[0];
      return range2 ? this._selection.setSelection({ selection: range2 }) : this._selection.setSelection();
    }
    /**
     * Returns the number of frozen rows.
     * @returns the number of frozen rows
     */
    getFrozenRows() {
      return this._config.freezeRow;
    }
    /**
     * Sets the width of the given column to fit its contents.
     * @param columnPosition
     */
    // todo  columnManageAPI
    // autoResizeColumn(columnPosition: number): WorkSheet {
    //     return this;
    // }
    /**
     * Returns the number of frozen columns.
     * @returns the number of frozen columns
     */
    getFrozenColumns() {
      return this._config.freezeColumn;
    }
    /**
     * Returns the current number of columns in the sheet, regardless of content.
     * @returns the current number of columns in the sheet, regardless of content
     */
    getMaxColumns() {
      const { _config } = this;
      const { columnCount } = _config;
      return columnCount;
    }
    /**
     * Returns the current number of rows in the sheet, regardless of content.
     * @returns the current number of rows in the sheet, regardless of content
     */
    getMaxRows() {
      const { _config } = this;
      const { rowCount } = _config;
      return rowCount;
    }
    /**
     * Returns the type of the sheet.
     * @returns the type of the sheet
     */
    getType() {
      const { _config } = this;
      const { type } = _config;
      return type;
    }
    /**
     * Clears the sheet of contents, while preserving formatting information.
     * @returns WorkSheet Instance
     */
    clearContents() {
      const { _config } = this;
      const { rowCount, columnCount } = _config;
      this.getRange({
        startRow: 0,
        endRow: rowCount,
        startColumn: 0,
        endColumn: columnCount
      }).clear({
        contentsOnly: true
      });
      return this;
    }
    /**
     * Clears the sheet of formatting, while preserving contents.
     * @returns WorkSheet Instance
     */
    clearFormats() {
      const { _config } = this;
      const { rowCount, columnCount } = _config;
      this.getRange({
        startRow: 0,
        endRow: rowCount,
        startColumn: 0,
        endColumn: columnCount
      }).clear({
        formatOnly: true
      });
      return this;
    }
    /**
     * Clears the sheet of all notes.
     * @returns WorkSheet Instance
     */
    clearNotes() {
      const { _config } = this;
      const { rowCount, columnCount } = _config;
      this.getRange({
        startRow: 0,
        endRow: rowCount,
        startColumn: 0,
        endColumn: columnCount
      }).clear({
        commentsOnly: true
      });
      return this;
    }
    /**
     * Deletes the column at the given column position.
     * @param columnPosition column index
     * @returns WorkSheet Instance
     */
    deleteColumn(columnPosition) {
      const { _context, _commandManager, _sheetId } = this;
      const deleteColumnData = {
        actionName: RemoveColumnDataAction.NAME,
        sheetId: _sheetId,
        columnCount: 1,
        columnIndex: columnPosition
      };
      const deleteColumn = {
        actionName: RemoveColumnAction.NAME,
        sheetId: _sheetId,
        columnCount: 1,
        columnIndex: columnPosition
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        deleteColumnData,
        deleteColumn
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Deletes a number of columns starting at the given column position.
     * @param columnPosition column index
     * @param howMany column count
     * @returns WorkSheet Instance
     */
    deleteColumns(columnPosition, howMany) {
      const { _context, _commandManager, _sheetId } = this;
      const deleteColumnData = {
        actionName: RemoveColumnDataAction.NAME,
        sheetId: _sheetId,
        columnCount: howMany,
        columnIndex: columnPosition
      };
      const deleteColumn = {
        actionName: RemoveColumnAction.NAME,
        sheetId: _sheetId,
        columnCount: howMany,
        columnIndex: columnPosition
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        deleteColumnData,
        deleteColumn
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Deletes the row at the given row position.
     * @param rowPosition row index
     * @returns WorkSheet Instance
     */
    deleteRow(rowPosition) {
      const { _context, _commandManager, _sheetId } = this;
      const dataRowDelete = {
        actionName: RemoveRowDataAction.NAME,
        sheetId: _sheetId,
        rowCount: 1,
        rowIndex: rowPosition
      };
      const rowDelete = {
        actionName: RemoveRowAction.NAME,
        sheetId: _sheetId,
        rowCount: 1,
        rowIndex: rowPosition
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        dataRowDelete,
        rowDelete
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Deletes a number of rows starting at the given row position.
     * @param rowPosition row index
     * @param howMany row count
     * @returns WorkSheet Instance
     */
    deleteRows(rowPosition, howMany) {
      const { _context, _commandManager, _sheetId } = this;
      const dataRowDelete = {
        actionName: RemoveRowDataAction.NAME,
        sheetId: _sheetId,
        rowCount: howMany,
        rowIndex: rowPosition
      };
      const rowDelete = {
        actionName: RemoveRowAction.NAME,
        sheetId: _sheetId,
        rowCount: howMany,
        rowIndex: rowPosition
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        dataRowDelete,
        rowDelete
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Returns Row Count
     * @returns Row Count
     */
    getRowCount() {
      return this._config.rowCount;
    }
    /**
     * Returns Column Count
     * @returns Column Count
     */
    getColumnCount() {
      return this._config.columnCount;
    }
    /**
     * Returns Border Styles
     * @returns Border Styles
     */
    // getBorderStyles(): BorderStyles {
    //     return this._borderStyles;
    // }
    /**
     * Sets the BorderStyles
     * @param rangeData
     * @param style
     * @param directions
     */
    setBorderStyle(rangeData, style, directions) {
      const { _commandManager, _sheetId } = this;
      const context = this.getContext();
      const matrix = this.getCellMatrix();
      const workbook = context.getWorkBook();
      const styles = workbook.getStyles();
      const tr = this.getRange({
        startRow: rangeData.startRow - 1,
        startColumn: rangeData.startColumn,
        endRow: rangeData.startRow - 1,
        endColumn: rangeData.endColumn
      });
      const lr = this.getRange({
        startRow: rangeData.startRow,
        startColumn: rangeData.startColumn - 1,
        endRow: rangeData.startRow,
        endColumn: rangeData.endColumn - 1
      });
      const br = this.getRange({
        startRow: rangeData.endRow + 1,
        startColumn: rangeData.startColumn,
        endRow: rangeData.endRow + 1,
        endColumn: rangeData.endColumn
      });
      const rr = this.getRange({
        startRow: rangeData.startRow,
        startColumn: rangeData.endColumn + 1,
        endRow: rangeData.startRow,
        endColumn: rangeData.endColumn + 1
      });
      const cc = this.getRange(rangeData);
      const mtr = new ObjectMatrix();
      const mlr = new ObjectMatrix();
      const mbr = new ObjectMatrix();
      const mrr = new ObjectMatrix();
      const mcr = new ObjectMatrix();
      tr.forEach((row, column) => {
        const cell = matrix.getValue(row, column);
        if (cell) {
          const cellStyle = styles.getStyleByCell(cell);
          if (cellStyle) {
            const copy = Tools.deepClone(cellStyle);
            if (copy.bd) {
              delete copy.bd.b;
            }
            mtr.setValue(row, column, copy);
          }
        }
      });
      br.forEach((row, column) => {
        const cell = matrix.getValue(row, column);
        if (cell) {
          const cellStyle = styles.getStyleByCell(cell);
          if (cellStyle) {
            const copy = Tools.deepClone(cellStyle);
            if (copy.bd) {
              delete copy.bd.t;
            }
            mbr.setValue(row, column, copy);
          }
        }
      });
      lr.forEach((row, column) => {
        const cell = matrix.getValue(row, column);
        if (cell) {
          const cellStyle = styles.getStyleByCell(cell);
          if (cellStyle) {
            const copy = Tools.deepClone(cellStyle);
            if (copy.bd) {
              delete copy.bd.r;
            }
            mlr.setValue(row, column, copy);
          }
        }
      });
      rr.forEach((row, column) => {
        const cell = matrix.getValue(row, column);
        if (cell) {
          const cellStyle = styles.getStyleByCell(cell);
          if (cellStyle) {
            const copy = Tools.deepClone(cellStyle);
            if (copy.bd) {
              delete copy.bd.l;
            }
            mrr.setValue(row, column, copy);
          }
        }
      });
      cc.forEach((row, column) => {
        mcr.setValue(row, column, style);
      });
      const actions = [];
      if (directions.includes(2 /* TOP */)) {
        const setBottomData = {
          sheetId: _sheetId,
          actionName: SetBorderAction.NAME,
          styles: mbr.toJSON()
        };
        actions.push(setBottomData);
      }
      if (directions.includes(3 /* BOTTOM */)) {
        const setTopData = {
          sheetId: _sheetId,
          actionName: SetBorderAction.NAME,
          styles: mtr.toJSON()
        };
        actions.push(setTopData);
      }
      if (directions.includes(0 /* LEFT */)) {
        const setRightData = {
          sheetId: _sheetId,
          actionName: SetBorderAction.NAME,
          styles: mrr.toJSON()
        };
        actions.push(setRightData);
      }
      if (directions.includes(1 /* RIGHT */)) {
        const setLeftData = {
          sheetId: _sheetId,
          actionName: SetBorderAction.NAME,
          styles: mlr.toJSON()
        };
        actions.push(setLeftData);
      }
      const setCCData = {
        sheetId: _sheetId,
        actionName: SetBorderAction.NAME,
        styles: mcr.toJSON()
      };
      actions.push(setCCData);
      const commandCC = new Command(
        {
          WorkBookUnit: workbook
        },
        ...actions
      );
      _commandManager.invoke(commandCC);
      return this;
    }
    /**
     * Sets the specified cell as the current cell.
     * @param cell cell range
     * @returns Range Instance
     */
    setCurrentCell(cell) {
      return cell.activateAsCurrentCell();
    }
    /**
     * Returns the active cell in this sheet.
     * @returns the active cell in this sheet
     */
    getActiveCell() {
      return this.getSelection().getCurrentCell();
    }
    /**
     * Returns the selected range in the active sheet
     * @returns the selected range in the active sheet
     */
    getActiveRange() {
      return this.getSelection().getActiveRange();
    }
    // /**
    //  * Returns Array OverGridImage
    //  * @returns Array OverGridImage
    //  */
    // getOverGridImages(): OverGridImage[] {
    //     return this._overGridImages;
    // }
    // /**
    //  * Returns all the bandings that are applied to any cells in this range.
    //  */
    // getBandings(): Array<Banding> {
    //     return this._bandings;
    // }
    // /**
    //  * get banding by range
    //  * @param range
    //  * @returns
    //  */
    // getBandingByRange(range: IRangeData): Nullable<Banding> {
    //     return this._bandings.find((banding: Banding, i) =>
    //         Tools.diffValue(banding.getRange().getRangeData(), range)
    //     );
    // }
    // /**
    //  * get banding by bandedRangeId
    //  * @param bandedRangeId
    //  * @returns
    //  */
    // getBandingById(bandedRangeId: string): Nullable<Banding> {
    //     return (
    //         this._bandings.find(
    //             (banding: Banding, i) =>
    //                 banding.getBandedRange().bandedRangeId === bandedRangeId
    //         ) || null
    //     );
    // }
    // /**
    //  * remove a banding in this sheet.
    //  * @param range
    //  */
    // removeBandingByRangeData(range: IRangeData): void {
    //     // remove from list
    //     const removedBanding = this._bandings.find((banding: Banding, i) => {
    //         if (Tools.diffValue(banding.getRange().getRangeData(), range)) {
    //             return banding;
    //         }
    //     });
    //     if (!removedBanding) {
    //         console.warn('Banding does not exist');
    //         return;
    //     }
    //     // remove from plugin meta
    //     removedBanding.remove();
    // }
    // /**
    //  * Applies a default column banding theme to the range. By default, the banding has header and no footer color.
    //  * @param range range to be set
    //  */
    // addBanding(range: IRangeType): Nullable<Banding>;
    // /**
    //  * Applies a specified column banding theme to the range. By default, the banding has header and no footer color.
    //  * @param range range to be set
    //  * @param bandingTheme A color theme to apply to the columns in the range,or custom color setting.
    //  */
    // addBanding(
    //     range: IRangeType,
    //     bandingTheme: BandingTheme | IBandingProperties
    // ): Nullable<Banding>;
    // /**
    //  * Applies a specified column banding theme to the range with specified header and footer settings.
    //  * @param range range to be set
    //  * @param bandingTheme A color theme to apply to the columns in the range,or custom color setting.
    //  * @param showHeader If true, the banding theme header color is applied to the first column.
    //  * @param showFooter If true, the banding theme footer color is applied to the last column.
    //  */
    // addBanding(
    //     range: IRangeType,
    //     bandingTheme: BandingTheme | IBandingProperties,
    //     showHeader: boolean,
    //     showFooter: boolean
    // ): Nullable<Banding>;
    // addBanding(...argument: any): Nullable<Banding> {
    //     const rangeData: IRangeType = argument[0],
    //         bandingTheme: BandingTheme = argument[1] || BandingTheme.LIGHT_GRAY,
    //         showHeader: boolean = argument[2] || true,
    //         showFooter: boolean = argument[3] || false;
    //     return this.getRange(rangeData).applyRowBanding(
    //         bandingTheme,
    //         showHeader,
    //         showFooter
    //     );
    // }
    /**
     * Returns the list of active ranges in the active sheet
     * @returns the list of active ranges in the active sheet
     */
    getActiveRangeList() {
      return this.getSelection().getActiveRangeList();
    }
    /**
     * Gets the position of the sheet in its parent spreadsheet. Starts at 1.
     * @returns Gets the position of the sheet in its parent spreadsheet. Starts at 1.
     */
    getIndex() {
      const worksheets = this._context.getWorkBook().getSheets();
      const index = worksheets.findIndex(
        (sheet) => sheet && sheet.getSheetId() === this._sheetId
      );
      if (index > -1)
        return index + 1;
      return null;
    }
    /**
     * Returns the Sheets that contains this sheet.
     * @returns the Sheets that contains this sheet.
     */
    getParent() {
      return this._context.getWorkBook();
    }
    /**
     * isSheetHidden
     * @returns hidden status of sheet
     */
    isSheetHidden() {
      return this._config.hidden;
    }
    /**
     * Sets the specified range as the active range in the active sheet, with the top left cell in the range as the current cell.
     * @param range active range types
     * @return Active Range
     */
    setActiveRange(range2) {
      return this.getSelection().setSelection(range2);
    }
    /**
     * Sets the specified list of ranges as the active ranges in the active sheet. The last range in the list is set as the active range.
     * @param rangeList active range types array
     * @return Active Range List
     */
    setActiveRangeList(rangeList) {
      const selection = this.getSelection();
      selection.setSelection(rangeList);
      return selection.getActiveRangeList();
    }
    /**
     * Hides the rows in the given range.
     * @param row row range
     * @returns WorkSheet Instance
     */
    hideRow(row) {
      const range2 = row.getRangeData();
      const index = range2.startRow;
      const count = range2.endRow - range2.startRow + 1;
      const { _context, _commandManager, _sheetId } = this;
      const hideRow = {
        actionName: SetRowHideAction.NAME,
        sheetId: _sheetId,
        rowCount: count,
        rowIndex: index
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        hideRow
      );
      _commandManager.invoke(command);
      return this;
    }
    hideRows(...argument) {
      const index = --argument[0];
      let count = 1;
      if (argument[1]) {
        count = argument[1];
      }
      const { _context, _commandManager, _sheetId } = this;
      const hideRow = {
        actionName: SetRowHideAction.NAME,
        sheetId: _sheetId,
        rowCount: count,
        rowIndex: index
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        hideRow
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Hides the columns in the given range.
     * @param column column range
     * @returns WorkSheet Instance
     */
    hideColumn(column) {
      const range2 = column.getRangeData();
      const index = range2.startColumn;
      const count = range2.endColumn - range2.startColumn + 1;
      const { _context, _commandManager, _sheetId } = this;
      const hideColumn = {
        actionName: SetColumnHideAction.NAME,
        sheetId: _sheetId,
        columnCount: count,
        columnIndex: index
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        hideColumn
      );
      _commandManager.invoke(command);
      return this;
    }
    hideColumns(...argument) {
      const index = argument[0];
      let count = 1;
      if (argument[1]) {
        count = argument[1];
      }
      const { _context, _commandManager, _sheetId } = this;
      const hideColumn = {
        actionName: SetColumnHideAction.NAME,
        sheetId: _sheetId,
        columnCount: count,
        columnIndex: index
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        hideColumn
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Unhides the row in the given range.
     * @param row row range
     * @return WorkSheet Instance
     */
    unhideRow(row) {
      const range2 = row.getRangeData();
      const index = range2.startRow;
      const count = range2.endRow - range2.startRow + 1;
      const { _context, _commandManager, _sheetId } = this;
      const unhideRow = {
        actionName: SetRowShowAction.NAME,
        rowCount: count,
        rowIndex: index,
        sheetId: _sheetId
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        unhideRow
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Unhides the column in the given range.
     * @param column column range
     * @return WorkSheet Instance
     */
    unhideColumn(column) {
      const range2 = column.getRangeData();
      const index = range2.startColumn;
      const count = range2.endColumn - range2.startColumn + 1;
      const { _context, _commandManager, _sheetId } = this;
      const unhideColumn = {
        actionName: SetColumnShowAction.NAME,
        sheetId: _sheetId,
        columnCount: count,
        columnIndex: index
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        unhideColumn
      );
      _commandManager.invoke(command);
      return this;
    }
    showColumns(...argument) {
      const index = argument[0];
      let count = 1;
      if (argument[1]) {
        count = argument[1];
      }
      const { _context, _commandManager, _sheetId } = this;
      const showColumn = {
        actionName: SetColumnShowAction.NAME,
        sheetId: _sheetId,
        columnCount: count,
        columnIndex: index
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        showColumn
      );
      _commandManager.invoke(command);
      return this;
    }
    showRows(...argument) {
      const index = --argument[0];
      let count = 1;
      if (argument[1]) {
        count = argument[1];
      }
      const { _context, _commandManager, _sheetId } = this;
      const showRow = {
        actionName: SetRowShowAction.NAME,
        sheetId: _sheetId,
        rowCount: count,
        rowIndex: index
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        showRow
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Returns true if the sheet's gridlines are hidden; otherwise returns false. Gridlines are visible by default.
     * @returns Gridlines Hidden Status
     */
    hasHiddenGridlines() {
      const { _config } = this;
      const { showGridlines } = _config;
      if (showGridlines === 0) {
        return true;
      }
      return false;
    }
    /**
     * Gets the sheet tab color, or null if the sheet tab has no color.
     * @returns the sheet tab color or null
     */
    getTabColor() {
      const { _config } = this;
      const { tabColor } = _config;
      return tabColor;
    }
    /**
     * Gets the width in pixels of the given column.
     * @param columnPosition column index
     * @returns Gets the width in pixels of the given column.
     */
    getColumnWidth(columnPosition) {
      return this.getColumnManager().getColumnWidth(columnPosition);
    }
    /**
     * Gets the height in pixels of the given row.
     * @param rowPosition row index
     * @returns Gets the height in pixels of the given row.
     */
    getRowHeight(rowPosition) {
      return this.getRowManager().getRowHeight(rowPosition);
    }
    setColumnWidth(...argument) {
      let columnIndex;
      let columnWidth = [];
      if (Tools.hasLength(argument, 2)) {
        columnIndex = argument[0];
        columnWidth = [argument[1]];
      }
      if (Tools.hasLength(argument, 3)) {
        columnIndex = argument[0];
        for (let i4 = 0; i4 < argument[1]; i4++) {
          columnWidth.push(argument[2]);
        }
      }
      this.getColumnManager().setColumnWidth(columnIndex, columnWidth);
      return this;
    }
    /**
     * Sets the height of the given rows in pixels.
     * @param startRow row index
     * @param numRows row count
     * @param height row height
     * @returns WorkSheet Instance
     */
    setRowHeights(startRow, numRows, height) {
      const rowHeight = [];
      for (let i4 = 0; i4 < numRows; i4++) {
        rowHeight.push(height);
      }
      this.getRowManager().setRowHeight(startRow, rowHeight);
      return this;
    }
    /**
     * Sets the row height of the given row in pixels.
     * @param rowPosition row index
     * @param height row height
     * @returns WorkSheet Instance
     */
    setRowHeight(rowPosition, height) {
      const rowHeight = [height];
      this.getRowManager().setRowHeight(rowPosition, rowHeight);
      return this;
    }
    /**
     * Hides or reveals the sheet gridlines.
     * @param hideGridlines hide gridlines status
     * @returns WorkSheet Instance
     */
    setHiddenGridlines(hideGridlines) {
      const { _context, _commandManager, _sheetId } = this;
      const configure = {
        actionName: SetHiddenGridlinesAction.NAME,
        hideGridlines,
        sheetId: _sheetId
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        configure
      );
      _commandManager.invoke(command);
      return this;
    }
    // /**
    //  * Freezes the given number of columns. If zero, no columns are frozen.
    //  * @param columns freeze columns, 0 - columns
    //  * @returns WorkSheet Instance
    //  */
    // setFrozenColumns(columns: number): WorkSheet {
    //     const frozen = new Freeze(this);
    //     return frozen.setFrozenColumns(columns);
    // }
    // /**
    //  * Freezes the given number of rows. If zero, no rows are frozen.
    //  * @param rows freeze rows, 0 - rows
    //  * @returns WorkSheet Instance
    //  */
    // setFrozenRows(rows: number): WorkSheet {
    //     const frozen = new Freeze(this);
    //     return frozen.setFrozenRows(rows);
    // }
    /**
     * Returns true if this sheet layout is right-to-left. Returns false if the sheet uses the default left-to-right layout.
     * @returns true if this sheet layout is right-to-left. Returns false if the sheet uses the default left-to-right layout.
     */
    isRightToLeft() {
      const { _config } = this;
      const { rightToLeft } = _config;
      return rightToLeft;
    }
    /**
     * Sets or unsets the sheet layout to right-to-left.
     * @param rightToLeft rightToLeft status
     * @returns WorkSheet Instance
     */
    setRightToLeft(rightToLeft) {
      const { _context, _commandManager, _sheetId } = this;
      const configure = {
        actionName: SetRightToLeftAction.NAME,
        rightToLeft,
        sheetId: _sheetId
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        configure
      );
      _commandManager.invoke(command);
      return this;
    }
    // /**
    //  *  Adds developer metadata with the specified key and value to the sheet.
    //  */
    // addDeveloperMetadata(key: string): WorkSheet;
    // addDeveloperMetadata(
    //     key: string,
    //     visibility: DeveloperMetadataVisibility
    // ): WorkSheet;
    // addDeveloperMetadata(key: string, value: string): WorkSheet;
    // addDeveloperMetadata(
    //     key: string,
    //     value: string,
    //     visibility: DeveloperMetadataVisibility
    // ): WorkSheet;
    // addDeveloperMetadata(...argument: any): WorkSheet {
    //     if (argument.length == 1) {
    //         this._config.metaData.push({
    //             metadataKey: argument[0],
    //         });
    //     } else if (argument.length == 2) {
    //         if (typeof argument[1] == 'string') {
    //             this._config.metaData.push({
    //                 metadataKey: argument[0],
    //                 metadataValue: argument[1],
    //             });
    //         } else {
    //             this._config.metaData.push({
    //                 metadataKey: argument[0],
    //                 visibility: argument[1],
    //             });
    //         }
    //     } else if (argument.length == 3) {
    //         this._config.metaData.push({
    //             metadataKey: argument[0],
    //             metadataValue: argument[1],
    //             visibility: argument[2],
    //         });
    //     }
    //     return this;
    // }
    // /**
    //  *  Get all developer metadata
    //  */
    // getDeveloperMetadata() {
    //     const { metaData } = this._config;
    //     return metaData;
    // }
    /**
     * @typeParam T - plugin data structure
     * @param name - plugin name
     * @returns information stored by the plugin
     */
    getPluginMeta(name) {
      return this._config.pluginMeta[name];
    }
    /**
     * @typeParam T - plugin data structure
     * @param name - plugin name
     * @param value - plugin value
     * @returns
     */
    setPluginMeta(name, value) {
      this._config.pluginMeta[name] = value;
    }
    /**
     * Copies the sheet to a given sheet,
     * @param sheetIndex sheet index
     * @returns WorkSheet Instance
     */
    copyTo(sheetIndex) {
      const worksheet = this._context.getWorkBook().getSheets()[sheetIndex];
      if (!worksheet)
        return this;
      const config = Tools.deepClone(this._config);
      config.sheetId = worksheet.getConfig().id;
      worksheet.setConfig(config);
      return worksheet;
    }
    /**
     * Returns the position of the last row that has content.
     * @returns the position of the last row that has content.
     */
    getLastRow() {
      return this._cellData.getLength();
    }
    /**
     * Returns the position of the last column that has content.
     * @returns the position of the last column that has content.
     */
    getLastColumn() {
      return this._cellData.getRange().endColumn;
    }
    /**
     * Returns the rectangular grid of values for this range starting at the given coordinates. A -1 value given as the row or column position is equivalent to getting the very last row or column that has data in the sheet.
     * @param startRow row start index
     * @param startColumn column start index
     * @param numRows row count
     * @param numColumns column count
     * @returns the rectangular grid of values for this range starting at the given coordinates. A -1 value given as the row or column position is equivalent to getting the very last row or column that has data in the sheet.
     */
    getSheetValues(startRow, startColumn, numRows, numColumns) {
      const range2 = new Range(this, {
        startRow,
        startColumn,
        endRow: startRow + numRows - 1,
        endColumn: startColumn + numColumns - 1
      });
      return range2.getValues();
    }
    /**
     * Returns a Range corresponding to the dimensions in which data is present.
     * @returns a Range corresponding to the dimensions in which data is present.
     */
    getDataRange() {
      const range2 = new Range(this, this._cellData.getRange());
      return range2;
    }
    /**
     * Moves the rows selected by the given range to the position indicated by the destinationIndex. The rowSpec itself does not have to exactly represent an entire row or group of rows to moveit selects all rows that the range spans.
     * @param rowSpec row range
     * @param destinationIndex row index
     * @returns WorkSheet Instance
     */
    moveRows(rowSpec, destinationIndex) {
      const { startRow } = rowSpec.getRangeData();
      const { endRow } = rowSpec.getRangeData();
      const data = this._cellData.spliceRows(startRow, endRow - startRow + 1);
      this._cellData.insertRows(destinationIndex, data);
      return this;
    }
    /**
     * Moves the columns selected by the given range to the position indicated by the destinationIndex. The columnSpec itself does not have to exactly represent an entire column or group of columns to moveit selects all columns that the range spans.
     * @param columnSpec column range
     * @param destinationIndex column index
     * @returns WorkSheet Instance
     */
    moveColumns(columnSpec, destinationIndex) {
      const startRow = columnSpec.getRangeData().startColumn;
      const endRow = columnSpec.getRangeData().endColumn;
      const data = this._cellData.spliceColumns(startRow, endRow - startRow + 1);
      this._cellData.insertColumns(destinationIndex, data);
      return this;
    }
    _initialize() {
      this._merges = new Merges(this, this._config.mergeData);
    }
    // /**
    //  *  Collapse All Row
    //  * @returns WorkSheet Instance
    //  */
    // collapseAllRowGroups(): WorkSheet {
    //     const { _context, _commandManager, _sheetId } = this;
    //     const collapseAllRowGroupsData: ISetCollapseAllRowGroupsData = {
    //         actionName: ACTION_NAMES.SET_COLLAPSE_ALL_ROW_GROUPS_ACTION,
    //         sheetId: _sheetId,
    //     };
    //     const command = new Command(
    //         _context.getWorkBook(),
    //         collapseAllRowGroupsData
    //     );
    //     _commandManager.invoke(command);
    //     return this;
    // }
    // /**
    //  * Collapse All Column
    //  * @returns WorkSheet Instance
    //  */
    // collapseAllColumnGroups(): WorkSheet {
    //     const { _context, _commandManager, _sheetId } = this;
    //     const collapseAllRowGroupsData: ISetCollapseAllColumnGroupsData = {
    //         actionName: ACTION_NAMES.SET_COLLAPSE_ALL_COLUMN_GROUPS_ACTION,
    //         sheetId: _sheetId,
    //     };
    //     const command = new Command(
    //         _context.getWorkBook(),
    //         collapseAllRowGroupsData
    //     );
    //     _commandManager.invoke(command);
    //     return this;
    // }
  };

  // ../../packages/core/src/Sheets/Domain/Range.ts
  var Range = class {
    _commandManager;
    _context;
    _rangeData;
    _worksheet;
    constructor(workSheet, range2) {
      this._context = workSheet.getContext();
      this._commandManager = this._context.getCommandManager();
      this._rangeData = this._context.getWorkBook().transformRangeType(range2).rangeData;
      this._worksheet = workSheet;
      if (Object.values(this._rangeData).includes(-1)) {
        console.error("Invalid range,default set index -1");
      }
    }
    static foreach(rangeData, action) {
      const { startRow, startColumn, endRow, endColumn } = rangeData;
      for (let i4 = startRow; i4 <= endRow; i4++) {
        for (let j3 = startColumn; j3 <= endColumn; j3++) {
          action(i4, j3);
        }
      }
    }
    /**
     * get current range data
     *
     * @returns current range
     */
    getRangeData() {
      return this._rangeData;
    }
    /**
     * Returns the value of the top-left cell in the range. The value may be of type Number, Boolean, Date, or String depending on the value of the cell. Empty cells return an empty string.
     * @returns  The value in this cell
     */
    getValue() {
      return this.getValues()[0][0];
    }
    /**
     * Returns the rectangular grid of values for this range.
     *
     * Returns a two-dimensional array of values, indexed by row, then by column. The values may be of type Number, Boolean, Date, or String, depending on the value of the cell. Empty cells are represented by an empty string in the array. Remember that while a range index starts at 0, 0, same as the JavaScript array is indexed from [0][0].
     *
     * In web apps, a Date value isn't a legal parameter. getValues() fails to return data to a web app if the range contains a cell with a Date value. Instead, transform all the values retrieved from the sheet to a supported JavaScript primitive like a Number, Boolean, or String.
     *
     * @returns  A two-dimensional array of values.
     */
    getValues() {
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const range2 = [];
      for (let r4 = startRow; r4 <= endRow; r4++) {
        const row = [];
        for (let c4 = startColumn; c4 <= endColumn; c4++) {
          row.push(this.getMatrix().getValue(r4, c4) || null);
        }
        range2.push(row);
      }
      return range2;
    }
    /**
     * get range matrix
     *
     * @returns range matrix
     */
    getMatrix() {
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const sheetMatrix = this._worksheet.getCellMatrix();
      const rangeMatrix = new ObjectMatrix();
      for (let r4 = startRow; r4 <= endRow; r4++) {
        for (let c4 = startColumn; c4 <= endColumn; c4++) {
          rangeMatrix.setValue(r4, c4, sheetMatrix.getValue(r4, c4) || null);
        }
      }
      return rangeMatrix;
    }
    /**
     * get range matrix object
     *
     * @returns range matrix object
     */
    getMatrixObject() {
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const sheetMatrix = this._worksheet.getCellMatrix();
      const rangeMatrix = new ObjectMatrix();
      for (let r4 = startRow; r4 <= endRow; r4++) {
        for (let c4 = startColumn; c4 <= endColumn; c4++) {
          rangeMatrix.setValue(
            r4 - startRow,
            c4 - startColumn,
            sheetMatrix.getValue(r4, c4) || {}
          );
        }
      }
      return rangeMatrix;
    }
    /**
     * Returns the displayed value of the top-left cell in the range. The value is a String. The displayed value takes into account date, time and currency formatting formatting, including formats applied automatically by the spreadsheet's Locale setting. Empty cells return an empty string.
     *
     * @returns  The displayed value in this cell.
     */
    getDisplayValue() {
      const value = this.getValue();
      if (value && value.p) {
        return value.p;
      }
      if (value && value.m) {
        return value.m;
      }
      return "";
    }
    /**
     * Returns the rectangular grid of values for this range.
     *
     * Returns a two-dimensional array of displayed values, indexed by row, then by column. The values are String objects. The displayed value takes into account date, time and currency formatting, including formats applied automatically by the spreadsheet's Locale setting. Empty cells are represented by an empty string in the array. Remember that while a range index starts at 0, 0, same as the JavaScript array is indexed from [0][0].
     *
     * @returns   A two-dimensional array of values.
     */
    getDisplayValues() {
      return this.getValues().map(
        (row) => row.map((value) => {
          if (value && value.p) {
            return value.p;
          }
          if (value && value.m) {
            return value.m;
          }
          return "";
        })
      );
    }
    /**
     * Returns a string description of the range, in A1 notation.
     *
     * @returns The string description of the range in A1 notation.
     */
    getA1Notation() {
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      let start;
      let end;
      if (startColumn < endColumn) {
        start = Tools.numToWord(startColumn + 1) + (startRow + 1);
        end = Tools.numToWord(endColumn + 1) + (endRow + 1);
      } else {
        start = Tools.numToWord(endColumn + 1) + (endRow + 1);
        end = Tools.numToWord(startColumn + 1) + (startRow + 1);
      }
      if (start === end)
        return `${start}`;
      return `${start}:${end}`;
    }
    /**
     * Returns the background color of the top-left cell in the range (for example, '#ffffff').
     *
     * @returns  The color code of the background.
     */
    getBackground() {
      return this.getBackgrounds()[0][0];
    }
    /**
     * Returns the background colors of the cells in the range (for example, '#ffffff').
     *
     * @returns   A two-dimensional array of color codes of the backgrounds.
     */
    getBackgrounds() {
      return this.getValues().map(
        (row) => row.map((cell) => {
          const styles = this._context.getWorkBook().getStyles();
          let rgbColor = DEFAULT_STYLES.bg?.rgb;
          rgbColor = styles.getStyleByCell(cell)?.bg?.rgb;
          return rgbColor;
        })
      );
    }
    /**
     * Returns a given cell within a range.
     *
     * The row and column here are relative to the range
     * e.g. "B2:D4", getCell(0,0) in this code returns the cell at B2
     * @returns   A range containing a single cell at the specified coordinates.
     */
    getCell(row, column) {
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const cell = {
        startRow: startRow + row,
        endRow: startRow + row,
        startColumn: startColumn + column,
        endColumn: startColumn + column
      };
      return new Range(this._worksheet, cell);
    }
    /**
     * Returns the starting column position for this range
     *
     * @returns   The range's starting column position in the spreadsheet.
     */
    getColumn() {
      return this._rangeData.startColumn;
    }
    /**
     * Returns the data of the object structure, and can set whether to bring styles
     */
    getObjectValue(options = {}) {
      return this.getObjectValues(options)[0][0];
    }
    /**
     * Returns the data of the object structure, and can set whether to bring styles
     *
     * @param options set whether to include style
     * @returns Returns a value in object format
     */
    getObjectValues(options = {}) {
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const values = this._worksheet.getCellMatrix().getFragments(startRow, endRow, startColumn, endColumn).getData();
      if (options.isIncludeStyle) {
        const style = this._context.getWorkBook().getStyles();
        for (let r4 = 0; r4 <= endRow - startRow; r4++) {
          for (let c4 = 0; c4 <= endColumn - startColumn; c4++) {
            if (!values[r4][c4])
              continue;
            const s4 = values[r4][c4].s;
            if (s4) {
              values[r4][c4].s = style.get(s4);
            }
          }
        }
      }
      return values;
    }
    /**
     * Notify other Components
     * TODO: 
     */
    // notifyUpdated() {
    //     this._context.onAfterChangeRangeDataObservable.notifyObservers(
    //         this._worksheet
    //     );
    // }
    /**
     * Returns the font color of the cell in the top-left corner of the range, in CSS notation
     */
    getFontColor() {
      return this.getFontColors()[0][0];
    }
    /**
     * Returns the font colors of the cells in the range in CSS notation (such as '#ffffff' or 'white').
     */
    getFontColors() {
      return this.getValues().map(
        (row) => row.map((cell) => {
          const styles = this._context.getWorkBook().getStyles();
          const cellStyle = styles.getStyleByCell(cell);
          return cellStyle?.cl?.rgb || DEFAULT_STYLES.cl?.rgb;
        })
      );
    }
    /**
     * Returns the font families of the cells in the range.
     */
    getFontFamilies() {
      return this._getStyles("ff");
    }
    /**
     * 	Returns the font family of the cell in the top-left corner of the range.
     */
    getFontFamily() {
      return this.getFontFamilies()[0][0];
    }
    /**
     * Returns the underlines of the cells in the range.
     */
    getUnderlines() {
      return this._getStyles("ul");
    }
    /**
     * Returns the underline of the cells in the range.
     */
    getUnderline() {
      return this.getUnderlines()[0][0];
    }
    /**
     * Returns the overlines of the cells in the range.
     */
    getOverlines() {
      return this._getStyles("ol");
    }
    /**
     * Returns the overline of the cells in the range.
     */
    getOverline() {
      return this.getOverlines()[0][0];
    }
    /**
     * Returns the strikeThroughs of the cells in the range.
     */
    getStrikeThroughs() {
      return this._getStyles("st");
    }
    /**
     * Returns the strikeThrough of the cells in the range.
     */
    getStrikeThrough() {
      return this.getStrikeThroughs()[0][0];
    }
    /**
     * Returns the font size in point size of the cell in the top-left corner of the range.
     */
    getFontSize() {
      return this.getFontSizes()[0][0];
    }
    /**
     * Returns the font sizes of the cells in the range.
     */
    getFontSizes() {
      return this._getStyles("fs");
    }
    /**
     * Returns the border info of the cells in the range.
     */
    getBorder() {
      return this.getBorders()[0][0];
    }
    getBorders() {
      return this._getStyles("bd");
    }
    /**
     * Returns the font style ('italic' or 'normal') of the cell in the top-left corner of the range.
     */
    getFontStyle() {
      return this.getFontStyles()[0][0];
    }
    /**
     * Returns the font styles of the cells in the range.
     */
    getFontStyles() {
      return this._getStyles("it");
    }
    /**
     * Returns the font weight (normal/bold) of the cell in the top-left corner of the range.
     */
    getFontWeight() {
      return this.getFontWeights()[0][0];
    }
    /**
     * Returns the font weights of the cells in the range.
     */
    getFontWeights() {
      return this._getStyles("bl");
    }
    /**
     * Returns the formula (A1 notation) for the top-left cell of the range, or an empty string if the cell is empty or doesn't contain a formula.
     */
    // getFormula(): string {
    //     return this.getFormulas()[0][0];
    // }
    /**
     * Returns the formulas (A1 notation) for the cells in the range.
     */
    // getFormulas(): string[][] {
    //     return this.getValues().map((row) =>
    //         row.map((cell: Nullable<ICellData>) => cell?.f || '')
    //     );
    // }
    /**
     * Returns the grid ID of the range's parent sheet.
     */
    getGridId() {
      return this._worksheet.getSheetId();
    }
    /**
     * Returns the height of the range.
     */
    getHeight() {
      const { _rangeData, _worksheet } = this;
      const { startRow, endRow } = _rangeData;
      let h4 = 0;
      for (let i4 = 0; i4 <= endRow - startRow; i4++) {
        const hh = _worksheet.getRowHeight(i4);
        h4 += hh;
      }
      return h4;
    }
    /**
     * 	Returns the horizontal alignment of the text (left/center/right) of the cell in the top-left corner of the range.
     */
    getHorizontalAlignment() {
      return this.getHorizontalAlignments()[0][0];
    }
    /**
     *Returns the horizontal alignments of the cells in the range.
     */
    getHorizontalAlignments() {
      return this._getStyles("ht");
    }
    /**
     * Returns the end column position.
     */
    getLastColumn() {
      return this._rangeData.endColumn;
    }
    /**
     * 	Returns the end row position.
     */
    getLastRow() {
      return this._rangeData.endRow;
    }
    /**
     * Returns an array of Range objects representing merged cells that either are fully within the current range, or contain at least one cell in the current range.
     */
    getMergedRanges() {
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      return this._worksheet.getMerges().getMergedRanges({ startRow, endRow, startColumn, endColumn }).map((rangeData) => new Range(this._worksheet, rangeData));
    }
    /**
     * Starting at the cell in the first column and row of the range, returns the next cell in the given direction that is the edge of a contiguous range of cells with data in them or the cell at the edge of the spreadsheet in that direction.
     * @param direction
     * @returns The data region edge cell or the cell at the edge of the spreadsheet.
     */
    getNextDataCell(direction) {
      const { _worksheet } = this;
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const maxRow = _worksheet.getMaxRows();
      const maxColumn = _worksheet.getMaxColumns();
      if (direction === 3 /* BOTTOM */) {
        for (let i4 = 0; i4 < maxRow - startColumn; i4++) {
          const value = this._worksheet.getCellMatrix().getValue(startRow + i4, startColumn);
          if (value)
            _worksheet.getRange(
              startRow + i4,
              startColumn,
              startRow + i4,
              startColumn
            );
        }
        return _worksheet.getRange(maxRow, startColumn, maxRow, startColumn);
      }
      if (direction === 2 /* TOP */) {
        for (let i4 = 0; i4 < startRow; i4++) {
          const value = this._worksheet.getCellMatrix().getValue(startRow - i4, startColumn);
          if (value)
            _worksheet.getRange(
              startRow - i4,
              startColumn,
              startRow - i4,
              startRow
            );
        }
        return _worksheet.getRange(0, startColumn, 0, startColumn);
      }
      if (direction === 1 /* RIGHT */) {
        for (let i4 = 0; i4 < maxColumn - startColumn; i4++) {
          const value = this._worksheet.getCellMatrix().getValue(startRow, startColumn + i4);
          if (value)
            _worksheet.getRange(
              startRow,
              startColumn + i4,
              startRow,
              startColumn + i4
            );
        }
        return _worksheet.getRange(startRow, maxColumn, startRow, maxColumn);
      }
      if (direction === 0 /* LEFT */) {
        for (let i4 = 0; i4 < maxRow - startColumn; i4++) {
          const value = this._worksheet.getCellMatrix().getValue(startRow, startColumn - i4);
          if (value)
            _worksheet.getRange(
              startRow,
              startColumn - i4,
              startRow,
              startColumn - i4
            );
        }
        return _worksheet.getRange(startRow, 0, startRow, 0);
      }
      return _worksheet.getRange(DEFAULT_RANGE);
    }
    /**
     * 	Returns the note associated with the given range.
     */
    // getNote(): string {
    //     return this.getNotes()[0][0];
    // }
    /**
     * 	Returns the notes associated with the cells in the range.
     */
    // getNotes(): string[][] {
    //     return this.getValues().map((row) =>
    //         row.map((cell: Nullable<ICellData>) => cell?.n || '')
    //     );
    // }
    /**
     * Returns the number of columns in this range.
     */
    getNumColumns() {
      const { startColumn, endColumn } = this._rangeData;
      return endColumn - startColumn + 1;
    }
    /**
     * Returns the number of rows in this range.
     */
    getNumRows() {
      const { startRow, endRow } = this._rangeData;
      return endRow - startRow + 1;
    }
    /**
     * Get the number or date formatting of the top-left cell of the given range.
     */
    // getNumberFormat(): string {
    //     return this.getNumberFormats()[0][0];
    // }
    /**
     * Returns the number or date formats for the cells in the range.
     */
    // getNumberFormats(): string[][] {
    //     return this.getValues().map((row) =>
    //         row.map((cell: Nullable<ICellData>) => cell?.fm?.f || '')
    //     );
    // }
    /**
     * Returns the Rich Text value for the top left cell of the range, or null if the cell value is not text.
     */
    getRichTextValue() {
      return this.getRichTextValues()[0][0];
    }
    /**
     * Returns the Rich Text values for the cells in the range.
     */
    getRichTextValues() {
      return this.getValues().map(
        (row) => row.map((cell) => cell?.p || "")
      );
    }
    /**
     * Returns the row position for this range.
     */
    getRowIndex() {
      return this._rangeData.startRow;
    }
    /**
     * Returns the sheet this range belongs to.
     */
    getSheet() {
      return this._worksheet;
    }
    /**
     * Returns the text direction for the top left cell of the range.
     */
    getTextDirection() {
      return this.getTextDirections()[0][0];
    }
    /**
     * Returns the text directions for the cells in the range.
     */
    getTextDirections() {
      return this._getStyles("td");
    }
    /**
     * Returns the text rotation settings for the top left cell of the range.
     */
    // getTextRotation(): number {
    getTextRotation() {
      return this.getTextRotations()[0][0];
    }
    /**
     * Returns the text rotation settings for the cells in the range.
     */
    // getTextRotations(): number[][] {
    getTextRotations() {
      return this._getStyles("tr");
    }
    /**
     * 	Returns the text style for the top left cell of the range.
     */
    getTextStyle() {
      return this.getTextStyles()[0][0];
    }
    /**
     * Returns the text styles for the cells in the range.
     */
    getTextStyles() {
      return this.getValues().map(
        (row) => row.map((cell) => {
          const styles = this._context.getWorkBook().getStyles();
          return styles.getStyleByCell(cell);
        })
      );
    }
    /**
     * Returns the vertical alignment (top/middle/bottom) of the cell in the top-left corner of the range.
     */
    getVerticalAlignment() {
      return this.getVerticalAlignments()[0][0];
    }
    /**
     * Returns the vertical alignments of the cells in the range.
     */
    getVerticalAlignments() {
      return this._getStyles("vt");
    }
    /**
     * Returns the width of the range in columns.
     */
    getWidth() {
      const { _rangeData, _worksheet } = this;
      const { startColumn, endColumn } = _rangeData;
      let w4 = 0;
      for (let i4 = 0; i4 <= endColumn - startColumn; i4++) {
        w4 += _worksheet.getColumnWidth(i4);
      }
      return w4;
    }
    /**
     * Returns whether the text in the cell wraps.
     */
    getWrap() {
      return this.getWraps()[0][0];
    }
    /**
     * Returns whether the text in the cells wrap.
     */
    getWraps() {
      return this._getStyles("tb");
    }
    /**
     * Returns the text wrapping strategies for the cells in the range.
     */
    getWrapStrategies() {
      return this._getStyles("tb");
    }
    /**
     * Returns the text wrapping strategy for the top left cell of the range.
     */
    getWrapStrategy() {
      return this.getWrapStrategies()[0][0];
    }
    /**
     * Returns true if the range is totally blank.
     */
    isBlank() {
      const data = this.getValues();
      return data.some((items) => items.some((item) => item?.m === ""));
    }
    // isChecked() {}
    // isEndColumnBounded() {}
    // isEndRowBounded() {}
    /**
     * Returns true if the cells in the current range overlap any merged cells.
     */
    isPartOfMerge() {
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const data = this._worksheet.getMerges().getByRowColumn(startRow, endRow, startColumn, endColumn);
      if (data) {
        return true;
      }
      return false;
    }
    /**
     * Sets the background color of all cells in the range in CSS notation (such as '#ffffff' or 'white').
     *
     * @param color Sets the background color of all cells in the range in CSS notation (such as '#ffffff' or 'white').
     * @returns This range, for chaining.
     */
    setBackground(color) {
      const { _context, _worksheet, _commandManager } = this;
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const colorObj = {
        bg: {
          rgb: color
        }
      };
      const stylesMatrix = Tools.fillObjectMatrix(
        endRow - startRow + 1,
        endColumn - startColumn + 1,
        colorObj
      );
      const setStyle = {
        sheetId: _worksheet.getSheetId(),
        actionName: "SetRangeStyleAction" /* SET_RANGE_STYLE_ACTION */,
        value: stylesMatrix,
        rangeData: this._rangeData
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setStyle
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Sets a rectangular grid of background colors (must match dimensions of this range). The colors are in CSS notation (such as '#ffffff' or 'white').
     *
     * @param color A two-dimensional array of colors in CSS notation (such as '#ffffff' or 'white'); null values reset the color.
     * @returns This range, for chaining.
     */
    setBackgrounds(color) {
      const { _context, _worksheet, _commandManager } = this;
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const matrix = new ObjectMatrix();
      for (let r4 = 0; r4 < endRow - startRow + 1; r4++) {
        for (let c4 = 0; c4 < endColumn - startColumn + 1; c4++) {
          matrix.setValue(r4, c4, {
            bg: {
              rgb: color[r4][c4]
            }
          });
        }
      }
      const setStyle = {
        sheetId: _worksheet.getSheetId(),
        actionName: "SetRangeStyleAction" /* SET_RANGE_STYLE_ACTION */,
        value: matrix.getData(),
        rangeData: this._rangeData
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setStyle
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Sets the background to the given color using RGB values (integers between 0 and 255 inclusive).
     *
     * @param red  	The red value in RGB notation.
     * @param green  The green value in RGB notation.
     * @param blue  The blue value in RGB notation.
     * @returns This range, for chaining.
     */
    setBackgroundRGB(red, green, blue) {
      const { _context, _worksheet, _commandManager } = this;
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const rgbString = `RGB(${red},${green},${blue})`;
      const colorObj = {
        bg: {
          rgb: rgbString
        }
      };
      const stylesMatrix = Tools.fillObjectMatrix(
        endRow - startRow + 1,
        endColumn - startColumn + 1,
        colorObj
      );
      const setStyle = {
        sheetId: _worksheet.getSheetId(),
        actionName: "SetRangeStyleAction" /* SET_RANGE_STYLE_ACTION */,
        value: stylesMatrix,
        rangeData: this._rangeData
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setStyle
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Sets a rectangular grid of font colors (must match dimensions of this range). The colors are in CSS notation (such as '#ffffff' or 'white').
     *
     * @param colors  A two-dimensional array of colors in CSS notation (such as '#ffffff' or 'white'); null values reset the color.
     * @returns This range, for chaining.
     */
    setFontColors(colors) {
      const { _context, _worksheet, _commandManager } = this;
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const matrix = new ObjectMatrix();
      for (let r4 = 0; r4 < endRow - startRow + 1; r4++) {
        for (let c4 = 0; c4 < endColumn - startColumn + 1; c4++) {
          matrix.setValue(r4, c4, { cl: { rgb: colors[r4][c4] } });
        }
      }
      const setStyle = {
        sheetId: _worksheet.getSheetId(),
        actionName: "SetRangeStyleAction" /* SET_RANGE_STYLE_ACTION */,
        value: matrix.getData(),
        rangeData: this._rangeData
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setStyle
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Sets a rectangular grid of font families (must match dimensions of this range). Examples of font families are "Arial" or "Helvetica".
     *
     * @param fontFamilies  A two-dimensional array of font families; null values reset the font family.
     * @returns This range, for chaining.
     */
    setFontFamilies(fontFamilies) {
      this._setStyles(fontFamilies, "ff");
      return this;
    }
    /**
     * Sets the font line style of the given range
     *
     * @param fontLine  The font line style; a null value resets the font line style
     * @returns This range, for chaining.
     */
    setUnderline(fontLine) {
      this._setStyle(fontLine, "ul");
      return this;
    }
    /**
     * Sets the font line style of the given range
     *
     * @param fontLine  The font line style; a null value resets the font line style
     * @returns This range, for chaining.
     */
    setOverline(fontLine) {
      this._setStyle(fontLine, "ol");
      return this;
    }
    /**
     * Sets a rectangular grid of line styles (must match dimensions of this range).
     *
     * @param fontLine  The font line style; a null value resets the font line style
     * @returns This range, for chaining.
     */
    setStrikeThrough(fontLine) {
      this._setStyle(fontLine, "st");
      return this;
    }
    /**
     * Sets the font line style of the given range
     *
     * @param fontLines  A two-dimensional array of font line styles ; null values reset the font line style.
     * @returns This range, for chaining.
     */
    setUnderlines(fontLines) {
      this._setStyles(fontLines, "ul");
      return this;
    }
    /**
     * Sets the font line style of the given range
     *
     * @param fontLines  A two-dimensional array of font line styles ; null values reset the font line style.
     * @returns This range, for chaining.
     */
    setOverlines(fontLines) {
      this._setStyles(fontLines, "ol");
      return this;
    }
    /**
     * Sets the font line style of the given range
     *
     * @param fontLines  A two-dimensional array of font line styles ; null values reset the font line style.
     * @returns This range, for chaining.
     */
    setStrikeThroughs(fontLines) {
      this._setStyles(fontLines, "st");
      return this;
    }
    /**
     * Sets a rectangular grid of font sizes (must match dimensions of this range).
     *
     * @param sizes  A two-dimensional array of sizes.
     * @returns This range, for chaining.
     */
    setFontSizes(sizes) {
      this._setStyles(sizes, "fs");
      return this;
    }
    /**
     * Set the font style for the given range ('italic' or 'normal').
     *
     * @param fontStyle  The font style, either 'italic' or 'normal'; a null value resets the font style.
     * @returns This range, for chaining.
     */
    setFontStyle(fontStyle) {
      this._setStyle(fontStyle, "it");
      return this;
    }
    /**
     * Sets a rectangular grid of font styles (must match dimensions of this range).
     *
     * @param fontStyles A two-dimensional array of font styles, either 'italic' or 'normal'; null values reset the font style.
     * @returns This range, for chaining.
     */
    setFontStyles(fontStyles) {
      this._setStyles(fontStyles, "it");
      return this;
    }
    /**
     * Set the font weight for the given range (normal/bold).
     *
     * @param fontWeight   The font weight, either 'bold' or 'normal'; a null value resets the font weight.
     * @returns This range, for chaining.
     */
    setFontWeight(fontWeight) {
      this._setStyle(fontWeight, "bl");
      return this;
    }
    /**
     * Sets a rectangular grid of font weights (must match dimensions of this range).
     *
     * @param fontWeights  A two-dimensional array of font weights, either 'bold' or 'normal'; null values reset the font weight.
     * @returns This range, for chaining.
     */
    setFontWeights(fontWeights) {
      this._setStyles(fontWeights, "bl");
      return this;
    }
    /**
     * Updates the formula for this range.
     *
     * @param formula A string representing the formula to set for the cell.
     * @returns This range, for chaining.
     */
    setFormula(formula) {
      const { _rangeData, _context, _commandManager, _worksheet } = this;
      const { startRow, startColumn, endRow, endColumn } = _rangeData;
      const cellValue = new ObjectMatrix();
      for (let r4 = startRow; r4 <= endRow; r4++) {
        for (let c4 = startColumn; c4 <= endColumn; c4++) {
          cellValue.setValue(r4, c4, formula);
        }
      }
      const setValue = {
        sheetId: _worksheet.getSheetId(),
        actionName: "SetRangeFormulaAction" /* SET_RANGE_FORMULA_ACTION */,
        cellFormula: cellValue.getData(),
        rangeData: this._rangeData
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setValue
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Sets a rectangular grid of formulas (must match dimensions of this range).
     *
     * @param formulas A two-dimensional string array of formulas.
     * @returns This range, for chaining.
     */
    setFormulas(formulas) {
      const { _rangeData, _context, _commandManager, _worksheet } = this;
      const { startRow, startColumn, endRow, endColumn } = _rangeData;
      const cellValue = new ObjectMatrix();
      for (let r4 = 0; r4 <= endRow - startRow; r4++) {
        for (let c4 = 0; c4 <= endColumn - startColumn; c4++) {
          cellValue.setValue(r4 + startRow, c4 + startColumn, formulas[r4][c4]);
        }
      }
      const setValue = {
        sheetId: _worksheet.getSheetId(),
        actionName: "SetRangeFormulaAction" /* SET_RANGE_FORMULA_ACTION */,
        cellFormula: cellValue.getData(),
        rangeData: this._rangeData
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setValue
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Sets a rectangular grid of horizontal alignments.
     *
     * @param alignments  A two-dimensional array of alignments, either 'left', 'center' or 'normal'; a null value resets the alignment.
     * @returns This range, for chaining.
     */
    setHorizontalAlignments(alignments) {
      this._setStyles(alignments, "ht");
      return this;
    }
    /**
     * Sets the note to the given value.
     *
     * @param note The note value to set for the range; a null value removes the note.
     * @returns This range, for chaining.
     */
    // setNote(note: string): Range {
    //     const { _rangeData, _context, _commandManager, _worksheet } = this;
    //     const { startRow, startColumn, endRow, endColumn } = _rangeData;
    //     const cellValue = new ObjectMatrix<string>();
    //     for (let r = startRow; r <= endRow; r++) {
    //         for (let c = startColumn; c <= endColumn; c++) {
    //             cellValue.setValue(r, c, note);
    //         }
    //     }
    //     const setValue: ISetRangeNoteActionData = {
    //         sheetId: _worksheet.getSheetId(),
    //         actionName: ACTION_NAMES.SET_RANGE_NOTE_ACTION,
    //         cellNote: cellValue.getData(),
    //         rangeData: this._rangeData,
    //     };
    //     const command = new Command(_context.getWorkBook(), setValue);
    //     _commandManager.invoke(command);
    //     return this;
    // }
    /**
     * Sets the note to the given value.
     *
     * @param notes A two-dimensional array of notes; null values remove the note.
     * @returns This range, for chaining.
     */
    // setNotes(notes: string[][]): Range {
    //     const { _rangeData, _context, _commandManager, _worksheet } = this;
    //     const { startRow, startColumn, endRow, endColumn } = _rangeData;
    //     const cellValue = new ObjectMatrix<string>();
    //     for (let r = 0; r <= endRow - startRow; r++) {
    //         for (let c = 0; c <= endColumn - startColumn; c++) {
    //             cellValue.setValue(r + startRow, c + startColumn, notes[r][c]);
    //         }
    //     }
    //     const setValue: ISetRangeNoteActionData = {
    //         sheetId: _worksheet.getSheetId(),
    //         actionName: ACTION_NAMES.SET_RANGE_NOTE_ACTION,
    //         cellNote: cellValue.getData(),
    //         rangeData: this._rangeData,
    //     };
    //     const command = new Command(_context.getWorkBook(), setValue);
    //     _commandManager.invoke(command);
    //     return this;
    // }
    /**
     * Sets the number or date format to the given formatting string.
     *
     * @param numberFormat 	A number format string.
     * @returns This range, for chaining.
     */
    // setNumberFormat(numberFormat: string): Range {
    //     const { _rangeData, _context, _commandManager, _worksheet } = this;
    //     const { startRow, startColumn, endRow, endColumn } = _rangeData;
    //     const cellValue = new ObjectMatrix<string>();
    //     for (let r = 0; r <= endRow - startRow; r++) {
    //         for (let c = 0; c <= endColumn - startColumn; c++) {
    //             const fm = {
    //                 f: numberFormat,
    //                 t: FormatType.NUMBER,
    //             };
    //             cellValue.setValue(r + startRow, c + startColumn, JSON.stringify(fm));
    //         }
    //     }
    //     const setValue: ISetRangeFormatActionData = {
    //         sheetId: _worksheet.getSheetId(),
    //         actionName: ACTION_NAMES.SET_RANGE_FORMAT_ACTION,
    //         cellFormat: cellValue.getData(),
    //         rangeData: this._rangeData,
    //     };
    //     const command = new Command(_context.getWorkBook(), setValue);
    //     _commandManager.invoke(command);
    //     return this;
    // }
    /**
     * Sets a rectangular grid of number or date formats (must match dimensions of this range).
     *
     * @param numberFormats A two-dimensional array of number formats.
     * @returns This range, for chaining.
     */
    // setNumberFormats(numberFormats: string[][]): Range {
    //     const { _rangeData, _context, _commandManager, _worksheet } = this;
    //     const { startRow, startColumn, endRow, endColumn } = _rangeData;
    //     const cellValue = new ObjectMatrix<string>();
    //     for (let r = 0; r <= endRow - startRow; r++) {
    //         for (let c = 0; c <= endColumn - startColumn; c++) {
    //             const fm = {
    //                 f: numberFormats[r][c],
    //                 t: FormatType.NUMBER,
    //             };
    //             cellValue.setValue(r + startRow, c + startColumn, JSON.stringify(fm));
    //         }
    //     }
    //     const setValue: ISetRangeFormatActionData = {
    //         sheetId: _worksheet.getSheetId(),
    //         actionName: ACTION_NAMES.SET_RANGE_FORMAT_ACTION,
    //         cellFormat: cellValue.getData(),
    //         rangeData: this._rangeData,
    //     };
    //     const command = new Command(_context.getWorkBook(), setValue);
    //     _commandManager.invoke(command);
    //     return this;
    // }
    // setRichTextValue(value) {}
    // setRichTextValues(values) {}
    // setShowHyperlink(showHyperlink) {}
    /**
     * Sets a rectangular grid of text directions.
     *
     * @param directions The desired text directions; if a specified direction is null it is inferred before setting.
     * @returns This range, for chaining.
     */
    setTextDirections(directions) {
      this._setStyles(directions, "td");
      return this;
    }
    /**
     * Sets the text rotation settings for the cells in the range.
     *
     * @param degrees The desired angle between the standard orientation and the desired orientation. For left to right text, positive angles are in the counterclockwise direction.
     * @returns This range, for chaining.
     */
    setTextRotation(degrees) {
      const { _context, _worksheet, _commandManager } = this;
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const styleObj = {
        tr: {
          v: 0,
          a: Number(degrees)
        }
      };
      const stylesMatrix = Tools.fillObjectMatrix(
        endRow - startRow + 1,
        endColumn - startColumn + 1,
        styleObj
      );
      const setStyle = {
        sheetId: _worksheet.getSheetId(),
        actionName: "SetRangeStyleAction" /* SET_RANGE_STYLE_ACTION */,
        value: stylesMatrix,
        rangeData: this._rangeData
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setStyle
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Sets a rectangular grid of text rotations.
     *
     * @param rotations The desired text rotation settings.
     * @returns This range, for chaining.
     */
    setTextRotations(rotations) {
      const { _context, _worksheet, _commandManager } = this;
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const matrix = new ObjectMatrix();
      for (let r4 = 0; r4 < endRow - startRow + 1; r4++) {
        for (let c4 = 0; c4 < endColumn - startColumn + 1; c4++) {
          matrix.setValue(r4, c4, {
            tr: {
              v: 0,
              a: rotations[r4][c4]
            }
          });
        }
      }
      const a4 = matrix.getData();
      const setStyle = {
        sheetId: _worksheet.getSheetId(),
        actionName: "SetRangeStyleAction" /* SET_RANGE_STYLE_ACTION */,
        value: matrix.getData(),
        rangeData: this._rangeData
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setStyle
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Sets the text style for the cells in the range.
     *
     * @param style The desired text style.
     * @returns This range, for chaining.
     */
    setTextStyle(style) {
      const { _context, _worksheet, _commandManager } = this;
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const stylesObj = { ...style };
      const stylesMatrix = Tools.fillObjectMatrix(
        endRow - startRow + 1,
        endColumn - startColumn + 1,
        stylesObj
      );
      const setStyle = {
        sheetId: _worksheet.getSheetId(),
        actionName: "SetRangeStyleAction" /* SET_RANGE_STYLE_ACTION */,
        value: stylesMatrix,
        rangeData: this._rangeData
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setStyle
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Sets a rectangular grid of text styles.
     *
     * @param styles The desired text styles.
     * @returns This range, for chaining.
     */
    setTextStyles(styles) {
      const { _context, _worksheet, _commandManager } = this;
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const matrix = new ObjectMatrix();
      for (let r4 = 0; r4 < endRow - startRow + 1; r4++) {
        for (let c4 = 0; c4 < endColumn - startColumn + 1; c4++) {
          matrix.setValue(r4, c4, { ...styles[r4][c4] });
        }
      }
      const setStyle = {
        sheetId: _worksheet.getSheetId(),
        actionName: "SetRangeStyleAction" /* SET_RANGE_STYLE_ACTION */,
        value: matrix.getData(),
        rangeData: this._rangeData
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setStyle
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Sets a rectangular grid of vertical alignments (must match dimensions of this range).
     *
     * @param alignments A two-dimensional array of alignments, either 'top', 'middle' or 'bottom'; a null value resets the alignment.
     * @returns This range, for chaining.
     */
    setVerticalAlignments(alignments) {
      this._setStyles(alignments, "vt");
      return this;
    }
    /**
     * 	Sets whether or not to stack the text for the cells in the range.
     * @param isVertical Whether or not to stack the text.
     * @returns
     */
    setVerticalText(isVertical) {
      const { _context, _worksheet, _commandManager } = this;
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const styleObj = {
        tr: {
          v: isVertical,
          a: 90
        }
      };
      const stylesMatrix = Tools.fillObjectMatrix(
        endRow - startRow + 1,
        endColumn - startColumn + 1,
        styleObj
      );
      const setStyle = {
        sheetId: _worksheet.getSheetId(),
        actionName: "SetRangeStyleAction" /* SET_RANGE_STYLE_ACTION */,
        value: stylesMatrix,
        rangeData: this._rangeData
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setStyle
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Set the cell wrap of the given range
     *
     * @param isWrapEnabled Whether to wrap text or not.
     * @returns This range, for chaining.
     */
    setWrap(isWrapEnabled) {
      this._setStyle(isWrapEnabled, "tb");
      return this;
    }
    /**
     * 	Sets a rectangular grid of wrap strategies.
     *
     * @param strategies The desired wrapping strategies.
     * @returns This range, for chaining.
     */
    setWrapStrategies(strategies) {
      this._setStyles(strategies, "tb");
      return this;
    }
    /**
     * 	Sets a rectangular grid of word wrap policies (must match dimensions of this range).
     *
     * @param isWrapEnabled A two-dimensional array of wrap variables that determine whether to wrap text in a cell or not.
     * @returns This range, for chaining.
     */
    setWraps(isWrapEnabled) {
      this._setStyles(isWrapEnabled, "tb");
      return this;
    }
    /**
     * Fills the destinationRange with data based on the data in this range. The new values are also determined by the specified series type. The destination range must contain this range and extend it in only one direction. For example, the following fills A1:A20 with a series of increasing numbers based on the current values in A1:A4:
     *
     * @param destination The range to be auto-filled with values. The destination range should contain this range and extend it in only one direction (upwards, downwards, left, or right).
     * @param series The type of autoFill series that should be used to calculate new values. The effect of this series differs based on the type and amount of source data.
     * @returns This range, for chaining.
     */
    autoFill(destination, series) {
      const { _worksheet, _context, _commandManager } = this;
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const {
        startRow: Dsr,
        endRow: Der,
        startColumn: Dsc,
        endColumn: Dec
      } = destination._rangeData;
      let direction = 3 /* BOTTOM */;
      let csLen = 0;
      let asLen = 0;
      const copy_str_r = startRow;
      const copy_end_r = endRow;
      const copy_str_c = startColumn;
      const copy_end_c = endColumn;
      const apply_str_r = Dsr;
      const apply_end_r = Der;
      const apply_str_c = Dsc;
      const apply_end_c = Dec;
      const matrix = new ObjectMatrix();
      if (apply_str_c === copy_str_c && apply_end_c === copy_end_c) {
        if (apply_end_r > copy_end_r) {
          direction = 3 /* BOTTOM */;
        } else {
          direction = 2 /* TOP */;
        }
      } else if (apply_end_c > copy_end_c) {
        direction = 1 /* RIGHT */;
      } else {
        direction = 0 /* LEFT */;
      }
      if (direction === 3 /* BOTTOM */ || direction === 2 /* TOP */) {
        csLen = copy_end_r - copy_str_r + 1;
        asLen = apply_end_r - apply_str_r + 1;
        for (let i4 = 0; i4 <= endColumn - startColumn; i4++) {
          const sourceRange = this.getColumnMatrix(i4).toArray();
          const copydata = DropCell.getCopyData(
            sourceRange,
            copy_str_r,
            copy_end_r,
            copy_str_c,
            copy_end_c,
            direction
          );
          copydata.forEach((item) => {
            const data = DropCell.getApplyData(
              item,
              csLen,
              asLen,
              series,
              direction
            );
            data.forEach((dataItem, j3) => {
              matrix.setValue(j3, i4, dataItem);
            });
          });
        }
      } else if (direction === 1 /* RIGHT */ || direction === 0 /* LEFT */) {
        asLen = apply_end_c - apply_str_c;
        csLen = copy_end_c - copy_str_c;
        for (let i4 = 0; i4 <= endRow - startRow; i4++) {
          const sourceRange = this.getRowMatrix(i4).toArray();
          const copydata = DropCell.getCopyData(
            sourceRange,
            copy_str_r,
            copy_end_r,
            copy_str_c,
            copy_end_c,
            direction
          );
          copydata.forEach((item) => {
            const data = DropCell.getApplyData(
              item,
              csLen,
              asLen,
              series,
              direction
            );
          });
        }
      }
      const setValue = {
        sheetId: _worksheet.getSheetId(),
        actionName: "SetRangeDataAction" /* SET_RANGE_DATA_ACTION */,
        cellValue: matrix.getData()
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setValue
      );
      _commandManager.invoke(command);
      return this;
    }
    getDataRegion(...argument) {
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      let numRows;
      let numColumns;
      const data = this._worksheet.getCellMatrix();
      if (Tools.isNumber(argument[0])) {
        const dimension = argument[0];
        if (dimension === 0 /* COLUMNS */) {
          let start = startRow;
          let end = startRow;
          const rowMax = this._worksheet.getRowCount();
          for (let i4 = 1; i4 < startRow; i4++) {
            const element = data.getValue(startRow - i4, startColumn);
            if (!element) {
              start = startRow - i4 + 1;
              break;
            }
          }
          const j3 = 0;
          while (j3 < rowMax - startRow) {
            const element = data.getValue(startRow + j3, startColumn);
            if (!element) {
              end = startRow - j3 - 1;
              break;
            }
          }
          numColumns = start - end;
          numRows = 0;
          return this._worksheet.getRange(
            startRow,
            start,
            numRows,
            numColumns
          );
        }
        if (dimension === 1 /* ROWS */) {
          let start = startRow;
          let end = startRow;
          const colMax = this._worksheet.getColumnCount();
          for (let i4 = 1; i4 < startRow; i4++) {
            const element = data.getValue(startRow, startColumn - i4);
            if (!element) {
              start = startRow - i4 + 1;
              break;
            }
          }
          const j3 = 0;
          while (j3 < colMax - startColumn) {
            const element = data.getValue(startRow, startColumn + j3);
            if (!element) {
              end = startRow - j3 - 1;
              break;
            }
          }
          numColumns = 0;
          numRows = start - end;
          return this._worksheet.getRange(
            start,
            startColumn,
            numRows,
            numColumns
          );
        }
      } else {
        let rowStart = startRow;
        let rowEnd = startRow;
        const rowMax = this._worksheet.getRowCount();
        for (let i4 = 1; i4 < startRow; i4++) {
          const element = data.getValue(startRow - i4, startColumn);
          if (!element) {
            rowStart = startRow - i4 + 1;
            break;
          }
        }
        const rj = 0;
        while (rj < rowMax - startRow) {
          const element = data.getValue(startRow + rj, startColumn);
          if (!element) {
            rowEnd = startRow - rj - 1;
            break;
          }
        }
        let columnStart = startRow;
        let columnEnd = startRow;
        const colMax = this._worksheet.getColumnCount();
        for (let i4 = 1; i4 < startRow; i4++) {
          const element = data.getValue(startRow, startColumn - i4);
          if (!element) {
            columnStart = startRow - i4 + 1;
            break;
          }
        }
        const cj = 0;
        while (cj < colMax - startColumn) {
          const element = data.getValue(startRow, startColumn + cj);
          if (!element) {
            columnEnd = startRow - cj - 1;
            break;
          }
        }
        numColumns = columnStart - columnEnd;
        numColumns = rowStart - rowEnd;
        numRows = startRow;
        return this._worksheet.getRange(
          rowStart,
          columnStart,
          numRows,
          numColumns
        );
      }
      return this;
    }
    /**
     * Trims the whitespace (such as spaces, tabs, or new lines) in every cell in this range. Removes all whitespace from the start and end of each cell's text, and reduces any subsequence of remaining whitespace characters to a single space.
     *
     * @returns This range, for chaining.
     */
    trimWhitespace() {
      const { _context, _worksheet, _commandManager } = this;
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const sheetMatrix = this._worksheet.getCellMatrix();
      const regx = /\s+/g;
      const cellValue = new ObjectMatrix();
      for (let r4 = 0; r4 <= endRow - startRow; r4++) {
        for (let c4 = 0; c4 <= endColumn - startColumn; c4++) {
          const value = sheetMatrix.getValue(r4, c4).m?.replace(regx, "");
          cellValue.setValue(r4 + startRow, c4 + startColumn, value || "");
        }
      }
      const setValue = {
        sheetId: _worksheet.getSheetId(),
        actionName: "SetRangeFormattedValueAction" /* SET_RANGE_FORMATTED_VALUE_ACTION */,
        cellValue: cellValue.getData(),
        rangeData: this._rangeData
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setValue
      );
      _commandManager.invoke(command);
      return this;
    }
    // uncheck
    /**
     * Sets the specified range as the active range, with the top left cell in the range as the current cell.
     *
     * @returns This range, for chaining.
     * @internal
     */
    activate() {
      if (this._rangeData?.startRow === -1) {
        console.error("Invalid range,default set startRow -1");
        return this;
      }
      this._worksheet.getSelection().setSelection({ selection: this });
      return this;
    }
    /**
     * Sets the specified cell as the current cell.
     *
     * If the specified cell is present in an existing range, then that range becomes the active range with the cell as the current cell.
     *
     * If the specified cell is not present in any existing range, then the existing selection is removed and the cell becomes the current cell and the active range.
     *
     * Note: The specified Range must consist of one cell, otherwise it throws an exception.
     *
     * @returns This range, for chaining.
     */
    activateAsCurrentCell() {
      this._worksheet.getSelection().setCurrentCell(this);
      return this;
    }
    /**
     * Whether the current range and the incoming range have an intersection
     *
     * @param range the incoming range
     * @returns Intersect or not
     */
    isIntersection(range2) {
      const currentStartRow = this._rangeData.startRow;
      const currentEndRow = this._rangeData.endRow;
      const currentStartColumn = this._rangeData.startColumn;
      const currentEndColumn = this._rangeData.endColumn;
      const incomingStartRow = range2.getRangeData().startRow;
      const incomingEndRow = range2.getRangeData().endRow;
      const incomingStartColumn = range2.getRangeData().startColumn;
      const incomingEndColumn = range2.getRangeData().endColumn;
      const zx = Math.abs(
        currentStartColumn + currentEndColumn - incomingStartColumn - incomingEndColumn
      );
      const x4 = Math.abs(currentStartColumn - currentEndColumn) + Math.abs(incomingStartColumn - incomingEndColumn);
      const zy = Math.abs(
        currentStartRow + currentEndRow - incomingStartRow - incomingEndRow
      );
      const y4 = Math.abs(currentStartRow - currentEndRow) + Math.abs(incomingStartRow - incomingEndRow);
      if (zx <= x4 && zy <= y4) {
        return true;
      }
      return false;
    }
    /**
     * Sets the font color in CSS notation (such as '#ffffff' or 'white').
     *
     * @param color The font color in CSS notation (such as '#ffffff' or 'white'); a null value resets the color.
     * @returns
     */
    setFontColor(color) {
      const { _context, _worksheet, _commandManager } = this;
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const colorObj = {
        cl: {
          rgb: color
        }
      };
      const stylesMatrix = Tools.fillObjectMatrix(
        endRow - startRow + 1,
        endColumn - startColumn + 1,
        colorObj
      );
      const setStyle = {
        sheetId: _worksheet.getSheetId(),
        actionName: "SetRangeStyleAction" /* SET_RANGE_STYLE_ACTION */,
        value: stylesMatrix,
        rangeData: this._rangeData
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setStyle
      );
      _commandManager.invoke(command);
      return this;
    }
    copyTo(...argument) {
      const { _context, _worksheet, _commandManager } = this;
      const destination = argument[0];
      const [value, range2] = this._handleCopyRange(this, destination);
      const { startRow, startColumn, endRow, endColumn } = range2;
      if (Tuples.checkup(argument, Range, Tuples.BOOLEAN_TYPE)) {
        const copyPasteType = argument[1];
        const transposed = argument[2];
        if (copyPasteType === 0 /* PASTE_NORMAL */) {
          const cellValue = new ObjectMatrix();
          value.forEach(
            (row, r4) => row.forEach((cell, c4) => {
              cell = cell;
              cellValue.setValue(
                r4 + startRow,
                c4 + startColumn,
                cell || {}
              );
            })
          );
          const setValue = {
            sheetId: _worksheet.getSheetId(),
            actionName: "SetRangeDataAction" /* SET_RANGE_DATA_ACTION */,
            cellValue: cellValue.getData()
          };
          const command = new Command(
            {
              WorkBookUnit: _context.getWorkBook()
            },
            setValue
          );
          _commandManager.invoke(command);
        } else if (copyPasteType === 2 /* PASTE_FORMAT */) {
          const styles = _context.getWorkBook().getStyles();
          const stylesMatrix = new ObjectMatrix();
          const stylesArray = value.map(
            (row, r4) => row.forEach((cell, c4) => {
              cell = cell;
              stylesMatrix.setValue(
                r4,
                c4,
                styles.getStyleByCell(cell) || {}
              );
            })
          );
          const setStyle = {
            sheetId: _worksheet.getSheetId(),
            actionName: "SetRangeStyleAction" /* SET_RANGE_STYLE_ACTION */,
            value: stylesMatrix.getData(),
            rangeData: range2
          };
          const command = new Command(
            {
              WorkBookUnit: _context.getWorkBook()
            },
            setStyle
          );
          _commandManager.invoke(command);
        } else if (copyPasteType === 5 /* PASTE_VALUES */) {
          const cellValue = new ObjectMatrix();
          value.forEach(
            (row, r4) => row.forEach((cell, c4) => {
              cell = cell;
              cellValue.setValue(
                r4 + startRow,
                c4 + startColumn,
                cell?.v || ""
              );
            })
          );
          const setValue = {
            sheetId: _worksheet.getSheetId(),
            actionName: "SetRangeFormattedValueAction" /* SET_RANGE_FORMATTED_VALUE_ACTION */,
            cellValue: cellValue.getData(),
            rangeData: range2
          };
          const command = new Command(
            {
              WorkBookUnit: _context.getWorkBook()
            },
            setValue
          );
          _commandManager.invoke(command);
        } else if (copyPasteType === 7 /* PASTE_COLUMN_WIDTHS */) {
          const rangeStartColumn = this._rangeData.startColumn;
          for (let i4 = 0; i4 < endColumn - rangeStartColumn; i4++) {
            const width = _worksheet.getColumnWidth(rangeStartColumn + i4);
            _worksheet.setColumnWidth(rangeStartColumn + i4, width);
          }
        }
      } else if (Tuples.checkup(argument, Range, Tuples.OBJECT_TYPE)) {
        const options = argument[1];
        const cellValue = new ObjectMatrix();
        value.forEach(
          (row, r4) => row.forEach((cell, c4) => {
            cell = cell;
            cellValue.setValue(r4 + startRow, c4 + startColumn, cell || {});
          })
        );
        const setValue = {
          sheetId: _worksheet.getSheetId(),
          actionName: "SetRangeDataAction" /* SET_RANGE_DATA_ACTION */,
          cellValue: cellValue.getData(),
          options
        };
        const command = new Command(
          {
            WorkBookUnit: _context.getWorkBook()
          },
          setValue
        );
        _commandManager.invoke(command);
      } else if (Tuples.checkup(argument, Range)) {
        const cellValue = new ObjectMatrix();
        value.forEach(
          (row, r4) => row.forEach((cell, c4) => {
            cell = cell;
            cellValue.setValue(r4 + startRow, c4 + startColumn, cell || {});
          })
        );
        const setValue = {
          sheetId: _worksheet.getSheetId(),
          actionName: "SetRangeDataAction" /* SET_RANGE_DATA_ACTION */,
          cellValue: cellValue.getData()
        };
        const command = new Command(
          {
            WorkBookUnit: _context.getWorkBook()
          },
          setValue
        );
        _commandManager.invoke(command);
      }
    }
    copyFormatToRange(...argument) {
      const { _context, _commandManager } = this;
      const startRow = argument[1];
      const endRow = argument[2];
      const startColumn = argument[3];
      const endColumn = argument[4];
      const sheetId = Tools.isAssignableFrom(argument[0], Worksheet) ? argument[0].getSheetId() : argument[0];
      const [value, range2] = this._handleCopyRange(this, {
        startRow,
        endRow,
        startColumn,
        endColumn
      });
      const styles = _context.getWorkBook().getStyles();
      const stylesMatrix = new ObjectMatrix();
      value.map(
        (row, r4) => row.map((cell, c4) => {
          cell = cell;
          stylesMatrix.setValue(r4, c4, styles.getStyleByCell(cell) || {});
          return styles.getStyleByCell(cell) || {};
        })
      );
      const setStyle = {
        sheetId,
        actionName: "SetRangeStyleAction" /* SET_RANGE_STYLE_ACTION */,
        value: stylesMatrix.getData(),
        rangeData: range2
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setStyle
      );
      _commandManager.invoke(command);
    }
    copyValuesToRange(...argument) {
      const { _context, _commandManager } = this;
      const startRow = argument[1];
      const endRow = argument[2];
      const startColumn = argument[3];
      const endColumn = argument[4];
      const sheetId = Tools.isAssignableFrom(argument[0], Worksheet) ? argument[0].getSheetId() : argument[0];
      const [value, range2] = this._handleCopyRange(this, {
        startRow,
        endRow,
        startColumn,
        endColumn
      });
      const cellValue = new ObjectMatrix();
      value.forEach(
        (row, r4) => row.forEach((cell, c4) => {
          cell = cell;
          cellValue.setValue(
            r4 + range2.startRow,
            c4 + range2.startColumn,
            cell?.v || ""
          );
        })
      );
      const setValue = {
        sheetId,
        actionName: "SetRangeFormattedValueAction" /* SET_RANGE_FORMATTED_VALUE_ACTION */,
        cellValue: cellValue.getData(),
        rangeData: range2
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setValue
      );
      _commandManager.invoke(command);
    }
    /**
     * Cut and paste (both format and values) from this range to the target range.
     * @param target A target range to copy this range to; only the top-left cell position is relevant.
     * @returns
     */
    moveTo(target) {
      const { _context, _worksheet, _commandManager, _rangeData } = this;
      const options = {
        formatOnly: true,
        contentsOnly: true,
        commentsOnly: true,
        validationsOnly: true,
        skipFilteredRows: true
      };
      const clearValue = {
        sheetId: _worksheet.getSheetId(),
        actionName: "ClearRangeAction" /* CLEAR_RANGE_ACTION */,
        options,
        rangeData: _rangeData
      };
      const currentMatrix = this.getMatrix();
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const { startRow: targetStartRow, startColumn: targetStartColumn } = target.getRangeData();
      const targetMatrix = new ObjectMatrix();
      for (let r4 = startRow; r4 <= endRow; r4++) {
        for (let c4 = startColumn; c4 <= endColumn; c4++) {
          targetMatrix.setValue(
            targetStartRow + (r4 - startRow),
            targetStartColumn + (c4 - startColumn),
            currentMatrix.getValue(r4, c4) || {}
          );
        }
      }
      const setValue = {
        sheetId: _worksheet.getSheetId(),
        actionName: "SetRangeDataAction" /* SET_RANGE_DATA_ACTION */,
        cellValue: targetMatrix.getData()
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        clearValue,
        setValue
      );
      _commandManager.invoke(command);
    }
    offset(...argument) {
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const rowOffset = argument[0];
      const columnOffset = argument[1];
      const numRows = argument[2];
      const numColumns = argument[3];
      const offset = {
        startRow: startRow + rowOffset,
        endRow: endRow + rowOffset,
        startColumn: startColumn + columnOffset,
        endColumn: endColumn + columnOffset
      };
      if (Tools.isNumber(numRows)) {
        offset.endRow = offset.startRow + numRows - 1;
      }
      if (Tools.isNumber(numColumns)) {
        offset.endColumn = offset.endColumn + numColumns - 1;
      }
      return new Range(this._worksheet, offset);
    }
    setBorder(...argument) {
      const top = argument[0];
      const left = argument[1];
      const bottom = argument[2];
      const right = argument[3];
      const vertical = argument[4];
      const horizontal = argument[5];
      const color = argument[6] ? argument[6] : "black";
      const style = argument[7] ? argument[7] : 5 /* DASH_DOT */;
      const { _context, _worksheet, _commandManager } = this;
      const _workbook = _context.getWorkBook();
      const rangeData = this._rangeData;
      const _sheetId = _worksheet.getSheetId();
      const topRangeOut = {
        startRow: rangeData.startRow - 1,
        startColumn: rangeData.startColumn,
        endRow: rangeData.startRow - 1,
        endColumn: rangeData.endColumn
      };
      const leftRangeOut = {
        startRow: rangeData.startRow,
        startColumn: rangeData.startColumn - 1,
        endRow: rangeData.endRow,
        endColumn: rangeData.startColumn - 1
      };
      const bottomRangeOut = {
        startRow: rangeData.endRow + 1,
        startColumn: rangeData.startColumn,
        endRow: rangeData.endRow + 1,
        endColumn: rangeData.endColumn
      };
      const rightRangeOut = {
        startRow: rangeData.startRow,
        startColumn: rangeData.endColumn + 1,
        endRow: rangeData.endRow,
        endColumn: rangeData.endColumn + 1
      };
      const topRange = {
        startRow: rangeData.startRow,
        startColumn: rangeData.startColumn,
        endRow: rangeData.startRow,
        endColumn: rangeData.endColumn
      };
      const leftRange = {
        startRow: rangeData.startRow,
        startColumn: rangeData.startColumn,
        endRow: rangeData.endRow,
        endColumn: rangeData.startColumn
      };
      const bottomRange = {
        startRow: rangeData.endRow,
        startColumn: rangeData.startColumn,
        endRow: rangeData.endRow,
        endColumn: rangeData.endColumn
      };
      const rightRange = {
        startRow: rangeData.startRow,
        startColumn: rangeData.endColumn,
        endRow: rangeData.endRow,
        endColumn: rangeData.endColumn
      };
      const tr = new Range(_worksheet, topRangeOut);
      const lr = new Range(_worksheet, leftRangeOut);
      const br = new Range(_worksheet, bottomRangeOut);
      const rr = new Range(_worksheet, rightRangeOut);
      const t4 = new Range(_worksheet, topRange);
      const l4 = new Range(_worksheet, leftRange);
      const b4 = new Range(_worksheet, bottomRange);
      const r4 = new Range(_worksheet, rightRange);
      const mtr = new ObjectMatrix();
      const mlr = new ObjectMatrix();
      const mbr = new ObjectMatrix();
      const mrr = new ObjectMatrix();
      const mcr = new ObjectMatrix();
      const actions = [];
      const border2 = {
        s: style,
        cl: {
          rgb: color
        }
      };
      if (top === true || top === false) {
        if (tr.isValid()) {
          tr.forEach((row, column) => {
            mtr.setValue(row, column, { bd: { b: null } });
          });
          const setBottomData = {
            sheetId: _sheetId,
            actionName: "SetRangeStyleAction" /* SET_RANGE_STYLE_ACTION */,
            value: mtr.getArrayData(),
            rangeData: topRangeOut
          };
          actions.push(setBottomData);
        }
        t4.forEach((row, column) => {
          if (top === true) {
            const style2 = Tools.deepMerge(mcr.getValue(row, column) || {}, {
              bd: { t: Tools.deepClone(border2) }
            });
            mcr.setValue(row, column, style2);
          } else if (top === false) {
            const style2 = Tools.deepMerge(mcr.getValue(row, column) || {}, {
              bd: { t: null }
            });
            mcr.setValue(row, column, style2);
          }
        });
      }
      if (bottom === true || bottom === false) {
        if (br.isValid()) {
          br.forEach((row, column) => {
            mbr.setValue(row, column, { bd: { t: null } });
          });
          const setTopData = {
            sheetId: _sheetId,
            actionName: "SetRangeStyleAction" /* SET_RANGE_STYLE_ACTION */,
            value: mbr.getArrayData(),
            rangeData: bottomRangeOut
          };
          actions.push(setTopData);
        }
        b4.forEach((row, column) => {
          if (bottom === true) {
            const style2 = Tools.deepMerge(mcr.getValue(row, column) || {}, {
              bd: { b: Tools.deepClone(border2) }
            });
            mcr.setValue(row, column, style2);
          } else if (bottom === false) {
            const style2 = Tools.deepMerge(mcr.getValue(row, column) || {}, {
              bd: { b: null }
            });
            mcr.setValue(row, column, style2);
          }
        });
      }
      if (left === true || left === false) {
        if (lr.isValid()) {
          lr.forEach((row, column) => {
            mlr.setValue(row, column, { bd: { r: null } });
          });
          const setRightData = {
            sheetId: _sheetId,
            actionName: "SetRangeStyleAction" /* SET_RANGE_STYLE_ACTION */,
            value: mlr.getArrayData(),
            rangeData: leftRangeOut
          };
          actions.push(setRightData);
        }
        l4.forEach((row, column) => {
          if (left === true) {
            const style2 = Tools.deepMerge(mcr.getValue(row, column) || {}, {
              bd: { l: Tools.deepClone(border2) }
            });
            mcr.setValue(row, column, style2);
          } else if (left === false) {
            const style2 = Tools.deepMerge(mcr.getValue(row, column) || {}, {
              bd: { l: null }
            });
            mcr.setValue(row, column, style2);
          }
        });
      }
      if (right === true || right === false) {
        if (rr.isValid()) {
          rr.forEach((row, column) => {
            mrr.setValue(row, column, { bd: { l: null } });
          });
          const setLeftData = {
            sheetId: _sheetId,
            actionName: "SetRangeStyleAction" /* SET_RANGE_STYLE_ACTION */,
            value: mrr.getArrayData(),
            rangeData: rightRangeOut
          };
          actions.push(setLeftData);
        }
        r4.forEach((row, column) => {
          if (right === true) {
            const style2 = Tools.deepMerge(mcr.getValue(row, column) || {}, {
              bd: { r: Tools.deepClone(border2) }
            });
            mcr.setValue(row, column, style2);
          } else if (right === false) {
            const style2 = Tools.deepMerge(mcr.getValue(row, column) || {}, {
              bd: { r: null }
            });
            mcr.setValue(row, column, style2);
          }
        });
      }
      if (vertical === true || vertical === false) {
        this.forEach((row, column) => {
          if (column !== rangeData.endColumn) {
            if (vertical === true) {
              const style2 = Tools.deepMerge(
                mcr.getValue(row, column) || {},
                {
                  bd: { r: Tools.deepClone(border2) }
                }
              );
              mcr.setValue(row, column, style2);
            } else if (vertical === false) {
              const style2 = Tools.deepMerge(
                mcr.getValue(row, column) || {},
                {
                  bd: { r: null }
                }
              );
              mcr.setValue(row, column, style2);
            }
          }
          if (column !== rangeData.startColumn) {
            const style2 = Tools.deepMerge(mcr.getValue(row, column) || {}, {
              bd: { l: null }
            });
            mcr.setValue(row, column, style2);
          }
        });
      }
      if (horizontal === true || horizontal === false) {
        this.forEach((row, column) => {
          if (row !== rangeData.endRow) {
            if (horizontal === true) {
              const style2 = Tools.deepMerge(
                mcr.getValue(row, column) || {},
                {
                  bd: { b: Tools.deepClone(border2) }
                }
              );
              mcr.setValue(row, column, style2);
            } else if (horizontal === false) {
              const style2 = Tools.deepMerge(
                mcr.getValue(row, column) || {},
                {
                  bd: { b: null }
                }
              );
              mcr.setValue(row, column, style2);
            }
          }
          if (row !== rangeData.startRow) {
            const style2 = Tools.deepMerge(mcr.getValue(row, column) || {}, {
              bd: { t: null }
            });
            mcr.setValue(row, column, style2);
          }
        });
      }
      const setCCData = {
        sheetId: _sheetId,
        actionName: "SetRangeStyleAction" /* SET_RANGE_STYLE_ACTION */,
        value: mcr.getArrayData(),
        rangeData: mcr.getDataRange()
      };
      actions.push(setCCData);
      const commandCC = new Command(
        {
          WorkBookUnit: _workbook
        },
        ...actions
      );
      _commandManager.invoke(commandCC);
      return this;
    }
    /**
     * Set Border by tool bar
     * @param type border type
     * @param color color
     * @param style size
     */
    setBorderByType(type, color, style) {
      let top = null;
      let left = null;
      let bottom = null;
      let right = null;
      let vertical = null;
      let horizontal = null;
      switch (type) {
        case "top" /* TOP */:
          top = true;
          break;
        case "bottom" /* BOTTOM */:
          bottom = true;
          break;
        case "left" /* LEFT */:
          left = true;
          break;
        case "right" /* RIGHT */:
          right = true;
          break;
        case "none" /* NONE */:
          top = false;
          left = false;
          bottom = false;
          right = false;
          vertical = false;
          horizontal = false;
          break;
        case "all" /* ALL */:
          top = true;
          left = true;
          bottom = true;
          right = true;
          vertical = true;
          horizontal = true;
          break;
        case "outside" /* OUTSIDE */:
          top = true;
          left = true;
          bottom = true;
          right = true;
          break;
        case "inside" /* INSIDE */:
          vertical = true;
          horizontal = true;
          break;
        case "horizontal" /* HORIZONTAL */:
          horizontal = true;
          break;
        case "vertical" /* VERTICAL */:
          vertical = true;
          break;
        default:
          break;
      }
      this.setBorder(top, left, bottom, right, vertical, horizontal, color, style);
    }
    /**
     * Sets the font family, such as "Arial" or "Helvetica".
     *
     * @param fontFamily The font family to set; a null value resets the font family.
     * @returns
     */
    setFontFamily(fontFamily) {
      const { _context, _worksheet, _commandManager } = this;
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const fontFamilyObj = { ff: fontFamily };
      const stylesMatrix = Tools.fillObjectMatrix(
        endRow - startRow + 1,
        endColumn - startColumn + 1,
        fontFamilyObj
      );
      const setStyle = {
        sheetId: _worksheet.getSheetId(),
        actionName: "SetRangeStyleAction" /* SET_RANGE_STYLE_ACTION */,
        value: stylesMatrix,
        rangeData: this._rangeData
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setStyle
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Sets the font size, with the size being the point size to use.
     *
     * @param size A font size in point size.
     * @returns
     */
    setFontSize(size) {
      const { _context, _worksheet, _commandManager } = this;
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const fontSizeObj = { fs: size };
      const stylesMatrix = Tools.fillObjectMatrix(
        endRow - startRow + 1,
        endColumn - startColumn + 1,
        fontSizeObj
      );
      const setStyle = {
        sheetId: _worksheet.getSheetId(),
        actionName: "SetRangeStyleAction" /* SET_RANGE_STYLE_ACTION */,
        value: stylesMatrix,
        rangeData: this._rangeData
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setStyle
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Set the horizontal (left to right) alignment for the given range (left/center/right).
     *
     * @param alignment The alignment, either 'left', 'center' or 'normal'; a null value resets the alignment.
     * @returns
     */
    setHorizontalAlignment(alignment) {
      const { _context, _worksheet, _commandManager } = this;
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const horizontalAlignmentObj = { ht: alignment };
      const stylesMatrix = Tools.fillObjectMatrix(
        endRow - startRow + 1,
        endColumn - startColumn + 1,
        horizontalAlignmentObj
      );
      const setStyle = {
        sheetId: _worksheet.getSheetId(),
        actionName: "SetRangeStyleAction" /* SET_RANGE_STYLE_ACTION */,
        value: stylesMatrix,
        rangeData: this._rangeData
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setStyle
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Set the vertical (top to bottom) alignment for the given range (top/middle/bottom).
     *
     * @param alignment The alignment, either 'top', 'middle' or 'bottom'; a null value resets the alignment.
     * @returns
     */
    setVerticalAlignment(alignment) {
      const { _context, _worksheet, _commandManager } = this;
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const verticalAlignmentObj = { vt: alignment };
      const stylesMatrix = Tools.fillObjectMatrix(
        endRow - startRow + 1,
        endColumn - startColumn + 1,
        verticalAlignmentObj
      );
      const setStyle = {
        sheetId: _worksheet.getSheetId(),
        actionName: "SetRangeStyleAction" /* SET_RANGE_STYLE_ACTION */,
        value: stylesMatrix,
        rangeData: this._rangeData
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setStyle
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Set the vertical (top to bottom) alignment for the given range (top/middle/bottom).
     *
     * @param direction The desired text direction; if null the direction is inferred before setting.
     * @returns
     */
    setTextDirection(direction) {
      const { _context, _worksheet, _commandManager } = this;
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const textDirectionObj = { td: direction };
      const stylesMatrix = Tools.fillObjectMatrix(
        endRow - startRow + 1,
        endColumn - startColumn + 1,
        textDirectionObj
      );
      const setStyle = {
        sheetId: _worksheet.getSheetId(),
        actionName: "SetRangeStyleAction" /* SET_RANGE_STYLE_ACTION */,
        value: stylesMatrix,
        rangeData: this._rangeData
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setStyle
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Sets the text wrapping strategy for the cells in the range.
     *
     * @param strategy The desired wrapping strategy.
     * @returns
     */
    setWrapStrategy(strategy) {
      const { _context, _worksheet, _commandManager } = this;
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const wrapStrategyObj = { tb: strategy };
      const stylesMatrix = Tools.fillObjectMatrix(
        endRow - startRow + 1,
        endColumn - startColumn + 1,
        wrapStrategyObj
      );
      const setStyle = {
        sheetId: _worksheet.getSheetId(),
        actionName: "SetRangeStyleAction" /* SET_RANGE_STYLE_ACTION */,
        value: stylesMatrix,
        rangeData: this._rangeData
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setStyle
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Sets the value of the range. The value can be numeric, string, boolean or date. If it begins with '=' it is interpreted as a formula.
     * @param value The value for the range.
     * @returns  This range, for chaining.
     */
    setValue(value) {
      const { _rangeData, _context, _commandManager, _worksheet } = this;
      const { startRow, startColumn, endRow, endColumn } = _rangeData;
      const cellValue = new ObjectMatrix();
      for (let r4 = startRow; r4 <= endRow; r4++) {
        for (let c4 = startColumn; c4 <= endColumn; c4++) {
          cellValue.setValue(r4, c4, value);
        }
      }
      const setValue = {
        sheetId: _worksheet.getSheetId(),
        actionName: "SetRangeFormattedValueAction" /* SET_RANGE_FORMATTED_VALUE_ACTION */,
        cellValue: cellValue.getData(),
        rangeData: this._rangeData
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setValue
      );
      _commandManager.invoke(command);
      return this;
    }
    setValues(...argument) {
      const { _rangeData, _context, _commandManager, _worksheet } = this;
      const values = argument[0];
      if (Tuples.checkup(argument, Array)) {
        const { startRow, startColumn, endRow, endColumn } = _rangeData;
        const cellValue = new ObjectMatrix();
        for (let r4 = 0; r4 <= endRow - startRow; r4++) {
          for (let c4 = 0; c4 <= endColumn - startColumn; c4++) {
            cellValue.setValue(r4 + startRow, c4 + startColumn, values[r4][c4]);
          }
        }
        const setValue = {
          sheetId: _worksheet.getSheetId(),
          actionName: "SetRangeFormattedValueAction" /* SET_RANGE_FORMATTED_VALUE_ACTION */,
          cellValue: cellValue.getData(),
          rangeData: this._rangeData
        };
        const command = new Command(
          {
            WorkBookUnit: _context.getWorkBook()
          },
          setValue
        );
        _commandManager.invoke(command);
      } else if (Tuples.checkup(argument, ObjectMatrix)) {
        const setValue = {
          sheetId: _worksheet.getSheetId(),
          actionName: "SetRangeFormattedValueAction" /* SET_RANGE_FORMATTED_VALUE_ACTION */,
          cellValue: values,
          rangeData: this._rangeData
        };
        const command = new Command(
          {
            WorkBookUnit: _context.getWorkBook()
          },
          setValue
        );
        _commandManager.invoke(command);
      }
      return this;
    }
    /**
     * Sets cell data object for current range
     * @param value Cell data object
     * @returns
     */
    setRangeData(value) {
      const { _rangeData, _context, _commandManager, _worksheet } = this;
      const { startRow, startColumn } = _rangeData;
      const setValue = {
        sheetId: _worksheet.getSheetId(),
        actionName: "SetRangeDataAction" /* SET_RANGE_DATA_ACTION */,
        cellValue: {
          [startRow]: {
            [startColumn]: value
          }
        }
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setValue
      );
      _commandManager.invoke(command);
      return this;
    }
    setRangeDatas(...argument) {
      const { _rangeData, _context, _commandManager, _worksheet } = this;
      const values = argument[0];
      if (Tuples.checkup(argument, Array)) {
        const { startRow, startColumn, endRow, endColumn } = _rangeData;
        const cellValue = new ObjectMatrix();
        for (let r4 = 0; r4 <= endRow - startRow; r4++) {
          for (let c4 = 0; c4 <= endColumn - startColumn; c4++) {
            cellValue.setValue(r4 + startRow, c4 + startColumn, values[r4][c4]);
          }
        }
        const setValue = {
          sheetId: _worksheet.getSheetId(),
          actionName: "SetRangeDataAction" /* SET_RANGE_DATA_ACTION */,
          cellValue: cellValue.getData()
        };
        const command = new Command(
          {
            WorkBookUnit: _context.getWorkBook()
          },
          setValue
        );
        _commandManager.invoke(command);
      } else if (Tuples.checkup(argument, ObjectMatrix)) {
        const setValue = {
          sheetId: _worksheet.getSheetId(),
          actionName: "SetRangeDataAction" /* SET_RANGE_DATA_ACTION */,
          cellValue: values
        };
        const command = new Command(
          {
            WorkBookUnit: _context.getWorkBook()
          },
          setValue
        );
        _commandManager.invoke(command);
      }
      return this;
    }
    clear(...argument) {
      const { _context, _worksheet, _commandManager, _rangeData } = this;
      let options = {
        formatOnly: true,
        contentsOnly: true
      };
      if (Tuples.checkup(argument, Tuples.OBJECT_TYPE)) {
        options = argument[0];
      }
      const setValue = {
        sheetId: _worksheet.getSheetId(),
        actionName: "ClearRangeAction" /* CLEAR_RANGE_ACTION */,
        options,
        rangeData: _rangeData
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setValue
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Clears formatting for this range.
     *
     * This clears text formatting for the cell or cells in the range, but does not reset any number formatting rules.
     *
     * @returns Range This range, for chaining.
     */
    clearFormat() {
      return this.clear({ formatOnly: true });
    }
    /**
     * Clears the content of the range, leaving the formatting intact.
     *
     * @returns Range This range, for chaining.
     */
    clearContent() {
      return this.clear({ contentsOnly: true });
    }
    /**
     * Clears the note in the given cell or cells.
     *
     * @returns Range This range, for chaining.
     */
    clearNote() {
      return this.clear({ commentsOnly: true });
    }
    /**
     * Deletes this range of cells. Existing data in the sheet along the provided dimension is shifted towards the deleted range.
     *
     * solution: Clear the range to be deleted, and then set the new value of the cell content at the bottom using setValue
     * @param  {Dimension} shiftDimension The dimension along which to shift existing data.
     * @returns void
     */
    deleteCells(shiftDimension) {
      const { _rangeData, _context, _commandManager, _worksheet } = this;
      const setValue = {
        sheetId: _worksheet.getSheetId(),
        actionName: "DeleteRangeAction" /* DELETE_RANGE_ACTION */,
        shiftDimension,
        rangeData: _rangeData
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setValue
      );
      _commandManager.invoke(command);
    }
    insertCells(...argument) {
      const shiftDimension = argument[0];
      const destination = argument[1];
      const { _rangeData, _context, _commandManager, _worksheet } = this;
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      let rangeData = this._rangeData;
      let cellValue = new ObjectMatrix();
      if (destination) {
        cellValue = destination.getMatrixObject();
        const destinationRangeData = destination.getRangeData();
        rangeData = {
          startRow,
          endRow: startRow + destinationRangeData.endRow - destinationRangeData.startRow,
          startColumn,
          endColumn: startRow + destinationRangeData.endColumn - destinationRangeData.startColumn
        };
      } else {
        for (let r4 = startRow; r4 <= endRow; r4++) {
          for (let c4 = startColumn; c4 <= endColumn; c4++) {
            cellValue.setValue(r4, c4, { m: "", v: "" });
          }
        }
      }
      const insertValue = {
        sheetId: _worksheet.getSheetId(),
        actionName: "InsertRangeAction" /* INSERT_RANGE_ACTION */,
        shiftDimension,
        rangeData,
        cellValue: cellValue.getData()
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        insertValue
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Merges the cells in the range together into a single block.
     *
     * @returns Range  This range, for chaining.
     */
    merge() {
      const { _worksheet } = this;
      const _context = _worksheet.getContext();
      const _sheetId = _worksheet.getSheetId();
      const _commandManager = _worksheet.getCommandManager();
      const dataRowInsert = {
        actionName: "AddMergeAction" /* ADD_MERGE_ACTION */,
        sheetId: _sheetId,
        rectangles: [this._rangeData]
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        dataRowInsert
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Merge the cells in the range across the columns of the range.
     *
     * @returns Range  This range, for chaining.
     */
    mergeAcross() {
      const { _worksheet } = this;
      const _commandManager = _worksheet.getCommandManager();
      const _context = _worksheet.getContext();
      const _sheetId = _worksheet.getSheetId();
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const rectangles = [];
      for (let r4 = startRow; r4 <= endRow; r4++) {
        const data = {
          startRow: r4,
          endRow: r4,
          startColumn,
          endColumn
        };
        rectangles.push(data);
      }
      const dataRowInsert = {
        actionName: "AddMergeAction" /* ADD_MERGE_ACTION */,
        sheetId: _sheetId,
        rectangles
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        dataRowInsert
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * Merges the cells in the range together.
     *
     * @returns Range  This range, for chaining.
     */
    mergeVertically() {
      const { _worksheet } = this;
      const _commandManager = _worksheet.getCommandManager();
      const _context = _worksheet.getContext();
      const _sheetId = _worksheet.getSheetId();
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const rectangles = [];
      for (let c4 = startColumn; c4 <= endColumn; c4++) {
        const data = {
          startRow,
          endRow,
          startColumn: c4,
          endColumn: c4
        };
        rectangles.push(data);
      }
      const dataRowInsert = {
        actionName: "AddMergeAction" /* ADD_MERGE_ACTION */,
        sheetId: _sheetId,
        rectangles
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        dataRowInsert
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
         * Break any multi-column cells in the range into individual cells again.
    
            Calling this function on a range is equivalent to selecting a range and clicking Format -> Merge -> Unmerge.
    
            @returns Range  This range, for chaining.
         */
    breakApart() {
      const { _worksheet } = this;
      const _commandManager = _worksheet.getCommandManager();
      const _context = _worksheet.getContext();
      const _sheetId = _worksheet.getSheetId();
      const rectangles = this._worksheet.getMerges().getMergedRanges(this._rangeData);
      const dataRowInsert = {
        actionName: "RemoveMergeAction" /* REMOVE_MERGE_ACTION */,
        sheetId: _sheetId,
        rectangles
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        dataRowInsert
      );
      _commandManager.invoke(command);
      return this;
    }
    removeDuplicates(...argument) {
      const { _rangeData, _context, _commandManager, _worksheet } = this;
      let columnsToCompare = [];
      if (Array.isArray(argument[0])) {
        columnsToCompare = argument[0];
      }
      const newCellValue = this.getMatrix().getData();
      const rowList = [];
      for (let i4 = 0; i4 <= _rangeData.endColumn - _rangeData.startColumn; i4++) {
        const arr = [];
        const obj = {};
        const column = this.getColumnMatrix(i4).getData();
        for (const key in column) {
          const value = column[key][i4].m;
          if (!obj.hasOwnProperty(value)) {
            obj[value] = 1;
            arr.push(i4);
          }
        }
        rowList.push(arr);
      }
      const newRowList = Array.from(new Set(rowList.flat()));
      const newData = {};
      newRowList.forEach((item, i4) => {
        newData[i4] = newCellValue[item];
      });
      const removeDatas = [
        {
          sheetId: _worksheet.getSheetId(),
          actionName: "SetRangeDataAction" /* SET_RANGE_DATA_ACTION */,
          cellValue: newData
        }
      ];
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        ...removeDatas
      );
      _commandManager.invoke(command);
      return this;
    }
    /**
     * get row matrix
     * @returns
     */
    getRowMatrix(index) {
      const { startColumn, endColumn } = this._rangeData;
      const sheetMatrix = this._worksheet.getCellMatrix();
      const rangeMatrix = new ObjectMatrix();
      for (let r4 = index; r4 <= index; r4++) {
        for (let c4 = startColumn; c4 <= endColumn; c4++) {
          rangeMatrix.setValue(r4, c4, sheetMatrix.getValue(r4, c4) || {});
        }
      }
      return rangeMatrix;
    }
    /**
     * get column matrix
     * @returns
     */
    getColumnMatrix(index) {
      const { startRow, endRow } = this._rangeData;
      const sheetMatrix = this._worksheet.getCellMatrix();
      const rangeMatrix = new ObjectMatrix();
      for (let r4 = startRow; r4 <= endRow; r4++) {
        for (let c4 = index; c4 <= index; c4++) {
          rangeMatrix.setValue(r4, c4, sheetMatrix.getValue(r4, c4) || {});
        }
      }
      return rangeMatrix;
    }
    forEach(action) {
      Range.foreach(this._rangeData, action);
    }
    /**
     * Randomizes the order of the rows in the given range.
     * TODO
     * 1. 
     * 2. 
     * @returns
     */
    randomize() {
      const { _context, _worksheet, _commandManager, _rangeData } = this;
      const { startRow, startColumn } = _rangeData;
      const cellValue = new ObjectMatrix();
      const value = Tools.randSort(this.getMatrix().toArray());
      value.forEach(
        (row, r4) => row.forEach((cell, c4) => {
          cell = cell;
          cellValue.setValue(r4 + startRow, c4 + startColumn, cell || {});
        })
      );
      const setValue = {
        sheetId: _worksheet.getSheetId(),
        actionName: "SetRangeDataAction" /* SET_RANGE_DATA_ACTION */,
        cellValue: cellValue.getData()
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setValue
      );
      _commandManager.invoke(command);
    }
    /**
     * Determine whether a range is legal
     */
    isValid() {
      if (Object.values(this._rangeData).includes(-1)) {
        return false;
      }
      return true;
    }
    _handleCopyRange(...argument) {
      const originRange = argument[0];
      let destinationRange = argument[1];
      destinationRange = Tuples.checkup(argument, Range, Range) ? destinationRange.getRangeData() : destinationRange;
      const cellData = originRange._worksheet.getCellMatrix();
      const { startRow, endRow, startColumn, endColumn } = originRange.getRangeData();
      let {
        startRow: dStartRow,
        endRow: dEndRow,
        startColumn: dStartColumn,
        endColumn: dEndColumn
      } = destinationRange;
      const originRows = endRow - startRow + 1;
      const originColumns = endColumn - startColumn + 1;
      const destinationRows = dEndRow - dStartRow + 1;
      const destinationColumns = dEndColumn - dStartColumn + 1;
      let value = [];
      let range2;
      if (destinationRows % originRows === 0 && destinationColumns % originColumns === 0) {
        for (let r4 = 0; r4 < destinationRows; r4++) {
          const row = [];
          for (let c4 = 0; c4 < destinationColumns; c4++) {
            const cell = cellData.getValue(
              (r4 + startRow) % originRows,
              (c4 + startColumn) % originColumns
            ) || {};
            row.push(cell);
          }
          value.push(row);
        }
        range2 = destinationRange;
      } else {
        value = cellData.getFragments(startRow, endRow, startColumn, endColumn).getData();
        dEndRow += originRows - destinationRows;
        dEndColumn += originColumns - destinationColumns;
        range2 = {
          startRow: dStartRow,
          endRow: dEndRow,
          startColumn: dStartColumn,
          endColumn: dEndColumn
        };
      }
      return [value, range2];
    }
    /**
     *
     * @param arg Shorthand for the style that gets
     * @returns style value
     */
    _getStyles(arg) {
      return this.getValues().map(
        (row) => row.map((cell) => {
          const styles = this._context.getWorkBook().getStyles();
          const style = styles && styles.getStyleByCell(cell);
          return style && style[arg] || DEFAULT_STYLES[arg];
        })
      );
    }
    // isStartColumnBounded() {}
    // isStartRowBounded() {}
    _setStyle(value, type) {
      const { _context, _worksheet, _commandManager } = this;
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const styleObj = { [type]: value };
      const stylesMatrix = Tools.fillObjectMatrix(
        endRow - startRow + 1,
        endColumn - startColumn + 1,
        styleObj
      );
      const setStyle = {
        sheetId: _worksheet.getSheetId(),
        actionName: SetRangeStyleAction.NAME,
        value: stylesMatrix,
        rangeData: this._rangeData
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setStyle
      );
      _commandManager.invoke(command);
      return this;
    }
    _setStyles(values, type) {
      const { _context, _worksheet, _commandManager } = this;
      const { startRow, endRow, startColumn, endColumn } = this._rangeData;
      const matrix = new ObjectMatrix();
      for (let r4 = 0; r4 < endRow - startRow + 1; r4++) {
        for (let c4 = 0; c4 < endColumn - startColumn + 1; c4++) {
          matrix.setValue(r4, c4, { [type]: values[r4][c4] });
        }
      }
      const setStyle = {
        sheetId: _worksheet.getSheetId(),
        actionName: "SetRangeStyleAction" /* SET_RANGE_STYLE_ACTION */,
        value: matrix.getData(),
        rangeData: this._rangeData
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        setStyle
      );
      _commandManager.invoke(command);
      return this;
    }
    // /**
    //  * Applies a default row banding theme to the range. By default, the banding has header and no footer color.
    //  */
    // applyRowBanding(): Nullable<Banding>;
    // /**
    //  * Applies a specified row banding theme to the range. By default, the banding has header and no footer color.
    //  * @param bandingTheme
    //  */
    // applyRowBanding(bandingTheme: BandingTheme | IBandingProperties): Nullable<Banding>;
    // /**
    //  * Applies a specified row banding theme to the range with specified header and footer settings.
    //  * @param bandingTheme
    //  * @param showHeader
    //  * @param showFooter
    //  */
    // applyRowBanding(
    //     bandingTheme: BandingTheme | IBandingProperties,
    //     showHeader: boolean,
    //     showFooter: boolean
    // ): Nullable<Banding>;
    // applyRowBanding(...argument: any): Nullable<Banding> {
    //     // default argument
    //     const bandedRangeId = 'banded-range-' + Tools.generateRandomId(6);
    //     const rangeData = this.getRangeData()
    //     let rowProperties:IBanding = {
    //         bandingTheme:argument[0] || BandingTheme.LIGHT_GRAY,
    //         showHeader:argument[1] || true,
    //         showFooter:argument[2] || false,
    //     }
    //     const { _context, _commandManager } = this;
    //     // Check whether the incoming range has been set to alternate colors
    //     const bandings = this.getSheet().getBandings();
    //     const isIntersection =
    //         bandings &&
    //         bandings.find((banding: Banding) =>
    //             banding.getRange().isIntersection(this)
    //         );
    //     if (isIntersection) {
    //         console.error(
    //             'You cannot add alternating background colors to a range that already has alternating background colors.'
    //         );
    //         return
    //     }
    //     // Organize action data
    //     const actionData: IAddBandingActionData = {
    //         actionName: ACTION_NAMES.ADD_BANDING_ACTION,
    //         bandedRange:{
    //             bandedRangeId,
    //             rangeData,
    //             rowProperties
    //         },
    //         sheetId: this.getSheet().getSheetId(),
    //     };
    //     // Execute action
    //     const command = new Command(_context.getWorkBook(), actionData);
    //     _commandManager.invoke(command);
    //     return this.getSheet().getBandingById(bandedRangeId)
    // }
    // /**
    //  * Applies a default row banding theme to the range. By default, the banding has header and no footer color.
    //  */
    // applyRowBanding(): Nullable<Banding>;
    // /**
    //  * Applies a specified row banding theme to the range. By default, the banding has header and no footer color.
    //  * @param bandingTheme
    //  */
    // applyRowBanding(
    //     bandingTheme: BandingTheme | IBandingProperties
    // ): Nullable<Banding>;
    // /**
    //  * Applies a specified row banding theme to the range with specified header and footer settings.
    //  * @param bandingTheme
    //  * @param showHeader
    //  * @param showFooter
    //  */
    // applyRowBanding(
    //     bandingTheme: BandingTheme | IBandingProperties,
    //     showHeader: boolean,
    //     showFooter: boolean
    // ): Nullable<Banding>;
    // applyRowBanding(...argument: any): Nullable<Banding> {
    //     // default argument
    //     const bandedRangeId = 'banded-range-' + Tools.generateRandomId(6);
    //     const rangeData = this.getRangeData();
    //     let rowProperties: IBanding = {
    //         bandingTheme: argument[0] || BandingTheme.LIGHT_GRAY,
    //         showHeader: argument[1] || true,
    //         showFooter: argument[2] || false,
    //     };
    //     const { _worksheet } = this;
    //     // Check whether the incoming range has been set to alternate colors
    //     const bandedRanges = _worksheet.getConfig().bandedRanges;
    //     const isIntersection =
    //         bandedRanges &&
    //         bandedRanges.find((bandedRange: IBandedRange) =>
    //             _worksheet.getRange(bandedRange.rangeData).isIntersection(this)
    //         );
    //     if (isIntersection) {
    //         console.error(
    //             'You cannot add alternating background colors to a range that already has alternating background colors.'
    //         );
    //         return;
    //     }
    //     return new Banding(this._worksheet).addRowBanding({
    //         bandedRangeId,
    //         rangeData,
    //         rowProperties,
    //     });
    // }
    /**
     * Creates a filter applied to the range. There can be at most one filter in a sheet.
     * @returns The new filter.
     */
    // createFilter(): Filter {
    //     return new Filter(this);
    // }
  };

  // ../../packages/core/src/Sheets/Domain/Styles.ts
  var Styles = class {
    _styles;
    constructor(styles = {}) {
      this._styles = styles;
    }
    each(callback) {
      Object.entries(this._styles).forEach(callback);
      return this;
    }
    search(data) {
      const { _styles } = this;
      for (const id in _styles) {
        if (Tools.diffValue(_styles[id], data)) {
          return id;
        }
      }
      return "-1";
    }
    get(id) {
      id = String(id);
      if (typeof id !== "string")
        return id;
      return this._styles[id];
    }
    add(data) {
      const id = Tools.generateRandomId(6);
      this._styles[id] = data;
      return id;
    }
    setValue(data) {
      if (data == null)
        return;
      const result = this.search(data);
      if (result !== "-1") {
        return result;
      }
      return this.add(data);
    }
    toJSON() {
      return this._styles;
    }
    getStyleByCell(cell) {
      let style;
      if (cell && Tools.isObject(cell.s)) {
        style = cell.s;
      } else {
        style = cell?.s && this.get(cell.s);
      }
      return style;
    }
  };

  // ../../packages/core/src/Sheets/Domain/NamedRange.ts
  var NamedRange = class {
    _workbook;
    _commandManager;
    _context;
    // private _name: string;
    // private _range: Range;
    // private _namedRangeId: string;
    constructor(workbook) {
      this._workbook = workbook;
      this._commandManager = this._workbook.getCommandManager();
      this._context = this._workbook.getContext();
    }
    addNamedRange(namedRange) {
      const { _workbook, _context, _commandManager } = this;
      const actionData = {
        actionName: AddNamedRangeAction.NAME,
        namedRange,
        sheetId: namedRange.range.sheetId
      };
      const command = new Command(
        {
          WorkBookUnit: _workbook
        },
        actionData
      );
      _commandManager.invoke(command);
    }
    setNamedRange(namedRange) {
      const { _workbook, _commandManager } = this;
      const actionData = {
        actionName: "SetNamedRangeAction" /* SET_NAMED_RANGE_ACTION */,
        namedRange,
        sheetId: namedRange.range.sheetId
      };
      const command = new Command(
        {
          WorkBookUnit: _workbook
        },
        actionData
      );
      _commandManager.invoke(command);
    }
    /**
     * Gets the name of this named range.
     *
     * @returns String  the name of this named range
     */
    // getName(): string {
    //     return this._name;
    // }
    /**
     * Sets/updates the name of the named range.
     * @param name 	The new name of the named range.
     *
     * @returns NamedRange  the range whose name was set by the call
     */
    // setName(name: string): NamedRange {
    //     this._name = name;
    //     this._setNamedRange();
    //     return this;
    // }
    /**
     * Gets the range referenced by this named range.
     *
     * @returns Range  the spreadsheet range that is associated with this named range
     */
    // getRange(): Range {
    //     return this._range;
    // }
    /**
     * Sets/updates the range for this named range.
     * @param range The spreadsheet range to associate with this named range.
     * @returns NamedRange  the named range for which the spreadsheet range was set
     */
    // setRange(range: Range): NamedRange {
    //     this._range = range;
    //     this._setNamedRange();
    //     return this;
    // }
    /**
     * Gets the namedRangeId of this named range.
     *
     * @returns String  the namedRangeId of this named range
     */
    // getNamedRangeId(): string {
    //     return this._namedRangeId;
    // }
    /**
     * Deletes this named range.
     */
    remove(namedRangeId) {
      const { _context, _workbook, _commandManager } = this;
      const actionData = {
        actionName: "DeleteNamedRangeAction" /* DELETE_NAMED_RANGE_ACTION */,
        namedRangeId,
        sheetId: _workbook.getActiveSheet().getSheetId()
      };
      const command = new Command(
        {
          WorkBookUnit: _workbook
        },
        actionData
      );
      _commandManager.invoke(command);
    }
  };

  // ../../packages/core/src/Sheets/Domain/Workbook.ts
  var Workbook = class {
    /**
     * sheets list
     * @private
     */
    _worksheets;
    /**
     * Common style
     * @private
     */
    _styles;
    /**
     * number format
     * @private
     */
    // private _formatManage: FormatManager;
    _config;
    _unitId;
    _context;
    _commandManager;
    _namedRange;
    constructor(workbookData = {}, context) {
      this._config = Tools.commonExtend(DEFAULT_WORKBOOK, workbookData);
      this._context = context;
      const { styles } = this._config;
      if (this._config.id === "") {
        this._config.id = Tools.generateRandomId(6);
      }
      this._unitId = this._config.id;
      this._styles = new Styles(styles);
      this._worksheets = /* @__PURE__ */ new Map();
      this._commandManager = context.getCommandManager();
      this._getDefaultWorkSheet();
      this._namedRange = new NamedRange(this);
    }
    /**
     *
     * @param rangeData
     * @returns
     */
    static rangeDataToRangeStringData(rangeData) {
      const { startRow, endRow, startColumn, endColumn } = rangeData;
      return `${Tools.chatAtABC(startColumn) + (startRow + 1)}:${Tools.chatAtABC(
        endColumn
      )}${endRow + 1}`;
    }
    static isIRangeType(range2) {
      return typeof range2 === "string" || "startRow" in range2 || "row" in range2;
    }
    getUnitId() {
      return this._unitId;
    }
    getWorksheets() {
      return this._worksheets;
    }
    getNamedRang() {
      return this._namedRange;
    }
    activateSheetByIndex(index) {
      if (index >= 0) {
        const { sheetOrder } = this._config;
        for (let i4 = index; i4 < sheetOrder.length; i4++) {
          const worksheet2 = this._worksheets.get(sheetOrder[i4]);
          if (worksheet2 && !worksheet2.isSheetHidden()) {
            worksheet2.activate();
            return worksheet2;
          }
        }
        if (index < sheetOrder.length) {
          for (let i4 = index - 1; i4 >= 0; i4--) {
            const worksheet2 = this._worksheets.get(sheetOrder[i4]);
            if (worksheet2 && !worksheet2.isSheetHidden()) {
              worksheet2.activate();
              return worksheet2;
            }
          }
        }
        const worksheet = this._worksheets.get(
          sheetOrder[sheetOrder.length - 1]
        );
        if (worksheet) {
          worksheet.activate();
        }
        return worksheet;
      }
    }
    setContext(context) {
      this._context = context;
    }
    setCommandManager(commandManager) {
      this._commandManager = commandManager;
    }
    insertSheet(...argument) {
      const { _context, _commandManager } = this;
      const before = _context.getContextObserver("onBeforeInsertSheetObservable");
      const after = _context.getContextObserver("onAfterInsertSheetObservable");
      if (Tools.hasLength(argument, 0)) {
        const worksheetConfig2 = {
          name: NameGen.getSheetName(),
          status: 0,
          id: Tools.generateRandomId(6)
        };
        const index = this.getSheetSize();
        before.notifyObservers({
          index,
          sheetId: worksheetConfig2.id
        });
        _commandManager.invoke(
          new Command(
            {
              WorkBookUnit: _context.getWorkBook()
            },
            {
              actionName: InsertSheetAction.NAME,
              sheetId: worksheetConfig2.id,
              index,
              sheet: worksheetConfig2
            }
          )
        );
        after.notifyObservers({
          index,
          sheetId: worksheetConfig2.id
        });
        return worksheetConfig2.id;
      }
      if (Tools.hasLength(argument, 1)) {
        if (Tools.isAssignableFrom(argument[0], Worksheet)) {
          const sheet = argument[0];
          const index = this.getSheetSize();
          const worksheetConfig2 = sheet.getConfig();
          worksheetConfig2.id = Tools.generateRandomId(6);
          before.notifyObservers({
            index,
            sheetId: worksheetConfig2.id
          });
          _commandManager.invoke(
            new Command(
              {
                WorkBookUnit: _context.getWorkBook()
              },
              {
                actionName: InsertSheetAction.NAME,
                sheetId: worksheetConfig2.id,
                index,
                sheet: worksheetConfig2
              }
            )
          );
          after.notifyObservers({
            index,
            sheetId: worksheetConfig2.id
          });
          return worksheetConfig2.id;
        }
        if (Tools.isNumber(argument[0])) {
          const index = argument[0];
          const worksheetConfig2 = {
            name: NameGen.getSheetName(),
            status: 0,
            id: Tools.generateRandomId(6)
          };
          before.notifyObservers({
            index,
            sheetId: worksheetConfig2.id
          });
          _commandManager.invoke(
            new Command(
              {
                WorkBookUnit: _context.getWorkBook()
              },
              {
                actionName: InsertSheetAction.NAME,
                sheetId: worksheetConfig2.id,
                index,
                sheet: worksheetConfig2
              }
            )
          );
          after.notifyObservers({
            index,
            sheetId: worksheetConfig2.id
          });
          return worksheetConfig2.id;
        }
        if (Tools.isString(argument[0])) {
          const name = argument[0];
          const index = this.getSheetSize();
          const worksheetConfig2 = {
            status: 0,
            name,
            id: Tools.generateRandomId(6)
          };
          before.notifyObservers({
            index,
            sheetId: worksheetConfig2.id
          });
          _commandManager.invoke(
            new Command(
              {
                WorkBookUnit: _context.getWorkBook()
              },
              {
                actionName: InsertSheetAction.NAME,
                sheetId: worksheetConfig2.id,
                index,
                sheet: worksheetConfig2
              }
            )
          );
          after.notifyObservers({
            index,
            sheetId: worksheetConfig2.id
          });
          return worksheetConfig2.id;
        }
        if (Tools.isPlainObject(argument[0])) {
          const worksheetConfig2 = argument[0];
          const index = this.getSheetSize();
          before.notifyObservers({
            index,
            sheetId: worksheetConfig2.id
          });
          _commandManager.invoke(
            new Command(
              {
                WorkBookUnit: _context.getWorkBook()
              },
              {
                actionName: InsertSheetAction.NAME,
                sheetId: worksheetConfig2.id,
                index,
                sheet: worksheetConfig2
              }
            )
          );
          after.notifyObservers({
            index,
            sheetId: worksheetConfig2.id
          });
          return worksheetConfig2.id;
        }
      }
      if (Tools.hasLength(argument, 2)) {
        if (Tools.isString(argument[0])) {
          const name = argument[0];
          const index = argument[1];
          const worksheetConfig2 = {
            status: 0,
            name,
            id: Tools.generateRandomId(6)
          };
          before.notifyObservers({
            index,
            sheetId: worksheetConfig2.id
          });
          _commandManager.invoke(
            new Command(
              {
                WorkBookUnit: _context.getWorkBook()
              },
              {
                actionName: InsertSheetAction.NAME,
                sheetId: worksheetConfig2.id,
                index,
                sheet: worksheetConfig2
              }
            )
          );
          after.notifyObservers({
            index,
            sheetId: worksheetConfig2.id
          });
          return worksheetConfig2.id;
        }
        if (Tools.isNumber(argument[0])) {
          if (Tools.isAssignableFrom(argument[1], Worksheet)) {
            const index = argument[0];
            const sheet = argument[1];
            const worksheetConfig2 = sheet.getConfig();
            worksheetConfig2.id = Tools.generateRandomId(6);
            before.notifyObservers({
              index,
              sheetId: worksheetConfig2.id
            });
            _commandManager.invoke(
              new Command(
                {
                  WorkBookUnit: _context.getWorkBook()
                },
                {
                  actionName: InsertSheetAction.NAME,
                  sheetId: worksheetConfig2.id,
                  index,
                  sheet: worksheetConfig2
                }
              )
            );
            after.notifyObservers({
              index,
              sheetId: worksheetConfig2.id
            });
            return worksheetConfig2.id;
          }
          if (Tools.isPlainObject(argument[1])) {
            const index = argument[0];
            const worksheetConfig2 = argument[1];
            before.notifyObservers({
              index,
              sheetId: worksheetConfig2.id
            });
            _commandManager.invoke(
              new Command(
                {
                  WorkBookUnit: _context.getWorkBook()
                },
                {
                  actionName: InsertSheetAction.NAME,
                  sheetId: worksheetConfig2.id,
                  index,
                  sheet: worksheetConfig2
                }
              )
            );
            after.notifyObservers({
              index,
              sheetId: worksheetConfig2.id
            });
            return worksheetConfig2.id;
          }
        }
      }
    }
    getActiveSpreadsheet() {
      return this;
    }
    getStyles() {
      return this._styles;
    }
    getContext() {
      return this._context;
    }
    getConfig() {
      return this._config;
    }
    create(...argument) {
      if (Tools.hasLength(argument, 1)) {
        const { _context } = this;
        const name = argument[0];
        const conf = { ...DEFAULT_WORKSHEET, name };
        const worksheet = new Worksheet(
          _context,
          conf
        );
        this.insertSheet(worksheet);
        return worksheet;
      }
      if (Tools.hasLength(argument, 3)) {
        const { _context } = this;
        const name = argument[0];
        const rowCount = argument[1];
        const columnCount = argument[2];
        const conf = { ...DEFAULT_WORKSHEET, name, rowCount, columnCount };
        const worksheet = new Worksheet(
          _context,
          conf
        );
        this.insertSheet(worksheet);
        return worksheet;
      }
    }
    setDefaultActiveSheet() {
      this._setDefaultActiveSheet();
    }
    getIndexBySheetId(sheetId) {
      const { sheetOrder } = this._config;
      return sheetOrder.findIndex((id) => id === sheetId);
    }
    getActiveSheet() {
      const { sheetOrder } = this._config;
      const activeSheetId = sheetOrder.find((sheetId) => {
        const worksheet = this._worksheets.get(sheetId);
        return worksheet.getStatus() === 1 /* TRUE */;
      });
      if (!activeSheetId) {
        console.warn("No active sheet, get first sheet");
        return this._worksheets[0];
      }
      return this._worksheets.get(activeSheetId);
    }
    getActiveSheetIndex() {
      const { sheetOrder } = this._config;
      return sheetOrder.findIndex((sheetId) => {
        const worksheet = this._worksheets.get(sheetId);
        if (worksheet.getStatus() === 1) {
          return true;
        }
        return false;
      });
    }
    getActiveRange() {
      const workSheet = this.getActiveSheet();
      if (workSheet) {
        const selection = workSheet.getSelection();
        return selection.getActiveRange();
      }
      return null;
    }
    setActiveRange(range2) {
      const workSheet = this.getActiveSheet();
      if (workSheet) {
        return workSheet.setActiveSelection(range2);
      }
      return null;
    }
    setActiveRangeList(rangeList) {
      const workSheet = this.getActiveSheet();
      if (workSheet) {
        const activeRangeList = workSheet.getRangeList(rangeList);
        activeRangeList.activate();
        return activeRangeList.getRangeList();
      }
      return null;
    }
    getActiveRangeList() {
      const workSheet = this.getActiveSheet();
      if (workSheet) {
        const selection = workSheet.getSelection();
        return selection.getActiveRangeList();
      }
      return null;
    }
    getSelection() {
      const workSheet = this.getActiveSheet();
      if (workSheet) {
        return workSheet.getSelection();
      }
    }
    getCurrentCell() {
      const selection = this.getSelection();
      if (selection) {
        return selection.getCurrentCell();
      }
    }
    getSheetSize() {
      return this._config.sheetOrder.length;
    }
    /**
     * Sets the specified cell as the current cell.
     * @param cell
     */
    setCurrentCell(cell) {
      return cell.activateAsCurrentCell();
    }
    /**
     * Applies all pending Sheets changes.
     *
     * @returns void
     */
    flush() {
    }
    setSheetOrder(sheetId, order) {
      const { _context, _commandManager } = this;
      const observer = _context.getContextObserver("onSheetOrderObservable");
      const config = {
        actionName: SetSheetOrderAction.NAME,
        sheetId,
        order
      };
      const command = new Command(
        {
          WorkBookUnit: _context.getWorkBook()
        },
        config
      );
      _commandManager.invoke(command);
      observer.notifyObservers();
    }
    getSheets() {
      const { sheetOrder } = this._config;
      return sheetOrder.map(
        (sheetId) => this._worksheets.get(sheetId)
      );
    }
    getSheetIndex(sheet) {
      const { sheetOrder } = this._config;
      return sheetOrder.findIndex((sheetId) => {
        if (sheet.getSheetId() === sheetId) {
          return true;
        }
        return false;
      });
    }
    removeSheetBySheetId(sheetId) {
      const { _commandManager, _config } = this;
      const { sheetOrder } = _config;
      const sheet = this.getSheetBySheetId(sheetId);
      if (sheetOrder.length > 1 && sheet != null) {
        const index = this.getSheetIndex(sheet);
        const before = this.getContext().getContextObserver(
          "onBeforeRemoveSheetObservable"
        );
        const aftert = this.getContext().getContextObserver(
          "onAfterRemoveSheetObservable"
        );
        before.notifyObservers({
          index
        });
        _commandManager.invoke(
          new Command(
            {
              WorkBookUnit: this
            },
            {
              actionName: RemoveSheetAction.NAME,
              sheetId
            }
          )
        );
        aftert.notifyObservers({
          index,
          sheetId
        });
        this.activateSheetByIndex(index);
      }
    }
    getSheetBySheetName(name) {
      const { sheetOrder } = this._config;
      const sheetId = sheetOrder.find((sheetId2) => {
        const worksheet = this._worksheets.get(sheetId2);
        return worksheet.getName() === name;
      });
      return this._worksheets.get(sheetId);
    }
    getSheetBySheetId(sheetId) {
      return this._worksheets.get(sheetId);
    }
    setActiveSheet(...argument) {
      let restoreSelection = false;
      const worksheet = argument[0];
      if (Tuples.checkup(argument, Worksheet, Tuples.BOOLEAN_TYPE)) {
        restoreSelection = argument[1];
      }
      worksheet.activate();
      if (restoreSelection) {
        worksheet.setActiveSelection();
      }
      return worksheet;
    }
    // getFormatManager(): FormatManager {
    //     return this._formatManage;
    // }
    getCommandManager() {
      return this._commandManager;
    }
    getPluginMeta(name) {
      return this._config.pluginMeta[name];
    }
    setPluginMeta(name, value) {
      if (!this._config.pluginMeta) {
        this._config.pluginMeta = {};
      }
      return this._config.pluginMeta[name] = value;
    }
    /**
     * Creates a builder for a conditional formatting rule.
     */
    // newConditionalFormatRule(): ConditionalFormatRuleBuilder {
    //     return new ConditionalFormatRuleBuilder();
    // }
    // newFilterCriteria(): FilterCriteriaBuilder {
    //     return new FilterCriteriaBuilder();
    // }
    /**
     * transform any range type to range data
     *
     * @remarks
     * e.g.,
     * "A1:B1", "Sheet2!A1:B1"
     *
     * or
     *
     * {
     *  row:[0,1],
     *  column:[0,1]
     * }
     *
     * or
     *
     * {
     *    startRow:0 ,
     *    startColumn:0,
     *    endRow:1,
     *    endColumn:1,
     * }
     *
     * to
     *
     * {
     *    startRow:0 ,
     *    startColumn:0,
     *    endRow:1,
     *    endColumn:1,
     * }
     *
     *   IRangeType[] is to prevent type detection
     *
     * @param range support all range types
     *
     * @returns range data
     */
    transformRangeType(range2) {
      if (typeof range2 === "string") {
        const gridRange = this._getCellRange(range2);
        return gridRange;
      }
      if (typeof range2 !== "string" && "row" in range2) {
        return {
          sheetId: "",
          rangeData: {
            startRow: range2.row[0],
            startColumn: range2.column[0],
            endRow: range2.row[1],
            endColumn: range2.column[1]
          }
        };
      }
      if (typeof range2 !== "string" && "startRow" in range2) {
        return { sheetId: "", rangeData: range2 };
      }
      return DEFAULT_RANGE_ARRAY;
    }
    load(config) {
      this._config = config;
    }
    save() {
      return this._config;
    }
    /**
     * Get Default Sheet
     * @private
     */
    _getDefaultWorkSheet() {
      const { _context, _config, _worksheets } = this;
      const { sheets, sheetOrder } = _config;
      if (Tools.isEmptyObject(sheets)) {
        sheets[DEFAULT_WORKSHEET.id] = Object.assign(DEFAULT_WORKSHEET, {
          status: 1 /* TRUE */
        });
      }
      let firstWorksheet = null;
      for (let sheetId in sheets) {
        let config = sheets[sheetId];
        config.name = NameGen.getSheetName(config.name);
        const worksheet = new Worksheet(_context, config);
        _worksheets.set(sheetId, worksheet);
        if (!sheetOrder.includes(sheetId)) {
          sheetOrder.push(sheetId);
        }
        if (firstWorksheet == null) {
          firstWorksheet = worksheet;
        }
      }
      if (firstWorksheet) {
        firstWorksheet.activate();
      }
    }
    /**
     * Get Default Active Sheet
     * @private
     */
    _setDefaultActiveSheet() {
      if (this._worksheets.size > 0) {
        this._worksheets.forEach((sheet) => {
          sheet.setStatus(0 /* FALSE */);
        });
        this._worksheets[0].setStatus(1 /* TRUE */);
      }
    }
    /**
     * Get the range array based on the range string and sheet id
     *
     * @privateRemarks
     * zh: sheet id
     *
     * @param txt - range string
     * @returns
     *
     * @internal
     */
    _getCellRange(txt) {
      let sheetTxt = "";
      let rangeTxt = "";
      if (txt.indexOf("!") > -1) {
        const val = txt.split("!");
        sheetTxt = val[0];
        rangeTxt = val[1];
        sheetTxt = sheetTxt.replace(/\\'/g, "'").replace(/''/g, "'");
        if (sheetTxt.substring(0, 1) === "'" && sheetTxt.substring(sheetTxt.length - 1, 1) === "'") {
          sheetTxt = sheetTxt.substring(1, sheetTxt.length - 1);
        }
      } else {
        rangeTxt = txt;
      }
      if (rangeTxt.indexOf(":") === -1) {
        const row2 = parseInt(rangeTxt.replace(/[^0-9]/g, ""), 10) - 1;
        const col2 = Tools.ABCatNum(rangeTxt.replace(/[^A-Za-z]/g, ""));
        if (!Number.isNaN(row2) && !Number.isNaN(col2)) {
          const item2 = {
            sheetId: sheetTxt,
            rangeData: {
              startRow: row2,
              endRow: row2,
              startColumn: col2,
              endColumn: col2
            }
          };
          return item2;
        }
        return DEFAULT_RANGE_ARRAY;
      }
      rangeTxt = rangeTxt.split(":");
      const row = [0, 0];
      const col = [0, 0];
      const maxRow = this.getSheetBySheetName(sheetTxt)?.getMaxRows() || this.getActiveSheet()?.getMaxRows();
      const maxCol = this.getSheetBySheetName(sheetTxt)?.getMaxColumns() || this.getActiveSheet()?.getMaxColumns();
      row[0] = parseInt(rangeTxt[0].replace(/[^0-9]/g, ""), 10) - 1;
      row[1] = parseInt(rangeTxt[1].replace(/[^0-9]/g, ""), 10) - 1;
      if (Number.isNaN(row[0])) {
        row[0] = 0;
      }
      if (Number.isNaN(row[1])) {
        row[1] = maxRow;
      }
      if (row[0] > row[1]) {
        return DEFAULT_RANGE_ARRAY;
      }
      col[0] = Tools.ABCatNum(rangeTxt[0].replace(/[^A-Za-z]/g, ""));
      col[1] = Tools.ABCatNum(rangeTxt[1].replace(/[^A-Za-z]/g, ""));
      if (Number.isNaN(col[0])) {
        col[0] = 0;
      }
      if (Number.isNaN(col[1])) {
        col[1] = maxCol;
      }
      if (col[0] > col[1]) {
        return DEFAULT_RANGE_ARRAY;
      }
      const item = {
        sheetId: this.getSheetBySheetName(sheetTxt)?.getSheetId() || "",
        rangeData: {
          startRow: row[0],
          endRow: row[1],
          startColumn: col[0],
          endColumn: col[1]
        }
      };
      return item;
    }
  };

  // ../../packages/core/src/Shared/Common.ts
  function makeCellToSelection(cellInfo) {
    if (!cellInfo) {
      return;
    }
    let { row, column, startY, endY, startX, endX, isMerged, mergeInfo } = cellInfo;
    let startRow = row;
    let startColumn = column;
    let endRow = row;
    let endColumn = column;
    if (isMerged && mergeInfo) {
      const {
        startRow: mergeStartRow,
        startColumn: mergeStartColumn,
        endRow: mergeEndRow,
        endColumn: mergeEndColumn,
        startY: mergeStartY,
        endY: mergeEndY,
        startX: mergeStartX,
        endX: mergeEndX
      } = mergeInfo;
      startRow = mergeStartRow;
      startColumn = mergeStartColumn;
      endRow = mergeEndRow;
      endColumn = mergeEndColumn;
      startY = mergeStartY;
      endY = mergeEndY;
      startX = mergeStartX;
      endX = mergeEndX;
    }
    return {
      startRow,
      startColumn,
      endRow,
      endColumn,
      startY,
      endY,
      startX,
      endX
    };
  }
  function isEmptyCell(cell) {
    if (!cell) {
      return true;
    }
    const content = cell?.m || "";
    if (content.length === 0 && !cell.p) {
      return true;
    }
    return false;
  }
  function getColorStyle(color) {
    if (color) {
      if (color.rgb) {
        return color.rgb;
      }
      if (color.th) {
        return new ColorBuilder().setThemeColor(color.th).asThemeColor().asRgbColor().getCssString();
      }
    }
    return null;
  }
  function isFormulaString(value) {
    return Tools.isString(value) && value.indexOf("=") === 0 && value.length > 1;
  }
  function handleJsonToDom(p4) {
    let span = "";
    if (p4.body?.blockElements) {
      for (let k5 in p4.body.blockElements) {
        const section = p4.body.blockElements[k5];
        if (section.blockType !== 0 /* PARAGRAPH */ && section.blockType !== 2 /* SECTION_BREAK */) {
          continue;
        }
        if (section.blockType === 0 /* PARAGRAPH */) {
          for (let i4 in section.paragraph) {
            const element = section.paragraph[i4];
            for (let j3 in element) {
              const item = element[j3];
              if (item.et === 0 /* TEXT_RUN */) {
                let style = `display:inline-block;${handleStyleToString(
                  item.tr.ts
                )}`;
                span += `<span id='${item.eId}' ${style.length ? `style="${style}"` : ""} >${item.tr.ct}</span>`;
              }
            }
          }
        }
      }
    }
    return span;
  }
  function handleStyleToString(style, isCell = false) {
    let str = "";
    const styleMap = /* @__PURE__ */ new Map([
      [
        "ff",
        () => {
          if (style.ff) {
            str += `font-family: ${style.ff}; `;
          }
        }
      ],
      [
        "fs",
        () => {
          if (style.fs) {
            let fs = style.fs;
            if (style.va) {
              fs /= 2;
            }
            str += `font-size: ${fs}pt; `;
          }
        }
      ],
      [
        "it",
        () => {
          if (style.it) {
            str += `font-style: italic; `;
          } else {
            str += `font-style: normal; `;
          }
        }
      ],
      [
        "bl",
        () => {
          if (style.bl) {
            str += `font-weight: bold; `;
          } else {
            str += `font-weight: normal; `;
          }
        }
      ],
      [
        "ul",
        () => {
          if (style.ul?.s) {
            if (str.indexOf("text-decoration-line") > -1) {
              str = str.replace(
                /(?<=text-decoration-line:.*)\b(?=;)/g,
                " underline"
              );
            } else {
              str += `text-decoration-line: underline; `;
            }
            if (style.ul.cl && str.indexOf("text-decoration-color") === -1) {
              str += `text-decoration-color: ${getColorStyle(
                style.ul.cl
              )}; `;
            }
            if (style.ul.t && str.indexOf("text-decoration-style") === -1) {
              str += `text-decoration-style: ${style.ul.t} `;
            }
          }
        }
      ],
      [
        "st",
        () => {
          if (style.st?.s) {
            if (str.indexOf("text-decoration-line") > -1) {
              str = str.replace(
                /(?<=text-decoration-line:.*)\b(?=;)/g,
                " line-through"
              );
            } else {
              str += `text-decoration-line: line-through; `;
            }
            if (style.st.cl && str.indexOf("text-decoration-color") === -1) {
              str += `text-decoration-color: ${getColorStyle(
                style.st.cl
              )}; `;
            }
            if (style.st.t && str.indexOf("text-decoration-style") === -1) {
              str += `text-decoration-style: ${style.st.t} `;
            }
          }
        }
      ],
      [
        "ol",
        () => {
          if (style.ol?.s) {
            if (str.indexOf("text-decoration-line") > -1) {
              str = str.replace(
                /(?<=text-decoration-line:.*)\b(?=;)/g,
                " overline"
              );
            } else {
              str += `text-decoration-line: overline; `;
            }
            if (style.ol.cl && str.indexOf("text-decoration-color") === -1) {
              str += `text-decoration-color: ${getColorStyle(
                style.ol.cl
              )}; `;
            }
            if (style.ol.t && str.indexOf("text-decoration-style") === -1) {
              str += `text-decoration-style: ${style.ol.t} `;
            }
          }
        }
      ],
      [
        "bg",
        () => {
          str += `background: ${getColorStyle(style.bg)}; `;
        }
      ],
      [
        "bd",
        () => {
          if (style.bd?.b) {
            str += `border-bottom: ${getBorderStyle(style.bd?.b.s)} ${getColorStyle(style.bd.b.cl) ?? ""}; `;
          }
          if (style.bd?.t) {
            str += `border-top: ${getBorderStyle(style.bd?.t.s)} ${getColorStyle(style.bd.t.cl) ?? ""}; `;
          }
          if (style.bd?.r) {
            str += `border-right: ${getBorderStyle(style.bd?.r.s)} ${getColorStyle(style.bd.r.cl) ?? ""}; `;
          }
          if (style.bd?.l) {
            str += `border-left: ${getBorderStyle(style.bd?.l.s)} ${getColorStyle(style.bd.l.cl) ?? ""}; `;
          }
        }
      ],
      [
        "cl",
        () => {
          str += `color: ${getColorStyle(style.cl)}; `;
        }
      ],
      [
        "va",
        () => {
          if (style.va === 0 /* NORMAL */) {
            str += `vertical-align: baseline; `;
          } else if (style.va === 1 /* SUBSCRIPT */) {
            str += `vertical-align: sub; `;
          } else {
            str += `vertical-align: super; `;
          }
        }
      ],
      [
        "td",
        () => {
          if (style.td === 0 /* UNSPECIFIED */) {
            str += `direction: inherit; `;
          } else if (style.td === 1 /* LEFT_TO_RIGHT */) {
            str += `direction: ltr; `;
          } else {
            str += `direction: rtl; `;
          }
        }
      ],
      [
        "tr",
        () => {
          str += `data-rotate: (${style.tr?.a}deg${style.tr?.v ? ` ,${style.tr?.v}` : ""});`;
        }
      ],
      [
        "ht",
        () => {
          if (style.ht === 0 /* UNSPECIFIED */) {
            str += `text-align: inherit; `;
          } else if (style.ht === 1 /* LEFT */) {
            str += `text-align: left; `;
          } else if (style.ht === 3 /* RIGHT */) {
            str += `text-align: right; `;
          } else if (style.ht === 2 /* CENTER */) {
            str += `text-align: center; `;
          } else {
            str += `text-align: justify; `;
          }
        }
      ],
      [
        "vt",
        () => {
          if (style.vt === 0 /* UNSPECIFIED */) {
            str += `vertical-align: inherit; `;
          } else if (style.vt === 3 /* BOTTOM */) {
            str += `vertical-align: bottom; `;
          } else if (style.vt === 1 /* TOP */) {
            str += `vertical-align: top; `;
          } else {
            str += `vertical-align: middle; `;
          }
        }
      ],
      [
        "tb",
        () => {
          if (style.tb === 2 /* CLIP */) {
            str += `text-overflow: clip; `;
          } else if (style.tb === 1 /* OVERFLOW */) {
            str += `text-break: overflow; `;
          } else if (style.tb === 3 /* WRAP */) {
            str += `word-wrap: break-word; word-break: normal; `;
          }
        }
      ],
      [
        "pd",
        () => {
          let b4 = `${style.pd?.b}pt`;
          let t4 = `${style.pd?.t}pt`;
          let l4 = `${style.pd?.l}pt`;
          let r4 = `${style.pd?.r}pt`;
          if (style.pd?.b) {
            str += `padding-bottom: ${b4}; `;
          }
          if (style.pd?.t) {
            str += `padding-top: ${t4}; `;
          }
          if (style.pd?.l) {
            str += `padding-left: ${l4}; `;
          }
          if (style.pd?.r) {
            str += `padding-right: ${r4}; `;
          }
        }
      ]
    ]);
    const cellSkip = ["bd", "tr", "tb"];
    for (let k5 in style) {
      if (isCell && cellSkip.includes(k5))
        continue;
      styleMap.get(k5)?.();
    }
    return str;
  }
  function getBorderStyle(type) {
    let str = "";
    if (type === 0 /* NONE */) {
      str = "none";
    } else if (type === 1 /* THIN */) {
      str = "0.5pt solid";
    } else if (type === 2 /* HAIR */) {
      str = "0.5pt double";
    } else if (type === 3 /* DOTTED */) {
      str = "0.5pt dotted";
    } else if (type === 4 /* DASHED */) {
      str = "0.5pt dashed";
    } else if (type === 5 /* DASH_DOT */) {
      str = "0.5pt dashed";
    } else if (type === 6 /* DASH_DOT_DOT */) {
      str = "0.5pt dotted";
    } else if (type === 7 /* DOUBLE */) {
      str = "0.5pt double";
    } else if (type === 8 /* MEDIUM */) {
      str = "1pt solid";
    } else if (type === 9 /* MEDIUM_DASHED */) {
      str = "1pt dashed";
    } else if (type === 10 /* MEDIUM_DASH_DOT */) {
      str = "1pt dashed";
    } else if (type === 11 /* MEDIUM_DASH_DOT_DOT */) {
      str = "1pt dotted";
    } else if (type === 12 /* SLANT_DASH_DOT */) {
      str = "0.5pt dashed";
    } else if (type === 13 /* THICK */) {
      str = "1.5pt solid";
    }
    return str;
  }

  // ../../packages/core/src/Shared/IOHttp.ts
  function extend(src, ...target) {
    for (const item of target) {
      if (item) {
        for (const key in item) {
          if (item.hasOwnProperty(key)) {
            if (isDef(item[key])) {
              src[key] = item[key];
            }
          }
        }
      }
    }
    return src;
  }
  function isDef(v4) {
    return v4 !== void 0 && v4 !== null;
  }
  function isString(value) {
    return Object.prototype.toString.apply(value) === "[object String]";
  }
  function ispPlain(value) {
    return value ? Object.getPrototypeOf(value) === Object.getPrototypeOf({}) : false;
  }
  function isArray(value) {
    return Object.prototype.toString.apply(value) === "[object Array]";
  }
  function isFormData(value) {
    return value instanceof FormData;
  }
  var noop = () => {
  };
  var defaultFilter = (data) => data;
  var defaultConfig = {
    type: "POST" /* POST */,
    url: "",
    async: true,
    header: {},
    dataType: "json" /* JSON */,
    contentType: "application/x-www-form-urlencoded; charset=UTF-8",
    data: {},
    username: "",
    password: "",
    timeout: 500,
    error: noop,
    beforeSend: defaultFilter,
    dataFilter: defaultFilter,
    success: noop,
    complete: noop
  };
  function IOHttp(config) {
    return new Promise((resolve, reject) => {
      const setting = extend({}, defaultConfig, config);
      const request = new XMLHttpRequest();
      setting.beforeSend(setting);
      request.responseType = setting.dataType;
      request.timeout = setting.timeout;
      request.addEventListener("readystatechange", (event) => {
        if (request.readyState === 4 /* DONE */) {
          if (request.status === 200) {
            const filter = setting.dataFilter(request.response);
            setting.success(filter);
            setting.complete();
            resolve(filter);
          } else {
            setting.error(event);
            reject(event);
          }
        }
      });
      request.addEventListener("timeout", (event) => {
        setting.error(event);
      });
      request.open(
        setting.type,
        setting.url,
        setting.async,
        setting.username,
        setting.password
      );
      Object.keys(setting.header).forEach((key) => {
        const value = setting.header[key];
        request.setRequestHeader(key, value);
      });
      if (isFormData(setting.data)) {
        request.setRequestHeader("Content-Type", "multipart/form-data");
      } else if (setting.contentType) {
        request.setRequestHeader("Content-Type", setting.contentType);
      }
      switch (setting.type) {
        case "DELETE" /* DELETE */:
        case "GET" /* GET */: {
          request.send();
          break;
        }
        case "POST" /* POST */:
        case "PUT" /* PUT */: {
          if (ispPlain(setting.data)) {
            request.send(JSON.stringify(setting.data));
            return;
          }
          if (isString(setting.data)) {
            request.send(setting.data);
            return;
          }
          if (isArray(setting.data)) {
            request.send(JSON.stringify(setting.data));
            return;
          }
          if (isFormData(setting.data)) {
            request.send(setting.data);
          }
          break;
        }
      }
    });
  }

  // ../../packages/core/src/Shared/IOSocket.ts
  function unDef(v4) {
    return v4 === void 0 || v4 === null;
  }
  function isBlank(v4) {
    return unDef(v4) || v4.toString() === "";
  }
  var defaultConfig2 = {
    url: "",
    heartbeatTime: 1e3 * 30
  };
  var HEART_BEAT_MESSAGE = "heart_beat_message";
  var IOSocket = class {
    _config;
    _listens;
    _timer;
    _socket;
    constructor(config) {
      const setting = Object.assign(defaultConfig2, config);
      if (isBlank(setting.url)) {
        throw new Error("url must be input");
      }
      this._listens = /* @__PURE__ */ new Map();
      this._timer = -1;
      this._config = setting;
    }
    link() {
      this._create();
      this._bind();
    }
    send(body) {
      this._socket.send(body);
    }
    destroy() {
      const listen = this._listens.get("destroy" /* DESTROY */);
      if (listen) {
        listen();
      }
      this._clear();
      this._listens.clear();
    }
    on(type, listen) {
      this._listens.set(type, listen);
    }
    close() {
      this._socket && this._socket.close();
    }
    _create() {
      const { _config } = this;
      this._socket = new WebSocket(_config.url);
    }
    _bind() {
      this._socket.addEventListener(
        "message" /* MESSAGE */,
        this._message.bind(this)
      );
      this._socket.addEventListener(
        "open" /* OPEN */,
        this._open.bind(this)
      );
      this._socket.addEventListener(
        "close" /* CLOSE */,
        this._close.bind(this)
      );
      this._socket.addEventListener(
        "error" /* ERROR */,
        this._error.bind(this)
      );
    }
    _message(event) {
      const listen = this._listens.get("message" /* MESSAGE */);
      if (listen) {
        listen(event);
      }
    }
    _open(event) {
      const listen = this._listens.get("open" /* OPEN */);
      if (listen) {
        listen(event);
        this._heartbeat();
      }
    }
    _error(event) {
      const listen = this._listens.get("error" /* ERROR */);
      if (listen) {
        listen(event);
        this._retry();
      }
    }
    _close(event) {
      const listen = this._listens.get("close" /* CLOSE */);
      if (listen) {
        listen(event);
        this.destroy();
      }
    }
    _clear() {
      if (this._timer > -1) {
        clearInterval(this._timer);
      }
      this._timer = -1;
      this._socket.removeEventListener(
        "message" /* MESSAGE */,
        this._message.bind(this)
      );
      this._socket.removeEventListener(
        "open" /* OPEN */,
        this._open.bind(this)
      );
      this._socket.removeEventListener(
        "close" /* CLOSE */,
        this._close.bind(this)
      );
      this._socket.removeEventListener(
        "error" /* ERROR */,
        this._error.bind(this)
      );
    }
    _heartbeat() {
      const { _socket, _config } = this;
      const { heartbeatTime } = _config;
      function handle() {
        _socket.send(HEART_BEAT_MESSAGE);
      }
      this._timer = setInterval(handle, heartbeatTime);
    }
    _retry() {
      const listen = this._listens.get("retry" /* RETRY */);
      if (listen) {
        listen();
      }
      this._clear();
      this._create();
      this._bind();
    }
  };

  // ../../packages/core/src/Shared/KeyboardUtil.ts
  var allKeys = Object.keys(KEYBOARD_KEYS).reduce(
    (acc, category) => [...acc, ...KEYBOARD_KEYS[category]],
    []
  );
  function isKeyPrintable(key) {
    return allKeys.indexOf(key) === -1;
  }

  // ../../packages/core/src/Shared/Locale.ts
  var zh = {};
  var en = {};
  var Locale = class {
    options;
    /**
     * get value from Locale object and key
     * @param locale - A specified language pack
     * @param key - Specify key
     * @returns Get the translation corresponding to the Key
     *
     * @private
     */
    static getValue(locale, key) {
      try {
        return locale[key] ? locale[key] : key.split(".").reduce((a4, b4) => a4[b4], locale);
      } catch (error2) {
        console.error("Key %s not found", key);
      }
    }
    initialize(locale) {
      this.options = {
        // use config first, or get language setting from browser
        currentLocale: locale || ["zh", "zh-CN"].includes(Tools.getLanguage()) ? "zh" /* ZH */ : "en" /* EN */,
        locales: { zh, en }
      };
    }
    /**
     * Get the formatted message by key
     *
     * @example
     * ```ts
     * Locale.get('name')
     * ```
     *
     * @param key - The string representing key in Locale data file
     * @returns Get the translation corresponding to the Key
     */
    get(key) {
      if (key) {
        const { locales, currentLocale } = this.options;
        return Locale.getValue(locales[currentLocale], key) || key;
      }
      return String();
    }
    getObject(key) {
      const { locales, currentLocale } = this.options;
      return Locale.getValue(locales[currentLocale], key);
    }
    /**
     * Load more locales after init
     *
     * @example
     * ```ts
     * Locale.load({zh,en})
     * ```
     *
     * @param locales - Locale object
     * @returns void
     *
     */
    load(locales) {
      Tools.deepMerge(this.options.locales, locales);
    }
    /**
     * change Locale
     *
     * @example
     * Change to Chinese
     * ```ts
     * Locale.change(LocaleType.ZH)
     * ```
     *
     * @param locale - Locale Type, see {@link LocaleType}
     *
     */
    change(locale) {
      this.options.currentLocale = locale;
    }
    getCurrentLocale() {
      return this.options.currentLocale;
    }
  };

  // ../../packages/core/src/Shared/Logger.ts
  var Logger = class {
    static log(...value) {
      if (console) {
        console.log(...value);
      }
    }
    static info(...value) {
      if (console) {
        console.info(...value);
      }
    }
    static error(...value) {
      if (console) {
        console.error(...value);
      }
    }
    static warn(...value) {
      if (console) {
        console.warn(...value);
      }
    }
    static br() {
      Logger.info("\n");
    }
    static capsule(env, version, prefix = "", suffix = "") {
      if (console) {
        console.log(
          `%c${prefix}%c${env}%c${version}%c${suffix}`,
          "",
          "padding:3px;color:white;background:#023047",
          "padding:3px;color:white;background:#219EBC",
          ""
        );
      }
    }
  };

  // ../../packages/core/src/Shared/LRU/LRUHelper.ts
  var LRUHelper = class {
    static hasLength(array, size) {
      return array.length === size;
    }
    static getValueType(value) {
      return Object.prototype.toString.apply(value);
    }
    static isObject(value) {
      return this.getValueType(value) === "[object Object]";
    }
    static isIterable(value) {
      return value[Symbol.iterator] != null;
    }
    static isNumber(value) {
      return this.getValueType(value) === "[object Number]";
    }
  };

  // ../../packages/core/src/Shared/LRU/LRUMap.ts
  var NEWER = Symbol("newer");
  var OLDER = Symbol("older");
  var KeyIterator = class {
    entry;
    constructor(oldestEntry) {
      this.entry = oldestEntry;
    }
    [Symbol.iterator]() {
      return this;
    }
    next() {
      let ent = this.entry;
      if (ent) {
        this.entry = ent[NEWER];
        return { done: false, value: ent.key };
      }
      return { done: true, value: void 0 };
    }
  };
  var ValueIterator = class {
    entry;
    constructor(oldestEntry) {
      this.entry = oldestEntry;
    }
    [Symbol.iterator]() {
      return this;
    }
    next() {
      let ent = this.entry;
      if (ent) {
        this.entry = ent[NEWER];
        return { done: false, value: ent.value };
      }
      return { done: true, value: void 0 };
    }
  };
  var EntryIterator = class {
    entry;
    constructor(oldestEntry) {
      this.entry = oldestEntry;
    }
    [Symbol.iterator]() {
      return this;
    }
    next() {
      let ent = this.entry;
      if (ent) {
        this.entry = ent[NEWER];
        return { done: false, value: [ent.key, ent.value] };
      }
      return { done: true, value: void 0 };
    }
  };
  var Entry = class {
    key;
    value;
    [NEWER];
    [OLDER];
    constructor(key, value) {
      this.key = key;
      this.value = value;
      this[NEWER] = void 0;
      this[OLDER] = void 0;
    }
    toJSON() {
      return {
        key: this.key,
        value: this.value
      };
    }
  };
  var LRUMap = class {
    _keymap;
    size;
    limit;
    oldest;
    newest;
    constructor(...parameter) {
      if (LRUHelper.hasLength(parameter, 1)) {
        if (LRUHelper.isNumber(parameter[0])) {
          const limit = parameter[0];
          this._initialize(limit, void 0);
          return;
        }
        if (LRUHelper.isIterable(parameter[0])) {
          const entries = parameter[0];
          this._initialize(0, entries);
          return;
        }
        return;
      }
      if (LRUHelper.hasLength(parameter, 2)) {
        const limit = parameter[0];
        const entries = parameter[1];
        this._initialize(limit, entries);
      }
    }
    _initialize(limit, entries) {
      this.oldest = void 0;
      this.newest = void 0;
      this.size = 0;
      this.limit = limit;
      this._keymap = /* @__PURE__ */ new Map();
      if (entries) {
        this.assign(entries);
        if (limit < 1) {
          this.limit = this.size;
        }
      }
    }
    _markEntryAsUsed(entry) {
      if (entry === this.newest) {
        return;
      }
      if (entry[NEWER]) {
        if (entry === this.oldest) {
          this.oldest = entry[NEWER];
        }
        entry[NEWER][OLDER] = entry[OLDER];
      }
      if (entry[OLDER]) {
        entry[OLDER][NEWER] = entry[NEWER];
      }
      entry[NEWER] = void 0;
      entry[OLDER] = this.newest;
      if (this.newest) {
        this.newest[NEWER] = entry;
      }
      this.newest = entry;
    }
    assign(entries) {
      let entry;
      let limit = this.limit || Number.MAX_VALUE;
      this._keymap.clear();
      let it = entries[Symbol.iterator]();
      for (let itv = it.next(); !itv.done; itv = it.next()) {
        let e4 = new Entry(itv.value[0], itv.value[1]);
        this._keymap.set(e4.key, e4);
        if (!entry) {
          this.oldest = e4;
        } else {
          entry[NEWER] = e4;
          e4[OLDER] = entry;
        }
        entry = e4;
        if (limit-- === 0) {
          throw new Error("overflow");
        }
      }
      this.newest = entry;
      this.size = this._keymap.size;
    }
    set(key, value) {
      let entry = this._keymap.get(key);
      if (entry) {
        entry.value = value;
        this._markEntryAsUsed(entry);
        return this;
      }
      this._keymap.set(key, entry = new Entry(key, value));
      if (this.newest) {
        this.newest[NEWER] = entry;
        entry[OLDER] = this.newest;
      } else {
        this.oldest = entry;
      }
      this.newest = entry;
      ++this.size;
      if (this.size > this.limit) {
        this.shift();
      }
      return this;
    }
    shift() {
      let entry = this.oldest;
      if (entry) {
        if (this.oldest && this.oldest[NEWER]) {
          this.oldest = this.oldest[NEWER];
          this.oldest[OLDER] = void 0;
        } else {
          this.oldest = void 0;
          this.newest = void 0;
        }
        entry[NEWER] = entry[OLDER] = void 0;
        this._keymap.delete(entry.key);
        --this.size;
        return [entry.key, entry.value];
      }
    }
    get(key) {
      const entry = this._keymap.get(key);
      if (!entry)
        return;
      this._markEntryAsUsed(entry);
      return entry.value;
    }
    has(key) {
      return this._keymap.has(key);
    }
    find(key) {
      let e4 = this._keymap.get(key);
      return e4 ? e4.value : void 0;
    }
    delete(key) {
      let entry = this._keymap.get(key);
      if (!entry)
        return;
      this._keymap.delete(entry.key);
      if (entry[NEWER] && entry[OLDER]) {
        entry[OLDER][NEWER] = entry[NEWER];
        entry[NEWER][OLDER] = entry[OLDER];
      } else if (entry[NEWER]) {
        entry[NEWER][OLDER] = void 0;
        this.oldest = entry[NEWER];
      } else if (entry[OLDER]) {
        entry[OLDER][NEWER] = void 0;
        this.newest = entry[OLDER];
      } else {
        this.oldest = this.newest = void 0;
      }
      this.size--;
      return entry.value;
    }
    clear() {
      this.oldest = void 0;
      this.newest = void 0;
      this.size = 0;
      this._keymap.clear();
    }
    keys() {
      return new KeyIterator(this.oldest);
    }
    values() {
      return new ValueIterator(this.oldest);
    }
    entries() {
      return this[Symbol.iterator]();
    }
    [Symbol.iterator]() {
      return new EntryIterator(this.oldest);
    }
    forEach(fun, thisObj) {
      if (typeof thisObj !== "object") {
        thisObj = this;
      }
      let entry = this.oldest;
      while (entry) {
        fun.call(thisObj, entry.value, entry.key, this);
        entry = entry[NEWER];
      }
    }
    toJSON() {
      let s4 = new Array(this.size);
      let i4 = 0;
      let entry = this.oldest;
      while (entry) {
        s4[i4++] = { key: entry.key, value: entry.value };
        entry = entry[NEWER];
      }
      return s4;
    }
    toString() {
      let s4 = String();
      let entry = this.oldest;
      while (entry) {
        s4 += `${String(entry.key)}:${entry.value}`;
        entry = entry[NEWER];
        if (entry) {
          s4 += " < ";
        }
      }
      return s4;
    }
  };

  // ../../packages/core/src/Shared/NameGen.ts
  var include = [];
  var identity = 0;
  var NameGen = class {
    static getSheetName(name) {
      if (name === void 0) {
        name = NameGen._generateName();
      }
      while (NameGen._checkedName(name)) {
        name = NameGen._generateName();
      }
      return name;
    }
    static _generateName() {
      return `sheet${++identity}`;
    }
    static _checkedName(name) {
      const checked = include.includes(name);
      if (!checked) {
        include.push(name);
      }
      return checked;
    }
  };

  // ../../packages/core/src/Shared/Rectangle.ts
  var Rectangle = class {
    startRow;
    startColumn;
    endRow;
    endColumn;
    constructor(...argument) {
      if (Tools.hasLength(argument, 0)) {
        this.startRow = 0;
        this.startColumn = 0;
        this.endRow = 0;
        this.endColumn = 0;
        return;
      }
      if (Tools.hasLength(argument, 1)) {
        const rectangle = argument[0];
        this.startRow = rectangle.startRow;
        this.startColumn = rectangle.startColumn;
        this.endRow = rectangle.endRow;
        this.endColumn = rectangle.endColumn;
        return;
      }
      if (Tools.hasLength(argument, 4)) {
        const startRow = argument[0];
        const startColumn = argument[1];
        const endRow = argument[2];
        const endColumn = argument[3];
        this.startRow = startRow;
        this.startColumn = startColumn;
        this.endRow = endRow;
        this.endColumn = endColumn;
      }
    }
    intersects(rectangle) {
      const currentStartRow = this.startRow;
      const currentEndRow = this.endRow;
      const currentStartColumn = this.startColumn;
      const currentEndColumn = this.endColumn;
      const incomingStartRow = rectangle.startRow;
      const incomingEndRow = rectangle.endRow;
      const incomingStartColumn = rectangle.startColumn;
      const incomingEndColumn = rectangle.endColumn;
      const zx = Math.abs(
        currentStartColumn + currentEndColumn - incomingStartColumn - incomingEndColumn
      );
      const x4 = Math.abs(currentStartColumn - currentEndColumn) + Math.abs(incomingStartColumn - incomingEndColumn);
      const zy = Math.abs(
        currentStartRow + currentEndRow - incomingStartRow - incomingEndRow
      );
      const y4 = Math.abs(currentStartRow - currentEndRow) + Math.abs(incomingStartRow - incomingEndRow);
      return zx <= x4 && zy <= y4;
    }
    union(rectangle) {
      const { startRow, startColumn, endRow, endColumn } = this;
      return new Rectangle(
        rectangle.startRow < this.startRow ? rectangle.startRow : startRow,
        rectangle.startColumn < startColumn ? rectangle.startColumn : startColumn,
        rectangle.endRow > endRow ? rectangle.endRow : endRow,
        rectangle.endColumn > endColumn ? rectangle.endColumn : endColumn
      );
    }
    getData() {
      return {
        startRow: this.startRow,
        startColumn: this.startColumn,
        endRow: this.endRow,
        endColumn: this.endColumn
      };
    }
    equals(rectangle) {
      return this.endRow === rectangle.endRow && this.endColumn === rectangle.endColumn && this.startRow === rectangle.startRow && this.startColumn === rectangle.startColumn;
    }
  };

  // ../../packages/core/src/Shared/Reference.ts
  var COLON_SYMBOL = ":";
  var $ROW_REGEX = /[^0-9]/g;
  var $COLUMN_REGEX = /[^A-Za-z]/g;
  function singleReferenceToGrid(refBody) {
    let row = parseInt(refBody.replace($ROW_REGEX, "")) - 1;
    let column = Tools.ABCatNum(refBody.replace($COLUMN_REGEX, ""));
    return {
      row,
      column
    };
  }
  function referenceToGrid(refString) {
    const sheetNameIndex = refString.indexOf("!");
    let sheetName = "";
    let refBody = "";
    if (sheetNameIndex > -1) {
      sheetName = refString.substring(0, sheetNameIndex);
      refBody = refString.substring(sheetNameIndex);
    } else {
      refBody = refString;
    }
    let colonIndex = refBody.indexOf(COLON_SYMBOL);
    if (colonIndex === -1) {
      const grid = singleReferenceToGrid(refBody);
      const row = grid.row;
      const column = grid.column;
      const rangeData2 = {
        startRow: row,
        startColumn: column,
        endRow: row,
        endColumn: column
      };
      return {
        sheetName,
        rangeData: rangeData2
      };
    }
    const refStartString = refBody.substring(0, colonIndex);
    const refEndString = refBody.substring(colonIndex + 1);
    const startGrid = singleReferenceToGrid(refStartString);
    const endGrid = singleReferenceToGrid(refEndString);
    const startRow = startGrid.row;
    const startColumn = startGrid.column;
    const endRow = endGrid.row;
    const endColumn = endGrid.column;
    const rangeData = {
      startRow,
      startColumn,
      endRow,
      endColumn
    };
    return {
      sheetName,
      rangeData
    };
  }

  // ../../packages/core/src/Shared/Sequence.ts
  var orderA = "A".charCodeAt(0);
  var orderZ = "Z".charCodeAt(0);
  var order_a = "a".charCodeAt(0);
  var order_z = "z".charCodeAt(0);
  function numberToABC(n3) {
    const len = orderZ - orderA + 1;
    let s4 = "";
    while (n3 >= 0) {
      s4 = String.fromCharCode(n3 % len + orderA) + s4;
      n3 = Math.floor(n3 / len) - 1;
    }
    return s4;
  }
  function repeatStringNumTimes(string, times) {
    let repeatedString = "";
    while (times > 0) {
      repeatedString += string;
      times--;
    }
    return repeatedString;
  }
  function numberToListABC(n3, uppercase = false) {
    const len = orderZ - orderA + 1;
    let order = order_a;
    if (uppercase) {
      order = orderA;
    }
    const abc = String.fromCharCode(n3 % len + order);
    let times = Math.floor(n3 / len) + 1;
    return repeatStringNumTimes(abc, times);
  }

  // ../../packages/core/src/Shared/Serialize/Serializer.ts
  var Serializer = class {
    static fromSequence(sequence) {
      if (Tools.isObject(sequence)) {
        if (Serializer.requiredNewInstance(this)) {
          const SerializerClass = this;
          return SerializerClass.newInstance(sequence);
        }
      }
      if (Tools.isArray(sequence)) {
        if (Serializer.requiredNewInstance(this)) {
          const SerializerClass = this;
          return sequence.map(
            (element) => SerializerClass.newInstance(element)
          );
        }
      }
      return [];
    }
    toSequence() {
      return { className: Tools.getClassName(this) };
    }
  };
  ((Serializer2) => {
    function requiredNewInstance(target) {
      if (Tools.isDefine(target.newInstance)) {
        return true;
      }
      throw new Error("sequence newInstance need subclass implement!");
    }
    Serializer2.requiredNewInstance = requiredNewInstance;
  })(Serializer || (Serializer = {}));

  // ../../packages/core/src/Shared/SortRules.ts
  function sortRules(oa, ob) {
    if (oa.zIndex > ob.zIndex) {
      return 1;
    }
    if (oa.zIndex === ob.zIndex) {
      return 0;
    }
    return -1;
  }
  function sortRulesByDesc(oa, ob) {
    if (oa.zIndex > ob.zIndex) {
      return -1;
    }
    if (oa.zIndex === ob.zIndex) {
      return 0;
    }
    return 1;
  }

  // ../../packages/core/src/Shared/Tuples.ts
  var _Tuples = class {
    static checkup(target, ...types) {
      if (target.length !== types.length) {
        return false;
      }
      const length = target.length;
      for (let i4 = 0; i4 < length; i4++) {
        const element = target[i4];
        const type = types[i4];
        switch (type) {
          case _Tuples.BOOLEAN_TYPE: {
            if (!Tools.isBoolean(element)) {
              return false;
            }
            break;
          }
          case _Tuples.NUMBER_TYPE: {
            if (!Tools.isNumber(element)) {
              return false;
            }
            break;
          }
          case _Tuples.STRING_TYPE: {
            if (!Tools.isString(element)) {
              return false;
            }
            break;
          }
          case _Tuples.FUNCTION_TYPE: {
            if (!Tools.isFunction(element)) {
              return false;
            }
            break;
          }
          case _Tuples.OBJECT_TYPE: {
            if (!Tools.isPlainObject(element)) {
              return false;
            }
            break;
          }
          default: {
            if (!Tools.isAssignableFrom(element, type)) {
              return false;
            }
            break;
          }
        }
      }
      return true;
    }
  };
  var Tuples = _Tuples;
  __publicField(Tuples, "STRING_TYPE", 1);
  __publicField(Tuples, "NUMBER_TYPE", 2);
  __publicField(Tuples, "BOOLEAN_TYPE", 3);
  __publicField(Tuples, "FUNCTION_TYPE", 4);
  __publicField(Tuples, "OBJECT_TYPE", 5);

  // ../../packages/core/src/Shared/HashAlgorithm.ts
  function hashAlgorithm(str) {
    let hash = 0;
    for (let i4 = 0; i4 < str.length; i4++) {
      hash = str.charCodeAt(i4) + (hash << 6) + (hash << 16) - hash;
    }
    return hash >>> 0;
  }

  // ../../packages/core/src/Observer/ObserverManager.ts
  var PathObservable = class {
    namespace;
    path;
    observable;
    constructor(path, namespace, observable) {
      this.path = path;
      this.namespace = namespace;
      this.observable = observable;
    }
  };
  var ObserverManager = class {
    _observableArray = [];
    hasObserver(name, namespace) {
      return this.getObserver(name, namespace) != null;
    }
    getObserver(...parameter) {
      if (parameter.length === 1) {
        const name = parameter[0];
        const item = this._observableArray.find((obs) => obs.path === name);
        return item ? item.observable : null;
      }
      if (parameter.length === 2) {
        const name = parameter[0];
        const namespace = parameter[1];
        const item = this._observableArray.find(
          (obs) => obs.path === name && obs.namespace === namespace
        );
        return item ? item.observable : null;
      }
    }
    requiredObserver(...parameter) {
      if (Tools.hasLength(parameter, 1)) {
        const name = parameter[0];
        const observable = this.getObserver(name);
        if (observable == null) {
          throw new Error(`not found observable ${name}`);
        }
        return observable;
      }
      if (Tools.hasLength(parameter, 2)) {
        const name = parameter[0];
        const namespace = parameter[1];
        const observable = this.getObserver(name, namespace);
        if (observable == null) {
          throw new Error(`not found observable ${name}`);
        }
        return observable;
      }
      throw new Error(`requiredObserver arguments error`);
    }
    removeObserver(...parameter) {
      if (Tools.hasLength(parameter, 1)) {
        const name = parameter[0];
        const index = this._observableArray.findIndex(
          (obs) => obs.path === name
        );
        if (index > -1) {
          this._observableArray.splice(index, 1);
        }
        return;
      }
      if (Tools.hasLength(parameter, 2)) {
        const name = parameter[0];
        const namespace = parameter[1];
        const index = this._observableArray.findIndex(
          (obs) => obs.path === name && obs.namespace === namespace
        );
        if (index > -1) {
          this._observableArray.splice(index, 1);
        }
      }
    }
    addObserver(...parameter) {
      if (parameter.length === 1) {
        const name = parameter[0];
        const observable = parameter[1];
        if (this.hasObserver(name, name)) {
          this.removeObserver(name);
        }
        this._observableArray.push(
          new PathObservable(name, name, observable)
        );
        return;
      }
      if (parameter.length === 3) {
        const name = parameter[0];
        const namespace = parameter[1];
        const observable = parameter[2];
        if (this.hasObserver(name, name)) {
          this.removeObserver(name, namespace);
        }
        this._observableArray.push(
          new PathObservable(name, namespace, observable)
        );
      }
    }
  };

  // ../../packages/core/src/Command/ActionObservers.ts
  var ActionObservers = class extends Observable {
  };

  // ../../packages/core/src/Command/CommandInjectorObservers.ts
  var CommandInjectorObservers = class extends Observable {
  };

  // ../../packages/core/src/Command/CommandObservers.ts
  var CommandObservers = class extends Observable {
  };

  // ../../packages/core/src/Command/CommandManager.ts
  var _CommandManager = class {
    _undoManager;
    _actionExtensionManager;
    constructor(context) {
      this._undoManager = context.getUndoManager();
      this._actionExtensionManager = new ActionExtensionManager();
    }
    static staticInitialize() {
      this._actionClass = /* @__PURE__ */ new Map();
      this._actionObservers = new ActionObservers();
      this._commandObservers = new CommandObservers();
      this._commandInjectorObservers = new CommandInjectorObservers();
    }
    static getAction(name) {
      return this._actionClass[name];
    }
    static getActionObservers() {
      return this._actionObservers;
    }
    static getCommandObservers() {
      return this._commandObservers;
    }
    static register(name, clazz) {
      this._actionClass[name] = clazz;
    }
    static getCommandInjectorObservers() {
      return this._commandInjectorObservers;
    }
    getActionExtensionManager() {
      return this._actionExtensionManager;
    }
    undo() {
      const { _undoManager } = this;
      const command = _undoManager.undo();
      if (command) {
        command.undo();
      }
    }
    redo() {
      const { _undoManager } = this;
      const command = _undoManager.redo();
      if (command) {
        command.redo();
      }
    }
    invoke(command) {
      const { _undoManager } = this;
      const { _actionDataList, _unit, _actionList } = command;
      this._actionExtensionManager.handle(_actionDataList);
      _actionDataList.forEach((data) => {
        const ActionClass = _CommandManager.getAction(data.actionName);
        const observers = _CommandManager.getActionObservers();
        const action = new ActionClass(data, _unit, observers);
        if (ActionOperation.hasUndo(data)) {
          _actionList.push(action);
        }
      });
      command.invoke();
      if (_actionList.length === 0) {
        return;
      }
      _undoManager.push(command);
    }
  };
  var CommandManager = _CommandManager;
  __publicField(CommandManager, "_actionClass");
  __publicField(CommandManager, "_commandObservers");
  __publicField(CommandManager, "_actionObservers");
  __publicField(CommandManager, "_commandInjectorObservers");
  CommandManager.staticInitialize();

  // ../../packages/core/src/Command/SheetActionBase.ts
  var SheetActionBase2 = class extends ActionBase {
    _commandUnit;
    _workbook;
    constructor(actionData, commandUnit, observers) {
      super(actionData, observers);
      if (commandUnit.WorkBookUnit == null) {
        throw new Error("action workbook domain can not be null!");
      }
      this._commandUnit = commandUnit;
      this._workbook = commandUnit.WorkBookUnit;
    }
    getWorkSheet() {
      const { _workbook, _doActionData } = this;
      const { sheetId } = _doActionData;
      return _workbook.getSheetBySheetId(sheetId);
    }
    getWorkBook() {
      return this._workbook;
    }
  };

  // ../../packages/core/src/Command/Command.ts
  var Command = class {
    _unit;
    _actionDataList;
    _actionList;
    constructor(commandUnit, ...list) {
      this._unit = commandUnit;
      this._actionDataList = list;
      this._actionList = [];
    }
    getDoData() {
      return this._actionList.map((action) => action.getDoActionData());
    }
    getOldData() {
      return this._actionList.map((action) => action.getOldActionDaa());
    }
    getInjector() {
      const commandThis = this;
      return new class {
        injectAction(action) {
          commandThis._actionList.push(action);
        }
        getActions() {
          return commandThis._actionList.concat([]);
        }
        include(action) {
          for (let i4 = 0; i4 < commandThis._actionList.length; i4++) {
            if (commandThis._actionList[i4] instanceof action) {
              return commandThis._actionList[i4];
            }
          }
          return null;
        }
      }();
    }
    redo() {
      this._actionList.forEach((action) => action.redo());
      CommandManager.getCommandObservers().notifyObservers({
        type: 0 /* REDO */,
        actions: this._actionList
      });
    }
    undo() {
      this._actionList.reverse().forEach((action) => action.undo());
      CommandManager.getCommandObservers().notifyObservers({
        type: 1 /* UNDO */,
        actions: this._actionList
      });
    }
    invoke() {
      CommandManager.getCommandInjectorObservers().notifyObservers(
        this.getInjector()
      );
      CommandManager.getCommandObservers().notifyObservers({
        type: 0 /* REDO */,
        actions: this._actionList
      });
    }
  };

  // ../../packages/core/src/Command/UndoManager.ts
  var UndoManager2 = class {
    _undoStack;
    _redoStack;
    constructor() {
      this._undoStack = [];
      this._redoStack = [];
    }
    push(command) {
      this._redoStack.push(command);
    }
    undo() {
      const command = this._redoStack.pop();
      if (command) {
        this._undoStack.push(command);
        return command;
      }
    }
    redo() {
      const command = this._undoStack.pop();
      if (command) {
        this._redoStack.push(command);
        return command;
      }
    }
  };

  // ../../packages/core/src/Command/ActionExtensionManager.ts
  var ActionExtensionManager = class {
    _actionExtensionFactoryList;
    // mounted on the instance
    _register;
    constructor() {
      this._register = new ActionExtensionRegister();
      this._register.initialize();
    }
    getRegister() {
      return this._register;
    }
    /**
     * inject all actions
     * @param command
     */
    handle(actions) {
      const actionExtensionFactoryList = this._register?.actionExtensionFactoryList;
      if (!actionExtensionFactoryList)
        return;
      this._actionExtensionFactoryList = actionExtensionFactoryList;
      if (actions.length === 0)
        return;
      this._checkExtension(actions);
    }
    /**
     * Execute when the action is matched
     * @param command
     * @returns
     */
    _checkExtension(actions) {
      if (!this._actionExtensionFactoryList)
        return false;
      this._actionExtensionFactoryList.forEach((actionExtensionFactory) => {
        const extension = actionExtensionFactory.check(actions);
        if (extension !== false) {
          extension.execute();
        }
      });
    }
  };

  // ../../packages/core/src/Command/ActionExtensionFactory.ts
  var BaseActionExtension = class {
    constructor(actionDataList, _plugin) {
      this.actionDataList = actionDataList;
      this._plugin = _plugin;
    }
    getActionDataList() {
      return this.actionDataList;
    }
    /**
     * Must use internal method to add action
     * @param actionData
     */
    push(actionData) {
      this.actionDataList.push(actionData);
    }
    /**
     * Modify the data of action
     */
    setValue() {
    }
    /**
     * Execute the core logic after the check is successful
     */
    execute() {
    }
  };
  var BaseActionExtensionFactory2 = class {
    constructor(_plugin) {
      this._plugin = _plugin;
    }
    get zIndex() {
      return 0;
    }
    /**
     * Generate Action Extension
     * @param actionDataList
     * @returns
     */
    create(actionDataList) {
      return new BaseActionExtension(actionDataList, this._plugin);
    }
    /**
     * Intercept actionDataList
     * @returns
     */
    check(actionDataList) {
      return this.create(actionDataList);
    }
  };

  // ../../packages/core/src/Command/RegistryFactory.ts
  var Registry = class {
    _data = [];
    static create() {
      return new Registry();
    }
    add(dataInstance) {
      this._data.push(dataInstance);
    }
    delete(dataInstance) {
      const index = this._data.indexOf(dataInstance);
      this._data.splice(index, 1);
    }
    getData() {
      return this._data;
    }
  };
  var REGISTRY_ACTION_FACTORY = Registry.create();

  // ../../packages/core/src/Command/ActionExtensionRegister.ts
  var ActionExtensionRegister = class {
    _actionExtensionFactoryList = [];
    get actionExtensionFactoryList() {
      return this._actionExtensionFactoryList;
    }
    initialize() {
      this._initExtensions();
    }
    add(...extensionFactoryList) {
      this._actionExtensionFactoryList.push(...extensionFactoryList);
      this._actionExtensionFactoryList.sort(sortRules);
    }
    delete(extensionFactory) {
      const index = this._actionExtensionFactoryList.indexOf(extensionFactory);
      this._actionExtensionFactoryList.splice(index, 1);
    }
    _initExtensions() {
      this._actionExtensionFactoryList.push(
        ...REGISTRY_ACTION_FACTORY.getData().sort(sortRules)
      );
    }
  };

  // ../../packages/core/src/Command/ActionOperation.ts
  var ActionOperation = class {
    _action;
    constructor(action) {
      this._action = action;
    }
    static hasObserver(action) {
      if (action.operation) {
        return (action.operation & 1 /* OBSERVER_ACTION */) === 1 /* OBSERVER_ACTION */;
      }
      return true;
    }
    static hasUndo(action) {
      if (action.operation) {
        return (action.operation & 3 /* UNDO_ACTION */) === 3 /* UNDO_ACTION */;
      }
      return true;
    }
    static hasCollaboration(action) {
      if (action.operation) {
        return (action.operation & 2 /* SERVER_ACTION */) === 2 /* SERVER_ACTION */;
      }
      return true;
    }
    static hasExtension(action) {
      if (action.operation) {
        return (action.operation & 4 /* EXTENSION_ACTION */) === 4 /* EXTENSION_ACTION */;
      }
      return true;
    }
    static make(action) {
      action.operation = 7 /* DEFAULT_ACTION */;
      return new ActionOperation(action);
    }
    removeObserver() {
      if (this._action.operation) {
        this._action.operation &= ~1 /* OBSERVER_ACTION */;
      }
      return this;
    }
    removeUndo() {
      if (this._action.operation) {
        this._action.operation &= ~3 /* UNDO_ACTION */;
      }
      return this;
    }
    removeCollaboration() {
      if (this._action.operation) {
        this._action.operation &= ~2 /* SERVER_ACTION */;
      }
      return this;
    }
    removeExtension() {
      if (this._action.operation) {
        this._action.operation &= ~4 /* EXTENSION_ACTION */;
      }
      return this;
    }
    getAction() {
      return this._action;
    }
  };

  // ../../packages/core/src/Sheets/Apply/AddMerge.ts
  function addMergeApply(unit, data) {
    let worksheet = unit?.WorkBookUnit?.getSheetBySheetId(data.sheetId);
    let removeMerges = [];
    if (worksheet) {
      let sheetMerges = worksheet.getMerges();
      for (let i4 = 0; i4 < data.rectangles.length; i4++) {
        sheetMerges.add(data.rectangles[i4]);
        removeMerges = removeMerges.concat(sheetMerges.add(data.rectangles[i4]));
      }
    }
    return removeMerges;
  }

  // ../../packages/core/src/Sheets/Apply/AddNamedRange.ts
  function AddNamedRangeApply(unit, data) {
    const namedRanges = unit.WorkBookUnit?.getConfig().namedRanges;
    namedRanges?.push(data.namedRange);
  }

  // ../../packages/core/src/Sheets/Apply/ClearRange.ts
  function ClearRangeApply(unit, data) {
    const worksheet = unit.WorkBookUnit?.getSheetBySheetId(data.sheetId);
    const cellMatrix = worksheet?.getCellMatrix();
    const { startRow, endRow, startColumn, endColumn } = data.rangeData;
    const rows = endRow - startRow + 1;
    const columns = endColumn - startColumn + 1;
    const result = new ObjectMatrix();
    for (let r4 = startRow; r4 <= endRow; r4++) {
      for (let c4 = startColumn; c4 <= endColumn; c4++) {
        const value = cellMatrix?.getValue(r4, c4);
        result.setValue(r4, c4, Tools.deepClone(value));
        if (value) {
          if (data.options.formatOnly) {
            delete value.s;
          }
          if (data.options.contentsOnly) {
            value.v = "";
            value.m = "";
          }
          cellMatrix?.setValue(r4, c4, Tools.deepClone(value));
        }
      }
    }
    return result.getData();
  }

  // ../../packages/core/src/Sheets/Apply/DeleteNamedRange.ts
  function DeleteNamedRangeApply(unit, data) {
    const workbook = unit.WorkBookUnit;
    const namedRanges = workbook?.getConfig().namedRanges;
    return namedRanges?.find((currentNamedRange, i4) => {
      if (currentNamedRange.namedRangeId === data.namedRangeId) {
        namedRanges.splice(i4, 1);
        return currentNamedRange;
      }
      return null;
    });
  }

  // ../../packages/core/src/Sheets/Apply/DeleteRange.ts
  function DeleteRangeApply(unit, data) {
    const worksheet = unit.WorkBookUnit?.getSheetBySheetId(data.sheetId);
    const cellMatrix = worksheet?.getCellMatrix();
    const count = {
      rowCount: worksheet?.getConfig().rowCount,
      columnCount: worksheet?.getConfig().columnCount
    };
    const { startRow, endRow, startColumn, endColumn } = data.rangeData;
    const rows = endRow - startRow + 1;
    const columns = endColumn - startColumn + 1;
    const lastEndRow = count.rowCount ?? 0;
    const lastEndColumn = count.columnCount ?? 0;
    const result = new ObjectMatrix();
    if (data.shiftDimension === 1 /* ROWS */) {
      for (let r4 = startRow; r4 <= lastEndRow; r4++) {
        for (let c4 = startColumn; c4 <= endColumn; c4++) {
          if (r4 <= endRow) {
            const cell = cellMatrix?.getValue(r4, c4);
            result.setValue(r4, c4, cell);
          }
          const value = cellMatrix?.getValue(r4 + rows, c4);
          if (value) {
            cellMatrix?.setValue(r4, c4, Tools.deepClone(value));
          } else {
            const originValue = cellMatrix?.getValue(r4, c4);
            if (originValue) {
              cellMatrix?.deleteValue(r4, c4);
              c4--;
            }
          }
        }
      }
    } else if (data.shiftDimension === 0 /* COLUMNS */) {
      for (let r4 = startRow; r4 <= endRow; r4++) {
        for (let c4 = startColumn; c4 <= lastEndColumn; c4++) {
          if (c4 <= endColumn) {
            const cell = cellMatrix?.getValue(r4, c4);
            result.setValue(r4, c4, cell);
          } else {
            for (let i4 = 0; i4 <= endColumn; i4++) {
              const cell = cellMatrix?.getValue(r4, c4);
              result.setValue(r4, c4 + i4, cell);
            }
          }
          const value = cellMatrix?.getValue(r4, c4 + columns);
          if (value) {
            cellMatrix?.setValue(r4, c4, Tools.deepClone(value));
          } else {
            const originValue = cellMatrix?.getValue(r4, c4);
            if (originValue) {
              for (let i4 = 0; i4 <= endColumn; i4++) {
                cellMatrix?.deleteValue(r4, c4);
              }
              break;
            }
          }
        }
      }
    }
    return result.getData();
  }

  // ../../packages/core/src/Sheets/Apply/HideSheet.ts
  function SetWorkSheetHideService(worksheet, hidden) {
    const config = worksheet.getConfig();
    const oldHidden = config.hidden;
    config.hidden = hidden;
    return oldHidden;
  }

  // ../../packages/core/src/Sheets/Apply/InsertColumn.ts
  function InsertColumnApply(unit, data) {
    const worksheet = unit.WorkBookUnit.getSheetBySheetId(data.sheetId);
    const columnManager = worksheet.getColumnManager();
    const primitiveData = columnManager.getColumnData().toJSON();
    const wrapper = new ObjectArray(primitiveData);
    wrapper.inserts(data.columnIndex, new ObjectArray(data.columnCount));
  }

  // ../../packages/core/src/Sheets/Apply/InsertDataColumn.ts
  function InsertDataColumnApply(unit, data) {
    const worksheet = unit.WorkBookUnit.getSheetBySheetId(data.sheetId);
    const primitiveData = worksheet.getCellMatrix().toJSON();
    const wrapper = new ObjectMatrix(primitiveData);
    wrapper.insertColumns(data.columnIndex, new ObjectMatrix(data.columnData));
  }

  // ../../packages/core/src/Sheets/Apply/InsertDataRow.ts
  function InsertDataRowApply(unit, data) {
    const worksheet = unit.WorkBookUnit.getSheetBySheetId(data.sheetId);
    const primitiveData = worksheet.getCellMatrix().toJSON();
    const wrapper = new ObjectMatrix(primitiveData);
    wrapper.insertRows(data.rowIndex, new ObjectMatrix(data.rowData));
  }

  // ../../packages/core/src/Sheets/Apply/InsertRange.ts
  function InsertRangeApply(unit, data) {
    const worksheet = unit.WorkBookUnit.getSheetBySheetId(data.sheetId);
    const rowCount = worksheet.getLastRow();
    const columnCount = worksheet.getLastColumn();
    const cellMatrix = worksheet.getCellMatrix();
    const { startRow, endRow, startColumn, endColumn } = data.rangeData;
    const rows = endRow - startRow + 1;
    const columns = endColumn - startColumn + 1;
    const lastEndRow = rowCount;
    const lastEndColumn = columnCount;
    if (data.shiftDimension === 1 /* ROWS */) {
      for (let r4 = lastEndRow; r4 >= startRow; r4--) {
        for (let c4 = startColumn; c4 <= endColumn; c4++) {
          const value = cellMatrix.getValue(r4, c4);
          cellMatrix.setValue(r4 + rows, c4, value);
        }
      }
      for (let r4 = endRow; r4 >= startRow; r4--) {
        for (let c4 = startColumn; c4 <= endColumn; c4++) {
          cellMatrix.setValue(
            r4,
            c4,
            data.cellValue[r4 - startRow][c4 - startColumn]
          );
        }
      }
    } else if (data.shiftDimension === 0 /* COLUMNS */) {
      for (let r4 = startRow; r4 <= endRow; r4++) {
        for (let c4 = lastEndColumn; c4 >= startColumn; c4--) {
          const value = cellMatrix.getValue(r4, c4);
          cellMatrix.setValue(r4, c4 + columns, value);
        }
      }
      for (let r4 = startRow; r4 <= endRow; r4++) {
        for (let c4 = endColumn; c4 >= startColumn; c4--) {
          cellMatrix.setValue(
            r4,
            c4,
            data.cellValue[r4 - startRow][c4 - startColumn]
          );
        }
      }
    }
  }

  // ../../packages/core/src/Sheets/Apply/InsertRow.ts
  function InsertRowApply(unit, data) {
    const worksheet = unit.WorkBookUnit.getSheetBySheetId(data.sheetId);
    const rowManager = worksheet.getRowManager();
    const primitiveData = rowManager.getRowData().toJSON();
    const wrapper = new ObjectArray(primitiveData);
    wrapper.inserts(data.rowIndex, new ObjectArray(data.rowCount));
  }

  // ../../packages/core/src/Sheets/Apply/InsertSheet.ts
  function InsertSheetApply(unit, data) {
    const worksheet = unit.WorkBookUnit.getSheetBySheetId(data.sheetId);
    const index = data.index;
    const worksheetConfig2 = data.sheet;
    const iSheets = unit.WorkBookUnit.getWorksheets();
    const config = unit.WorkBookUnit.getConfig();
    const { sheets, sheetOrder } = config;
    if (sheets[worksheetConfig2.id]) {
      throw new Error(`Insert Sheet fail ${worksheetConfig2.id} is already exist`);
    }
    sheets[worksheetConfig2.id] = worksheetConfig2;
    sheetOrder.splice(index, 0, worksheetConfig2.id);
    iSheets.set(
      worksheetConfig2.id,
      new Worksheet(unit.WorkBookUnit.getContext(), worksheetConfig2)
    );
    return worksheetConfig2.id;
  }

  // ../../packages/core/src/Sheets/Apply/RemoveColumn.ts
  function RemoveColumnApply(unit, data) {
    const worksheet = unit.WorkBookUnit.getSheetBySheetId(data.sheetId);
    const columnManager = worksheet.getColumnManager();
    const primitiveData = columnManager.getColumnData().toJSON();
    const wrapper = new ObjectArray(primitiveData);
    const result = new ObjectArray();
    const start = data.columnIndex;
    const end = data.columnIndex + data.columnCount;
    for (let i4 = start; i4 < end; i4++) {
      const splice = wrapper.splice(data.columnIndex, 1);
      if (splice.getLength()) {
        result.set(i4, splice.first());
      }
    }
    return result.getLength();
  }

  // ../../packages/core/src/Sheets/Apply/RemoveColumnData.ts
  function RemoveColumnDataApply(unit, data) {
    const worksheet = unit.WorkBookUnit.getSheetBySheetId(data.sheetId);
    const primitiveData = worksheet.getCellMatrix().toJSON();
    return new ObjectMatrix(primitiveData).spliceColumns(data.columnIndex, data.columnCount).toJSON();
  }

  // ../../packages/core/src/Sheets/Apply/RemoveMerge.ts
  function RemoveMergeApply(unit, data) {
    let worksheet = unit.WorkBookUnit.getSheetBySheetId(data.sheetId);
    let merges = worksheet.getMerges();
    let remove = [];
    for (let i4 = 0; i4 < data.rectangles.length; i4++) {
      remove = remove.concat(merges.remove(data.rectangles[i4]));
    }
    return remove;
  }

  // ../../packages/core/src/Sheets/Apply/RemoveRow.ts
  function RemoveRowApply(unit, data) {
    const worksheet = unit.WorkBookUnit.getSheetBySheetId(data.sheetId);
    const rowManager = worksheet.getRowManager();
    const primitiveData = rowManager.getRowData().toJSON();
    const wrapper = new ObjectArray(primitiveData);
    const result = new ObjectArray();
    const start = data.rowIndex;
    const end = data.rowIndex + data.rowCount;
    for (let i4 = start; i4 < end; i4++) {
      const splice = wrapper.splice(data.rowIndex, 1);
      if (splice.getLength()) {
        result.set(i4, splice.first());
      }
    }
    return result.getLength();
  }

  // ../../packages/core/src/Sheets/Apply/RemoveRowData.ts
  function RemoveRowDataApply(unit, data) {
    const worksheet = unit.WorkBookUnit.getSheetBySheetId(data.sheetId);
    const primitiveData = worksheet.getCellMatrix().toJSON();
    const wrapper = new ObjectMatrix(primitiveData);
    return wrapper.spliceRows(data.rowIndex, data.rowCount).toJSON();
  }

  // ../../packages/core/src/Sheets/Apply/RemoveSheet.ts
  function RemoveSheetApply(unit, data) {
    let workbook = unit.WorkBookUnit;
    let sheetId = data.sheetId;
    const iSheets = workbook.getWorksheets();
    const config = workbook.getConfig();
    const { sheets } = config;
    if (sheets[sheetId] == null) {
      throw new Error(`Remove Sheet fail ${sheetId} is not exist`);
    }
    const findSheet = sheets[sheetId];
    const findIndex = config.sheetOrder.findIndex((id) => id === sheetId);
    delete sheets[sheetId];
    config.sheetOrder.splice(findIndex, 1);
    iSheets.delete(sheetId);
    return {
      index: findIndex,
      sheet: findSheet
    };
  }

  // ../../packages/core/src/Sheets/Apply/SetBorder.ts
  function SetBorderApply(unit, data) {
    const workbook = unit.WorkBookUnit;
    const worksheet = workbook.getSheetBySheetId(data.sheetId);
    const globalStyles = workbook.getStyles();
    const matrix = worksheet.getCellMatrix();
    const wrapper = new ObjectMatrix(data.styles);
    const result = new ObjectMatrix();
    wrapper.forValue((row, column, value) => {
      const cell = matrix.getValue(row, column);
      if (cell) {
        const old = globalStyles.get(cell.s);
        if (old) {
          result.setValue(row, column, old);
        }
        cell.s = globalStyles.setValue(value);
      }
    });
    return result.toJSON();
  }

  // ../../packages/core/src/Sheets/Apply/SetColumnHide.ts
  function SetColumnHideApply(unit, data) {
    const workbook = unit.WorkBookUnit;
    const worksheet = workbook.getSheetBySheetId(data.sheetId);
    const columnIndex = data.columnIndex;
    const columnCount = data.columnCount;
    const columnManager = worksheet.getColumnManager();
    for (let i4 = columnIndex; i4 < columnIndex + columnCount; i4++) {
      const column = columnManager.getColumnOrCreate(i4);
      column.hd = 1;
    }
  }

  // ../../packages/core/src/Sheets/Apply/SetColumnShow.ts
  function SetColumnShowApply(unit, data) {
    const workbook = unit.WorkBookUnit;
    const worksheet = workbook.getSheetBySheetId(data.sheetId);
    const columnIndex = 0;
    const columnCount = 0;
    const columnManager = worksheet.getColumnManager();
    for (let i4 = columnIndex; i4 < columnIndex + columnCount; i4++) {
      const column = columnManager.getColumn(i4);
      if (column) {
        column.hd = 0;
      }
    }
  }

  // ../../packages/core/src/Sheets/Apply/SetColumnWidth.ts
  function SetColumnWidthApply(unit, data) {
    const workbook = unit.WorkBookUnit;
    const worksheet = workbook.getSheetBySheetId(data.sheetId);
    const columnIndex = data.columnIndex;
    const columnWidth = data.columnWidth;
    const columnManager = worksheet.getColumnManager();
    const result = [];
    for (let i4 = columnIndex; i4 < columnIndex + columnWidth.length; i4++) {
      const column = columnManager.getColumnOrCreate(i4);
      result[i4 - columnIndex] = column.w;
      column.w = columnWidth[i4 - columnIndex];
    }
    return result;
  }

  // ../../packages/core/src/Sheets/Apply/SetHiddenGridlines.ts
  function SetHiddenGridlinesApply(unit, data) {
    const workbook = unit.WorkBookUnit;
    const worksheet = workbook.getSheetBySheetId(data.sheetId);
    const hideGridlines = data.hideGridlines;
    const config = worksheet.getConfig();
    const oldStatus = config.showGridlines === 0;
    if (hideGridlines) {
      config.showGridlines = 0;
    } else {
      config.showGridlines = 1;
    }
    return oldStatus;
  }

  // ../../packages/core/src/Sheets/Apply/SetHideRows.ts
  function SetHideRow(rowIndex = 0, rowCount, rowManager) {
    for (let i4 = rowIndex; i4 < rowIndex + rowCount; i4++) {
      const row = rowManager.getRowOrCreate(i4);
      if (row) {
        row.hd = 1;
      }
    }
  }

  // ../../packages/core/src/Sheets/Apply/SetNamedRange.ts
  function SetNamedRangeApply(unit, data) {
    const workbook = unit.WorkBookUnit;
    const worksheet = workbook.getSheetBySheetId(data.sheetId);
    const namedRange = data.namedRange;
    const namedRanges = workbook.getConfig().namedRanges;
    return namedRanges.find((currentNamedRange, i4) => {
      if (currentNamedRange.namedRangeId === namedRange.namedRangeId) {
        namedRanges[i4] = namedRange;
        return currentNamedRange;
      }
      return null;
    });
  }

  // ../../packages/core/src/Sheets/Apply/SetRangeStyle.ts
  function SetRangeStyle(cellMatrix, value, rangeData, styles) {
    const { startRow, endRow, startColumn, endColumn } = rangeData;
    const result = new ObjectMatrix();
    for (let r4 = startRow; r4 <= endRow; r4++) {
      const rowResult = [];
      for (let c4 = startColumn; c4 <= endColumn; c4++) {
        const cell = cellMatrix.getValue(r4, c4) || {};
        const old = styles.getStyleByCell(cell);
        if (old == null) {
          delete cell.s;
        }
        const merge = mergeStyle(
          old,
          value[r4 - startRow][c4 - startColumn]
        );
        merge && Tools.removeNull(merge);
        if (Tools.isEmptyObject(merge)) {
          delete cell.s;
        } else {
          cell.s = styles.setValue(merge);
        }
        if (cell.p) {
          mergeRichTextStyle(
            cell.p,
            value[r4 - startRow][c4 - startColumn]
          );
        }
        cellMatrix.setValue(r4, c4, cell);
        result.setValue(
          r4 - startRow,
          c4 - startColumn,
          transformStyle(
            old,
            value[r4 - startRow][c4 - startColumn]
          )
        );
      }
    }
    return result.getData();
  }
  function transformStyle(oldStyle, newStyle) {
    const backupStyle = transformNormalKey(oldStyle, newStyle);
    return backupStyle;
  }
  function transformNormalKey(oldStyle, newStyle) {
    if (!newStyle || !Object.keys(newStyle).length) {
      return oldStyle;
    }
    const backupStyle = Tools.deepClone(oldStyle) || {};
    for (const k5 in newStyle) {
      if (k5 === "bd") {
        backupStyle[k5] = transformBorders(backupStyle[k5] || {}, newStyle[k5]);
      } else if (!(k5 in backupStyle)) {
        backupStyle[k5] = null;
      }
    }
    return backupStyle;
  }
  function transformBorders(oldBorders, newBorders) {
    if (!newBorders || !Object.keys(newBorders).length) {
      return oldBorders;
    }
    for (const k5 in newBorders) {
      if (!(k5 in oldBorders)) {
        oldBorders[k5] = null;
      }
    }
    return oldBorders;
  }
  function mergeStyle(oldStyle, newStyle, isRichText = false) {
    if (newStyle === null)
      return newStyle;
    if (newStyle === void 0)
      return oldStyle;
    const backupStyle = Tools.deepClone(oldStyle) || {};
    for (const k5 in newStyle) {
      if (isRichText && ["bd", "tr", "td", "ht", "vt", "tb", "pd"].includes(k5)) {
        continue;
      }
      if (k5 in backupStyle && k5 === "bd") {
        backupStyle[k5] = Object.assign(backupStyle[k5], newStyle[k5]);
      } else {
        backupStyle[k5] = newStyle[k5];
        if ("cl" in backupStyle) {
          if (["ul", "ol", "st"].includes(k5)) {
            backupStyle[k5].cl = backupStyle.cl;
          }
        }
      }
    }
    return backupStyle;
  }
  function mergeRichTextStyle(p4, newStyle) {
    p4.body?.blockElements.forEach((blockElement) => {
      if (blockElement.blockType === 0) {
        const paragraph = blockElement.paragraph;
        paragraph?.elements.forEach((element) => {
          if (!element.tr) {
            element.tr = {};
          }
          const textRun = element.tr;
          if (!textRun.ts) {
            textRun.ts = {};
          }
          const oldStyle = textRun.ts;
          const merge = mergeStyle(
            oldStyle,
            newStyle,
            true
          );
          merge && Tools.removeNull(merge);
          if (Tools.isEmptyObject(merge)) {
            delete textRun.ts;
          } else {
            textRun.ts = merge;
          }
        });
      }
    });
  }

  // ../../packages/core/src/Sheets/Apply/SetRangeData.ts
  function SetRangeData(cellMatrix, addMatrix, styles, options) {
    let target = new ObjectMatrix(addMatrix);
    const result = new ObjectMatrix();
    if (options) {
      target.forValue((r4, c4, value) => {
        const cell = cellMatrix.getValue(r4, c4);
        const newCell = {};
        if (options.contentsOnly) {
          newCell.m = cell?.m;
          newCell.v = cell?.v;
        }
        if (options.formatOnly) {
          newCell.v = cell?.v;
          newCell.m = cell?.m;
        }
        result.setValue(r4, c4, newCell || {});
        cellMatrix.setValue(r4, c4, value || {});
      });
      return result.getData();
    }
    target.forValue((r4, c4, value) => {
      const cell = cellMatrix.getValue(r4, c4) || {};
      if (!value) {
        cellMatrix.setValue(r4, c4, value);
        result.setValue(r4, c4, cell);
      } else {
        const old = styles.getStyleByCell(cell);
        const oldCellStyle = transformStyle(
          old,
          value?.s
        );
        const oldCellData = Tools.deepClone(cell);
        oldCellData.s = oldCellStyle;
        result.setValue(r4, c4, oldCellData);
        if (old == null) {
          delete cell.s;
        }
        const merge = mergeStyle(old, value?.s);
        merge && Tools.removeNull(merge);
        if (Tools.isEmptyObject(merge)) {
          delete cell.s;
        } else {
          cell.s = styles.setValue(merge);
        }
        if (value.v != null) {
          cell.v = value.v;
        }
        if (value.m != null) {
          cell.m = value.m;
        } else {
          cell.m = String(cell.v);
        }
        if (value.t != null) {
          cell.t = value.t;
        }
        cellMatrix.setValue(r4, c4, cell);
      }
    });
    return result.getData();
  }
  function SetRangeDataApply(unit, data) {
    const workbook = unit.WorkBookUnit;
    const worksheet = workbook.getSheetBySheetId(data.sheetId);
    const cellMatrix = worksheet.getCellMatrix();
    const options = data.options;
    const addMatrix = data.cellValue;
    const styles = workbook.getStyles();
    const target = new ObjectMatrix(addMatrix);
    const result = new ObjectMatrix();
    if (options) {
      target.forValue((r4, c4, value) => {
        const cell = cellMatrix.getValue(r4, c4);
        const newCell = {};
        if (options.contentsOnly) {
          newCell.m = cell?.m;
          newCell.v = cell?.v;
        }
        if (options.formatOnly) {
          newCell.v = cell?.v;
          newCell.m = cell?.m;
        }
        result.setValue(r4, c4, newCell || {});
        cellMatrix.setValue(r4, c4, value || {});
      });
      return result.getData();
    }
    target.forValue((r4, c4, value) => {
      const cell = cellMatrix.getValue(r4, c4) || {};
      if (!value) {
        cellMatrix.setValue(r4, c4, value);
        result.setValue(r4, c4, cell);
      } else {
        const old = styles.getStyleByCell(cell);
        const oldCellStyle = transformStyle(
          old,
          value?.s
        );
        const oldCellData = Tools.deepClone(cell);
        oldCellData.s = oldCellStyle;
        result.setValue(r4, c4, oldCellData);
        if (old == null) {
          delete cell.s;
        }
        const merge = mergeStyle(old, value?.s);
        merge && Tools.removeNull(merge);
        if (Tools.isEmptyObject(merge)) {
          delete cell.s;
        } else {
          cell.s = styles.setValue(merge);
        }
        if (value.v != null) {
          cell.v = value.v;
        }
        if (value.m != null) {
          cell.m = value.m;
        } else {
          cell.m = String(cell.v);
        }
        if (value.t != null) {
          cell.t = value.t;
        }
        cellMatrix.setValue(r4, c4, cell);
      }
    });
    return result.getData();
  }

  // ../../packages/core/src/Sheets/Apply/SetRangeFormat.ts
  function SetRangeFormat(cellMatrix, addMatrix, rangeData) {
    const target = new ObjectMatrix(addMatrix);
    const result = new ObjectMatrix();
    for (let i4 = rangeData.startRow; i4 <= rangeData.endRow; i4++) {
      for (let j3 = rangeData.startColumn; j3 <= rangeData.endColumn; j3++) {
        const targetValue = target.getValue(i4, j3);
        if (targetValue) {
          const value = JSON.parse(targetValue);
          const cell = cellMatrix.getValue(i4, j3);
          const cellValue = Tools.deepClone(cell || {});
          cellMatrix.setValue(i4, j3, cellValue || {});
        } else {
          const cell = cellMatrix.getValue(i4, j3);
          const cellValue = Tools.deepClone(cell || {});
          cellMatrix.setValue(i4, j3, cellValue || {});
        }
      }
    }
    return result.getData();
  }

  // ../../packages/core/src/Sheets/Apply/SetRangeFormula.ts
  function SetRangeFormula(cellMatrix, addMatrix, rangeData) {
    const target = new ObjectMatrix(addMatrix);
    const result = new ObjectMatrix();
    for (let i4 = rangeData.startRow; i4 <= rangeData.endRow; i4++) {
      for (let j3 = rangeData.startColumn; j3 <= rangeData.endColumn; j3++) {
        const value = target.getValue(i4, j3);
        const cell = cellMatrix.getValue(i4, j3);
        const cellValue = Tools.deepClone(cell || {});
        cellValue.f = value;
        cellMatrix.setValue(i4, j3, cellValue || {});
      }
    }
    return result.getData();
  }

  // ../../packages/core/src/Sheets/Apply/SetRangeNote.ts
  function SetRangeNote(cellMatrix, addMatrix, rangeData) {
    const target = new ObjectMatrix(addMatrix);
    const result = new ObjectMatrix();
    for (let i4 = rangeData.startRow; i4 <= rangeData.endRow; i4++) {
      for (let j3 = rangeData.startColumn; j3 <= rangeData.endColumn; j3++) {
        const value = target.getValue(i4, j3);
        const cell = cellMatrix.getValue(i4, j3);
        const cellValue = Tools.deepClone(cell || {});
        cellValue.n = value;
        cellMatrix.setValue(i4, j3, cellValue || {});
      }
    }
    return result.getData();
  }

  // ../../packages/core/src/Sheets/Apply/SetRangeFormattedValue.ts
  function SetRangeFormattedValue(cellMatrix, addMatrix, rangeData) {
    const target = new ObjectMatrix(addMatrix);
    const result = new ObjectMatrix();
    for (let i4 = rangeData.startRow; i4 <= rangeData.endRow; i4++) {
      for (let j3 = rangeData.startColumn; j3 <= rangeData.endColumn; j3++) {
        const value = target.getValue(i4, j3);
        const cell = cellMatrix.getValue(i4, j3);
        result.setValue(i4, j3, cell && cell.v || "");
        const cellValue = Tools.deepClone(cell || {});
        cellValue.v = value;
        cellValue.m = `${value}`;
        cellMatrix.setValue(i4, j3, cellValue || {});
      }
    }
    return result.getData();
  }

  // ../../packages/core/src/Sheets/Apply/SetRightToLeft.ts
  function SetRightToLeft(worksheet, rightToLeft) {
    const config = worksheet.getConfig();
    const oldState = config.rightToLeft;
    config.rightToLeft = rightToLeft;
    return oldState;
  }

  // ../../packages/core/src/Sheets/Apply/SetRowHeight.ts
  function SetRowHeight(rowIndex = 0, rowHeight, rowManager) {
    const result = [];
    for (let i4 = rowIndex; i4 < rowIndex + rowHeight.length; i4++) {
      const row = rowManager.getRowOrCreate(i4);
      result[i4 - rowIndex] = row.h;
      row.h = rowHeight[i4 - rowIndex];
    }
    return result;
  }

  // ../../packages/core/src/Sheets/Apply/SetSelectionActivate.ts
  function SetSelectionActivate(worksheet, activeRangeList, activeRange, currentCell) {
    const selectionIns = worksheet.getSelection();
    const oldActiveRangeList = selectionIns.getActiveRangeList()?.getRangeList();
    const oldActiveRange = selectionIns.getActiveRange()?.getRangeData();
    const oldCurrentCell = selectionIns.getCurrentCell()?.getRangeData();
    selectionIns.setRanges(activeRangeList, activeRange, currentCell);
    return {
      activeRangeList: oldActiveRangeList,
      activeRange: oldActiveRange,
      currentCell: oldCurrentCell
    };
  }

  // ../../packages/core/src/Sheets/Apply/SetSheetOrder.ts
  function SetSheetOrder(workbook, sheetId, order) {
    const config = workbook.getConfig();
    const oldIndex = config.sheetOrder.findIndex((current) => current === sheetId);
    const exclude = config.sheetOrder.filter((currentId) => currentId !== sheetId);
    exclude.splice(order, 0, sheetId);
    config.sheetOrder = exclude;
    return oldIndex;
  }

  // ../../packages/core/src/Sheets/Apply/SetShowRow.ts
  function SetShowRow(rowIndex = 0, rowCount, rowManager) {
    for (let i4 = rowIndex; i4 < rowIndex + rowCount; i4++) {
      const row = rowManager.getRow(i4);
      if (row) {
        row.hd = 0;
      }
    }
  }

  // ../../packages/core/src/Sheets/Apply/SetTabColor.ts
  function SetTabColor(worksheet, color) {
    const config = worksheet.getConfig();
    const oldTabColor = config.tabColor;
    config.tabColor = color;
    return oldTabColor;
  }

  // ../../packages/core/src/Sheets/Apply/SetWorkSheetActivate.ts
  function SetWorkSheetActivate(worksheet, status) {
    const oldSheet = worksheet.getContext().getWorkBook().getActiveSheet();
    let oldSheetId = "";
    const oldStatus = 0 /* FALSE */;
    if (oldSheet) {
      oldSheetId = oldSheet.getSheetId();
    }
    const sheets = worksheet.getContext().getWorkBook().getSheets();
    const currentSheetId = worksheet.getSheetId();
    sheets.forEach((sheet) => {
      const sheetId = sheet.getSheetId();
      if (sheetId === currentSheetId) {
        sheet.getConfig().status = 1 /* TRUE */;
      } else {
        sheet.getConfig().status = 0 /* FALSE */;
      }
    });
    return { oldSheetId, status: oldStatus };
  }

  // ../../packages/core/src/Sheets/Apply/SetWorkSheetName.ts
  function SetWorkSheetName(worksheet, sheetName) {
    const config = worksheet.getConfig();
    const oldSheetName = config.name;
    config.name = sheetName;
    return oldSheetName;
  }

  // ../../packages/core/src/Sheets/Apply/SetWorkSheetStatus.ts
  function SetWorkSheetStatus(worksheet, sheetStatus) {
    const config = worksheet.getConfig();
    const oldStatus = config.status;
    config.status = sheetStatus;
    return oldStatus;
  }

  // ../../packages/core/src/Sheets/Apply/SetZoomRatio.ts
  function SetZoomRatio(workbook, sheetId, zoom) {
    const worksheet = workbook.getSheetBySheetId(sheetId);
    if (worksheet) {
      const order = worksheet.getConfig().zoomRatio;
      worksheet.getConfig().zoomRatio = zoom;
      return order;
    }
    return 1;
  }

  // ../../packages/core/src/Sheets/Action/AddMergeAction.ts
  var AddMergeAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this._oldActionData = {
        ...actionData,
        rectangles: this.do()
      };
      this.validate();
    }
    do() {
      return addMergeApply(this._commandUnit, this._doActionData);
    }
    redo() {
      this.do();
    }
    undo() {
      RemoveMergeApply(this._commandUnit, this._doActionData);
    }
    validate() {
      return false;
    }
  };
  __publicField(AddMergeAction, "NAME", "AddMergeAction");
  CommandManager.register(AddMergeAction.NAME, AddMergeAction);

  // ../../packages/core/src/Sheets/Action/DeleteNamedRangeAction.ts
  var DeleteNamedRangeAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this._oldActionData = {
        // actionName: ACTION_NAMES.ADD_NAMED_RANGE_ACTION,
        actionName: AddNamedRangeAction.NAME,
        sheetId: actionData.sheetId,
        namedRange: this.do()
      };
      this.validate();
    }
    do() {
      const result = DeleteNamedRangeApply(this._commandUnit, this._doActionData);
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    redo() {
      const { sheetId } = this._doActionData;
      this._oldActionData = {
        sheetId,
        // actionName: ACTION_NAMES.ADD_BANDING_ACTION,
        actionName: AddNamedRangeAction.NAME,
        namedRange: this.do()
      };
    }
    undo() {
      AddNamedRangeApply(this._commandUnit, this._oldActionData);
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
    }
    validate() {
      return false;
    }
  };
  __publicField(DeleteNamedRangeAction, "NAME", "DeleteNamedRangeAction");
  CommandManager.register(DeleteNamedRangeAction.NAME, DeleteNamedRangeAction);

  // ../../packages/core/src/Sheets/Action/AddNamedRangeAction.ts
  var _AddNamedRangeAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this.do();
      this._oldActionData = {
        //actionName: ACTION_NAMES.DELETE_NAMED_RANGE_ACTION,
        actionName: DeleteNamedRangeAction.NAME,
        sheetId: actionData.sheetId,
        namedRangeId: actionData.namedRange.namedRangeId
      };
      this.validate();
    }
    do() {
      AddNamedRangeApply(this._commandUnit, this._doActionData);
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
    }
    redo() {
      this.do();
    }
    undo() {
      const { sheetId } = this._oldActionData;
      this._doActionData = {
        // actionName: ACTION_NAMES.ADD_NAMED_RANGE_ACTION,
        actionName: _AddNamedRangeAction.NAME,
        sheetId,
        namedRange: DeleteNamedRangeApply(
          this._commandUnit,
          this._oldActionData
        )
      };
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
    }
    validate() {
      return false;
    }
  };
  var AddNamedRangeAction = _AddNamedRangeAction;
  __publicField(AddNamedRangeAction, "NAME", "AddNamedRangeAction");
  CommandManager.register(AddNamedRangeAction.NAME, AddNamedRangeAction);

  // ../../packages/core/src/Sheets/Action/SetRangeDataAction.ts
  var _SetRangeDataAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this._oldActionData = {
        ...actionData,
        cellValue: this.do()
      };
      this.validate();
    }
    do() {
      const result = SetRangeDataApply(this._commandUnit, this._doActionData);
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    redo() {
      const { sheetId, options } = this._doActionData;
      this._oldActionData = {
        // actionName: ACTION_NAMES.SET_RANGE_DATA_ACTION,
        actionName: _SetRangeDataAction.NAME,
        sheetId,
        cellValue: this.do(),
        options
      };
    }
    undo() {
      const { sheetId, cellValue, options } = this._oldActionData;
      const worksheet = this.getWorkSheet();
      const styles = this._workbook.getStyles();
      if (worksheet) {
        this._doActionData = {
          // actionName: ACTION_NAMES.SET_RANGE_DATA_ACTION,
          actionName: _SetRangeDataAction.NAME,
          sheetId,
          cellValue: SetRangeData(
            worksheet.getCellMatrix(),
            cellValue,
            styles
          ),
          options
        };
        this._observers.notifyObservers({
          type: 1 /* UNDO */,
          data: this._oldActionData,
          action: this
        });
      }
    }
    validate() {
      return false;
    }
  };
  var SetRangeDataAction = _SetRangeDataAction;
  __publicField(SetRangeDataAction, "NAME", "SetRangeDataAction");
  CommandManager.register(SetRangeDataAction.NAME, SetRangeDataAction);

  // ../../packages/core/src/Sheets/Action/ClearRangeAction.ts
  var ClearRangeAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this._oldActionData = {
        ...actionData,
        cellValue: this.do()
      };
      this.validate();
    }
    do() {
      const result = ClearRangeApply(this._commandUnit, this._doActionData);
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    redo() {
      const { sheetId } = this._doActionData;
      this._oldActionData = {
        // actionName: ACTION_NAMES.SET_RANGE_DATA_ACTION,
        actionName: SetRangeDataAction.NAME,
        sheetId,
        cellValue: this.do()
      };
    }
    undo() {
      const worksheet = this.getWorkSheet();
      if (worksheet) {
        SetRangeDataApply(this._commandUnit, this._oldActionData);
        this._observers.notifyObservers({
          type: 1 /* UNDO */,
          data: this._oldActionData,
          action: this
        });
      }
    }
    validate() {
      return false;
    }
  };
  __publicField(ClearRangeAction, "NAME", "ClearRangeAction");
  CommandManager.register(ClearRangeAction.NAME, ClearRangeAction);

  // ../../packages/core/src/Sheets/Action/InsertRangeAction.ts
  var InsertRangeAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this.do();
      this._oldActionData = {
        ...actionData
      };
      this.validate();
    }
    do() {
      const worksheet = this.getWorkSheet();
      if (worksheet) {
        InsertRangeApply(this._commandUnit, this._doActionData);
        this._observers.notifyObservers({
          type: 0 /* REDO */,
          data: this._doActionData,
          action: this
        });
      }
    }
    redo() {
      this.do();
    }
    undo() {
      const { rangeData, sheetId, shiftDimension } = this._oldActionData;
      const worksheet = this.getWorkSheet();
      if (worksheet) {
        this._doActionData = {
          // actionName: ACTION_NAMES.SET_RANGE_DATA_ACTION,
          actionName: SetRangeDataAction.NAME,
          sheetId,
          cellValue: DeleteRangeApply(this._commandUnit, this._oldActionData),
          rangeData,
          shiftDimension
        };
        this._observers.notifyObservers({
          type: 1 /* UNDO */,
          data: this._oldActionData,
          action: this
        });
      }
    }
    validate() {
      return false;
    }
  };
  __publicField(InsertRangeAction, "NAME", "InsertRangeAction");
  CommandManager.register(InsertRangeAction.NAME, InsertRangeAction);

  // ../../packages/core/src/Sheets/Action/DeleteRangeAction.ts
  var DeleteRangeAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this._oldActionData = {
        ...actionData,
        cellValue: this.do()
      };
      this.validate();
    }
    do() {
      const result = DeleteRangeApply(this._commandUnit, this._doActionData);
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    redo() {
      const { sheetId, rangeData, shiftDimension } = this._doActionData;
      this._oldActionData = {
        sheetId,
        // actionName: ACTION_NAMES.INSERT_RANGE_ACTION,
        actionName: InsertRangeAction.NAME,
        shiftDimension,
        rangeData,
        cellValue: this.do()
      };
    }
    undo() {
      const worksheet = this.getWorkSheet();
      if (worksheet) {
        InsertRangeApply(this._commandUnit, this._oldActionData);
        this._observers.notifyObservers({
          type: 1 /* UNDO */,
          data: this._oldActionData,
          action: this
        });
      }
    }
    validate() {
      return false;
    }
  };
  __publicField(DeleteRangeAction, "NAME", "DeleteRangeAction");
  CommandManager.register(DeleteRangeAction.NAME, DeleteRangeAction);

  // ../../packages/core/src/Sheets/Action/InsertColumnAction.ts
  var InsertColumnAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this.do();
      this._oldActionData = {
        ...actionData
      };
      this.validate();
    }
    do() {
      InsertColumnApply(this._commandUnit, this._doActionData);
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
    }
    redo() {
      this.do();
    }
    undo() {
      RemoveColumnApply(this._commandUnit, this._oldActionData);
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
    }
    validate() {
      return false;
    }
  };
  __publicField(InsertColumnAction, "NAME", "InsertColumnAction");
  CommandManager.register(InsertColumnAction.NAME, InsertColumnAction);

  // ../../packages/core/src/Sheets/Action/InsertColumnDataAction.ts
  var InsertColumnDataAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this.do();
      this._oldActionData = {
        ...actionData,
        columnCount: ObjectArray.getMaxLength(actionData.columnData[0])
      };
      this.validate();
    }
    do() {
      InsertDataColumnApply(this._commandUnit, this._doActionData);
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
    }
    redo() {
      this.do();
    }
    undo() {
      RemoveColumnDataApply(this._commandUnit, this._oldActionData);
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
    }
    validate() {
      return false;
    }
  };
  __publicField(InsertColumnDataAction, "NAME", "InsertColumnDataAction");
  CommandManager.register(InsertColumnDataAction.NAME, InsertColumnDataAction);

  // ../../packages/core/src/Sheets/Action/InsertRowAction.ts
  var InsertRowAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this.do();
      this._oldActionData = {
        ...actionData
      };
      this.validate();
    }
    do() {
      InsertRowApply(this._commandUnit, this._doActionData);
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
    }
    redo() {
      this.do();
    }
    undo() {
      RemoveRowApply(this._commandUnit, this._oldActionData);
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
    }
    validate() {
      return false;
    }
  };
  __publicField(InsertRowAction, "NAME", "InsertRowAction");
  CommandManager.register(InsertRowAction.NAME, InsertRowAction);

  // ../../packages/core/src/Sheets/Action/InsertRowDataAction.ts
  var InsertRowDataAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this.do();
      this._oldActionData = {
        ...actionData,
        rowCount: ObjectArray.getMaxLength(actionData.rowData[0])
      };
      this.validate();
    }
    do() {
      InsertDataRowApply(this._commandUnit, this._doActionData);
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
    }
    redo() {
      this.do();
    }
    undo() {
      RemoveRowDataApply(this._commandUnit, this._oldActionData);
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
    }
    validate() {
      return false;
    }
  };
  __publicField(InsertRowDataAction, "NAME", "InsertRowDataAction");
  CommandManager.register(InsertRowDataAction.NAME, InsertRowDataAction);

  // ../../packages/core/src/Sheets/Action/InsertSheetAction.ts
  var InsertSheetAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this._oldActionData = {
        ...actionData,
        sheetId: this.do()
      };
    }
    do() {
      const result = InsertSheetApply(this._commandUnit, this._doActionData);
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    redo() {
      this.redo();
    }
    undo() {
      RemoveSheetApply(this._commandUnit, this._oldActionData);
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
    }
    validate() {
      throw new Error("Method not implemented.");
    }
  };
  __publicField(InsertSheetAction, "NAME", "InsertSheetAction");
  CommandManager.register(InsertSheetAction.NAME, InsertSheetAction);

  // ../../packages/core/src/Sheets/Action/removeColumnAction.ts
  var RemoveColumnAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this._oldActionData = {
        ...actionData,
        columnCount: this.do()
      };
      this.validate();
    }
    do() {
      const result = RemoveColumnApply(this._commandUnit, this._doActionData);
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    redo() {
      this.do();
    }
    undo() {
      InsertColumnApply(this._commandUnit, this._oldActionData);
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
    }
    validate() {
      return false;
    }
  };
  __publicField(RemoveColumnAction, "NAME", "RemoveColumnAction");
  CommandManager.register(RemoveColumnAction.NAME, RemoveColumnAction);

  // ../../packages/core/src/Sheets/Action/RemoveColumnDataAction.ts
  var RemoveColumnDataAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this._oldActionData = {
        ...actionData,
        columnData: this.do()
      };
      this.validate();
    }
    do() {
      const result = RemoveColumnDataApply(this._commandUnit, this._doActionData);
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    redo() {
      this.do();
    }
    undo() {
      InsertDataColumnApply(this._commandUnit, this._oldActionData);
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
    }
    validate() {
      return false;
    }
  };
  __publicField(RemoveColumnDataAction, "NAME", "RemoveColumnDataAction");
  CommandManager.register(RemoveColumnDataAction.NAME, RemoveColumnDataAction);

  // ../../packages/core/src/Sheets/Action/RemoveMergeAction.ts
  var RemoveMergeAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this._oldActionData = {
        ...actionData,
        rectangles: this.do()
      };
      this.validate();
    }
    do() {
      const result = RemoveMergeApply(this._commandUnit, this._doActionData);
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    redo() {
      this.do();
    }
    undo() {
      addMergeApply(this._commandUnit, this._oldActionData);
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
    }
    validate() {
      return false;
    }
  };
  __publicField(RemoveMergeAction, "NAME", "RemoveMergeAction");
  CommandManager.register(RemoveMergeAction.NAME, RemoveMergeAction);

  // ../../packages/core/src/Sheets/Action/RemoveRowAction.ts
  var RemoveRowAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this._oldActionData = {
        ...actionData,
        rowCount: this.do()
      };
      this.validate();
    }
    do() {
      const result = RemoveRowApply(this._commandUnit, this._doActionData);
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    redo() {
      this.do();
    }
    undo() {
      InsertRowApply(this._commandUnit, this._oldActionData);
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
    }
    validate() {
      return false;
    }
  };
  __publicField(RemoveRowAction, "NAME", "RemoveRowAction");
  CommandManager.register(RemoveRowAction.NAME, RemoveRowAction);

  // ../../packages/core/src/Sheets/Action/RemoveRowDataAction.ts
  var RemoveRowDataAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this._oldActionData = {
        ...actionData,
        rowData: this.do()
      };
      this.validate();
    }
    do() {
      const result = RemoveRowDataApply(this._commandUnit, this._doActionData);
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    redo() {
      this.do();
    }
    undo() {
      InsertDataRowApply(this._commandUnit, this._oldActionData);
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
    }
    validate() {
      return false;
    }
  };
  __publicField(RemoveRowDataAction, "NAME", "RemoveRowDataAction");
  CommandManager.register(RemoveRowDataAction.NAME, RemoveRowDataAction);

  // ../../packages/core/src/Sheets/Action/RemoveSheetAction.ts
  var RemoveSheetAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this._oldActionData = {
        ...actionData,
        ...this.do()
      };
    }
    do() {
      return this.redo();
    }
    redo() {
      const result = RemoveSheetApply(this._commandUnit, this._doActionData);
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    undo() {
      const workbook = this.getWorkBook();
      InsertSheetApply(this._commandUnit, this._oldActionData);
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
    }
    validate() {
      throw new Error("Method not implemented.");
    }
  };
  __publicField(RemoveSheetAction, "NAME", "RemoveSheetAction");
  CommandManager.register(RemoveSheetAction.NAME, RemoveSheetAction);

  // ../../packages/core/src/Sheets/Action/SetBorderAction.ts
  var SetBorderAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this._oldActionData = {
        ...actionData,
        styles: this.do()
      };
      this.validate();
    }
    do() {
      const result = SetBorderApply(this._commandUnit, this._doActionData);
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    redo() {
      this.do();
    }
    undo() {
      SetBorderApply(this._commandUnit, this._oldActionData);
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
    }
    validate() {
      return false;
    }
  };
  __publicField(SetBorderAction, "NAME", "SetBorderAction");
  CommandManager.register(SetBorderAction.NAME, SetBorderAction);

  // ../../packages/core/src/Sheets/Action/SetColumnHideAction.ts
  var SetColumnHideAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this.do();
      this._oldActionData = {
        ...actionData
      };
      this.validate();
    }
    do() {
      SetColumnHideApply(this._commandUnit, this._doActionData);
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
    }
    redo() {
      this.do();
    }
    undo() {
      SetColumnShowApply(this._commandUnit, this._oldActionData);
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
    }
    validate() {
      return false;
    }
  };
  __publicField(SetColumnHideAction, "NAME", "SetColumnHideAction");
  CommandManager.register(SetColumnHideAction.NAME, SetColumnHideAction);

  // ../../packages/core/src/Sheets/Action/SetColumnShowAction.ts
  var SetColumnShowAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this.do();
      this._oldActionData = {
        ...actionData
      };
      this.validate();
    }
    do() {
      SetColumnShowApply(this._commandUnit, this._doActionData);
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
    }
    redo() {
      this.do();
    }
    undo() {
      SetColumnHideApply(this._commandUnit, this._oldActionData);
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
    }
    validate() {
      return false;
    }
  };
  __publicField(SetColumnShowAction, "NAME", "SetColumnShowAction");
  CommandManager.register(SetColumnShowAction.NAME, SetColumnShowAction);

  // ../../packages/core/src/Sheets/Action/SetColumnWidthAction.ts
  var SetColumnWidthAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this._oldActionData = {
        ...actionData,
        columnWidth: this.do()
      };
      this.validate();
    }
    do() {
      const result = SetColumnWidthApply(this._commandUnit, this._doActionData);
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    redo() {
      this.do();
    }
    undo() {
      const result = SetColumnWidthApply(this._commandUnit, this._doActionData);
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
      return result;
    }
    validate() {
      return false;
    }
  };
  __publicField(SetColumnWidthAction, "NAME", "SetColumnWidthAction");
  CommandManager.register(SetColumnWidthAction.NAME, SetColumnWidthAction);

  // ../../packages/core/src/Sheets/Action/SetHiddenGridlinesAction.ts
  var SetHiddenGridlinesAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this._oldActionData = {
        ...actionData,
        hideGridlines: this.do()
      };
      this.validate();
    }
    do() {
      const result = SetHiddenGridlinesApply(
        this._commandUnit,
        this._doActionData
      );
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    redo() {
      this.do();
    }
    undo() {
      SetHiddenGridlinesApply(this._commandUnit, this._oldActionData);
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
    }
    validate() {
      return false;
    }
  };
  __publicField(SetHiddenGridlinesAction, "NAME", "SetHiddenGridlinesAction");
  CommandManager.register(SetHiddenGridlinesAction.NAME, SetHiddenGridlinesAction);

  // ../../packages/core/src/Sheets/Action/SetNamedRangeAction.ts
  var _SetNamedRangeAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this._oldActionData = {
        // actionName: ACTION_NAMES.SET_NAMED_RANGE_ACTION,
        actionName: _SetNamedRangeAction.NAME,
        namedRange: this.do(),
        sheetId: actionData.sheetId
      };
      this.validate();
    }
    do() {
      const result = SetNamedRangeApply(this._commandUnit, this._doActionData);
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    redo() {
      const { sheetId } = this._doActionData;
      this._oldActionData = {
        // actionName: ACTION_NAMES.SET_NAMED_RANGE_ACTION,
        actionName: _SetNamedRangeAction.NAME,
        sheetId,
        namedRange: this.do()
      };
    }
    undo() {
      const { sheetId } = this._oldActionData;
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
      this._doActionData = {
        // actionName: ACTION_NAMES.SET_NAMED_RANGE_ACTION,
        actionName: _SetNamedRangeAction.NAME,
        sheetId,
        namedRange: SetNamedRangeApply(this._commandUnit, this._oldActionData)
      };
    }
    validate() {
      return false;
    }
  };
  var SetNamedRangeAction = _SetNamedRangeAction;
  __publicField(SetNamedRangeAction, "NAME", "SetNamedRangeAction");
  CommandManager.register(SetNamedRangeAction.NAME, SetNamedRangeAction);

  // ../../packages/core/src/Sheets/Action/SetRangeFormatAction.ts
  var _SetRangeFormatAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this._oldActionData = {
        ...actionData,
        cellFormat: this.do()
      };
      this.validate();
    }
    do() {
      const worksheet = this.getWorkSheet();
      const result = SetRangeFormat(
        worksheet.getCellMatrix(),
        this._doActionData.cellFormat,
        this._doActionData.rangeData
      );
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    redo() {
      const { sheetId, rangeData } = this._doActionData;
      this._oldActionData = {
        // actionName: ACTION_NAMES.SET_RANGE_FORMAT_ACTION,
        actionName: _SetRangeFormatAction.NAME,
        sheetId,
        cellFormat: this.do(),
        rangeData
      };
    }
    undo() {
      const { rangeData, sheetId, cellFormat } = this._oldActionData;
      const worksheet = this.getWorkSheet();
      if (worksheet) {
        this._doActionData = {
          // actionName: ACTION_NAMES.SET_RANGE_FORMAT_ACTION,
          actionName: _SetRangeFormatAction.NAME,
          sheetId,
          cellFormat: SetRangeFormat(
            worksheet.getCellMatrix(),
            cellFormat,
            rangeData
          ),
          rangeData
        };
        this._observers.notifyObservers({
          type: 1 /* UNDO */,
          data: this._oldActionData,
          action: this
        });
      }
    }
    validate() {
      return false;
    }
  };
  var SetRangeFormatAction = _SetRangeFormatAction;
  __publicField(SetRangeFormatAction, "NAME", "SetRangeFormatAction");
  CommandManager.register(SetRangeFormatAction.NAME, SetRangeFormatAction);

  // ../../packages/core/src/Sheets/Action/SetRangeFormulaAction.ts
  var _SetRangeFormulaAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this._oldActionData = {
        ...actionData,
        cellFormula: this.do()
      };
      this.validate();
    }
    do() {
      const worksheet = this.getWorkSheet();
      const result = SetRangeFormula(
        worksheet.getCellMatrix(),
        this._doActionData.cellFormula,
        this._doActionData.rangeData
      );
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    redo() {
      const { sheetId, rangeData } = this._doActionData;
      this._oldActionData = {
        // actionName: ACTION_NAMES.SET_RANGE_FORMULA_ACTION,
        actionName: _SetRangeFormulaAction.NAME,
        sheetId,
        cellFormula: this.do(),
        rangeData
      };
    }
    undo() {
      const { rangeData, sheetId, cellFormula } = this._oldActionData;
      const worksheet = this.getWorkSheet();
      if (worksheet) {
        this._doActionData = {
          // actionName: ACTION_NAMES.SET_RANGE_FORMULA_ACTION,
          actionName: _SetRangeFormulaAction.NAME,
          sheetId,
          cellFormula: SetRangeFormula(
            worksheet.getCellMatrix(),
            cellFormula,
            rangeData
          ),
          rangeData
        };
        this._observers.notifyObservers({
          type: 1 /* UNDO */,
          data: this._oldActionData,
          action: this
        });
      }
    }
    validate() {
      return false;
    }
  };
  var SetRangeFormulaAction = _SetRangeFormulaAction;
  __publicField(SetRangeFormulaAction, "NAME", "SetRangeFormulaAction");
  CommandManager.register(SetRangeFormulaAction.NAME, SetRangeFormulaAction);

  // ../../packages/core/src/Sheets/Action/SetRangeNoteAction.ts
  var _SetRangeNoteAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this._oldActionData = {
        ...actionData,
        cellNote: this.do()
      };
      this.validate();
    }
    do() {
      const worksheet = this.getWorkSheet();
      const result = SetRangeNote(
        worksheet.getCellMatrix(),
        this._doActionData.cellNote,
        this._doActionData.rangeData
      );
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    redo() {
      const { sheetId, rangeData } = this._doActionData;
      this._oldActionData = {
        // actionName: ACTION_NAMES.SET_RANGE_NOTE_ACTION,
        actionName: _SetRangeNoteAction.NAME,
        sheetId,
        cellNote: this.do(),
        rangeData
      };
    }
    undo() {
      const { rangeData, sheetId, cellNote } = this._oldActionData;
      const worksheet = this.getWorkSheet();
      if (worksheet) {
        this._doActionData = {
          // actionName: ACTION_NAMES.SET_RANGE_NOTE_ACTION,
          actionName: _SetRangeNoteAction.NAME,
          sheetId,
          cellNote: SetRangeNote(
            worksheet.getCellMatrix(),
            cellNote,
            rangeData
          ),
          rangeData
        };
        this._observers.notifyObservers({
          type: 1 /* UNDO */,
          data: this._oldActionData,
          action: this
        });
      }
    }
    validate() {
      return false;
    }
  };
  var SetRangeNoteAction = _SetRangeNoteAction;
  __publicField(SetRangeNoteAction, "NAME", "SetRangeNoteAction");
  CommandManager.register(SetRangeNoteAction.NAME, SetRangeNoteAction);

  // ../../packages/core/src/Sheets/Action/SetRangeStyleAction.ts
  var _SetRangeStyleAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._oldActionData = {
        ...actionData,
        value: this.do()
      };
      this.validate();
    }
    do() {
      const { value, rangeData } = this._doActionData;
      const styles = this._workbook.getStyles();
      const cellMatrix = this.getWorkSheet().getCellMatrix();
      const result = SetRangeStyle(cellMatrix, value, rangeData, styles);
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    redo() {
      const { sheetId, rangeData } = this._doActionData;
      this._oldActionData = {
        // actionName: ACTION_NAMES.SET_RANGE_STYLE_ACTION,
        actionName: _SetRangeStyleAction.NAME,
        sheetId,
        value: this.do(),
        rangeData
      };
    }
    undo() {
      const { value, rangeData, sheetId } = this._oldActionData;
      const styles = this._workbook.getStyles();
      const cellMatrix = this.getWorkSheet().getCellMatrix();
      this._doActionData = {
        // actionName: ACTION_NAMES.SET_RANGE_STYLE_ACTION,
        actionName: _SetRangeStyleAction.NAME,
        sheetId,
        value: SetRangeStyle(cellMatrix, value, rangeData, styles),
        rangeData
      };
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
    }
    validate() {
      return false;
    }
  };
  var SetRangeStyleAction = _SetRangeStyleAction;
  __publicField(SetRangeStyleAction, "NAME", "SetRangeStyleAction");
  CommandManager.register(SetRangeStyleAction.NAME, SetRangeStyleAction);

  // ../../packages/core/src/Sheets/Action/SetRangeFormattedValueAction.ts
  var SetRangeFormattedValueAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this._oldActionData = {
        ...actionData,
        cellValue: this.do()
      };
      this.validate();
    }
    do() {
      const worksheet = this.getWorkSheet();
      const result = SetRangeFormattedValue(
        worksheet.getCellMatrix(),
        this._doActionData.cellValue,
        this._doActionData.rangeData
      );
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    redo() {
      const { sheetId, rangeData } = this._doActionData;
      this._oldActionData = {
        // actionName: ACTION_NAMES.SET_RANGE_DATA_ACTION,
        actionName: SetRangeDataAction.NAME,
        sheetId,
        cellValue: this.do(),
        rangeData
      };
    }
    undo() {
      const { rangeData, sheetId, cellValue } = this._oldActionData;
      const worksheet = this.getWorkSheet();
      if (worksheet) {
        this._doActionData = {
          // actionName: ACTION_NAMES.SET_RANGE_DATA_ACTION,
          actionName: SetRangeDataAction.NAME,
          sheetId,
          cellValue: SetRangeFormattedValue(
            worksheet.getCellMatrix(),
            cellValue,
            rangeData
          ),
          rangeData
        };
        this._observers.notifyObservers({
          type: 1 /* UNDO */,
          data: this._oldActionData,
          action: this
        });
      }
    }
    validate() {
      return false;
    }
  };
  __publicField(SetRangeFormattedValueAction, "NAME", "SetRangeFormattedValueAction");
  CommandManager.register(
    SetRangeFormattedValueAction.NAME,
    SetRangeFormattedValueAction
  );

  // ../../packages/core/src/Sheets/Action/SetRightToLeftAction.ts
  var SetRightToLeftAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this._oldActionData = {
        ...actionData,
        rightToLeft: this.do()
      };
      this.validate();
    }
    do() {
      const worksheet = this.getWorkSheet();
      const result = SetRightToLeft(worksheet, this._doActionData.rightToLeft);
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    redo() {
      this.do();
    }
    undo() {
      const { rightToLeft, sheetId } = this._oldActionData;
      const worksheet = this.getWorkSheet();
      SetRightToLeft(worksheet, this._oldActionData.rightToLeft);
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
    }
    validate() {
      return false;
    }
  };
  __publicField(SetRightToLeftAction, "NAME", "SetRightToLeftAction");
  CommandManager.register(SetRightToLeftAction.NAME, SetRightToLeftAction);

  // ../../packages/core/src/Sheets/Action/SetRowHeightAction.ts
  var SetRowHeightAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this._oldActionData = {
        ...actionData,
        rowHeight: this.do()
      };
      this.validate();
    }
    do() {
      const worksheet = this.getWorkSheet();
      const result = SetRowHeight(
        this._doActionData.rowIndex,
        this._doActionData.rowHeight,
        worksheet.getRowManager()
      );
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    redo() {
      this.do();
    }
    undo() {
      const worksheet = this.getWorkSheet();
      const result = SetRowHeight(
        this._oldActionData.rowIndex,
        this._oldActionData.rowHeight,
        worksheet.getRowManager()
      );
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
      return result;
    }
    validate() {
      return false;
    }
  };
  __publicField(SetRowHeightAction, "NAME", "SetRowHeightAction");
  CommandManager.register(SetRowHeightAction.NAME, SetRowHeightAction);

  // ../../packages/core/src/Sheets/Action/SetRowHideAction.ts
  var SetRowHideAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this.do();
      this._oldActionData = {
        ...actionData
      };
      this.validate();
    }
    do() {
      const worksheet = this.getWorkSheet();
      SetHideRow(
        this._doActionData.rowIndex,
        this._doActionData.rowCount,
        worksheet.getRowManager()
      );
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
    }
    redo() {
      this.do();
    }
    undo() {
      const worksheet = this.getWorkSheet();
      SetShowRow(
        this._oldActionData.rowIndex,
        this._doActionData.rowCount,
        worksheet.getRowManager()
      );
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
    }
    validate() {
      return false;
    }
  };
  __publicField(SetRowHideAction, "NAME", "SetRowHideAction");
  CommandManager.register(SetRowHideAction.NAME, SetRowHideAction);

  // ../../packages/core/src/Sheets/Action/SetRowShowAction.ts
  var SetRowShowAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this.do();
      this._oldActionData = {
        ...actionData
      };
      this.validate();
    }
    do() {
      const worksheet = this.getWorkSheet();
      SetShowRow(
        this._doActionData.rowIndex,
        this._doActionData.rowCount,
        worksheet.getRowManager()
      );
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
    }
    redo() {
      this.do();
    }
    undo() {
      const worksheet = this.getWorkSheet();
      SetHideRow(
        this._oldActionData.rowIndex,
        this._oldActionData.rowCount,
        worksheet.getRowManager()
      );
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
    }
    validate() {
      return false;
    }
  };
  __publicField(SetRowShowAction, "NAME", "SetRowShowAction");
  CommandManager.register(SetRowShowAction.NAME, SetRowShowAction);

  // ../../packages/core/src/Sheets/Action/SetSelectionActivateAction.ts
  var _SetSelectionActivateAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      const { activeRangeList, activeRange, currentCell } = this.do();
      this._oldActionData = {
        ...actionData,
        activeRangeList,
        activeRange,
        currentCell
      };
      this.validate();
    }
    do() {
      const { activeRangeList, activeRange, currentCell } = this._doActionData;
      const worksheet = this.getWorkSheet();
      const result = SetSelectionActivate(
        worksheet,
        activeRangeList,
        activeRange,
        currentCell
      );
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    redo() {
      const { sheetId } = this._doActionData;
      const { activeRangeList, activeRange, currentCell } = this.do();
      this._oldActionData = {
        // actionName: ACTION_NAMES.SET_SELECTION_ACTION,
        actionName: _SetSelectionActivateAction.NAME,
        sheetId,
        activeRangeList,
        activeRange,
        currentCell
      };
    }
    undo() {
      const { activeRangeList, activeRange, currentCell, sheetId } = this._oldActionData;
      const worksheet = this.getWorkSheet();
      const doData = SetSelectionActivate(
        worksheet,
        activeRangeList,
        activeRange,
        currentCell
      );
      this._doActionData = {
        // actionName: ACTION_NAMES.SET_SELECTION_ACTION,
        actionName: _SetSelectionActivateAction.NAME,
        sheetId,
        activeRangeList: doData.activeRangeList,
        activeRange: doData.activeRange,
        currentCell: doData.currentCell
      };
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
    }
    validate() {
      return false;
    }
  };
  var SetSelectionActivateAction = _SetSelectionActivateAction;
  __publicField(SetSelectionActivateAction, "NAME", "SetSelectionActivateAction");
  CommandManager.register(SetSelectionActivateAction.NAME, SetSelectionActivateAction);

  // ../../packages/core/src/Sheets/Action/SetSheetOrderAction.ts
  var SetSheetOrderAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this._oldActionData = {
        ...actionData,
        order: this.do()
      };
      this.validate();
    }
    do() {
      const worksheet = this.getWorkSheet();
      const context = worksheet.getContext();
      const workbook = context.getWorkBook();
      const result = SetSheetOrder(
        workbook,
        this._doActionData.sheetId,
        this._doActionData.order
      );
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    redo() {
      this.do();
    }
    undo() {
      const worksheet = this.getWorkSheet();
      const context = worksheet.getContext();
      const workbook = context.getWorkBook();
      SetSheetOrder(
        workbook,
        this._oldActionData.sheetId,
        this._oldActionData.order
      );
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
    }
    validate() {
      return false;
    }
  };
  __publicField(SetSheetOrderAction, "NAME", "SetSheetOrderAction");
  CommandManager.register(SetSheetOrderAction.NAME, SetSheetOrderAction);

  // ../../packages/core/src/Sheets/Action/SetTabColorAction.ts
  var _SetTabColorAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this._oldActionData = {
        ...actionData,
        color: this.do()
      };
      this.validate();
    }
    do() {
      const worksheet = this.getWorkSheet();
      const result = SetTabColor(worksheet, this._doActionData.color);
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    redo() {
      const { sheetId } = this._doActionData;
      this._oldActionData = {
        sheetId,
        // actionName: ACTION_NAMES.SET_TAB_COLOR_ACTION,
        actionName: _SetTabColorAction.NAME,
        color: this.do()
      };
    }
    undo() {
      const { color, sheetId } = this._oldActionData;
      const worksheet = this.getWorkSheet();
      this._doActionData = {
        // actionName: ACTION_NAMES.SET_TAB_COLOR_ACTION,
        actionName: _SetTabColorAction.NAME,
        sheetId,
        color: SetTabColor(worksheet, color)
      };
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
    }
    validate() {
      return false;
    }
  };
  var SetTabColorAction = _SetTabColorAction;
  __publicField(SetTabColorAction, "NAME", "SetTabColorAction");
  CommandManager.register(SetTabColorAction.NAME, SetTabColorAction);

  // ../../packages/core/src/Sheets/Action/SetWorkSheetActivateAction.ts
  var _SetWorkSheetActivateAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      const { oldSheetId, status } = this.do();
      this._oldActionData = {
        ...actionData,
        sheetId: oldSheetId,
        status
      };
      this.validate();
      this.removeOperation(2 /* SERVER_ACTION */);
    }
    do() {
      const { sheetId, status } = this._doActionData;
      const worksheet = this._workbook.getSheetBySheetId(sheetId);
      const result = SetWorkSheetActivate(worksheet, status);
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    redo() {
      const { oldSheetId, status } = this.do();
      this._oldActionData = {
        // actionName: ACTION_NAMES.SET_WORKSHEET_ACTIVATE_ACTION,
        actionName: _SetWorkSheetActivateAction.NAME,
        sheetId: oldSheetId,
        status
      };
    }
    undo() {
      const { sheetId } = this._oldActionData;
      const oldStatus = this._oldActionData.status;
      const worksheet = this._workbook.getSheetBySheetId(sheetId);
      if (worksheet) {
        const { oldSheetId, status } = SetWorkSheetActivate(
          worksheet,
          oldStatus
        );
        this._doActionData = {
          actionName: _SetWorkSheetActivateAction.NAME,
          sheetId: oldSheetId,
          status
        };
        this._observers.notifyObservers({
          type: 1 /* UNDO */,
          data: this._oldActionData,
          action: this
        });
      }
    }
    validate() {
      return false;
    }
  };
  var SetWorkSheetActivateAction = _SetWorkSheetActivateAction;
  __publicField(SetWorkSheetActivateAction, "NAME", "SetWorkSheetActivateAction");
  CommandManager.register(SetWorkSheetActivateAction.NAME, SetWorkSheetActivateAction);

  // ../../packages/core/src/Sheets/Action/SetWorkSheetHideAction.ts
  var _SetWorkSheetHideAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this._oldActionData = {
        ...actionData,
        hidden: this.do()
      };
      this.validate();
    }
    do() {
      const worksheet = this.getWorkSheet();
      const result = SetWorkSheetHideService(worksheet, this._doActionData.hidden);
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    redo() {
      const { sheetId } = this._doActionData;
      this._oldActionData = {
        sheetId,
        // actionName: ACTION_NAMES.HIDE_SHEET_ACTION,
        actionName: _SetWorkSheetHideAction.NAME,
        hidden: this.do()
      };
    }
    undo() {
      const { hidden, sheetId } = this._oldActionData;
      const worksheet = this.getWorkSheet();
      this._doActionData = {
        actionName: _SetWorkSheetHideAction.NAME,
        sheetId,
        hidden: SetWorkSheetHideService(worksheet, hidden)
      };
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
    }
    validate() {
      return false;
    }
  };
  var SetWorkSheetHideAction = _SetWorkSheetHideAction;
  __publicField(SetWorkSheetHideAction, "NAME", "SetWorkSheetHideAction");
  CommandManager.register(SetWorkSheetHideAction.NAME, SetWorkSheetHideAction);

  // ../../packages/core/src/Sheets/Action/SetWorkSheetNameAction.ts
  var _SetWorkSheetNameAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this._oldActionData = {
        ...actionData,
        sheetName: this.do()
      };
      this.validate();
    }
    do() {
      const worksheet = this.getWorkSheet();
      const result = SetWorkSheetName(worksheet, this._doActionData.sheetName);
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    redo() {
      const { sheetId } = this._doActionData;
      this._oldActionData = {
        sheetId,
        actionName: _SetWorkSheetNameAction.NAME,
        sheetName: this.do()
      };
    }
    undo() {
      const { sheetName, sheetId } = this._oldActionData;
      const worksheet = this.getWorkSheet();
      this._doActionData = {
        actionName: _SetWorkSheetNameAction.NAME,
        sheetId,
        sheetName: SetWorkSheetName(worksheet, sheetName)
      };
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
    }
    validate() {
      return false;
    }
  };
  var SetWorkSheetNameAction = _SetWorkSheetNameAction;
  __publicField(SetWorkSheetNameAction, "NAME", "SetWorkSheetNameAction");
  CommandManager.register(SetWorkSheetNameAction.NAME, SetWorkSheetNameAction);

  // ../../packages/core/src/Sheets/Action/SetWorkSheetStatusAction.ts
  var SetWorkSheetStatusAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this._oldActionData = {
        ...actionData,
        sheetStatus: this.do()
      };
      this.validate();
    }
    do() {
      const worksheet = this.getWorkSheet();
      const result = SetWorkSheetStatus(worksheet, this._doActionData.sheetStatus);
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    redo() {
      const { sheetId } = this._doActionData;
      this._oldActionData = {
        sheetId,
        actionName: "SetWorkSheetStatusAction" /* SET_WORKSHEET_STATUS_ACTION */,
        sheetStatus: this.do()
      };
    }
    undo() {
      const { sheetStatus, sheetId } = this._oldActionData;
      const worksheet = this.getWorkSheet();
      this._doActionData = {
        actionName: "SetWorkSheetStatusAction" /* SET_WORKSHEET_STATUS_ACTION */,
        sheetId,
        sheetStatus: SetWorkSheetStatus(worksheet, sheetStatus)
      };
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
    }
    validate() {
      return false;
    }
  };
  __publicField(SetWorkSheetStatusAction, "NAME", "SetWorkSheetStatusAction");
  CommandManager.register(SetWorkSheetStatusAction.NAME, SetWorkSheetStatusAction);

  // ../../packages/core/src/Sheets/Action/SetZoomRatioAction.ts
  var SetZoomRatioAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this._oldActionData = {
        ...actionData,
        zoom: this.do()
      };
      this.validate();
    }
    redo() {
      const result = SetZoomRatio(
        this.getWorkBook(),
        this._doActionData.sheetId,
        this._doActionData.zoom
      );
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    do() {
      return this.redo();
    }
    undo() {
      SetZoomRatio(
        this.getWorkBook(),
        this._oldActionData.sheetId,
        this._oldActionData.zoom
      );
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._oldActionData,
        action: this
      });
    }
    validate() {
      return false;
    }
  };
  __publicField(SetZoomRatioAction, "NAME", "SetZoomRatioAction");
  CommandManager.register(SetZoomRatioAction.NAME, SetZoomRatioAction);

  // ../../packages/core/src/Plugin/Plugin.ts
  var Plugin = class {
    context;
    _name;
    _observeNames;
    constructor(name) {
      this._name = name;
      this._observeNames = [];
    }
    onCreate(context) {
      this.context = context;
    }
    load(data) {
    }
    save() {
      return Object();
    }
    onMounted(context) {
    }
    onDestroy() {
      this.deleteObserve(...this._observeNames);
    }
    getPluginName() {
      return this._name;
    }
    getContext() {
      return this.context;
    }
    getGlobalContext() {
      return this.context.getUniver().getGlobalContext();
    }
    getLocale() {
      return this.getGlobalContext().getLocale();
    }
    getUniver() {
      return this.context.getUniver();
    }
    getObserver(name) {
      const manager = this.context.getObserverManager();
      return manager.getObserver(name, this._name);
    }
    getPluginByName(name) {
      return this.context.getPluginManager().getPluginByName(name);
    }
    pushToObserve(...names) {
      const manager = this.context.getObserverManager();
      names.forEach((name) => {
        if (!this._observeNames.includes(name)) {
          this._observeNames.push(name);
        }
        manager.addObserver(name, this._name, new Observable());
      });
    }
    deleteObserve(...names) {
      const manager = this.context.getObserverManager();
      names.forEach((name) => {
        manager.removeObserver(name, this._name);
      });
    }
  };

  // ../../packages/core/src/Plugin/PluginManager.ts
  var PluginManager = class {
    _context;
    _plugins;
    _initialized;
    constructor(context, plugins = []) {
      this._context = context;
      this._plugins = [];
      this._initialized = true;
      this._plugins = this._plugins.concat(plugins);
      this._initialize();
    }
    install(plugin) {
      const { _plugins } = this;
      _plugins.push(plugin);
      plugin.onCreate(this._context);
      plugin.onMounted(this._context);
    }
    uninstall(name) {
      const { _plugins } = this;
      const index = _plugins.findIndex((item) => item.getPluginName() === name);
      if (index > -1) {
        const plugin = _plugins.splice(index, 1)[0];
        if (plugin) {
          plugin.onDestroy();
        }
      }
    }
    setContext(context) {
      this._context = context;
    }
    getRequirePluginByName(pluginName) {
      for (let i4 = 0; i4 < this._plugins.length; i4++) {
        if (this._plugins[i4].getPluginName() === pluginName) {
          return this._plugins[i4];
        }
      }
      throw new Error(`not found plugin ${pluginName}`);
    }
    getPlugins() {
      return this._plugins;
    }
    getPluginByName(pluginName) {
      for (let i4 = 0; i4 < this._plugins.length; i4++) {
        if (this._plugins[i4].getPluginName() === pluginName) {
          return this._plugins[i4];
        }
      }
      return null;
    }
    _initialize() {
      if (this._initialized) {
        this._initialized = false;
        this._plugins.forEach((plugin) => {
          plugin.onCreate(this._context);
          plugin.onMounted(this._context);
        });
      }
    }
  };

  // ../../packages/core/src/Basics/Environment.ts
  var Environment = class {
    os;
    app_version;
    device_id;
    platform;
    os_version;
    constructor() {
      this.os = "";
      this.app_version = "";
      this.platform = "";
      this.device_id = "";
      this.os_version = "";
    }
  };

  // ../../packages/core/src/Basics/ContextBase.ts
  var ContextBase = class {
    _commandManager;
    _environment;
    _hooksManager;
    _undoManager;
    _pluginManager;
    _observerManager;
    _univer;
    constructor() {
      this._undoManager = new UndoManager2();
      this._commandManager = new CommandManager(this);
      this._environment = new Environment();
      this._hooksManager = new HooksManager();
      this._pluginManager = new PluginManager(this);
      this._observerManager = new ObserverManager();
    }
    onUniver(univer2) {
      this._univer = univer2;
    }
    getHook(path) {
      return this._hooksManager.getHooks(path);
    }
    getHooksManager() {
      return this._hooksManager;
    }
    getObserverManager() {
      return this._observerManager;
    }
    getPluginManager() {
      return this._pluginManager;
    }
    getUndoManager() {
      return this._undoManager;
    }
    getCommandManager() {
      return this._commandManager;
    }
    getUniver() {
      return this._univer;
    }
  };

  // ../../packages/core/src/Basics/Registry.ts
  var Registry2 = class {
    _data = [];
    static create() {
      return new Registry2();
    }
    add(dataInstance) {
      if (this._data.indexOf(dataInstance) > -1) {
        return;
      }
      this._data.push(dataInstance);
    }
    delete(dataInstance) {
      const index = this._data.indexOf(dataInstance);
      this._data.splice(index, 1);
    }
    getData() {
      return this._data;
    }
  };
  var RegistryAsMap = class {
    _data = /* @__PURE__ */ new Map();
    static create() {
      return new RegistryAsMap();
    }
    add(id, dataInstance) {
      if (this._data.has(id)) {
        return;
      }
      this._data.set(id, dataInstance);
    }
    delete(id) {
      this._data.delete(id);
    }
    getData() {
      return this._data;
    }
  };

  // ../../packages/core/src/Basics/WorkBookObserverImpl.ts
  var WorkBookObserverImpl = class {
    install(manager) {
      manager.addObserver(
        "onAfterSetSelectionObservable",
        "core",
        new Observable()
      );
      manager.addObserver(
        "onBeforeChangeNameObservable",
        "core",
        new Observable()
      );
      manager.addObserver("onAfterChangeNameObservable", "core", new Observable());
      manager.addObserver(
        "onBeforeChangeActiveSheetObservable",
        "core",
        new Observable()
      );
      manager.addObserver(
        "onAfterChangeActiveSheetObservable",
        "core",
        new Observable()
      );
      manager.addObserver(
        "onBeforeChangeSheetNameObservable",
        "core",
        new Observable()
      );
      manager.addObserver(
        "onAfterChangeSheetNameObservable",
        "core",
        new Observable()
      );
      manager.addObserver(
        "onBeforeInsertSheetObservable",
        "core",
        new Observable()
      );
      manager.addObserver(
        "onAfterInsertSheetObservable",
        "core",
        new Observable()
      );
      manager.addObserver(
        "onBeforeRemoveSheetObservable",
        "core",
        new Observable()
      );
      manager.addObserver(
        "onAfterRemoveSheetObservable",
        "core",
        new Observable()
      );
      manager.addObserver(
        "onBeforeChangeSheetColorObservable",
        "core",
        new Observable()
      );
      manager.addObserver(
        "onAfterChangeSheetColorObservable",
        "core",
        new Observable()
      );
      manager.addObserver(
        "onBeforeChangeSheetDataObservable",
        "core",
        new Observable()
      );
      manager.addObserver(
        "onAfterChangeSheetDataObservable",
        "core",
        new Observable()
      );
      manager.addObserver(
        "onSheetBarDidMountObservable",
        "core",
        new Observable()
      );
      manager.addObserver("onInfoBarDidMountObservable", "core", new Observable());
      manager.addObserver(
        "onRightMenuDidMountObservable",
        "core",
        new Observable()
      );
      manager.addObserver(
        "onAfterChangeSheetScrollObservable",
        "core",
        new Observable()
      );
      manager.addObserver(
        "onAfterChangeUILocaleObservable",
        "core",
        new Observable()
      );
      manager.addObserver(
        "onSheetRenderDidMountObservable",
        "core",
        new Observable()
      );
      manager.addObserver(
        "onAfterChangeUISkinObservable",
        "core",
        new Observable()
      );
      manager.addObserver("onHideSheetObservable", "core", new Observable());
      manager.addObserver("onShowSheetObservable", "core", new Observable());
      manager.addObserver(
        "onSheetTabColorChangeObservable",
        "core",
        new Observable()
      );
      manager.addObserver("onSheetOrderObservable", "core", new Observable());
      manager.addObserver("onZoomRatioSheetObservable", "core", new Observable());
    }
  };

  // ../../packages/core/src/Basics/SheetContext.ts
  var SheetContext = class extends ContextBase {
    _workbook;
    constructor(univerSheetData = {}) {
      super();
      this._setObserver();
      this._workbook = new Workbook(univerSheetData, this);
    }
    getWorkBook() {
      return this._workbook;
    }
    getContextObserver(value) {
      return this.getObserverManager().requiredObserver(value, "core");
    }
    refreshWorkbook(univerSheetData = {}) {
      this._workbook = new Workbook(univerSheetData, this);
    }
    _setObserver() {
      const manager = this.getObserverManager();
      new WorkBookObserverImpl().install(manager);
    }
  };

  // ../../packages/core/package.json
  var package_default = {
    name: "@univerjs/core",
    version: "0.0.1",
    description: "Univer core",
    keywords: [
      "univer",
      "core",
      "sheets",
      "docs",
      "slides",
      "excel",
      "word",
      "ppt"
    ],
    author: "DreamNum <msoffice2@126.com>",
    main: "./src/index.ts",
    module: "./src/index.ts",
    types: "./src/Types/index.d.ts",
    publishConfig: {
      main: "./lib/univer-core.js",
      module: "./lib/univer-core.mjs",
      types: "./lib/index.d.ts",
      exports: {
        ".": {
          require: "./lib/univer-core.js",
          default: "./lib/univer-core.mjs"
        },
        "./*": "./lib/*"
      },
      access: "public"
    },
    exports: {
      ".": "./src/index.ts",
      "./*": "./src/*"
    },
    directories: {
      lib: "lib"
    },
    files: [
      "lib"
    ],
    scripts: {
      test: "cross-env NODE_ENV=--experimental-vm-modules jest --config=jest.config.js",
      dev: "vite",
      build: "tsc && vite build",
      watch: "vite build",
      link: "pnpm link ./",
      api: "node ./api.js",
      tsc: "tsc",
      serve: "node test/Server/server.js"
    },
    license: "MIT",
    homepage: "https://github.com/dream-num/univer",
    repository: {
      type: "git",
      url: "https://github.com/dream-num/univer.git"
    },
    dependencies: {
      dayjs: "^1.11.5",
      "es6-proxy-polyfill": "^2.1.1",
      nanoid: "4.0.0",
      numeral: "^2.0.6",
      "reflect-metadata": "^0.1.13"
    },
    devDependencies: {
      "@types/jest": "^28.1.8",
      "@types/node": "^18.14.0",
      "@typescript-eslint/eslint-plugin": "^5.34.0",
      "@typescript-eslint/parser": "^5.34.0",
      debug: "^4.3.4",
      jest: "29.0.0",
      "jest-dev-server": "^6.1.1",
      "jest-environment-jsdom": "^29.0.3",
      less: "^4.1.3",
      "ts-jest": "29.0.1",
      "ts-node": "^10.9.1",
      typescript: "^4.7.4",
      vite: "^3.0.9",
      "vite-plugin-external": "1.2.3"
    }
  };

  // ../../packages/core/src/Basics/Version.ts
  var VersionEnv = "dev";
  var VersionCode = package_default.version;

  // ../../packages/core/src/Basics/UniverSheet.ts
  var UniverSheet = class {
    univerSheetConfig;
    _context;
    constructor(univerSheetData = {}) {
      this.univerSheetConfig = univerSheetData;
      this._context = new SheetContext(univerSheetData);
    }
    /**
     * get SheetContext
     */
    get context() {
      return this._context;
    }
    static newInstance(univerSheetData = {}) {
      Logger.capsule(VersionEnv, VersionCode, "powered by :: universheet :: ");
      return new UniverSheet(univerSheetData);
    }
    /**
     *
     * Request data
     *
     * @example
     * Get data for all tables, including core and plugin data
     *
     * @param config
     */
    static get(config) {
      return IOHttp({ ...config, type: "GET" });
    }
    /**
     * Submit data
     * @param config
     */
    static post(config) {
      return IOHttp({ ...config, type: "POST" });
    }
    /**
     * Load data
     *
     * @example
     * UniverSheet.get gets all the core and plug-in data, UniverSheet.load(univerSheetInstance,data) internally calls the load API of each plug-in to centrally load the core and plug-in data
     *
     * @param sheet
     * @param data
     */
    static load(sheet, data) {
      sheet.getWorkBook().load(data.workbookConfig);
      sheet.context.getPluginManager().getPlugins().forEach((plugin) => {
        plugin.load(data[`${plugin.getPluginName()}Config`]);
      });
    }
    static newColor() {
      return new ColorBuilder();
    }
    /**
     * Save data
     *
     * @example
     * get all the core and plug-in data
     *
     * @param univerSheet
     */
    static toJson(univerSheet) {
      const workbookConfig = univerSheet.getWorkBook().save();
      const pluginConfig = {};
      univerSheet.context.getPluginManager().getPlugins().forEach((plugin) => {
        pluginConfig[`${plugin.getPluginName()}Config`] = plugin.save();
      });
      return { workbookConfig, ...pluginConfig };
    }
    /**
     * get unit id
     */
    getUnitId() {
      return this.getWorkBook().getUnitId();
    }
    /**
     * install plugin
     *
     * @param plugin - install plugin
     */
    installPlugin(plugin) {
      this._context.getPluginManager().install(plugin);
    }
    /**
     * uninstall plugin
     *
     * @param name - plugin name
     */
    uninstallPlugin(name) {
      this._context.getPluginManager().uninstall(name);
    }
    /**
     * get WorkBook
     *
     * @returns Workbook
     */
    getWorkBook() {
      return this._context.getWorkBook();
    }
    refreshWorkbook(univerSheetData = {}) {
      this._context.refreshWorkbook(univerSheetData);
    }
  };

  // ../../packages/core/src/Basics/Context.ts
  var Context = class extends ContextBase {
    _locale;
    constructor(univerData = {}) {
      super();
      this._locale = new Locale();
      this._locale.initialize();
    }
    getLocale() {
      return this._locale;
    }
    _setObserver() {
    }
  };

  // ../../packages/core/src/Basics/Univer.ts
  var Univer = class {
    _univerSheets;
    _univerDocs;
    _univerSlides;
    _context;
    constructor() {
      this._univerSheets = [];
      this._univerDocs = [];
      this._univerSlides = [];
      this._context = new Context();
      this._context.onUniver(this);
    }
    addUniverSheet(univerSheet) {
      univerSheet.context.onUniver(this);
      this._univerSheets.push(univerSheet);
    }
    addUniverDoc(univerDoc) {
      univerDoc.context.onUniver(this);
      this._univerDocs.push(univerDoc);
    }
    addUniverSlide(univerSlide) {
      univerSlide.context.onUniver(this);
      this._univerSlides.push(univerSlide);
    }
    getUniverSheetInstance(id) {
      return this._univerSheets.find((sheet) => sheet.getUnitId() === id);
    }
    getUniverDocInstance(id) {
      return this._univerDocs.find((doc) => doc.getUnitId() === id);
    }
    getUniverSlideInstance(id) {
      return null;
    }
    getAllUniverSheetsInstance() {
      return this._univerSheets;
    }
    getAllUniverDocsInstance() {
      return this._univerDocs;
    }
    getAllUniverSlidesInstance() {
      return this._univerSlides;
    }
    /**
     * get active universheet
     * @returns
     */
    getCurrentUniverSheetInstance() {
      return this._univerSheets[0];
    }
    getCurrentUniverDocInstance() {
      return this._univerDocs[0];
    }
    getCurrentUniverSlideInstance() {
      return this._univerSlides[0];
    }
    getGlobalContext() {
      return this._context;
    }
    /**
     * install plugin
     *
     * @param plugin - install plugin
     */
    install(plugin) {
      this._context.getPluginManager().install(plugin);
    }
    /**
     * uninstall plugin
     *
     * @param name - plugin name
     */
    uninstall(name) {
      this._context.getPluginManager().uninstall(name);
    }
  };

  // ../../node_modules/.pnpm/reflect-metadata@0.1.13/node_modules/reflect-metadata/Reflect.js
  var Reflect2;
  (function(Reflect3) {
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : Function("return this;")();
      var exporter = makeExporter(Reflect3);
      if (typeof root.Reflect === "undefined") {
        root.Reflect = Reflect3;
      } else {
        exporter = makeExporter(root.Reflect, exporter);
      }
      factory(exporter);
      function makeExporter(target, previous) {
        return function(key, value) {
          if (typeof target[key] !== "function") {
            Object.defineProperty(target, key, { configurable: true, writable: true, value });
          }
          if (previous)
            previous(key, value);
        };
      }
    })(function(exporter) {
      var hasOwn = Object.prototype.hasOwnProperty;
      var supportsSymbol = typeof Symbol === "function";
      var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
      var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
      var supportsCreate = typeof Object.create === "function";
      var supportsProto = { __proto__: [] } instanceof Array;
      var downLevel = !supportsCreate && !supportsProto;
      var HashMap = {
        // create an object in dictionary mode (a.k.a. "slow" mode in v8)
        create: supportsCreate ? function() {
          return MakeDictionary(/* @__PURE__ */ Object.create(null));
        } : supportsProto ? function() {
          return MakeDictionary({ __proto__: null });
        } : function() {
          return MakeDictionary({});
        },
        has: downLevel ? function(map, key) {
          return hasOwn.call(map, key);
        } : function(map, key) {
          return key in map;
        },
        get: downLevel ? function(map, key) {
          return hasOwn.call(map, key) ? map[key] : void 0;
        } : function(map, key) {
          return map[key];
        }
      };
      var functionPrototype = Object.getPrototypeOf(Function);
      var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
      var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
      var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
      var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
      var Metadata = new _WeakMap();
      function decorate(decorators, target, propertyKey, attributes) {
        if (!IsUndefined(propertyKey)) {
          if (!IsArray(decorators))
            throw new TypeError();
          if (!IsObject(target))
            throw new TypeError();
          if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
            throw new TypeError();
          if (IsNull(attributes))
            attributes = void 0;
          propertyKey = ToPropertyKey(propertyKey);
          return DecorateProperty(decorators, target, propertyKey, attributes);
        } else {
          if (!IsArray(decorators))
            throw new TypeError();
          if (!IsConstructor(target))
            throw new TypeError();
          return DecorateConstructor(decorators, target);
        }
      }
      exporter("decorate", decorate);
      function metadata(metadataKey, metadataValue) {
        function decorator(target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
            throw new TypeError();
          OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        return decorator;
      }
      exporter("metadata", metadata);
      function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
      }
      exporter("defineMetadata", defineMetadata);
      function hasMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryHasMetadata(metadataKey, target, propertyKey);
      }
      exporter("hasMetadata", hasMetadata);
      function hasOwnMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
      }
      exporter("hasOwnMetadata", hasOwnMetadata);
      function getMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryGetMetadata(metadataKey, target, propertyKey);
      }
      exporter("getMetadata", getMetadata);
      function getOwnMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
      }
      exporter("getOwnMetadata", getOwnMetadata);
      function getMetadataKeys(target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryMetadataKeys(target, propertyKey);
      }
      exporter("getMetadataKeys", getMetadataKeys);
      function getOwnMetadataKeys(target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryOwnMetadataKeys(target, propertyKey);
      }
      exporter("getOwnMetadataKeys", getOwnMetadataKeys);
      function deleteMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        var metadataMap = GetOrCreateMetadataMap(
          target,
          propertyKey,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return false;
        if (!metadataMap.delete(metadataKey))
          return false;
        if (metadataMap.size > 0)
          return true;
        var targetMetadata = Metadata.get(target);
        targetMetadata.delete(propertyKey);
        if (targetMetadata.size > 0)
          return true;
        Metadata.delete(target);
        return true;
      }
      exporter("deleteMetadata", deleteMetadata);
      function DecorateConstructor(decorators, target) {
        for (var i4 = decorators.length - 1; i4 >= 0; --i4) {
          var decorator = decorators[i4];
          var decorated = decorator(target);
          if (!IsUndefined(decorated) && !IsNull(decorated)) {
            if (!IsConstructor(decorated))
              throw new TypeError();
            target = decorated;
          }
        }
        return target;
      }
      function DecorateProperty(decorators, target, propertyKey, descriptor) {
        for (var i4 = decorators.length - 1; i4 >= 0; --i4) {
          var decorator = decorators[i4];
          var decorated = decorator(target, propertyKey, descriptor);
          if (!IsUndefined(decorated) && !IsNull(decorated)) {
            if (!IsObject(decorated))
              throw new TypeError();
            descriptor = decorated;
          }
        }
        return descriptor;
      }
      function GetOrCreateMetadataMap(O2, P4, Create) {
        var targetMetadata = Metadata.get(O2);
        if (IsUndefined(targetMetadata)) {
          if (!Create)
            return void 0;
          targetMetadata = new _Map();
          Metadata.set(O2, targetMetadata);
        }
        var metadataMap = targetMetadata.get(P4);
        if (IsUndefined(metadataMap)) {
          if (!Create)
            return void 0;
          metadataMap = new _Map();
          targetMetadata.set(P4, metadataMap);
        }
        return metadataMap;
      }
      function OrdinaryHasMetadata(MetadataKey, O2, P4) {
        var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O2, P4);
        if (hasOwn2)
          return true;
        var parent = OrdinaryGetPrototypeOf(O2);
        if (!IsNull(parent))
          return OrdinaryHasMetadata(MetadataKey, parent, P4);
        return false;
      }
      function OrdinaryHasOwnMetadata(MetadataKey, O2, P4) {
        var metadataMap = GetOrCreateMetadataMap(
          O2,
          P4,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return false;
        return ToBoolean(metadataMap.has(MetadataKey));
      }
      function OrdinaryGetMetadata(MetadataKey, O2, P4) {
        var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O2, P4);
        if (hasOwn2)
          return OrdinaryGetOwnMetadata(MetadataKey, O2, P4);
        var parent = OrdinaryGetPrototypeOf(O2);
        if (!IsNull(parent))
          return OrdinaryGetMetadata(MetadataKey, parent, P4);
        return void 0;
      }
      function OrdinaryGetOwnMetadata(MetadataKey, O2, P4) {
        var metadataMap = GetOrCreateMetadataMap(
          O2,
          P4,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return void 0;
        return metadataMap.get(MetadataKey);
      }
      function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O2, P4) {
        var metadataMap = GetOrCreateMetadataMap(
          O2,
          P4,
          /*Create*/
          true
        );
        metadataMap.set(MetadataKey, MetadataValue);
      }
      function OrdinaryMetadataKeys(O2, P4) {
        var ownKeys = OrdinaryOwnMetadataKeys(O2, P4);
        var parent = OrdinaryGetPrototypeOf(O2);
        if (parent === null)
          return ownKeys;
        var parentKeys = OrdinaryMetadataKeys(parent, P4);
        if (parentKeys.length <= 0)
          return ownKeys;
        if (ownKeys.length <= 0)
          return parentKeys;
        var set = new _Set();
        var keys = [];
        for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
          var key = ownKeys_1[_i];
          var hasKey = set.has(key);
          if (!hasKey) {
            set.add(key);
            keys.push(key);
          }
        }
        for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
          var key = parentKeys_1[_a];
          var hasKey = set.has(key);
          if (!hasKey) {
            set.add(key);
            keys.push(key);
          }
        }
        return keys;
      }
      function OrdinaryOwnMetadataKeys(O2, P4) {
        var keys = [];
        var metadataMap = GetOrCreateMetadataMap(
          O2,
          P4,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return keys;
        var keysObj = metadataMap.keys();
        var iterator = GetIterator(keysObj);
        var k5 = 0;
        while (true) {
          var next = IteratorStep(iterator);
          if (!next) {
            keys.length = k5;
            return keys;
          }
          var nextValue = IteratorValue(next);
          try {
            keys[k5] = nextValue;
          } catch (e4) {
            try {
              IteratorClose(iterator);
            } finally {
              throw e4;
            }
          }
          k5++;
        }
      }
      function Type(x4) {
        if (x4 === null)
          return 1;
        switch (typeof x4) {
          case "undefined":
            return 0;
          case "boolean":
            return 2;
          case "string":
            return 3;
          case "symbol":
            return 4;
          case "number":
            return 5;
          case "object":
            return x4 === null ? 1 : 6;
          default:
            return 6;
        }
      }
      function IsUndefined(x4) {
        return x4 === void 0;
      }
      function IsNull(x4) {
        return x4 === null;
      }
      function IsSymbol(x4) {
        return typeof x4 === "symbol";
      }
      function IsObject(x4) {
        return typeof x4 === "object" ? x4 !== null : typeof x4 === "function";
      }
      function ToPrimitive(input, PreferredType) {
        switch (Type(input)) {
          case 0:
            return input;
          case 1:
            return input;
          case 2:
            return input;
          case 3:
            return input;
          case 4:
            return input;
          case 5:
            return input;
        }
        var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
        var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
        if (exoticToPrim !== void 0) {
          var result = exoticToPrim.call(input, hint);
          if (IsObject(result))
            throw new TypeError();
          return result;
        }
        return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
      }
      function OrdinaryToPrimitive(O2, hint) {
        if (hint === "string") {
          var toString_1 = O2.toString;
          if (IsCallable(toString_1)) {
            var result = toString_1.call(O2);
            if (!IsObject(result))
              return result;
          }
          var valueOf = O2.valueOf;
          if (IsCallable(valueOf)) {
            var result = valueOf.call(O2);
            if (!IsObject(result))
              return result;
          }
        } else {
          var valueOf = O2.valueOf;
          if (IsCallable(valueOf)) {
            var result = valueOf.call(O2);
            if (!IsObject(result))
              return result;
          }
          var toString_2 = O2.toString;
          if (IsCallable(toString_2)) {
            var result = toString_2.call(O2);
            if (!IsObject(result))
              return result;
          }
        }
        throw new TypeError();
      }
      function ToBoolean(argument) {
        return !!argument;
      }
      function ToString(argument) {
        return "" + argument;
      }
      function ToPropertyKey(argument) {
        var key = ToPrimitive(
          argument,
          3
          /* String */
        );
        if (IsSymbol(key))
          return key;
        return ToString(key);
      }
      function IsArray(argument) {
        return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
      }
      function IsCallable(argument) {
        return typeof argument === "function";
      }
      function IsConstructor(argument) {
        return typeof argument === "function";
      }
      function IsPropertyKey(argument) {
        switch (Type(argument)) {
          case 3:
            return true;
          case 4:
            return true;
          default:
            return false;
        }
      }
      function GetMethod(V4, P4) {
        var func = V4[P4];
        if (func === void 0 || func === null)
          return void 0;
        if (!IsCallable(func))
          throw new TypeError();
        return func;
      }
      function GetIterator(obj) {
        var method = GetMethod(obj, iteratorSymbol);
        if (!IsCallable(method))
          throw new TypeError();
        var iterator = method.call(obj);
        if (!IsObject(iterator))
          throw new TypeError();
        return iterator;
      }
      function IteratorValue(iterResult) {
        return iterResult.value;
      }
      function IteratorStep(iterator) {
        var result = iterator.next();
        return result.done ? false : result;
      }
      function IteratorClose(iterator) {
        var f4 = iterator["return"];
        if (f4)
          f4.call(iterator);
      }
      function OrdinaryGetPrototypeOf(O2) {
        var proto = Object.getPrototypeOf(O2);
        if (typeof O2 !== "function" || O2 === functionPrototype)
          return proto;
        if (proto !== functionPrototype)
          return proto;
        var prototype = O2.prototype;
        var prototypeProto = prototype && Object.getPrototypeOf(prototype);
        if (prototypeProto == null || prototypeProto === Object.prototype)
          return proto;
        var constructor = prototypeProto.constructor;
        if (typeof constructor !== "function")
          return proto;
        if (constructor === O2)
          return proto;
        return constructor;
      }
      function CreateMapPolyfill() {
        var cacheSentinel = {};
        var arraySentinel = [];
        var MapIterator = (
          /** @class */
          function() {
            function MapIterator2(keys, values, selector) {
              this._index = 0;
              this._keys = keys;
              this._values = values;
              this._selector = selector;
            }
            MapIterator2.prototype["@@iterator"] = function() {
              return this;
            };
            MapIterator2.prototype[iteratorSymbol] = function() {
              return this;
            };
            MapIterator2.prototype.next = function() {
              var index = this._index;
              if (index >= 0 && index < this._keys.length) {
                var result = this._selector(this._keys[index], this._values[index]);
                if (index + 1 >= this._keys.length) {
                  this._index = -1;
                  this._keys = arraySentinel;
                  this._values = arraySentinel;
                } else {
                  this._index++;
                }
                return { value: result, done: false };
              }
              return { value: void 0, done: true };
            };
            MapIterator2.prototype.throw = function(error2) {
              if (this._index >= 0) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              }
              throw error2;
            };
            MapIterator2.prototype.return = function(value) {
              if (this._index >= 0) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              }
              return { value, done: true };
            };
            return MapIterator2;
          }()
        );
        return (
          /** @class */
          function() {
            function Map2() {
              this._keys = [];
              this._values = [];
              this._cacheKey = cacheSentinel;
              this._cacheIndex = -2;
            }
            Object.defineProperty(Map2.prototype, "size", {
              get: function() {
                return this._keys.length;
              },
              enumerable: true,
              configurable: true
            });
            Map2.prototype.has = function(key) {
              return this._find(
                key,
                /*insert*/
                false
              ) >= 0;
            };
            Map2.prototype.get = function(key) {
              var index = this._find(
                key,
                /*insert*/
                false
              );
              return index >= 0 ? this._values[index] : void 0;
            };
            Map2.prototype.set = function(key, value) {
              var index = this._find(
                key,
                /*insert*/
                true
              );
              this._values[index] = value;
              return this;
            };
            Map2.prototype.delete = function(key) {
              var index = this._find(
                key,
                /*insert*/
                false
              );
              if (index >= 0) {
                var size = this._keys.length;
                for (var i4 = index + 1; i4 < size; i4++) {
                  this._keys[i4 - 1] = this._keys[i4];
                  this._values[i4 - 1] = this._values[i4];
                }
                this._keys.length--;
                this._values.length--;
                if (key === this._cacheKey) {
                  this._cacheKey = cacheSentinel;
                  this._cacheIndex = -2;
                }
                return true;
              }
              return false;
            };
            Map2.prototype.clear = function() {
              this._keys.length = 0;
              this._values.length = 0;
              this._cacheKey = cacheSentinel;
              this._cacheIndex = -2;
            };
            Map2.prototype.keys = function() {
              return new MapIterator(this._keys, this._values, getKey);
            };
            Map2.prototype.values = function() {
              return new MapIterator(this._keys, this._values, getValue);
            };
            Map2.prototype.entries = function() {
              return new MapIterator(this._keys, this._values, getEntry);
            };
            Map2.prototype["@@iterator"] = function() {
              return this.entries();
            };
            Map2.prototype[iteratorSymbol] = function() {
              return this.entries();
            };
            Map2.prototype._find = function(key, insert) {
              if (this._cacheKey !== key) {
                this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
              }
              if (this._cacheIndex < 0 && insert) {
                this._cacheIndex = this._keys.length;
                this._keys.push(key);
                this._values.push(void 0);
              }
              return this._cacheIndex;
            };
            return Map2;
          }()
        );
        function getKey(key, _4) {
          return key;
        }
        function getValue(_4, value) {
          return value;
        }
        function getEntry(key, value) {
          return [key, value];
        }
      }
      function CreateSetPolyfill() {
        return (
          /** @class */
          function() {
            function Set2() {
              this._map = new _Map();
            }
            Object.defineProperty(Set2.prototype, "size", {
              get: function() {
                return this._map.size;
              },
              enumerable: true,
              configurable: true
            });
            Set2.prototype.has = function(value) {
              return this._map.has(value);
            };
            Set2.prototype.add = function(value) {
              return this._map.set(value, value), this;
            };
            Set2.prototype.delete = function(value) {
              return this._map.delete(value);
            };
            Set2.prototype.clear = function() {
              this._map.clear();
            };
            Set2.prototype.keys = function() {
              return this._map.keys();
            };
            Set2.prototype.values = function() {
              return this._map.values();
            };
            Set2.prototype.entries = function() {
              return this._map.entries();
            };
            Set2.prototype["@@iterator"] = function() {
              return this.keys();
            };
            Set2.prototype[iteratorSymbol] = function() {
              return this.keys();
            };
            return Set2;
          }()
        );
      }
      function CreateWeakMapPolyfill() {
        var UUID_SIZE = 16;
        var keys = HashMap.create();
        var rootKey = CreateUniqueKey();
        return (
          /** @class */
          function() {
            function WeakMap2() {
              this._key = CreateUniqueKey();
            }
            WeakMap2.prototype.has = function(target) {
              var table = GetOrCreateWeakMapTable(
                target,
                /*create*/
                false
              );
              return table !== void 0 ? HashMap.has(table, this._key) : false;
            };
            WeakMap2.prototype.get = function(target) {
              var table = GetOrCreateWeakMapTable(
                target,
                /*create*/
                false
              );
              return table !== void 0 ? HashMap.get(table, this._key) : void 0;
            };
            WeakMap2.prototype.set = function(target, value) {
              var table = GetOrCreateWeakMapTable(
                target,
                /*create*/
                true
              );
              table[this._key] = value;
              return this;
            };
            WeakMap2.prototype.delete = function(target) {
              var table = GetOrCreateWeakMapTable(
                target,
                /*create*/
                false
              );
              return table !== void 0 ? delete table[this._key] : false;
            };
            WeakMap2.prototype.clear = function() {
              this._key = CreateUniqueKey();
            };
            return WeakMap2;
          }()
        );
        function CreateUniqueKey() {
          var key;
          do
            key = "@@WeakMap@@" + CreateUUID();
          while (HashMap.has(keys, key));
          keys[key] = true;
          return key;
        }
        function GetOrCreateWeakMapTable(target, create) {
          if (!hasOwn.call(target, rootKey)) {
            if (!create)
              return void 0;
            Object.defineProperty(target, rootKey, { value: HashMap.create() });
          }
          return target[rootKey];
        }
        function FillRandomBytes(buffer, size) {
          for (var i4 = 0; i4 < size; ++i4)
            buffer[i4] = Math.random() * 255 | 0;
          return buffer;
        }
        function GenRandomBytes(size) {
          if (typeof Uint8Array === "function") {
            if (typeof crypto !== "undefined")
              return crypto.getRandomValues(new Uint8Array(size));
            if (typeof msCrypto !== "undefined")
              return msCrypto.getRandomValues(new Uint8Array(size));
            return FillRandomBytes(new Uint8Array(size), size);
          }
          return FillRandomBytes(new Array(size), size);
        }
        function CreateUUID() {
          var data = GenRandomBytes(UUID_SIZE);
          data[6] = data[6] & 79 | 64;
          data[8] = data[8] & 191 | 128;
          var result = "";
          for (var offset = 0; offset < UUID_SIZE; ++offset) {
            var byte = data[offset];
            if (offset === 4 || offset === 6 || offset === 8)
              result += "-";
            if (byte < 16)
              result += "0";
            result += byte.toString(16).toLowerCase();
          }
          return result;
        }
      }
      function MakeDictionary(obj) {
        obj.__ = void 0;
        delete obj.__;
        return obj;
      }
    });
  })(Reflect2 || (Reflect2 = {}));

  // ../../packages/core/src/IOC/IOCContainer.ts
  var _AttributeMap = class {
    static register(target, name) {
      let table = _AttributeMap.sMap.get(target);
      if (table) {
        table.push(name);
      } else {
        table = new Array();
        table.push(name);
        _AttributeMap.sMap.set(target, table);
      }
    }
    static getTable(target) {
      let result = new Array();
      let parent = target;
      while (parent != null) {
        const table = _AttributeMap.sMap.get(parent) ?? [];
        result = result.concat(table);
        parent = Object.getPrototypeOf(parent);
      }
      return result;
    }
  };
  var AttributeMap = _AttributeMap;
  __publicField(AttributeMap, "sMap", /* @__PURE__ */ new Map());
  function PostConstruct() {
    return (target, propertyKey, descriptor) => {
      AttributeMap.register(target, propertyKey);
      Reflect.defineMetadata("PostConstruct", descriptor, target, propertyKey);
    };
  }
  function AttributeValue() {
    return (target, propertyKey) => {
      AttributeMap.register(target, propertyKey);
      Reflect.defineMetadata("AttributeValue", {}, target, propertyKey);
    };
  }

  // ../../packages/core/src/Server/MessageQueue.ts
  var STORAGE_NAME = "MessageQueue";
  var MessageQueue = class {
    _messages;
    constructor() {
      this.load();
    }
    first() {
      return this._messages[0];
    }
    last() {
      return this._messages[this._messages.length - 1];
    }
    size() {
      return this._messages.length;
    }
    pop() {
      const result = this._messages.shift();
      this.save();
    }
    push(data) {
      this._messages.push(data);
      this.save();
    }
    hasMessage() {
      return this._messages.length > 0;
    }
    isEmpty() {
      return !this.hasMessage();
    }
    save() {
      const json = JSON.stringify(this._messages);
      localStorage.setItem(STORAGE_NAME, json);
    }
    load() {
      const json = localStorage.getItem(STORAGE_NAME);
      if (json) {
        this._messages = JSON.parse(json);
      }
    }
  };

  // ../../packages/core/src/Server/ServerBase.ts
  var ServerBase = class {
    static isMessageResponseReceive(receive) {
      return receive.type === "message_response" /* MESSAGE_RESPONSE */;
    }
    /**
     * Pack the action data
     *
     * @privateRemarks
     * zh: action
     *
     * @param changed
     * @returns
     */
    packMessage(changed) {
      return {
        changed,
        version: Tools.generateRandomId(6)
      };
    }
  };

  // ../../packages/core/src/Server/ServerSocket.ts
  var _ServerSocket = class extends ServerBase {
    config;
    globalSendResolve;
    socket;
    status;
    messageQueue;
    initialize() {
      this.messageQueue = new MessageQueue();
      this.status = "wait" /* WAIT */;
      this.globalSendResolve = () => {
      };
      if (this.config.socketEnable) {
        this.socket = new IOSocket({ url: this.config.socketUrl });
        this.socket.on("message" /* MESSAGE */, (event) => {
          this.checkupReceiveMessage(event.data);
        });
        this.socket.on("error" /* ERROR */, () => {
        });
        this.socket.on("open" /* OPEN */, () => {
        });
        this.socket.on("close" /* CLOSE */, () => {
        });
        this.socket.on("retry" /* RETRY */, () => {
        });
        this.socket.on("destroy" /* DESTROY */, () => {
        });
        this.socket.link();
      }
    }
    /**
     * zh: 
     * @param data
     */
    pushMessageQueue(changed) {
      if (this.config.socketEnable) {
        this.messageQueue.push(this.packMessage(changed));
        this.sendMessageQueue();
      }
    }
    /**
     * get first message
     *
     * @privateRemarks
     * zh: 
     * @returns
     */
    getTopMessage() {
      return this.messageQueue.first();
    }
    /**
     * zh: 
     * @returns
     */
    popTopMessage() {
      this.messageQueue.pop();
    }
    /**
     * zh: 
     * @returns
     */
    serializeTopMessage() {
      const data = this.getTopMessage();
      return JSON.stringify(data) ?? "";
    }
    /**
     * zh: 
     * @param event
     * @returns
     */
    checkupReceiveMessage(receive) {
      if (_ServerSocket.isMessageResponseReceive(receive)) {
        if (this.getTopMessage().version === receive.message.version) {
          this.popTopMessage();
          this.globalSendResolve();
        }
      }
    }
    /**
     * zh: 
     * @returns
     */
    async sendTopMessage() {
      const message = this.serializeTopMessage();
      this.socket.send(message);
      return new Promise(
        // TODO
        // eslint-disable-next-line no-promise-executor-return
        (resolve) => this.globalSendResolve = resolve
      );
    }
    /**
     * zh: 
     * @returns
     */
    async sendMessageQueue() {
      const { messageQueue, status } = this;
      if (status === "wait" /* WAIT */) {
        this.status = "work" /* WORK */;
        while (messageQueue.hasMessage()) {
          await this.sendTopMessage();
        }
        this.status = "wait" /* WAIT */;
      }
      return this.status;
    }
  };
  var ServerSocket = _ServerSocket;
  __decorateClass([
    AttributeValue()
  ], ServerSocket.prototype, "config", 2);
  __decorateClass([
    PostConstruct()
  ], ServerSocket.prototype, "initialize", 1);

  // ../../packages/base-render/src/Locale/zh.ts
  var zh_default = {
    renderFont: {
      defaultFont: "Times New Roman",
      fontList: ["Times New Roman", "Arial", "Tahoma", "Verdana", "\u5FAE\u8F6F\u96C5\u9ED1", "\u5B8B\u4F53", "\u9ED1\u4F53", "\u6977\u4F53", "\u4EFF\u5B8B", "\u65B0\u5B8B\u4F53", "\u534E\u6587\u65B0\u9B4F", "\u534E\u6587\u884C\u6977", "\u534E\u6587\u96B6\u4E66"],
      defaultFontSize: 14,
      unit: "pt"
    }
  };

  // ../../packages/base-render/src/Locale/en.ts
  var en_default = {
    renderFont: {
      defaultFont: "Times New Roman",
      fontList: ["Times New Roman", "Arial", "Tahoma", "Verdana"],
      defaultFontSize: 9,
      unit: "pt"
    }
  };

  // ../../packages/base-render/src/Basics/Const.ts
  var COLORS = {
    aliceBlue: [240, 248, 255],
    antiqueWhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blancheAlmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueViolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlyWood: [222, 184, 135],
    cadetBlue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornFlowerBlue: [100, 149, 237],
    cornSilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkCyan: [0, 139, 139],
    darkGoldenrod: [184, 132, 11],
    darkGray: [169, 169, 169],
    darkGreen: [0, 100, 0],
    darkGrey: [169, 169, 169],
    darkKhaki: [189, 183, 107],
    darkMagenta: [139, 0, 139],
    darkOliveGreen: [85, 107, 47],
    darkOrange: [255, 140, 0],
    darkOrchid: [153, 50, 204],
    darkRed: [139, 0, 0],
    darkSalmon: [233, 150, 122],
    darkSeaGreen: [143, 188, 143],
    darkSlateBlue: [72, 61, 139],
    darkSlateGray: [47, 79, 79],
    darkSlateGrey: [47, 79, 79],
    darkTurquoise: [0, 206, 209],
    darkViolet: [148, 0, 211],
    deepPink: [255, 20, 147],
    deepSkyBlue: [0, 191, 255],
    dimGray: [105, 105, 105],
    dimGrey: [105, 105, 105],
    dodgerBlue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralWhite: [255, 255, 240],
    forestGreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostWhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenYellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotPink: [255, 105, 180],
    indianRed: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderBlush: [255, 240, 245],
    lawnGreen: [124, 252, 0],
    lemonChiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightCoral: [240, 128, 128],
    lightCyan: [224, 255, 255],
    lightGoldenrodYellow: [250, 250, 210],
    lightGray: [211, 211, 211],
    lightGreen: [144, 238, 144],
    lightGrey: [211, 211, 211],
    lightPink: [255, 182, 193],
    lightSalmon: [255, 160, 122],
    lightSeaGreen: [32, 178, 170],
    lightSkyBlue: [135, 206, 250],
    lightSlateGray: [119, 136, 153],
    lightSlateGrey: [119, 136, 153],
    lightSteelBlue: [176, 196, 222],
    lightYellow: [255, 255, 224],
    lime: [0, 255, 0],
    limeGreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumAquamarine: [102, 205, 170],
    mediumBlue: [0, 0, 205],
    mediumOrchid: [186, 85, 211],
    mediumPurple: [147, 112, 219],
    mediumSeaGreen: [60, 179, 113],
    mediumSlateBlue: [123, 104, 238],
    mediumSpringGreen: [0, 250, 154],
    mediumTurquoise: [72, 209, 204],
    mediumVioletRed: [199, 21, 133],
    midBightBlue: [25, 25, 112],
    mintCream: [245, 255, 250],
    mistyRose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajoWhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldLace: [253, 245, 230],
    olive: [128, 128, 0],
    oliveDrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangeRed: [255, 69, 0],
    orchid: [218, 112, 214],
    paleGoldenrod: [238, 232, 170],
    paleGreen: [152, 251, 152],
    paleTurquoise: [175, 238, 238],
    paleVioletRed: [219, 112, 147],
    papayaWhip: [255, 239, 213],
    peachPuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 203],
    powderBlue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccaPurple: [102, 51, 153],
    red: [255, 0, 0],
    rosyBrown: [188, 143, 143],
    royalBlue: [65, 105, 225],
    saddleBrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandyBrown: [244, 164, 96],
    seaGreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyBlue: [135, 206, 235],
    slateBlue: [106, 90, 205],
    slateGray: [119, 128, 144],
    slateGrey: [119, 128, 144],
    snow: [255, 255, 250],
    springGreen: [0, 255, 127],
    steelBlue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    transparent: [255, 255, 255, 0],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whiteSmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowGreen: [154, 205, 5]
  };
  var MIDDLE_CELL_POS_MAGIC_NUMBER = 1;
  var DEFAULT_FONTFACE_PLANE = '"Helvetica Neue", Helvetica, Arial, "PingFang SC", "Hiragino Sans GB", "Heiti SC", "Microsoft YaHei", "WenQuanYi Micro Hei", sans-serif';
  var DEFAULT_SKELETON_HEADER_FOOTER = {
    lines: [],
    drawings: /* @__PURE__ */ new Map(),
    height: 0,
    st: 0,
    ed: 0,
    marginLeft: 0
  };
  var DEFAULT_SKELETON_HEADER = {
    ...DEFAULT_SKELETON_HEADER_FOOTER,
    marginTop: 20
  };
  var DEFAULT_SKELETON_FOOTER = {
    ...DEFAULT_SKELETON_HEADER_FOOTER,
    marginBottom: 20
  };
  var DEFAULT_MEASURE_TEXT = "0";
  var DEFAULT_OFFSET_SPACING = 1;
  var DEFAULT_DOCUMENT_FONTSIZE = 14;
  var COLOR_BLACK_RGB = "rgb(0,0,0)";

  // ../../packages/base-render/src/Basics/FontCache.ts
  var getDefaultBaselineOffset = (fontSize) => ({
    sbr: 0.5,
    sbo: fontSize,
    spr: 0.5,
    spo: fontSize
  });
  var FontCache = class {
    static get globalFontMeasureCache() {
      return this._globalFontMeasureCache;
    }
    static setFontMeasureCache(fontStyle, content, tm) {
      if (!this._globalFontMeasureCache.has(fontStyle)) {
        this._globalFontMeasureCache[fontStyle] = /* @__PURE__ */ new Map();
      }
      this._globalFontMeasureCache[fontStyle][content] = tm;
    }
    static clearFontMeasureCache(path) {
      const pathArr = path.split("/");
      if (pathArr.length === 1) {
        const fontStyle = pathArr[0];
        this._globalFontMeasureCache.delete(fontStyle);
      } else if (pathArr.length === 2) {
        const fontStyle = pathArr[0];
        const content = pathArr[1];
        this._globalFontMeasureCache.get(fontStyle)?.delete(content);
      } else {
        return false;
      }
      return true;
    }
    static getFontMeasureCache(fontStyle, content) {
      return this._globalFontMeasureCache[fontStyle]?.[content];
    }
    // 
    static autoCleanFontMeasureCache(cacheLimit = 1e6) {
      let allSize = 0;
      let isDelete = false;
      let i4 = 0;
      for (let item of this._globalFontMeasureCache) {
        const [, values] = item;
        allSize += values.size;
        if (allSize > cacheLimit) {
          isDelete = true;
          break;
        }
        i4++;
      }
      if (isDelete) {
        let deleteAllSize = 0;
        for (let item of this._globalFontMeasureCache) {
          const [key, values] = item;
          deleteAllSize += values.size;
          if (deleteAllSize > cacheLimit / 2) {
            const limit = deleteAllSize - cacheLimit / 2;
            this._clearMeasureCache(limit, values);
            break;
          }
          this._globalFontMeasureCache.delete(key);
        }
        return true;
      }
      return false;
    }
    static getBaselineOffsetInfo(fontFamily, fontSize) {
      if (this._fontDataMap.size === 0) {
        return getDefaultBaselineOffset(fontSize);
      }
      const fontFamilyList = fontFamily.split(",");
      for (let ff of fontFamilyList) {
        ff = ff.replace(/'/g, "");
        const fontData = this._fontDataMap.get(ff);
        if (!fontData) {
          continue;
        }
        const { subscriptSizeRatio, subscriptOffset, superscriptSizeRatio, superscriptOffset } = fontData;
        return {
          sbr: subscriptSizeRatio,
          sbo: subscriptOffset * fontSize,
          spr: superscriptSizeRatio,
          spo: superscriptOffset * fontSize
        };
      }
      return getDefaultBaselineOffset(fontSize);
    }
    static getTextSizeByDom(text, fontStyle) {
      if (fontStyle in this._getTextHeightCache) {
        return this._getTextHeightCache[fontStyle];
      }
      let dom = document.getElementById("universheetTextSizeTest");
      const defaultStyle = "float:left;white-space:nowrap;visibility:hidden;margin:0;padding:0;";
      if (!dom) {
        dom = document.createElement("span");
        dom.id = "universheetTextSizeTest";
        document.getElementsByTagName("body")[0].appendChild(dom);
      }
      dom.style.cssText += `${defaultStyle};${fontStyle}`;
      dom.innerText = text;
      const rect = dom.getBoundingClientRect();
      const result = { width: rect.width, height: rect.height };
      this._getTextHeightCache[fontStyle] = result;
      return result;
    }
    static getTextSize(content, fontStyle) {
      const { fontString, fontSize, fontFamily } = fontStyle;
      let bBox = this._getBoundingBoxByFont(fontFamily, fontSize);
      if (!bBox) {
        const measureText = this.getMeasureText(content, fontString);
        bBox = this._calculateBoundingBoxByMeasureText(measureText, fontSize);
      }
      return bBox;
    }
    // 
    // let measureTextCache = {}, measureTextCacheTimeOut = null;
    static getMeasureText(content, fontString) {
      if (!this._context) {
        const canvas = document.createElement("canvas");
        this._context = canvas.getContext("2d");
      }
      const ctx = this._context;
      const mtc = this.getFontMeasureCache(fontString, content);
      if (mtc != null) {
        return mtc;
      }
      ctx.font = fontString;
      const textMetrics = ctx.measureText(content);
      const { width, fontBoundingBoxAscent, fontBoundingBoxDescent, actualBoundingBoxAscent, actualBoundingBoxDescent } = textMetrics;
      const cache = {
        width,
        fontBoundingBoxAscent,
        fontBoundingBoxDescent,
        actualBoundingBoxAscent,
        actualBoundingBoxDescent
      };
      if (fontBoundingBoxAscent == null || fontBoundingBoxDescent == null || Number.isNaN(fontBoundingBoxAscent) || Number.isNaN(fontBoundingBoxDescent)) {
        let oneLineTextHeight = this.getTextSizeByDom(DEFAULT_MEASURE_TEXT, fontString)[1];
        if (ctx.textBaseline === "top") {
          cache.fontBoundingBoxAscent = cache.actualBoundingBoxAscent = oneLineTextHeight;
          cache.fontBoundingBoxDescent = cache.actualBoundingBoxDescent = 0;
        } else if (ctx.textBaseline === "middle") {
          cache.fontBoundingBoxDescent = cache.actualBoundingBoxDescent = oneLineTextHeight / 2;
          cache.fontBoundingBoxAscent = cache.actualBoundingBoxAscent = oneLineTextHeight / 2;
        } else {
          cache.fontBoundingBoxDescent = cache.actualBoundingBoxDescent = 0;
          cache.fontBoundingBoxAscent = cache.actualBoundingBoxAscent = oneLineTextHeight;
        }
      }
      this.setFontMeasureCache(fontString, content, cache);
      return cache;
    }
    static _clearMeasureCache(limit, values) {
      let valueIndex = 0;
      for (let txtItem of values) {
        const [txtKey] = txtItem;
        if (valueIndex > limit) {
          break;
        }
        values.delete(txtKey);
        valueIndex++;
      }
      return true;
    }
    /**
     * Vertical Metrics https://glyphsapp.com/learn/vertical-metrics
     * @param fontFamily
     * @param fontSize
     * @param content
     * @returns
     */
    static _getBoundingBoxByFont(fontFamily, fontSize = 28, content = "") {
      const fontData = this._fontDataMap.get(fontFamily);
      if (!fontData) {
        return;
      }
      const {
        notDefWidth,
        ascender,
        descender,
        typoAscender,
        typoDescender,
        strikeoutPosition,
        subscriptSizeRatio,
        subscriptOffset,
        superscriptSizeRatio,
        superscriptOffset,
        hdmxData,
        glyphHorizonMap
      } = fontData;
      const pixelsPerEmIndex = hdmxData?.indexOf(Math.floor(fontSize));
      const glyph = glyphHorizonMap.get(content.charCodeAt(0));
      let widthResult = notDefWidth;
      if (glyph) {
        const { width, pixelsPerEm = [] } = glyph;
        if (pixelsPerEmIndex) {
          widthResult = pixelsPerEm[pixelsPerEmIndex];
        } else {
          widthResult = width;
        }
      }
      return {
        width: widthResult * fontSize,
        ba: ascender * fontSize,
        bd: descender * fontSize,
        aba: typoAscender * fontSize,
        abd: typoDescender * fontSize,
        sp: strikeoutPosition * fontSize,
        sbr: subscriptSizeRatio,
        sbo: subscriptOffset * fontSize,
        spr: superscriptSizeRatio,
        spo: superscriptOffset * fontSize
      };
    }
    static _calculateBoundingBoxByMeasureText(textCache, fontSize) {
      const { width, fontBoundingBoxAscent, fontBoundingBoxDescent, actualBoundingBoxAscent, actualBoundingBoxDescent } = textCache;
      return {
        width,
        ba: fontBoundingBoxAscent,
        bd: fontBoundingBoxDescent,
        aba: actualBoundingBoxAscent,
        abd: actualBoundingBoxDescent,
        sp: (fontBoundingBoxAscent + fontBoundingBoxDescent) / 2,
        sbr: 0.5,
        sbo: fontSize,
        spr: 0.5,
        spo: fontSize
      };
    }
  };
  __publicField(FontCache, "_getTextHeightCache", {});
  __publicField(FontCache, "_context");
  __publicField(FontCache, "_fontDataMap", /* @__PURE__ */ new Map());
  // 
  __publicField(FontCache, "_globalFontMeasureCache", /* @__PURE__ */ new Map());

  // ../../packages/base-render/src/Basics/PerformanceMonitor.ts
  var PerformanceMonitor = class {
    _enabled = true;
    _rollingFrameTime;
    _lastFrameTimeMs;
    /**
     * constructor
     * @param frameSampleSize The number of samples required to saturate the sliding window
     */
    constructor(frameSampleSize = 30) {
      this._rollingFrameTime = new RollingAverage(frameSampleSize);
    }
    /**
     * Returns the average frame time in milliseconds over the sliding window (or the subset of frames sampled so far)
     */
    get averageFrameTime() {
      return this._rollingFrameTime.average;
    }
    /**
     * Returns the variance frame time in milliseconds over the sliding window (or the subset of frames sampled so far)
     */
    get averageFrameTimeVariance() {
      return this._rollingFrameTime.variance;
    }
    /**
     * Returns the frame time of the most recent frame
     */
    get instantaneousFrameTime() {
      return this._rollingFrameTime.history(0);
    }
    /**
     * Returns the average framerate in frames per second over the sliding window (or the subset of frames sampled so far)
     */
    get averageFPS() {
      return 1e3 / this._rollingFrameTime.average;
    }
    /**
     * Returns the average framerate in frames per second using the most recent frame time
     */
    get instantaneousFPS() {
      let history = this._rollingFrameTime.history(0);
      if (history === 0) {
        return 0;
      }
      return 1e3 / history;
    }
    /**
     * Returns true if enough samples have been taken to completely fill the sliding window
     */
    get isSaturated() {
      return this._rollingFrameTime.isSaturated();
    }
    /**
     * Returns true if sampling is enabled
     */
    get isEnabled() {
      return this._enabled;
    }
    /**
     * Samples current frame
     * @param timeMs A timestamp in milliseconds of the current frame to compare with other frames
     */
    sampleFrame(timeMs = this.Now()) {
      if (!this._enabled) {
        return;
      }
      if (this._lastFrameTimeMs != null) {
        let dt = timeMs - this._lastFrameTimeMs;
        this._rollingFrameTime.add(dt);
      }
      this._lastFrameTimeMs = timeMs;
    }
    Now() {
      if (window.performance && window.performance.now) {
        return window.performance.now();
      }
      return Date.now();
    }
    /**
     * Enables contributions to the sliding window sample set
     */
    enable() {
      this._enabled = true;
    }
    /**
     * Disables contributions to the sliding window sample set
     * Samples will not be interpolated over the disabled period
     */
    disable() {
      this._enabled = false;
      this._lastFrameTimeMs = null;
    }
    /**
     * Resets performance monitor
     */
    reset() {
      this._lastFrameTimeMs = null;
      this._rollingFrameTime.reset();
    }
  };
  var RollingAverage = class {
    /**
     * Current average
     */
    average;
    /**
     * Current variance
     */
    variance;
    _samples;
    _sampleCount;
    _pos;
    _m2;
    // sum of squares of differences from the (current) mean
    /**
     * constructor
     * @param length The number of samples required to saturate the sliding window
     */
    constructor(length) {
      this._samples = new Array(length);
      this.reset();
    }
    /**
     * Adds a sample to the sample set
     * @param v The sample value
     */
    add(v4) {
      let delta;
      if (this.isSaturated()) {
        let bottomValue = this._samples[this._pos];
        delta = bottomValue - this.average;
        this.average -= delta / (this._sampleCount - 1);
        this._m2 -= delta * (bottomValue - this.average);
      } else {
        this._sampleCount++;
      }
      delta = v4 - this.average;
      this.average += delta / this._sampleCount;
      this._m2 += delta * (v4 - this.average);
      this.variance = this._m2 / (this._sampleCount - 1);
      this._samples[this._pos] = v4;
      this._pos++;
      this._pos %= this._samples.length;
    }
    /**
     * Returns previously added values or null if outside of history or outside the sliding window domain
     * @param i Index in history. For example, pass 0 for the most recent value and 1 for the value before that
     * @return Value previously recorded with add() or null if outside of range
     */
    history(i4) {
      if (i4 >= this._sampleCount || i4 >= this._samples.length) {
        return 0;
      }
      let i0 = this._wrapPosition(this._pos - 1);
      return this._samples[this._wrapPosition(i0 - i4)];
    }
    /**
     * Returns true if enough samples have been taken to completely fill the sliding window
     * @return true if sample-set saturated
     */
    isSaturated() {
      return this._sampleCount >= this._samples.length;
    }
    /**
     * Resets the rolling average (equivalent to 0 samples taken so far)
     */
    reset() {
      this.average = 0;
      this.variance = 0;
      this._sampleCount = 0;
      this._pos = 0;
      this._m2 = 0;
    }
    /**
     * Wraps a value around the sample range boundaries
     * @param i Position in sample range, for example if the sample length is 5, and i is -3, then 2 will be returned.
     * @return Wrapped position in sample range
     */
    _wrapPosition(i4) {
      let max = this._samples.length;
      return (i4 % max + max) % max;
    }
  };

  // ../../packages/base-render/src/Basics/Tools.ts
  var PI_OVER_DEG180 = Math.PI / 180;
  var DEG180_OVER_PI = 180 / Math.PI;
  var RGB_PAREN = "rgb(";
  var RGBA_PAREN = "rgba(";
  var getColor = (RgbArray, opacity) => {
    if (!RgbArray) {
      return `${RGB_PAREN}0,0,0)`;
    }
    if (opacity != null) {
      return `${RGBA_PAREN + RgbArray.join(",")},${opacity})`;
    }
    return `${RGB_PAREN + RgbArray.join(",")})`;
  };
  var toPx = (num, ReferenceValue) => {
    if (Tools.isNumber(num)) {
      return num;
    }
    if (ReferenceValue && num && Tools.isString(num) && num.substr(num.length - 1, 1) === "%") {
      const numFloat = parseFloat(num) / 100;
      return ReferenceValue * numFloat;
    }
    return 0;
  };
  var requestNewFrame = (func, requester) => {
    if (!requester) {
      requester = window;
    }
    if (requester.requestPostAnimationFrame) {
      return requester.requestPostAnimationFrame(func);
    }
    if (requester.requestAnimationFrame) {
      return requester.requestAnimationFrame(func);
    }
    if (requester.msRequestAnimationFrame) {
      return requester.msRequestAnimationFrame(func);
    }
    if (requester.webkitRequestAnimationFrame) {
      return requester.webkitRequestAnimationFrame(func);
    }
    if (requester.mozRequestAnimationFrame) {
      return requester.mozRequestAnimationFrame(func);
    }
    if (requester.oRequestAnimationFrame) {
      return requester.oRequestAnimationFrame(func);
    }
    return window.setTimeout(func, 16);
  };
  var cancelRequestFrame = (requestID, requester) => {
    if (!requester) {
      requester = window;
    }
    if (requester.requestPostAnimationFrame) {
      return requester.cancelPostAnimationFrame(requestID);
    }
    if (requester.requestAnimationFrame) {
      return requester.cancelAnimationFrame(requestID);
    }
    if (requester.msRequestAnimationFrame) {
      return requester.msCancelAnimationFrame(requestID);
    }
    if (requester.webkitRequestAnimationFrame) {
      return requester.webkitCancelAnimationFrame(requestID);
    }
    if (requester.mozRequestAnimationFrame) {
      return requester.mozCancelAnimationFrame(requestID);
    }
    if (requester.oRequestAnimationFrame) {
      return requester.oCancelAnimationFrame(requestID);
    }
    return window.clearTimeout(requestID);
  };
  var createCanvasElement = () => {
    let canvas = document.createElement("canvas");
    try {
      canvas.style = canvas.style || {};
    } catch (e4) {
      console.error(e4);
    }
    return canvas;
  };
  var radToDeg = (rad) => rad * DEG180_OVER_PI;
  var degToRad = (deg) => deg * PI_OVER_DEG180;
  var getPointerPrefix = () => {
    let eventPrefix = "pointer";
    if (typeof window !== "undefined" && !window.PointerEvent && typeof navigator !== "undefined" && !navigator.pointerEnabled) {
      eventPrefix = "mouse";
    }
    if (Tools.isTablet() && !Tools.isIPhone() && // And not ipad pros who claim to be macs...
    !(document && "ontouchend" in document)) {
      eventPrefix = "mouse";
    }
    return eventPrefix;
  };
  var IsSafari = () => {
    if (Tools.getBrowserType() === "safari") {
      return true;
    }
    return false;
  };
  var generateRandomKey = (prefix = "obj", keyLength = 4) => {
    let userAgent = window.navigator.userAgent.replace(/[^a-zA-Z0-9]/g, "").split("");
    let mid = "";
    for (let i4 = 0; i4 < keyLength; i4++) {
      mid += userAgent[Math.round(Math.random() * (userAgent.length - 1))];
    }
    let time = (/* @__PURE__ */ new Date()).getTime();
    return `${prefix}_${mid}_${time}`;
  };
  function getValueType(value) {
    return Object.prototype.toString.apply(value);
  }
  function isFunction(value) {
    return getValueType(value) === "[object Function]";
  }
  function isString2(value) {
    return getValueType(value) === "[object String]";
  }
  function precisionTo(num, accurate) {
    accurate = 10 ** accurate;
    return Math.round(num * accurate) / accurate;
  }
  function fixLineWidthByScale(num, scale) {
    return Math.round(num * scale) / scale;
  }
  function getFontStyleString(textStyle, fontLocale) {
    if (!fontLocale) {
      fontLocale = {
        fontList: ["Arial"],
        defaultFontSize: 14
      };
    }
    const { fontList, defaultFontSize } = fontLocale;
    if (!textStyle) {
      return { fontString: `${defaultFontSize}px  ${fontList[0]}`, fontSize: defaultFontSize, fontFamily: fontList[0] };
    }
    let italic = "italic" /* ITALIC */;
    if (textStyle.it === 0 || textStyle.it === void 0) {
      italic = "normal" /* NORMAL */;
    }
    let bold = "bold" /* BOLD */;
    if (textStyle.bl === 0 || textStyle.bl === void 0) {
      bold = "normal" /* NORMAL */;
    }
    let fontSize = defaultFontSize;
    if (textStyle.fs) {
      fontSize = Math.ceil(textStyle.fs);
    }
    let fontFamilyResult = fontList[0];
    if (textStyle.ff) {
      let fontFamily = textStyle.ff;
      fontFamily = fontFamily.replace(/"/g, "").replace(/'/g, "");
      if (fontFamily.indexOf(" ") > -1) {
        fontFamily = `"${fontFamily}"`;
      }
      if (fontFamily == null) {
        fontFamily = fontList[0];
      }
      fontFamilyResult = fontFamily;
    }
    const { va: baselineOffset } = textStyle;
    if (baselineOffset === 1 /* SUBSCRIPT */ || baselineOffset === 2 /* SUPERSCRIPT */) {
      const baselineOffsetInfo = FontCache.getBaselineOffsetInfo(fontFamilyResult, fontSize);
      const { sbr, spr } = baselineOffsetInfo;
      fontSize *= baselineOffset === 1 /* SUBSCRIPT */ ? sbr : spr;
    }
    const fontString = `${italic} ${bold} ${fontSize}px ${fontFamilyResult}, ${DEFAULT_FONTFACE_PLANE} `;
    return {
      fontString,
      fontSize,
      fontFamily: fontFamilyResult
    };
  }
  function hasCJK(text) {
    let pattern = /[\u2E80-\uA4CF]|[\uF900-\uFAFF]|[\uFE30-\uFE4F]|[\uFF00-\uFFEF]/gi;
    if (!pattern.exec(text)) {
      return false;
    }
    return true;
  }
  function hasArabic(text) {
    let pattern = /[\u0600-\u06FF]|[\u0750-\u0750]|[\u0870-\u08FF]|[\uFB50-\uFDFF]|[\uFE70-\uFEFF]/gi;
    if (!pattern.exec(text)) {
      return false;
    }
    return true;
  }
  function hasTibetan(text) {
    let pattern = /[\u0180-\u024F]/gi;
    if (!pattern.exec(text)) {
      return false;
    }
    return true;
  }
  function hasSpaceAndTab(text) {
    let pattern = /\s+|\t+/g;
    if (!pattern.exec(text)) {
      return false;
    }
    return true;
  }
  var dpi_cache;
  function getDPI() {
    if (dpi_cache) {
      return dpi_cache;
    }
    let i4 = 56;
    for (; i4 < 2e3; i4++) {
      if (matchMedia(`(max-resolution: ${i4}dpi)`).matches === true) {
        return i4;
      }
    }
    dpi_cache = i4;
    setTimeout(() => {
      dpi_cache = null;
    }, 1e3);
    return i4;
  }
  var BENCHMARK_DPI = 72;
  function pxToPt(px) {
    return px * (BENCHMARK_DPI / getDPI());
  }
  function getScale(parentScale) {
    const { scaleX = 1, scaleY = 1 } = parentScale;
    return Math.max(scaleX, scaleY);
  }
  function getCellPositionByIndex(row, column, rowHeightAccumulation, columnWidthAccumulation) {
    const startRow = row - 1;
    const startColumn = column - 1;
    let startY = rowHeightAccumulation[startRow] || 0;
    let endY = rowHeightAccumulation[row];
    let startX = columnWidthAccumulation[startColumn] || 0;
    let endX = columnWidthAccumulation[column];
    return {
      startY,
      endY,
      startX,
      endX
    };
  }
  function getCellByIndex(row, column, rowHeightAccumulation, columnWidthAccumulation, dataMergeCache) {
    let { startY, endY, startX, endX } = getCellPositionByIndex(row, column, rowHeightAccumulation, columnWidthAccumulation);
    const { isMerged, isMergedMainCell, newEndRow, newEndColumn, mergeRow, mergeColumn } = mergeCellHandler(row, column, dataMergeCache);
    let mergeInfo = {
      startRow: mergeRow,
      startColumn: mergeColumn,
      endRow: newEndRow,
      endColumn: newEndColumn,
      startY: 0,
      endY: 0,
      startX: 0,
      endX: 0
    };
    if (isMerged && mergeRow !== -1 && mergeColumn !== -1) {
      let mergeStartY = rowHeightAccumulation[mergeRow - 1] || 0;
      let mergeEndY = rowHeightAccumulation[newEndRow];
      let mergeStartX = columnWidthAccumulation[mergeColumn - 1] || 0;
      let mergeEndX = columnWidthAccumulation[newEndColumn];
      mergeInfo = {
        ...mergeInfo,
        startY: mergeStartY,
        endY: mergeEndY,
        startX: mergeStartX,
        endX: mergeEndX
      };
    } else if (!isMerged && newEndRow !== -1 && newEndColumn !== -1) {
      endY = rowHeightAccumulation[newEndRow] || 0;
      endX = columnWidthAccumulation[newEndColumn] || 0;
    }
    return {
      isMerged,
      isMergedMainCell,
      row,
      column,
      startY,
      endY,
      startX,
      endX,
      mergeInfo
    };
  }
  function mergeCellHandler(row, column, dataMergeCache) {
    let isMerged = false;
    let isMergedMainCell = false;
    let newEndRow = -1;
    let newEndColumn = -1;
    let mergeRow = -1;
    let mergeColumn = -1;
    dataMergeCache?.forEach((r4, dataMergeRow) => {
      let isSuspended = false;
      dataMergeRow?.forEach((c4, dataCache) => {
        const { startRow: startRowMarge, endRow: endRowMarge, startColumn: startColumnMarge, endColumn: endColumnMarge } = dataCache;
        if (row === startRowMarge && column === startColumnMarge) {
          newEndRow = endRowMarge;
          newEndColumn = endColumnMarge;
          mergeRow = startRowMarge;
          mergeColumn = startColumnMarge;
          isSuspended = true;
          isMergedMainCell = true;
          return false;
        }
        if (row >= startRowMarge && row <= endRowMarge && column >= startColumnMarge && column <= endColumnMarge) {
          newEndRow = endRowMarge;
          newEndColumn = endColumnMarge;
          mergeRow = startRowMarge;
          mergeColumn = startColumnMarge;
          isSuspended = true;
          isMerged = true;
          return false;
        }
      });
      if (isSuspended) {
        return false;
      }
    });
    return {
      isMergedMainCell,
      isMerged,
      newEndRow,
      newEndColumn,
      mergeRow,
      mergeColumn
    };
  }
  function mergeInfoOffset(mergeInfo, offsetX, offsetY, scaleX, scaleY) {
    const { startY, endY, startX, endX } = mergeInfo;
    mergeInfo.startY = fixLineWidthByScale(startY + offsetY, scaleY);
    mergeInfo.endY = fixLineWidthByScale(endY + offsetY, scaleY);
    mergeInfo.startX = fixLineWidthByScale(startX + offsetX, scaleX);
    mergeInfo.endX = fixLineWidthByScale(endX + offsetX, scaleX);
    return {
      ...mergeInfo
    };
  }
  function isRectIntersect(rect1, rect2) {
    return !(rect1.left > rect2.right || rect1.top > rect2.bottom || rect2.left > rect1.right || rect2.top > rect1.bottom);
  }
  function injectStyle(styles) {
    const styleElement = document.createElement("style");
    document.head.appendChild(styleElement);
    const styleSheet = styleElement.sheet;
    for (let style of styles) {
      styleSheet?.insertRule(style, styleSheet.cssRules.length);
    }
  }
  function checkStyle(content) {
    for (let i4 = 0, len = document.head.childNodes.length; i4 < len; i4++) {
      const node = document.head.childNodes[i4];
      if (node.nodeName === "STYLE" && node.textContent && node.textContent.indexOf(content) > -1) {
        return true;
      }
    }
    return false;
  }
  function pxToNum(unit) {
    return Number(unit.replace(/px/gi, ""));
  }
  function getSizeForDom(dom) {
    const style = getComputedStyle(dom);
    const { borderTopWidth, borderLeftWidth, borderRightWidth, borderBottomWidth, width, height } = style;
    return {
      top: pxToNum(borderTopWidth),
      left: pxToNum(borderLeftWidth),
      right: pxToNum(borderRightWidth),
      bottom: pxToNum(borderBottomWidth),
      width: pxToNum(width),
      height: pxToNum(height)
    };
  }

  // ../../packages/base-render/src/Basics/Vector2.ts
  var Vector2 = class {
    /**
     * Creates a new Vector2 from the given x and y coordinates
     * @param x defines the first coordinate
     * @param y defines the second coordinate
     */
    constructor(x4 = 0, y4 = 0) {
      this.x = x4;
      this.y = y4;
    }
    // Statics
    /**
     * Gets a new Vector2(0, 0)
     * @returns a new Vector2
     */
    static Zero() {
      return new Vector2(0, 0);
    }
    /**
     * Gets a new Vector2(1, 1)
     * @returns a new Vector2
     */
    static One() {
      return new Vector2(1, 1);
    }
    /**
     * Gets a new Vector2 set from the given index element of the given array
     * @param array defines the data source
     * @param offset defines the offset in the data source
     * @returns a new Vector2
     */
    static FromArray(array, offset = 0) {
      return new Vector2(array[offset], array[offset + 1]);
    }
    /**
     * Sets "result" from the given index element of the given array
     * @param array defines the data source
     * @param offset defines the offset in the data source
     * @param result defines the target vector
     */
    static FromArrayToRef(array, offset, result) {
      result.x = array[offset];
      result.y = array[offset + 1];
    }
    /**
     * Gets a new Vector2 located for "amount" (float) on the CatmullRom spline defined by the given four Vector2
     * @param value1 defines 1st point of control
     * @param value2 defines 2nd point of control
     * @param value3 defines 3rd point of control
     * @param value4 defines 4th point of control
     * @param amount defines the interpolation factor
     * @returns a new Vector2
     */
    static CatmullRom(value1, value2, value3, value4, amount) {
      let squared = amount * amount;
      let cubed = amount * squared;
      let x4 = 0.5 * (2 * value2.x + (-value1.x + value3.x) * amount + (2 * value1.x - 5 * value2.x + 4 * value3.x - value4.x) * squared + (-value1.x + 3 * value2.x - 3 * value3.x + value4.x) * cubed);
      let y4 = 0.5 * (2 * value2.y + (-value1.y + value3.y) * amount + (2 * value1.y - 5 * value2.y + 4 * value3.y - value4.y) * squared + (-value1.y + 3 * value2.y - 3 * value3.y + value4.y) * cubed);
      return new Vector2(x4, y4);
    }
    /**
     * Returns a new Vector2 set with same the coordinates than "value" ones if the vector "value" is in the square defined by "min" and "max".
     * If a coordinate of "value" is lower than "min" coordinates, the returned Vector2 is given this "min" coordinate.
     * If a coordinate of "value" is greater than "max" coordinates, the returned Vector2 is given this "max" coordinate
     * @param value defines the value to clamp
     * @param min defines the lower limit
     * @param max defines the upper limit
     * @returns a new Vector2
     */
    static Clamp(value, min, max) {
      let x4 = value.x;
      x4 = x4 > max.x ? max.x : x4;
      x4 = x4 < min.x ? min.x : x4;
      let y4 = value.y;
      y4 = y4 > max.y ? max.y : y4;
      y4 = y4 < min.y ? min.y : y4;
      return new Vector2(x4, y4);
    }
    /**
     * Returns a new Vector2 located for "amount" (float) on the Hermite spline defined by the vectors "value1", "value2", "tangent1", "tangent2"
     * @param value1 defines the 1st control point
     * @param tangent1 defines the outgoing tangent
     * @param value2 defines the 2nd control point
     * @param tangent2 defines the incoming tangent
     * @param amount defines the interpolation factor
     * @returns a new Vector2
     */
    static Hermite(value1, tangent1, value2, tangent2, amount) {
      let squared = amount * amount;
      let cubed = amount * squared;
      let part1 = 2 * cubed - 3 * squared + 1;
      let part2 = -2 * cubed + 3 * squared;
      let part3 = cubed - 2 * squared + amount;
      let part4 = cubed - squared;
      let x4 = value1.x * part1 + value2.x * part2 + tangent1.x * part3 + tangent2.x * part4;
      let y4 = value1.y * part1 + value2.y * part2 + tangent1.y * part3 + tangent2.y * part4;
      return new Vector2(x4, y4);
    }
    /**
     * Returns a new Vector2 which is the 1st derivative of the Hermite spline defined by the vectors "value1", "value2", "tangent1", "tangent2".
     * @param value1 defines the first control point
     * @param tangent1 defines the first tangent
     * @param value2 defines the second control point
     * @param tangent2 defines the second tangent
     * @param time define where the derivative must be done
     * @returns 1st derivative
     */
    static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {
      let result = Vector2.Zero();
      this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
      return result;
    }
    /**
     * Returns a new Vector2 which is the 1st derivative of the Hermite spline defined by the vectors "value1", "value2", "tangent1", "tangent2".
     * @param value1 defines the first control point
     * @param tangent1 defines the first tangent
     * @param value2 defines the second control point
     * @param tangent2 defines the second tangent
     * @param time define where the derivative must be done
     * @param result define where the derivative will be stored
     */
    static Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result) {
      const t22 = time * time;
      result.x = (t22 - time) * 6 * value1.x + (3 * t22 - 4 * time + 1) * tangent1.x + (-t22 + time) * 6 * value2.x + (3 * t22 - 2 * time) * tangent2.x;
      result.y = (t22 - time) * 6 * value1.y + (3 * t22 - 4 * time + 1) * tangent1.y + (-t22 + time) * 6 * value2.y + (3 * t22 - 2 * time) * tangent2.y;
    }
    /**
     * Returns a new Vector2 located for "amount" (float) on the linear interpolation between the vector "start" adn the vector "end".
     * @param start defines the start vector
     * @param end defines the end vector
     * @param amount defines the interpolation factor
     * @returns a new Vector2
     */
    static Lerp(start, end, amount) {
      let x4 = start.x + (end.x - start.x) * amount;
      let y4 = start.y + (end.y - start.y) * amount;
      return new Vector2(x4, y4);
    }
    /**
     * Gets the dot product of the vector "left" and the vector "right"
     * @param left defines first vector
     * @param right defines second vector
     * @returns the dot product (float)
     */
    static Dot(left, right) {
      return left.x * right.x + left.y * right.y;
    }
    /**
     * Returns a new Vector2 equal to the normalized given vector
     * @param vector defines the vector to normalize
     * @returns a new Vector2
     */
    static Normalize(vector) {
      let newVector = Vector2.Zero();
      this.NormalizeToRef(vector, newVector);
      return newVector;
    }
    /**
     * Normalize a given vector into a second one
     * @param vector defines the vector to normalize
     * @param result defines the vector where to store the result
     */
    static NormalizeToRef(vector, result) {
      let len = vector.length();
      if (len === 0) {
        return;
      }
      result.x = vector.x / len;
      result.y = vector.y / len;
    }
    /**
     * Gets a new Vector2 set with the minimal coordinate values from the "left" and "right" vectors
     * @param left defines 1st vector
     * @param right defines 2nd vector
     * @returns a new Vector2
     */
    static Minimize(left, right) {
      let x4 = left.x < right.x ? left.x : right.x;
      let y4 = left.y < right.y ? left.y : right.y;
      return new Vector2(x4, y4);
    }
    /**
     * Gets a new Vector2 set with the maximal coordinate values from the "left" and "right" vectors
     * @param left defines 1st vector
     * @param right defines 2nd vector
     * @returns a new Vector2
     */
    static Maximize(left, right) {
      let x4 = left.x > right.x ? left.x : right.x;
      let y4 = left.y > right.y ? left.y : right.y;
      return new Vector2(x4, y4);
    }
    /**
     * Transforms the given vector coordinates by the given transformation Transform and stores the result in the vector "result" coordinates
     * @param vector defines the vector to transform
     * @param transformation defines the Transform to apply
     * @param result defines the target vector
     */
    static Transform(vector, transformation, ignoreOffset = false) {
      const t4 = transformation;
      const p4 = vector;
      if (ignoreOffset) {
        return new Vector2(t4[0] * p4.x + t4[2] * p4.y, t4[1] * p4.x + t4[3] * p4.y);
      }
      return new Vector2(t4[0] * p4.x + t4[2] * p4.y + t4[4], t4[1] * p4.x + t4[3] * p4.y + t4[5]);
    }
    /**
     * Determines if a given vector is included in a triangle
     * @param p defines the vector to test
     * @param p0 defines 1st triangle point
     * @param p1 defines 2nd triangle point
     * @param p2 defines 3rd triangle point
     * @returns true if the point "p" is in the triangle defined by the vectors "p0", "p1", "p2"
     */
    static PointInTriangle(p4, p0, p1, p22) {
      let a4 = 1 / 2 * (-p1.y * p22.x + p0.y * (-p1.x + p22.x) + p0.x * (p1.y - p22.y) + p1.x * p22.y);
      let sign = a4 < 0 ? -1 : 1;
      let s4 = (p0.y * p22.x - p0.x * p22.y + (p22.y - p0.y) * p4.x + (p0.x - p22.x) * p4.y) * sign;
      let t4 = (p0.x * p1.y - p0.y * p1.x + (p0.y - p1.y) * p4.x + (p1.x - p0.x) * p4.y) * sign;
      return s4 > 0 && t4 > 0 && s4 + t4 < 2 * a4 * sign;
    }
    /**
     * Gets the distance between the vectors "value1" and "value2"
     * @param value1 defines first vector
     * @param value2 defines second vector
     * @returns the distance between vectors
     */
    static Distance(value1, value2) {
      return Math.sqrt(Vector2.DistanceSquared(value1, value2));
    }
    /**
     * Returns the squared distance between the vectors "value1" and "value2"
     * @param value1 defines first vector
     * @param value2 defines second vector
     * @returns the squared distance between vectors
     */
    static DistanceSquared(value1, value2) {
      let x4 = value1.x - value2.x;
      let y4 = value1.y - value2.y;
      return x4 * x4 + y4 * y4;
    }
    /**
     * Gets a new Vector2 located at the center of the vectors "value1" and "value2"
     * @param value1 defines first vector
     * @param value2 defines second vector
     * @returns a new Vector2
     */
    static Center(value1, value2) {
      return Vector2.CenterToRef(value1, value2, Vector2.Zero());
    }
    /**
     * Gets the center of the vectors "value1" and "value2" and stores the result in the vector "ref"
     * @param value1 defines first vector
     * @param value2 defines second vector
     * @param ref defines third vector
     * @returns ref
     */
    static CenterToRef(value1, value2, ref) {
      return ref.copyFromFloats((value1.x + value2.x) / 2, (value1.y + value2.y) / 2);
    }
    /**
     * Gets the shortest distance (float) between the point "p" and the segment defined by the two points "segA" and "segB".
     * @param p defines the middle point
     * @param segA defines one point of the segment
     * @param segB defines the other point of the segment
     * @returns the shortest distance
     */
    static DistanceOfPointFromSegment(p4, segA, segB) {
      let l22 = Vector2.DistanceSquared(segA, segB);
      if (l22 === 0) {
        return Vector2.Distance(p4, segA);
      }
      let v4 = segB.subtract(segA);
      let t4 = Math.max(0, Math.min(1, Vector2.Dot(p4.subtract(segA), v4) / l22));
      let proj = segA.add(v4.multiplyByFloats(t4, t4));
      return Vector2.Distance(p4, proj);
    }
    static create(x4, y4) {
      return new Vector2(x4, y4);
    }
    /**
     * Gets a string with the Vector2 coordinates
     * @returns a string with the Vector2 coordinates
     */
    toString() {
      return `{X: ${this.x} Y: ${this.y}}`;
    }
    /**
     * Gets class name
     * @returns the string "Vector2"
     */
    getClassName() {
      return "Vector2";
    }
    /**
     * Gets current vector hash code
     * @returns the Vector2 hash code as a number
     */
    getHashCode() {
      let hash = this.x | 0;
      hash = hash * 397 ^ (this.y | 0);
      return hash;
    }
    // Operators
    /**
     * Sets the Vector2 coordinates in the given array or Float32Array from the given index.
     * @param array defines the source array
     * @param index defines the offset in source array
     * @returns the current Vector2
     */
    toArray(array, index = 0) {
      array[index] = this.x;
      array[index + 1] = this.y;
      return this;
    }
    /**
     * Update the current vector from an array
     * @param array defines the destination array
     * @param index defines the offset in the destination array
     * @returns the current Vector3
     */
    fromArray(array, index = 0) {
      Vector2.FromArrayToRef(array, index, this);
      return this;
    }
    /**
     * Copy the current vector to an array
     * @returns a new array with 2 elements: the Vector2 coordinates.
     */
    asArray() {
      let result = new Array();
      this.toArray(result, 0);
      return result;
    }
    /**
     * Sets the Vector2 coordinates with the given Vector2 coordinates
     * @param source defines the source Vector2
     * @returns the current updated Vector2
     */
    copyFrom(source) {
      this.x = source.x;
      this.y = source.y;
      return this;
    }
    /**
     * Sets the Vector2 coordinates with the given floats
     * @param x defines the first coordinate
     * @param y defines the second coordinate
     * @returns the current updated Vector2
     */
    copyFromFloats(x4, y4) {
      this.x = x4;
      this.y = y4;
      return this;
    }
    /**
     * Sets the Vector2 coordinates with the given floats
     * @param x defines the first coordinate
     * @param y defines the second coordinate
     * @returns the current updated Vector2
     */
    set(x4, y4) {
      return this.copyFromFloats(x4, y4);
    }
    /**
     * Add another vector with the current one
     * @param otherVector defines the other vector
     * @returns a new Vector2 set with the addition of the current Vector2 and the given one coordinates
     */
    add(otherVector) {
      return new Vector2(this.x + otherVector.x, this.y + otherVector.y);
    }
    /**
     * Sets the "result" coordinates with the addition of the current Vector2 and the given one coordinates
     * @param otherVector defines the other vector
     * @param result defines the target vector
     * @returns the unmodified current Vector2
     */
    addToRef(otherVector, result) {
      result.x = this.x + otherVector.x;
      result.y = this.y + otherVector.y;
      return this;
    }
    addByPoint(x4, y4) {
      return new Vector2(this.x + x4, this.y + y4);
    }
    /**
     * Set the Vector2 coordinates by adding the given Vector2 coordinates
     * @param otherVector defines the other vector
     * @returns the current updated Vector2
     */
    addInPlace(otherVector) {
      this.x += otherVector.x;
      this.y += otherVector.y;
      return this;
    }
    /**
     * Gets a new Vector2 set with the subtracted coordinates of the given one from the current Vector2
     * @param otherVector defines the other vector
     * @returns a new Vector2
     */
    subtract(otherVector) {
      return new Vector2(this.x - otherVector.x, this.y - otherVector.y);
    }
    subtractByPoint(x4, y4) {
      return new Vector2(this.x - x4, this.y - y4);
    }
    /**
     * Sets the "result" coordinates with the subtraction of the given one from the current Vector2 coordinates.
     * @param otherVector defines the other vector
     * @param result defines the target vector
     * @returns the unmodified current Vector2
     */
    subtractToRef(otherVector, result) {
      result.x = this.x - otherVector.x;
      result.y = this.y - otherVector.y;
      return this;
    }
    /**
     * Sets the current Vector2 coordinates by subtracting from it the given one coordinates
     * @param otherVector defines the other vector
     * @returns the current updated Vector2
     */
    subtractInPlace(otherVector) {
      this.x -= otherVector.x;
      this.y -= otherVector.y;
      return this;
    }
    /**
     * Multiplies in place the current Vector2 coordinates by the given ones
     * @param otherVector defines the other vector
     * @returns the current updated Vector2
     */
    multiplyInPlace(otherVector) {
      this.x *= otherVector.x;
      this.y *= otherVector.y;
      return this;
    }
    /**
     * Returns a new Vector2 set with the multiplication of the current Vector2 and the given one coordinates
     * @param otherVector defines the other vector
     * @returns a new Vector2
     */
    multiply(otherVector) {
      return new Vector2(this.x * otherVector.x, this.y * otherVector.y);
    }
    /**
     * Sets "result" coordinates with the multiplication of the current Vector2 and the given one coordinates
     * @param otherVector defines the other vector
     * @param result defines the target vector
     * @returns the unmodified current Vector2
     */
    multiplyToRef(otherVector, result) {
      result.x = this.x * otherVector.x;
      result.y = this.y * otherVector.y;
      return this;
    }
    /**
     * Gets a new Vector2 set with the Vector2 coordinates multiplied by the given floats
     * @param x defines the first coordinate
     * @param y defines the second coordinate
     * @returns a new Vector2
     */
    multiplyByFloats(x4, y4) {
      return new Vector2(this.x * x4, this.y * y4);
    }
    /**
     * Returns a new Vector2 set with the Vector2 coordinates divided by the given one coordinates
     * @param otherVector defines the other vector
     * @returns a new Vector2
     */
    divide(otherVector) {
      return new Vector2(this.x / otherVector.x, this.y / otherVector.y);
    }
    /**
     * Sets the "result" coordinates with the Vector2 divided by the given one coordinates
     * @param otherVector defines the other vector
     * @param result defines the target vector
     * @returns the unmodified current Vector2
     */
    divideToRef(otherVector, result) {
      result.x = this.x / otherVector.x;
      result.y = this.y / otherVector.y;
      return this;
    }
    /**
     * Divides the current Vector2 coordinates by the given ones
     * @param otherVector defines the other vector
     * @returns the current updated Vector2
     */
    divideInPlace(otherVector) {
      return this.divideToRef(otherVector, this);
    }
    /**
     * Gets a new Vector2 with current Vector2 negated coordinates
     * @returns a new Vector2
     */
    negate() {
      return new Vector2(-this.x, -this.y);
    }
    /**
     * Negate this vector in place
     * @returns this
     */
    negateInPlace() {
      this.x *= -1;
      this.y *= -1;
      return this;
    }
    /**
     * Negate the current Vector2 and stores the result in the given vector "result" coordinates
     * @param result defines the Vector3 object where to store the result
     * @returns the current Vector2
     */
    negateToRef(result) {
      return result.copyFromFloats(this.x * -1, this.y * -1);
    }
    /**
     * Multiply the Vector2 coordinates by scale
     * @param scale defines the scaling factor
     * @returns the current updated Vector2
     */
    scaleInPlace(scale) {
      this.x *= scale;
      this.y *= scale;
      return this;
    }
    /**
     * Returns a new Vector2 scaled by "scale" from the current Vector2
     * @param scale defines the scaling factor
     * @returns a new Vector2
     */
    scale(scale) {
      let result = new Vector2(0, 0);
      this.scaleToRef(scale, result);
      return result;
    }
    /**
     * Scale the current Vector2 values by a factor to a given Vector2
     * @param scale defines the scale factor
     * @param result defines the Vector2 object where to store the result
     * @returns the unmodified current Vector2
     */
    scaleToRef(scale, result) {
      result.x = this.x * scale;
      result.y = this.y * scale;
      return this;
    }
    /**
     * Scale the current Vector2 values by a factor and add the result to a given Vector2
     * @param scale defines the scale factor
     * @param result defines the Vector2 object where to store the result
     * @returns the unmodified current Vector2
     */
    scaleAndAddToRef(scale, result) {
      result.x += this.x * scale;
      result.y += this.y * scale;
      return this;
    }
    /**
     * Gets a boolean if two vectors are equals
     * @param otherVector defines the other vector
     * @returns true if the given vector coordinates strictly equal the current Vector2 ones
     */
    equals(otherVector) {
      return otherVector && this.x === otherVector.x && this.y === otherVector.y;
    }
    /**
     * Gets a new Vector2 from current Vector2 floored values
     * eg (1.2, 2.31) returns (1, 2)
     * @returns a new Vector2
     */
    floor() {
      return new Vector2(Math.floor(this.x), Math.floor(this.y));
    }
    /**
     * Gets a new Vector2 from current Vector2 fractional values
     * eg (1.2, 2.31) returns (0.2, 0.31)
     * @returns a new Vector2
     */
    fract() {
      return new Vector2(this.x - Math.floor(this.x), this.y - Math.floor(this.y));
    }
    /**
     * Rotate the current vector into a given result vector
     * @param angle defines the rotation angle
     * @returns the current vector
     */
    rotate(angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const rx = cos * this.x - sin * this.y;
      const ry = sin * this.x + cos * this.y;
      this.x = rx;
      this.y = ry;
      return this;
    }
    /**
     * Rotate the current vector into a given result vector
     * @param angle defines the rotation angle
     * @param result defines the result vector where to store the rotated vector
     * @returns the current vector
     */
    rotateToRef(angle, result) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      result.x = cos * this.x - sin * this.y;
      result.y = sin * this.x + cos * this.y;
      return this;
    }
    rotateByPoint(angle, originPoint = Vector2.create(0, 0)) {
      const cosA = Math.cos(angle);
      const sinA = Math.sin(angle);
      const rx = originPoint.x + (this.x - originPoint.x) * cosA - (this.y - originPoint.y) * sinA;
      const ry = originPoint.y + (this.x - originPoint.x) * sinA + (this.y - originPoint.y) * cosA;
      this.x = rx;
      this.y = ry;
      return this;
    }
    transformCoordinateOnRotate(angle) {
      const hypotenuse = Math.sqrt(this.x ** 2 + this.y ** 2);
      const beta = Math.atan2(this.y, this.x);
      const theta = -angle + beta;
      this.x = hypotenuse * Math.cos(theta);
      this.y = hypotenuse * Math.sin(theta);
      return this;
    }
    // Properties
    /**
     * Gets the length of the vector
     * @returns the vector length (float)
     */
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    /**
     * Gets the vector squared length
     * @returns the vector squared length (float)
     */
    lengthSquared() {
      return this.x * this.x + this.y * this.y;
    }
    // Methods
    /**
     * Normalize the vector
     * @returns the current updated Vector2
     */
    normalize() {
      Vector2.NormalizeToRef(this, this);
      return this;
    }
    /**
     * Gets a new Vector2 copied from the Vector2
     * @returns a new Vector2
     */
    clone() {
      return new Vector2(this.x, this.y);
    }
  };

  // ../../packages/base-render/src/Basics/Transform.ts
  var INITIAL_MATRIX = [1, 0, 0, 1, 0, 0];
  var Transform = class {
    dirty = false;
    _m;
    constructor(m4 = INITIAL_MATRIX) {
      this._m = m4 && m4.slice() || INITIAL_MATRIX;
    }
    static create(m4 = INITIAL_MATRIX) {
      return new this(m4);
    }
    reset() {
      this._m[0] = 1;
      this._m[1] = 0;
      this._m[2] = 0;
      this._m[3] = 1;
      this._m[4] = 0;
      this._m[5] = 0;
    }
    /**
     * Copy UniverSheet.Transform object
     * @method
     * @name UniverSheet.Transform#copy
     * @returns {UniverSheet.Transform}
     * @example
     * const tr = shape.getTransform().copy()
     */
    copy() {
      return new Transform(this._m);
    }
    copyInto(tr) {
      tr._m[0] = this._m[0];
      tr._m[1] = this._m[1];
      tr._m[2] = this._m[2];
      tr._m[3] = this._m[3];
      tr._m[4] = this._m[4];
      tr._m[5] = this._m[5];
    }
    /**
     * Transform point
     * @method
     * @name UniverSheet.Transform#point
     * @param {Object} point 2D point(x, y)
     * @returns {Object} 2D point(x, y)
     */
    applyPoint(point, ignoreOffset = false) {
      const m4 = this._m;
      let xNew = m4[0] * point.x + m4[2] * point.y;
      let yNew = m4[1] * point.x + m4[3] * point.y;
      if (ignoreOffset) {
        return new Vector2(xNew, yNew);
      }
      return new Vector2(xNew + m4[4], yNew + m4[5]);
    }
    /**
     * Apply translation
     * @method
     * @name universheet.Transform#translate
     * @param {Number} x
     * @param {Number} y
     * @returns {UniverSheet.Transform}
     */
    translate(x4, y4) {
      this._m[4] += this._m[0] * x4 + this._m[2] * y4;
      this._m[5] += this._m[1] * x4 + this._m[3] * y4;
      return this;
    }
    /**
     * Apply scale
     * @method
     * @name UniverSheet.Transform#scale
     * @param {Number} sx
     * @param {Number} sy
     * @returns {UniverSheet.Transform}
     */
    scale(sx, sy) {
      this._m[0] *= sx;
      this._m[1] *= sx;
      this._m[2] *= sy;
      this._m[3] *= sy;
      return this;
    }
    /**
     * Apply rotation
     * @method
     * @name UniverSheet.Transform#rotate
     * @param {Number} Degree  Angle in Degree
     * @returns {UniverSheet.Transform}
     */
    rotate(deg) {
      const rad = degToRad(deg);
      let c4 = Math.cos(rad);
      let s4 = Math.sin(rad);
      let m11 = this._m[0] * c4 + this._m[2] * s4;
      let m12 = this._m[1] * c4 + this._m[3] * s4;
      let m21 = this._m[0] * -s4 + this._m[2] * c4;
      let m22 = this._m[1] * -s4 + this._m[3] * c4;
      this._m[0] = m11;
      this._m[1] = m12;
      this._m[2] = m21;
      this._m[3] = m22;
      return this;
    }
    /**
     * Returns the translation
     * @method
     * @name UniverSheet.Transform#getTranslation
     * @returns {Object} 2D point(x, y)
     */
    getTranslation() {
      return {
        x: this._m[4],
        y: this._m[5]
      };
    }
    /**
     * Apply skew
     * @method
     * @name UniverSheet.Transform#skew
     * @param {Number} sx
     * @param {Number} sy
     * @returns {UniverSheet.Transform}
     */
    skew(sx, sy) {
      let m11 = this._m[0] + this._m[2] * sy;
      let m12 = this._m[1] + this._m[3] * sy;
      let m21 = this._m[2] + this._m[0] * sx;
      let m22 = this._m[3] + this._m[1] * sx;
      this._m[0] = m11;
      this._m[1] = m12;
      this._m[2] = m21;
      this._m[3] = m22;
      return this;
    }
    /**
     * Transform multiplication
     * @method
     * @name UniverSheet.Transform#multiply
     * @param {UniverSheet.Transform} matrix
     * @returns {UniverSheet.Transform}
     */
    multiply(matrix) {
      let m11 = this._m[0] * matrix._m[0] + this._m[2] * matrix._m[1];
      let m12 = this._m[1] * matrix._m[0] + this._m[3] * matrix._m[1];
      let m21 = this._m[0] * matrix._m[2] + this._m[2] * matrix._m[3];
      let m22 = this._m[1] * matrix._m[2] + this._m[3] * matrix._m[3];
      let dx = this._m[0] * matrix._m[4] + this._m[2] * matrix._m[5] + this._m[4];
      let dy = this._m[1] * matrix._m[4] + this._m[3] * matrix._m[5] + this._m[5];
      this._m[0] = m11;
      this._m[1] = m12;
      this._m[2] = m21;
      this._m[3] = m22;
      this._m[4] = dx;
      this._m[5] = dy;
      return this;
    }
    /**
     * Invert the matrix
     * @method
     * @name UniverSheet.Transform#invert
     * @returns {UniverSheet.Transform}
     */
    invert() {
      let d4 = 1 / (this._m[0] * this._m[3] - this._m[1] * this._m[2]);
      let m0 = this._m[3] * d4;
      let m1 = -this._m[1] * d4;
      let m22 = -this._m[2] * d4;
      let m32 = this._m[0] * d4;
      let m4 = d4 * (this._m[2] * this._m[5] - this._m[3] * this._m[4]);
      let m5 = d4 * (this._m[1] * this._m[4] - this._m[0] * this._m[5]);
      this._m[0] = m0;
      this._m[1] = m1;
      this._m[2] = m22;
      this._m[3] = m32;
      this._m[4] = m4;
      this._m[5] = m5;
      return this;
    }
    /**
     * return matrix
     * @method
     * @name UniverSheet.Transform#getMatrix
     */
    getMatrix() {
      return this._m;
    }
    /**
     * return matrix
     * @method
     * @name UniverSheet.Transform#getMatrix
     */
    getMatrixByAccurate(accurate = 3) {
      return this._m.map((value) => precisionTo(value, accurate));
    }
    /**
     * set to absolute position via translation
     * @method
     * @name UniverSheet.Transform#setAbsolutePosition
     * @returns {UniverSheet.Transform}
     */
    setAbsolutePosition(coord) {
      let m0 = this._m[0];
      let m1 = this._m[1];
      let m22 = this._m[2];
      let m32 = this._m[3];
      let m4 = this._m[4];
      let m5 = this._m[5];
      let yt = (m0 * (coord.y - m5) - m1 * (coord.x - m4)) / (m0 * m32 - m1 * m22);
      let xt = (coord.x - m4 - m22 * yt) / m0;
      return this.translate(xt, yt);
    }
    /**
     * convert transformation matrix back into node's attributes
     * @method
     * @name UniverSheet.Transform#decompose
     * @returns {UniverSheet.Transform}
     */
    decompose() {
      let a4 = this._m[0];
      let b4 = this._m[1];
      let c4 = this._m[2];
      let d4 = this._m[3];
      let e4 = this._m[4];
      let f4 = this._m[5];
      let delta = a4 * d4 - b4 * c4;
      let result = {
        x: e4,
        y: f4,
        angle: 0,
        scaleX: 0,
        scaleY: 0,
        skewX: 0,
        skewY: 0
      };
      if (a4 !== 0 || b4 !== 0) {
        let r4 = Math.sqrt(a4 * a4 + b4 * b4);
        result.angle = b4 > 0 ? Math.acos(a4 / r4) : -Math.acos(a4 / r4);
        result.scaleX = r4;
        result.scaleY = delta / r4;
        result.skewX = (a4 * c4 + b4 * d4) / delta;
        result.skewY = 0;
      } else if (c4 !== 0 || d4 !== 0) {
        let s4 = Math.sqrt(c4 * c4 + d4 * d4);
        result.angle = Math.PI / 2 - (d4 > 0 ? Math.acos(-c4 / s4) : -Math.acos(c4 / s4));
        result.scaleX = delta / s4;
        result.scaleY = s4;
        result.skewX = 0;
        result.skewY = (a4 * c4 + b4 * d4) / delta;
      } else {
      }
      result.angle = radToDeg(result.angle);
      return result;
    }
    makeBoundingBoxFromPoints(points) {
      if (this) {
        for (let i4 = 0; i4 < points.length; i4++) {
          points[i4] = this.applyPoint(points[i4]);
        }
      }
      const xPoints = [points[0].x, points[1].x, points[2].x, points[3].x];
      const minX = Math.min(...xPoints);
      const maxX = Math.max(...xPoints);
      const width = maxX - minX;
      const yPoints = [points[0].y, points[1].y, points[2].y, points[3].y];
      const minY = Math.min(...yPoints);
      const maxY = Math.max(...yPoints);
      const height = maxY - minY;
      return {
        left: minX,
        top: minY,
        width,
        height,
        points
      };
    }
    composeMatrix(options) {
      const matrix = new Transform([1, 0, 0, 1, options.left || 0, options.top || 0]);
      if (options.angle) {
        matrix.rotate(options.angle);
      }
      if (options.scaleX !== 1 || options.scaleY !== 1 || options.skewX || options.skewY || options.flipX || options.flipY) {
        matrix.multiply(this._calcDimensionsMatrix(options));
      }
      this._m = matrix.getMatrix();
      return this;
    }
    clone() {
      return new Transform([...this._m]);
    }
    /**
     * Returns a transform matrix starting from an object of the same kind of
     * the one returned from qrDecompose, useful also if you want to calculate some
     * transformations from an object that is not enLived yet.
     * is called DimensionsTransformMatrix because those properties are the one that influence
     * the size of the resulting box of the object.
     * @param  {Object} options
     * @param  {Number} [options.scaleX]
     * @param  {Number} [options.scaleY]
     * @param  {Boolean} [options.flipX]
     * @param  {Boolean} [options.flipY]
     * @param  {Number} [options.skewX]
     * @param  {Number} [options.skewX]
     * @return {Number[]} transform matrix
     */
    _calcDimensionsMatrix(options) {
      const scaleX = options.scaleX ?? 1;
      const scaleY = options.scaleY ?? 1;
      const scaleMatrix = new Transform([options.flipX ? -scaleX : scaleX, 0, 0, options.flipY ? -scaleY : scaleY, 0, 0]);
      if (options.skewX) {
        scaleMatrix.multiply(new Transform([1, 0, Math.tan(degToRad(options.skewX)), 1, 0, 0]));
      }
      if (options.skewY) {
        scaleMatrix.multiply(new Transform([1, Math.tan(degToRad(options.skewY)), 0, 1, 0, 0]));
      }
      return scaleMatrix;
    }
    // static createTransformByState(state: positionState) {
    //     const newTr = new this();
    //     let { x, y, angle, scaleX, scaleY, skewX, skewY, flipX, flipY } = state;
    //     x = x ?? 0;
    //     y = y ?? 0;
    //     newTr.translate(x, y);
    //     if (angle) {
    //         newTr.rotate(angle);
    //     }
    //     scaleX = scaleX ?? 1;
    //     scaleY = scaleY ?? 1;
    //     newTr.scale(scaleX, scaleY);
    //     return newTr;
    // }
  };

  // ../../packages/base-render/src/Basics/Draw.ts
  function drawLineByBorderType(ctx, type, position) {
    let drawStartX = 0;
    let drawStartY = 0;
    let drawEndX = 0;
    let drawEndY = 0;
    const { startX, startY, endX, endY } = position;
    if (type === "t" /* TOP */) {
      drawStartX = startX;
      drawStartY = startY;
      drawEndX = endX;
      drawEndY = startY;
    } else if (type === "b" /* BOTTOM */) {
      drawStartX = startX;
      drawStartY = endY;
      drawEndX = endX;
      drawEndY = endY;
    } else if (type === "l" /* LEFT */) {
      drawStartX = startX;
      drawStartY = startY;
      drawEndX = startX;
      drawEndY = endY;
    } else if (type === "r" /* RIGHT */) {
      drawStartX = endX;
      drawStartY = startY;
      drawEndX = endX;
      drawEndY = endY;
    }
    ctx.beginPath();
    ctx.moveTo(drawStartX, drawStartY);
    ctx.lineTo(drawEndX, drawEndY);
    ctx.stroke();
  }
  function setLineType(ctx, style) {
    if (style === 2 /* HAIR */) {
      ctx.setLineDash([1, 2]);
    } else if (style === 6 /* DASH_DOT_DOT */ || style === 11 /* MEDIUM_DASH_DOT_DOT */) {
      ctx.setLineDash([2, 2, 5, 2, 2]);
    } else if (style === 5 /* DASH_DOT */ || style === 10 /* MEDIUM_DASH_DOT */ || style === 12 /* SLANT_DASH_DOT */) {
      ctx.setLineDash([2, 5, 2]);
    } else if (style === 3 /* DOTTED */) {
      ctx.setLineDash([2]);
    } else if (style === 4 /* DASHED */ || style === 9 /* MEDIUM_DASHED */) {
      ctx.setLineDash([3]);
    } else {
      ctx.setLineDash([0]);
    }
  }
  function getLineWidth(style) {
    let lineWidth = 1;
    if (style === 8 /* MEDIUM */ || style === 10 /* MEDIUM_DASH_DOT */ || style === 9 /* MEDIUM_DASHED */ || style === 11 /* MEDIUM_DASH_DOT_DOT */) {
      lineWidth = 2;
    } else if (style === 13 /* THICK */) {
      lineWidth = 3;
    }
    return lineWidth;
  }
  function calculateRectRotate(startPoint, centerPoint, radiusCenter, radiusVertex, offsetPoint = Vector2.create(0, 0)) {
    const rotationVector = startPoint.add(centerPoint).rotateByPoint(radiusVertex);
    const newVector = rotationVector.subtract(centerPoint);
    const finalAngle = radiusVertex - radiusCenter;
    const finalXY = newVector.rotateByPoint(finalAngle, rotationVector);
    const newXY = finalXY.add(offsetPoint).transformCoordinateOnRotate(finalAngle);
    return newXY;
  }
  function getRotateOrientation(angle) {
    return angle > 0 ? 1 /* DOWN */ : 0 /* UP */;
  }
  function getRotateOffsetAndFarthestHypotenuse(lines, rectWidth, vertexAngle) {
    const rotateTranslateXList = [];
    let rotateTranslateY = 0;
    let rotatedHeight = 0;
    let rotatedWidth = 0;
    let fixOffsetX = 0;
    let fixOffsetY = 0;
    const orientation = getRotateOrientation(vertexAngle);
    const linesCount = lines.length;
    vertexAngle = Math.abs(vertexAngle);
    const tanTheta = Math.tan(vertexAngle);
    const sinTheta = Math.sin(vertexAngle);
    const cosTheta = Math.cos(vertexAngle);
    if (orientation === 0 /* UP */) {
      let cumRectHeight = 0;
      for (let i4 = 0; i4 < linesCount; i4++) {
        const line = lines[i4];
        const { lineHeight: rectHeight = 0 } = line;
        cumRectHeight += i4 === 0 ? 0 : rectHeight;
        const currentRotateHeight = (rectHeight / tanTheta + rectWidth) * sinTheta;
        rotateTranslateXList.push(cumRectHeight / tanTheta);
        if (currentRotateHeight > rotatedHeight) {
          rotatedHeight = currentRotateHeight;
        }
        if (i4 === 0) {
          rotatedWidth += rectHeight * sinTheta;
          fixOffsetY += rectHeight * cosTheta;
        }
      }
      rotatedWidth += cumRectHeight / sinTheta + rectWidth * cosTheta;
      fixOffsetY -= rotatedHeight;
    } else {
      let maxOffsetX = 0;
      let maxOffsetLineIndex = -1;
      const rotateOffsetXList = [];
      for (let i4 = linesCount - 1; i4 >= 0; i4--) {
        const line = lines[i4];
        const { lineHeight: rectHeight = 0 } = line;
        const offsetX = rectHeight / tanTheta;
        const currentRotateHeight = (rectWidth + offsetX) * sinTheta;
        rotateOffsetXList.unshift(rectHeight / tanTheta);
        if (currentRotateHeight > rotatedHeight) {
          rotatedHeight = currentRotateHeight;
          maxOffsetX = offsetX;
          maxOffsetLineIndex = i4;
        }
        if (i4 === 0) {
          rotatedWidth += rectHeight * sinTheta;
        } else if (i4 === linesCount - 1) {
          rotatedWidth += rectWidth * cosTheta + rectHeight / sinTheta;
        } else {
          rotatedWidth += rectHeight / sinTheta;
        }
      }
      let cumRotateHeightFix = lines[maxOffsetLineIndex].lineHeight || 0;
      let cumBlowValue = 0;
      for (let i4 = maxOffsetLineIndex + 1; i4 <= linesCount - 1; i4++) {
        const line = lines[i4];
        const { lineHeight: rectHeight = 0 } = line;
        cumRotateHeightFix += rectHeight;
        cumBlowValue += rotateOffsetXList[i4] || 0;
        rotateTranslateXList[i4] = -cumBlowValue;
      }
      cumBlowValue = 0;
      for (let i4 = maxOffsetLineIndex - 1; i4 >= 0; i4--) {
        const line = lines[i4];
        const { lineHeight: rectHeight = 0 } = line;
        cumBlowValue += rotateOffsetXList[i4 + 1] || 0;
        rotateTranslateXList[i4] = cumBlowValue;
        rotateTranslateY += rectHeight;
      }
      rotateTranslateXList[maxOffsetLineIndex] = 0;
      if (linesCount === 1) {
        rotatedWidth += rectWidth * cosTheta;
      }
      fixOffsetX = cumRotateHeightFix / sinTheta - maxOffsetX * cosTheta;
    }
    return {
      rotateTranslateXList,
      rotatedHeight,
      rotatedWidth,
      fixOffsetX,
      fixOffsetY,
      rotateTranslateY
    };
  }

  // ../../packages/base-render/src/Basics/Path2.ts
  var INITIAL_Path2 = [new Vector2(0, 0), new Vector2(1, 1)];
  var Path2 = class {
    constructor(_lines = INITIAL_Path2) {
      this._lines = _lines;
    }
    intersection(lines) {
      if (this._lines.length < 1 || lines.length < 1) {
        return;
      }
      const crossPoint = [];
      for (let o4 = 1; o4 < this._lines.length; o4++) {
        const from = this._lines[o4 - 1];
        const to = this._lines[o4];
        for (let n3 = 1; n3 < lines.length; n3++) {
          const contrastFrom = this._lines[o4 - 1];
          const contrastTo = this._lines[o4];
          const point = this._intersection(
            {
              from,
              to
            },
            {
              from: contrastFrom,
              to: contrastTo
            }
          );
          if (point) {
            crossPoint.push(point);
          }
        }
      }
      return crossPoint;
    }
    _intersection(line1, line2) {
      const a4 = line1.from;
      const b4 = line1.to;
      const c4 = line2.from;
      const d4 = line2.to;
      let area_abc = (a4.x - c4.x) * (b4.y - c4.y) - (a4.y - c4.y) * (b4.x - c4.x);
      let area_abd = (a4.x - d4.x) * (b4.y - d4.y) - (a4.y - d4.y) * (b4.x - d4.x);
      if (area_abc * area_abd >= 0) {
        return false;
      }
      let area_cda = (c4.x - a4.x) * (d4.y - a4.y) - (c4.y - a4.y) * (d4.x - a4.x);
      let area_cdb = area_cda + area_abc - area_abd;
      if (area_cda * area_cdb >= 0) {
        return false;
      }
      let t4 = area_cda / (area_abd - area_abc);
      let dx = t4 * (b4.x - a4.x);
      let dy = t4 * (b4.y - a4.y);
      return new Vector2(a4.x + dx, a4.y + dy);
    }
  };

  // ../../packages/base-render/src/Custom/UseCustom.ts
  var DOCUMENT_CUSTOM_BLOCK = "documentCustomBlock";
  var DOCUMENT_CUSTOM_BULLET = "documentCustomBullet";
  function dealWidthCustomBlock(blockId, custom, curPage, sectionBreakConfig, skeletonResourceReference, context) {
    if (!context) {
      return [];
    }
    const blockPlugin = context.getPluginManager().getPluginByName(DOCUMENT_CUSTOM_BLOCK);
    if (blockPlugin) {
      return blockPlugin.dealWidthCustomBlock(blockId, custom, curPage, sectionBreakConfig, skeletonResourceReference);
    }
    return [];
  }
  function dealWidthCustomBulletOrderedSymbol(startIndex, startNumber, glyphType, context) {
    if (!context) {
      return "";
    }
    const bulletPlugin = context.getPluginManager().getPluginByName(DOCUMENT_CUSTOM_BULLET);
    if (bulletPlugin) {
      return bulletPlugin.dealWidthCustomBulletOrderedSymbol(startIndex, startNumber, glyphType);
    }
    return "";
  }

  // ../../packages/base-render/src/BaseObject.ts
  var BASE_OBJECT_ARRAY = ["top", "left", "width", "height", "angle", "scaleX", "scaleY", "skewX", "skewY", "flipX", "flipY", "strokeWidth"];
  var BaseObject = class {
    groupKey;
    isInGroup = false;
    onTransformChangeObservable = new Observable();
    onPointerDownObserver = new Observable();
    onPointerMoveObserver = new Observable();
    onPointerUpObserver = new Observable();
    onDblclickObserver = new Observable();
    onMouseWheelObserver = new Observable();
    // onKeyDownObservable = new Observable<IKeyboardEvent>();
    // onKeyUpObservable = new Observable<IKeyboardEvent>();
    onPointerOutObserver = new Observable();
    onPointerLeaveObserver = new Observable();
    onPointerOverObserver = new Observable();
    onPointerEnterObserver = new Observable();
    onIsAddedToParentObserver = new Observable();
    onDisposeObserver = new Observable();
    _oKey;
    _dirty = true;
    _top = 0;
    _topOrigin = 0;
    _left = 0;
    _leftOrigin = 0;
    _width = 0;
    _widthOrigin = 0;
    _height = 0;
    _heightOrigin = 0;
    _angle = 0;
    _scaleX = 1;
    _scaleY = 1;
    _skewX = 0;
    _skewY = 0;
    _flipX = false;
    _flipY = false;
    _strokeWidth = 0;
    _parent;
    _zIndex = 0;
    _evented = true;
    _visible = true;
    _debounceParentDirty = true;
    _transform = new Transform();
    __debounceParentTimeout;
    _cursor = "default" /* DEFAULT */;
    _isTransformer = false;
    _forceRender = false;
    constructor(key) {
      if (key) {
        this._oKey = key;
      } else {
        this._oKey = generateRandomKey();
      }
    }
    get transform() {
      return this._transform;
    }
    get topOrigin() {
      return this._topOrigin;
    }
    get leftOrigin() {
      return this._leftOrigin;
    }
    get widthOrigin() {
      return this._widthOrigin;
    }
    get heightOrigin() {
      return this._heightOrigin;
    }
    get classType() {
      return "BaseObject" /* BASE_OBJECT */;
    }
    get top() {
      return this._top;
    }
    get left() {
      return this._left;
    }
    get width() {
      return this._width;
    }
    get height() {
      return this._height;
    }
    get strokeWidth() {
      return this._strokeWidth;
    }
    get angle() {
      return this._angle;
    }
    get scaleX() {
      return this._scaleX;
    }
    get scaleY() {
      return this._scaleY;
    }
    get ancestorScaleX() {
      let pScale = this.getParent()?.ancestorScaleX || 1;
      return this.scaleX * pScale;
    }
    get ancestorScaleY() {
      let pScale = this.getParent()?.ancestorScaleY || 1;
      return this.scaleY * pScale;
    }
    get skewX() {
      return this._skewX;
    }
    get skewY() {
      return this._skewY;
    }
    get flipX() {
      return this._flipX;
    }
    get flipY() {
      return this._flipY;
    }
    get parent() {
      return this._parent;
    }
    get oKey() {
      return this._oKey;
    }
    get zIndex() {
      return this._zIndex;
    }
    get evented() {
      return this._evented;
    }
    get visible() {
      return this._visible;
    }
    get debounceParentDirty() {
      return this._debounceParentDirty;
    }
    get isTransformer() {
      return this._isTransformer;
    }
    get cursor() {
      return this._cursor;
    }
    set transform(trans) {
      this._transform = trans;
    }
    set zIndex(index) {
      this._zIndex = index;
    }
    set parent(o4) {
      this._parent = o4;
    }
    set evented(state) {
      this._evented = state;
    }
    set debounceParentDirty(state) {
      this._debounceParentDirty = state;
    }
    set isTransformer(state) {
      this._isTransformer = state;
    }
    set cursor(val) {
      this.setCursor(val);
    }
    set top(num) {
      this._topOrigin = num;
      this._top = toPx(num, this._parent?.height);
    }
    set left(num) {
      this._leftOrigin = num;
      this._left = toPx(num, this._parent?.width);
    }
    set width(num) {
      this._widthOrigin = num;
      this._width = toPx(num, this._parent?.width);
    }
    set height(num) {
      this._heightOrigin = num;
      this._height = toPx(num, this._parent?.height);
    }
    set strokeWidth(width) {
      this._strokeWidth = width;
    }
    set angle(angle) {
      this._angle = angle;
    }
    set scaleX(scaleX) {
      this._scaleX = scaleX;
    }
    set scaleY(scaleY) {
      this._scaleY = scaleY;
    }
    set skewX(skewX) {
      this._skewX = skewX;
    }
    set flipY(flipY) {
      this._flipY = flipY;
    }
    set flipX(flipX) {
      this._flipX = flipX;
    }
    set skewY(skewY) {
      this._skewY = skewY;
    }
    makeDirty(state = true) {
      this._dirty = state;
      if (state) {
        window.clearTimeout(this.__debounceParentTimeout);
        this.__debounceParentTimeout = window.setTimeout(() => {
          this.parent?.makeDirty(state);
        }, 0);
      }
      return this;
    }
    makeDirtyNoDebounce(state = true) {
      this._dirty = state;
      if (state) {
        this.parent?.makeDirty(state);
      }
      return this;
    }
    isDirty() {
      return this._dirty;
    }
    translate(x4, y4) {
      const preTop = this.top;
      if (y4 !== void 0) {
        this.top = y4;
      }
      const preLeft = this.left;
      if (x4 !== void 0) {
        this.left = x4;
      }
      this._setTransForm();
      this.onTransformChangeObservable.notifyObservers({
        type: 0 /* translate */,
        value: { top: this._top, left: this._left },
        preValue: { top: preTop, left: preLeft }
      });
      return this;
    }
    resize(width, height) {
      const preWidth = this.width;
      if (width !== void 0) {
        this.width = width;
      }
      const preHeight = this.height;
      if (height !== void 0) {
        this.height = height;
      }
      this._setTransForm();
      this.onTransformChangeObservable.notifyObservers({
        type: 1 /* resize */,
        value: { width: this._width, height: this._height },
        preValue: { width: preWidth, height: preHeight }
      });
      return this;
    }
    scale(scaleX, scaleY) {
      const preScaleX = this.scaleX;
      if (scaleX !== void 0) {
        this.scaleX = scaleX;
      }
      const preScaleY = this.scaleY;
      if (scaleY !== void 0) {
        this.scaleY = scaleY;
      }
      this._setTransForm();
      this.onTransformChangeObservable.notifyObservers({
        type: 2 /* scale */,
        value: { scaleX: this._scaleX, scaleY: this._scaleY },
        preValue: { scaleX: preScaleX, scaleY: preScaleY }
      });
      return this;
    }
    skew(skewX, skewY) {
      const preSkewX = skewX;
      if (skewX !== void 0) {
        this.skewX = skewX;
      }
      const preSkewY = skewY;
      if (skewY !== void 0) {
        this.skewY = skewY;
      }
      this._setTransForm();
      this.onTransformChangeObservable.notifyObservers({
        type: 3 /* skew */,
        value: { skewX: this._skewX, skewY: this._skewY },
        preValue: { skewX: preSkewX, skewY: preSkewY }
      });
      return this;
    }
    flip(flipX, flipY) {
      const preFlipX = flipX;
      if (flipX !== void 0) {
        this.flipX = flipX;
      }
      const preFlipY = flipY;
      if (flipY !== void 0) {
        this.flipY = flipY;
      }
      this._setTransForm();
      this.onTransformChangeObservable.notifyObservers({
        type: 4 /* flip */,
        value: { flipX: this._flipX, flipY: this._flipY },
        preValue: { flipX: preFlipX, flipY: preFlipY }
      });
      return this;
    }
    transformByState(option) {
      const optionKeys = Object.keys(option);
      const preKeys = {};
      if (optionKeys.length === 0) {
        return;
      }
      optionKeys.forEach((pKey) => {
        if (option[pKey] !== void 0) {
          preKeys[pKey] = this[pKey];
          this[pKey] = option[pKey];
        }
      });
      this._setTransForm();
      this.onTransformChangeObservable.notifyObservers({
        type: 5 /* all */,
        value: option,
        preValue: preKeys
      });
      return this;
    }
    isRender(bounds) {
      if (this._forceRender) {
        return false;
      }
      return bounds && !this.isInGroup;
    }
    getParent() {
      return this._parent;
    }
    getState() {
      return {
        left: this.left,
        top: this.top,
        width: this.width,
        height: this.height,
        scaleX: this.scaleX,
        scaleY: this.scaleY,
        angle: this.angle,
        skewX: this.skewX,
        skewY: this.skewY,
        flipX: this.flipX,
        flipY: this.flipY
      };
    }
    hide() {
      this._visible = false;
      this._makeDirtyMix();
    }
    show() {
      this._visible = true;
      this._makeDirtyMix();
    }
    render(ctx, bounds) {
    }
    isHit(coord) {
      const oCoord = this._getInverseCoord(coord);
      if (oCoord.x >= -this.strokeWidth / 2 && oCoord.x <= this.width + this.strokeWidth / 2 && oCoord.y >= -this.strokeWidth / 2 && oCoord.y <= this.height + this.strokeWidth / 2) {
        return true;
      }
      return false;
    }
    on(eventType, func) {
      const observable = this[`on${eventType}Observer`];
      const observer = observable.add(func.bind(this));
      return observer;
    }
    off(eventType, observer) {
      const observable = this[`on${eventType}Observer`];
      observable.remove(observer);
    }
    clear(eventType) {
      const observable = this[`on${eventType}Observer`];
      observable.clear();
    }
    resizeCacheCanvas() {
    }
    scaleCacheCanvas() {
    }
    triggerPointerMove(evt) {
      if (!this.onPointerMoveObserver.notifyObservers(evt)?.stopPropagation) {
        this._parent?.triggerPointerMove(evt);
        return false;
      }
      return true;
    }
    triggerPointerDown(evt) {
      if (!this.onPointerDownObserver.notifyObservers(evt)?.stopPropagation) {
        this._parent?.triggerPointerDown(evt);
        return false;
      }
      return true;
    }
    triggerPointerUp(evt) {
      if (!this.onPointerUpObserver.notifyObservers(evt)?.stopPropagation) {
        this._parent?.triggerPointerUp(evt);
        return false;
      }
      return true;
    }
    triggerDblclick(evt) {
      if (!this.onDblclickObserver.notifyObservers(evt)?.stopPropagation) {
        this._parent?.triggerDblclick(evt);
        return false;
      }
      return true;
    }
    triggerMouseWheel(evt) {
      if (!this.onMouseWheelObserver.notifyObservers(evt)?.stopPropagation) {
        this._parent?.triggerMouseWheel(evt);
        return false;
      }
      return true;
    }
    // triggerKeyDown(evt: IKeyboardEvent) {
    //     // this.onKeyDownObservable.notifyObservers(evt);
    //     this._parent?.triggerKeyDown(evt);
    // }
    // triggerKeyUp(evt: IKeyboardEvent) {
    //     // this.onKeyUpObservable.notifyObservers(evt);
    //     this._parent?.triggerKeyUp(evt);
    // }
    triggerPointerOut(evt) {
      if (!this.onPointerOutObserver.notifyObservers(evt)?.stopPropagation) {
        this._parent?.triggerPointerOut(evt);
        return false;
      }
      return true;
    }
    triggerPointerLeave(evt) {
      if (!this.onPointerLeaveObserver.notifyObservers(evt)?.stopPropagation) {
        this._parent?.triggerPointerLeave(evt);
        return false;
      }
      return true;
    }
    triggerPointerOver(evt) {
      if (!this.onPointerOverObserver.notifyObservers(evt)) {
        this._parent?.triggerPointerOver(evt);
        return false;
      }
      return true;
    }
    triggerPointerEnter(evt) {
      if (!this.onPointerEnterObserver.notifyObservers(evt)?.stopPropagation) {
        this._parent?.triggerPointerEnter(evt);
        return false;
      }
      return true;
    }
    dispose() {
      this.onPointerDownObserver.clear();
      this.onPointerMoveObserver.clear();
      this.onPointerUpObserver.clear();
      this.onMouseWheelObserver.clear();
      this.onPointerOutObserver.clear();
      this.onPointerLeaveObserver.clear();
      this.onPointerOverObserver.clear();
      this.onPointerEnterObserver.clear();
      this.onDblclickObserver.clear();
      this.onIsAddedToParentObserver.clear();
      this.parent?.removeObject(this);
      this.onDisposeObserver.notifyObservers(this);
    }
    toJson() {
      const props = {};
      BASE_OBJECT_ARRAY.forEach((key) => {
        if (this[key]) {
          props[key] = this[key];
        }
      });
      return props;
    }
    getScene() {
      let parent = this.parent;
      if (parent == null) {
        return;
      }
      if (parent.classType === "Scene" /* SCENE */) {
        return parent;
      }
      while (parent) {
        if (parent.classType === "Scene" /* SCENE */) {
          return parent;
        }
        parent = parent.getParent();
      }
    }
    resetCursor() {
      this.setCursor("default" /* DEFAULT */);
    }
    setCursor(val) {
      this._cursor = val;
      this.getScene()?.setCursor(val);
    }
    getEngine() {
      let parent = this.getParent();
      while (parent != null) {
        if (parent === "Engine" /* ENGINE */) {
          return parent;
        }
        parent = parent.getParent();
      }
      return null;
    }
    _getInverseCoord(coord) {
      return this._transform.clone().invert().applyPoint(coord);
    }
    _setTransForm() {
      const composeResult = Transform.create().composeMatrix({
        left: this.left + this.strokeWidth / 2,
        top: this.top + this.strokeWidth / 2,
        scaleX: this.scaleX,
        scaleY: this.scaleY,
        angle: this.angle,
        skewX: this.skewX,
        skewY: this.skewY,
        flipX: this.flipX,
        flipY: this.flipY
      });
      this.transform = composeResult;
      this._makeDirtyMix();
    }
    _makeDirtyMix() {
      if (this.debounceParentDirty) {
        this.makeDirty(true);
      } else {
        this.makeDirtyNoDebounce(true);
      }
    }
  };

  // ../../packages/base-render/src/Basics/Position.ts
  function getCurrentScrollXY(scrollTimer) {
    const scene = scrollTimer.getScene();
    const viewport = scrollTimer.getViewportByCoord(scene);
    let scrollX2 = 0;
    let scrollY2 = 0;
    if (!viewport) {
      return {
        scrollX: scrollX2,
        scrollY: scrollY2
      };
    }
    const actualScroll = viewport.getActualScroll(viewport.scrollX, viewport.scrollY);
    return {
      scrollX: actualScroll.x,
      scrollY: actualScroll.y
    };
  }
  function getOffsetRectForDom(ele) {
    let box = ele.getBoundingClientRect();
    let body = document.body;
    let docElem = document.documentElement;
    let scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
    let scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
    let clientTop = docElem.clientTop || body.clientTop;
    let clientLeft = docElem.clientLeft || body.clientLeft;
    let top = box.top + scrollTop - clientTop;
    let left = box.left + scrollLeft - clientLeft;
    return {
      //Math.round bug
      top,
      left
    };
  }
  function transformBoundingCoord(object, bounds) {
    const tl = object.transform.clone().invert().applyPoint(bounds.tl);
    const tr = object.transform.clone().invert().applyPoint(bounds.tr);
    const bl = object.transform.clone().invert().applyPoint(bounds.bl);
    const br = object.transform.clone().invert().applyPoint(bounds.br);
    const xList = [tl.x, tr.x, bl.x, br.x];
    const yList = [tl.y, tr.y, bl.y, br.y];
    const maxX = Math.max(...xList);
    const minX = Math.min(...xList);
    const maxY = Math.max(...yList);
    const minY = Math.min(...yList);
    return {
      minX,
      maxX,
      minY,
      maxY
    };
  }

  // ../../packages/base-render/src/Canvas.ts
  function getDevicePixelRatio() {
    let _pixelRatio = 1;
    let canvas = createCanvasElement();
    let context = canvas.getContext("2d");
    _pixelRatio = (() => {
      let devicePixelRatio = window.devicePixelRatio || 1;
      let backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
      return devicePixelRatio / backingStoreRatio;
    })();
    if (_pixelRatio < 1) {
      return 1;
    }
    return Math.ceil(_pixelRatio * 10) / 10;
  }
  var Canvas = class {
    isCache = false;
    _pixelRatio = 1;
    _canvasEle;
    _context;
    _width = 0;
    _height = 0;
    constructor(props) {
      props = props || {};
      this._canvasEle = createCanvasElement();
      this._canvasEle.style.padding = "0";
      this._canvasEle.style.margin = "0";
      this._canvasEle.style.border = "0";
      this._canvasEle.style.background = "transparent";
      this._canvasEle.style.position = "absolute";
      this._canvasEle.style.top = "0";
      this._canvasEle.style.left = "0";
      this._canvasEle.tabIndex = 1;
      this._canvasEle.style.touchAction = "none";
      this._canvasEle.style.outline = "0";
      this._context = this._canvasEle.getContext("2d");
      this.setSize(props.width, props.height, props.pixelRatio);
    }
    getCanvasEle() {
      return this._canvasEle;
    }
    /**
     * get canvas context
     * @method
     * @returns {CanvasContext} context
     */
    getContext() {
      return this._context;
    }
    getPixelRatio() {
      return this._pixelRatio;
    }
    getWidth() {
      return this._width;
    }
    getHeight() {
      return this._height;
    }
    setSize(width, height, pixelRatioParam) {
      this._pixelRatio = pixelRatioParam || getDevicePixelRatio();
      if (width) {
        this._width = width;
        this._canvasEle.width = width * this._pixelRatio;
        this._canvasEle.style.width = `${width}px`;
      }
      if (height) {
        this._height = height;
        this._canvasEle.height = height * this._pixelRatio;
        this._canvasEle.style.height = `${height}px`;
      }
      this.getContext().setTransform(this._pixelRatio, 0, 0, this._pixelRatio, 0, 0);
    }
    setPixelRatio(pixelRatio) {
      if (this._width === 0 || this._height === 0) {
        return;
      }
      if (pixelRatio < 1) {
        pixelRatio = 1;
      }
      this.setSize(this._width, this._height, pixelRatio);
    }
    dispose() {
      this.clear();
      this._canvasEle.remove();
    }
    clear() {
      const ctx = this.getContext();
      ctx.clearRect(0, 0, this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    /**
     * to data url
     * @method
     * @param {String} mimeType
     * @param {Number} quality between 0 and 1 for jpg mime types
     * @returns {String} data url string
     */
    toDataURL(mimeType, quality) {
      try {
        return this._canvasEle.toDataURL(mimeType, quality);
      } catch (e4) {
        try {
          return this._canvasEle.toDataURL();
        } catch (err) {
          const { message } = err;
          console.error(`Unable to get data URL. ${message} For more info read https://universheet.net/docs/Canvas.html.`);
          return "";
        }
      }
    }
  };

  // ../../packages/base-render/src/Engine.ts
  var Engine = class {
    onInputChangedObservable = new Observable();
    renderEvenInBackground = true;
    /**
     * Observable raised when the engine begins a new frame
     */
    onBeginFrameObservable = new Observable();
    /**
     * Observable raised when the engine ends the current frame
     */
    onEndFrameObservable = new Observable();
    onTransformChangeObservable = new Observable();
    _container;
    _canvas = new Canvas();
    _canvasEle;
    _scenes = {};
    _activeScene = null;
    _renderingQueueLaunched = false;
    _activeRenderLoops = new Array();
    _renderFunction;
    _requestNewFrameHandler;
    _frameId;
    _usingSafari = IsSafari();
    // FPS
    _fps = 60;
    _deltaTime = 0;
    _performanceMonitor = new PerformanceMonitor();
    _pointerMoveEvent;
    _pointerDownEvent;
    _pointerUpEvent;
    _pointerBlurEvent;
    _pointerWheelEvent;
    __pointer = {};
    __mouseId = -1;
    __isUsingFirefox = navigator.userAgent.indexOf("Firefox") !== -1;
    constructor(elemWidth = 100, elemHeight = 100) {
      this._canvasEle = this._canvas.getCanvasEle();
      this._canvas.setSize(elemWidth, elemHeight);
      this._handleKeyboardAction();
      this._handlePointerAction();
    }
    get width() {
      return this._canvas.getWidth();
    }
    get height() {
      return this._canvas.getHeight();
    }
    get classType() {
      return "Engine" /* ENGINE */;
    }
    get activeScene() {
      return this._activeScene;
    }
    get requestNewFrameHandler() {
      return this._requestNewFrameHandler;
    }
    /**
     * Gets the current frame id
     */
    get frameId() {
      return this._frameId;
    }
    getCanvas() {
      return this._canvas;
    }
    getScenes() {
      return this._scenes;
    }
    getScene(sceneKey) {
      return this._scenes[sceneKey];
    }
    hasScene(sceneKey) {
      return sceneKey in this._scenes;
    }
    addScene(sceneInstance) {
      const sceneKey = sceneInstance.sceneKey;
      if (this.hasScene(sceneKey)) {
        console.warn("Scenes has similar key, it will be covered");
      }
      this._scenes[sceneKey] = sceneInstance;
      return sceneInstance;
    }
    setActiveScene(sceneKey) {
      const scene = this.getScene(sceneKey);
      if (scene) {
        this._activeScene = scene;
      }
      return scene;
    }
    hasActiveScene() {
      return this._activeScene != null;
    }
    setContainer(elem) {
      this._container = elem;
      this._container.appendChild(this._canvasEle);
      this.resize();
    }
    resize() {
      if (!this._container) {
        return;
      }
      const { width, height } = getSizeForDom(this._container);
      this.resizeBySize(width, height);
    }
    resizeBySize(width, height) {
      const preWidth = this.width;
      const preHeight = this.height;
      this._canvas.setSize(width, height);
      this.onTransformChangeObservable.notifyObservers({
        type: 1 /* resize */,
        value: {
          width,
          height
        },
        preValue: {
          width: preWidth,
          height: preHeight
        }
      });
    }
    dispose() {
      const scenes = this.getScenes();
      const sceneKeys = Object.keys(scenes);
      sceneKeys.forEach((key) => {
        scenes[key].dispose();
      });
      const eventPrefix = getPointerPrefix();
      this._canvasEle.removeEventListener(`${eventPrefix}move`, this._pointerMoveEvent);
      this._canvasEle.removeEventListener(`${eventPrefix}down`, this._pointerDownEvent);
      this._canvasEle.removeEventListener(`${eventPrefix}up`, this._pointerUpEvent);
      this._canvasEle.removeEventListener("blur", this._pointerBlurEvent);
      this._canvasEle.removeEventListener(this._getWheelEventName(), this._pointerWheelEvent);
      this._activeRenderLoops = [];
      this._canvas.dispose();
      this.onBeginFrameObservable.clear();
      this.onEndFrameObservable.clear();
      this.onTransformChangeObservable.clear();
    }
    remainScene(key) {
      const scenes = this.getScenes();
      if (scenes[key]) {
        const scene = scenes[key];
        delete scenes[key];
        return scene;
      }
    }
    /**
     * Register and execute a render loop. The engine can have more than one render function
     * @param renderFunction defines the function to continuously execute
     */
    runRenderLoop(renderFunction) {
      if (this._activeRenderLoops.indexOf(renderFunction) !== -1) {
        return;
      }
      this._activeRenderLoops.push(renderFunction);
      if (!this._renderingQueueLaunched) {
        this._renderingQueueLaunched = true;
        this._renderFunction = this._renderLoop.bind(this);
        this._requestNewFrameHandler = requestNewFrame(this._renderFunction);
      }
    }
    /**
     * Begin a new frame
     */
    beginFrame() {
      this._measureFps();
      this.onBeginFrameObservable.notifyObservers(this);
    }
    /**
     * End the current frame
     */
    endFrame() {
      this._frameId++;
      this.onEndFrameObservable.notifyObservers(this);
    }
    // FPS
    /**
     * Gets the current framerate
     * @returns a number representing the framerate
     */
    getFps() {
      return this._fps;
    }
    /**
     * Gets the time spent between current and previous frame
     * @returns a number representing the delta time in ms
     */
    getDeltaTime() {
      return this._deltaTime;
    }
    _renderFrame() {
      for (let index = 0; index < this._activeRenderLoops.length; index++) {
        let renderFunction = this._activeRenderLoops[index];
        renderFunction();
      }
    }
    /** @hidden */
    _renderLoop() {
      let shouldRender = true;
      if (!this.renderEvenInBackground) {
        shouldRender = false;
      }
      if (shouldRender) {
        this.beginFrame();
        this._renderFrame();
        this.endFrame();
      }
      if (this._activeRenderLoops.length > 0) {
        this._requestNewFrameHandler = requestNewFrame(this._renderFunction);
      } else {
        this._renderingQueueLaunched = false;
      }
    }
    _measureFps() {
      this._performanceMonitor.sampleFrame();
      this._fps = this._performanceMonitor.averageFPS;
      this._deltaTime = this._performanceMonitor.instantaneousFrameTime || 0;
    }
    _handleKeyboardAction() {
      const keyboardDownEvent = (evt) => {
        let deviceEvent = evt;
        deviceEvent.deviceType = 1 /* Keyboard */;
        deviceEvent.inputIndex = evt.keyCode;
        deviceEvent.previousState = 0;
        deviceEvent.currentState = 1;
        this.onInputChangedObservable.notifyObservers(deviceEvent);
      };
      const keyboardUpEvent = (evt) => {
        let deviceEvent = evt;
        deviceEvent.deviceType = 1 /* Keyboard */;
        deviceEvent.inputIndex = evt.keyCode;
        deviceEvent.previousState = 1;
        deviceEvent.currentState = 0;
        this.onInputChangedObservable.notifyObservers(deviceEvent);
      };
      this._canvasEle.addEventListener("keydown", keyboardDownEvent);
      this._canvasEle.addEventListener("keyup", keyboardUpEvent);
    }
    _handlePointerAction() {
      const eventPrefix = getPointerPrefix();
      this._pointerMoveEvent = (evt) => {
        const deviceType = this.__getPointerType(evt);
        const previousHorizontal = this.__pointer[0 /* Horizontal */];
        const previousVertical = this.__pointer[1 /* Vertical */];
        const previousDeltaHorizontal = this.__pointer[10 /* DeltaHorizontal */];
        const previousDeltaVertical = this.__pointer[11 /* DeltaVertical */];
        this.__pointer[0 /* Horizontal */] = evt.clientX;
        this.__pointer[1 /* Vertical */] = evt.clientY;
        this.__pointer[10 /* DeltaHorizontal */] = evt.movementX;
        this.__pointer[11 /* DeltaVertical */] = evt.movementY;
        let deviceEvent = evt;
        deviceEvent.deviceType = deviceType;
        if (previousHorizontal !== evt.clientX) {
          deviceEvent.inputIndex = 0 /* Horizontal */;
          deviceEvent.previousState = previousHorizontal;
          deviceEvent.currentState = this.__pointer[0 /* Horizontal */];
          this.onInputChangedObservable.notifyObservers(deviceEvent);
        }
        if (previousVertical !== evt.clientY) {
          deviceEvent.inputIndex = 1 /* Vertical */;
          deviceEvent.previousState = previousVertical;
          deviceEvent.currentState = this.__pointer[1 /* Vertical */];
          this.onInputChangedObservable.notifyObservers(deviceEvent);
        }
        if (this.__pointer[10 /* DeltaHorizontal */] !== 0) {
          deviceEvent.inputIndex = 10 /* DeltaHorizontal */;
          deviceEvent.previousState = previousDeltaHorizontal;
          deviceEvent.currentState = this.__pointer[10 /* DeltaHorizontal */];
          this.onInputChangedObservable.notifyObservers(deviceEvent);
        }
        if (this.__pointer[11 /* DeltaVertical */] !== 0) {
          deviceEvent.inputIndex = 11 /* DeltaVertical */;
          deviceEvent.previousState = previousDeltaVertical;
          deviceEvent.currentState = this.__pointer[11 /* DeltaVertical */];
          this.onInputChangedObservable.notifyObservers(deviceEvent);
        }
        if (!this._usingSafari && evt.button !== -1) {
          deviceEvent.inputIndex = evt.button + 2;
          deviceEvent.previousState = this.__pointer[evt.button + 2];
          this.__pointer[evt.button + 2] = this.__pointer[evt.button + 2] ? 0 : 1;
          deviceEvent.currentState = this.__pointer[evt.button + 2];
          this.onInputChangedObservable.notifyObservers(deviceEvent);
        }
      };
      this._pointerDownEvent = (evt) => {
        const deviceType = this.__getPointerType(evt);
        const previousHorizontal = this.__pointer[0 /* Horizontal */];
        const previousVertical = this.__pointer[1 /* Vertical */];
        const previousButton = this.__pointer[evt.button + 2];
        if (deviceType === 2 /* Mouse */) {
          if (this.__mouseId === -1) {
            if (evt.pointerId === void 0) {
              this.__mouseId = this.__isUsingFirefox ? 0 : 1;
            } else {
              this.__mouseId = evt.pointerId;
            }
          }
          if (!document.pointerLockElement) {
            this._canvasEle.setPointerCapture(this.__mouseId);
          }
        } else {
          if (evt.pointerId && !document.pointerLockElement) {
            this._canvasEle.setPointerCapture(evt.pointerId);
          }
        }
        this.__pointer[0 /* Horizontal */] = evt.clientX;
        this.__pointer[1 /* Vertical */] = evt.clientY;
        this.__pointer[evt.button + 2] = 1;
        let deviceEvent = evt;
        deviceEvent.deviceType = deviceType;
        if (previousHorizontal !== evt.clientX) {
          deviceEvent.inputIndex = 0 /* Horizontal */;
          deviceEvent.previousState = previousHorizontal;
          deviceEvent.currentState = this.__pointer[0 /* Horizontal */];
          this.onInputChangedObservable.notifyObservers(deviceEvent);
        }
        if (previousVertical !== evt.clientY) {
          deviceEvent.inputIndex = 1 /* Vertical */;
          deviceEvent.previousState = previousVertical;
          deviceEvent.currentState = this.__pointer[1 /* Vertical */];
          this.onInputChangedObservable.notifyObservers(deviceEvent);
        }
        deviceEvent.inputIndex = evt.button + 2;
        deviceEvent.previousState = previousButton;
        deviceEvent.currentState = this.__pointer[evt.button + 2];
        this.onInputChangedObservable.notifyObservers(deviceEvent);
      };
      this._pointerUpEvent = (evt) => {
        const deviceType = this.__getPointerType(evt);
        const previousHorizontal = this.__pointer[0 /* Horizontal */];
        const previousVertical = this.__pointer[1 /* Vertical */];
        const previousButton = this.__pointer[evt.button + 2];
        this.__pointer[0 /* Horizontal */] = evt.clientX;
        this.__pointer[1 /* Vertical */] = evt.clientY;
        this.__pointer[evt.button + 2] = 0;
        let deviceEvent = evt;
        deviceEvent.deviceType = deviceType;
        if (previousHorizontal !== evt.clientX) {
          deviceEvent.inputIndex = 0 /* Horizontal */;
          deviceEvent.previousState = previousHorizontal;
          deviceEvent.currentState = this.__pointer[0 /* Horizontal */];
          this.onInputChangedObservable.notifyObservers(deviceEvent);
        }
        if (previousVertical !== evt.clientY) {
          deviceEvent.inputIndex = 1 /* Vertical */;
          deviceEvent.previousState = previousVertical;
          deviceEvent.currentState = this.__pointer[1 /* Vertical */];
          this.onInputChangedObservable.notifyObservers(deviceEvent);
        }
        deviceEvent.inputIndex = evt.button + 2;
        deviceEvent.previousState = previousButton;
        deviceEvent.currentState = this.__pointer[evt.button + 2];
        if (deviceType === 2 /* Mouse */ && this.__mouseId >= 0 && this._canvasEle.hasPointerCapture(this.__mouseId)) {
          this._canvasEle.releasePointerCapture(this.__mouseId);
        } else if (evt.pointerId && this._canvasEle.hasPointerCapture(evt.pointerId)) {
          this._canvasEle.releasePointerCapture(evt.pointerId);
        }
        this.onInputChangedObservable.notifyObservers(deviceEvent);
        if (deviceType !== 2 /* Mouse */) {
          this.__pointer = {};
        }
      };
      this._pointerBlurEvent = (evt) => {
        if (this.__mouseId >= 0 && this._canvasEle.hasPointerCapture(this.__mouseId)) {
          this._canvasEle.releasePointerCapture(this.__mouseId);
          this.__mouseId = -1;
        }
        this.__pointer = {};
      };
      this._pointerWheelEvent = (evt) => {
        const deviceType = 2 /* Mouse */;
        let previousWheelScrollX = this.__pointer[7 /* MouseWheelX */];
        let previousWheelScrollY = this.__pointer[8 /* MouseWheelY */];
        let previousWheelScrollZ = this.__pointer[9 /* MouseWheelZ */];
        this.__pointer[7 /* MouseWheelX */] = evt.deltaX || 0;
        this.__pointer[8 /* MouseWheelY */] = evt.deltaY || evt.wheelDelta || 0;
        this.__pointer[9 /* MouseWheelZ */] = evt.deltaZ || 0;
        let deviceEvent = evt;
        deviceEvent.deviceType = deviceType;
        if (this.__pointer[7 /* MouseWheelX */] !== 0) {
          deviceEvent.inputIndex = 7 /* MouseWheelX */;
          deviceEvent.previousState = previousWheelScrollX;
          deviceEvent.currentState = this.__pointer[7 /* MouseWheelX */];
          this.onInputChangedObservable.notifyObservers(deviceEvent);
        }
        if (this.__pointer[8 /* MouseWheelY */] !== 0) {
          deviceEvent.inputIndex = 8 /* MouseWheelY */;
          deviceEvent.previousState = previousWheelScrollY;
          deviceEvent.currentState = this.__pointer[8 /* MouseWheelY */];
          this.onInputChangedObservable.notifyObservers(deviceEvent);
        }
        if (this.__pointer[9 /* MouseWheelZ */] !== 0) {
          deviceEvent.inputIndex = 9 /* MouseWheelZ */;
          deviceEvent.previousState = previousWheelScrollZ;
          deviceEvent.currentState = this.__pointer[9 /* MouseWheelZ */];
          this.onInputChangedObservable.notifyObservers(deviceEvent);
        }
      };
      this._canvasEle.addEventListener(`${eventPrefix}move`, this._pointerMoveEvent);
      this._canvasEle.addEventListener(`${eventPrefix}down`, this._pointerDownEvent);
      this._canvasEle.addEventListener(`${eventPrefix}up`, this._pointerUpEvent);
      this._canvasEle.addEventListener("blur", this._pointerBlurEvent);
      this._canvasEle.addEventListener(this._getWheelEventName(), this._pointerWheelEvent, this._getPassive() ? { passive: false } : false);
    }
    _getWheelEventName() {
      let wheelEventName = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== void 0 ? "mousewheel" : "DOMMouseScroll";
      return wheelEventName;
    }
    _getPassive() {
      let passiveSupported = false;
      const noop2 = () => {
      };
      try {
        const options = {
          passive: {
            get() {
              passiveSupported = true;
            }
          }
        };
        this._canvasEle.addEventListener("test", noop2, options);
        this._canvasEle.removeEventListener("test", noop2, options);
      } catch (e4) {
      }
      return passiveSupported;
    }
    __getPointerType(evt) {
      let deviceType = 2 /* Mouse */;
      if (evt.pointerType === "touch" || evt.pointerType === "pen" || evt.touches) {
        deviceType = 3 /* Touch */;
      }
      return deviceType;
    }
  };

  // ../../packages/base-render/src/Layer.ts
  var Layer = class {
    constructor(_scene, objects = [], _zIndex = 1) {
      this._scene = _scene;
      this._zIndex = _zIndex;
      this.addObjects(objects);
    }
    _objects = [];
    get scene() {
      return this._scene;
    }
    get zIndex() {
      return this._zIndex;
    }
    static create(scene, objects = [], zIndex = 1e3) {
      return new this(scene, objects, zIndex);
    }
    getObjectsByOrder() {
      const objects = [];
      this._objects.sort(sortRules);
      for (let o4 of this._objects) {
        if (!o4.isInGroup && o4.visible) {
          objects.push(o4);
        }
      }
      return objects;
    }
    getObjectsByOrderForPick() {
      const objects = [];
      this._objects.sort(sortRules);
      for (let o4 of this._objects) {
        if (!(o4.classType === "Group" /* GROUP */) && o4.visible) {
          objects.push(o4);
        }
      }
      return objects;
    }
    getObjects() {
      return this._objects;
    }
    addObject(o4) {
      if (o4.classType === "Group" /* GROUP */) {
        const objects = o4.getObjects();
        for (let object of objects) {
          if (this.scene.getObject(object.oKey)) {
            continue;
          }
          this._objects.push(object);
          this.scene.setObjectBehavior(object);
        }
      }
      this._objects.push(o4);
      this.scene.setObjectBehavior(o4);
      this.scene.applyTransformer(o4);
      return this;
    }
    removeObject(object) {
      const objects = this.getObjects();
      const objectsLength = objects.length;
      if (object instanceof BaseObject) {
        for (let i4 = 0; i4 < objectsLength; i4++) {
          const o4 = objects[i4];
          if (o4 === object) {
            objects.splice(i4, 1);
            return;
          }
        }
      } else {
        for (let i4 = 0; i4 < objectsLength; i4++) {
          const o4 = objects[i4];
          if (o4.oKey === object) {
            objects.splice(i4, 1);
            return;
          }
        }
      }
    }
    addObjects(objects) {
      objects.forEach((o4) => {
        this.addObject(o4);
      });
      return this;
    }
    removeObjects(objects) {
      const allObjects = this.getObjects();
      const allObjectsLength = allObjects.length;
      for (let i4 = allObjectsLength - 1; i4 >= 0; i4--) {
        let o4 = allObjects[i4];
        const objectsLength = objects.length;
        if (objectsLength === 0)
          break;
        for (let j3 = 0; j3 < objectsLength; j3++) {
          const object = objects[j3];
          o4 = object instanceof BaseObject ? o4 : o4.oKey;
          if (o4 === object) {
            allObjects.splice(i4, 1);
            break;
          }
        }
      }
    }
    clear() {
      this._objects = [];
    }
    dispose() {
      this.getObjects().forEach((o4) => {
        o4.dispose();
      });
      this.clear();
    }
  };

  // ../../packages/base-render/src/Scene.inputManager.ts
  var _InputManager = class {
    /** This is a defensive check to not allow control attachment prior to an already active one. If already attached, previous control is unattached before attaching the new one. */
    _alreadyAttached = false;
    _alreadyAttachedTo;
    // WorkBookObserver
    _onInputObserver;
    // Pointers
    _onPointerMove;
    _onPointerDown;
    _onPointerUp;
    _onMouseWheel;
    // Keyboard
    _onKeyDown;
    _onKeyUp;
    _scene;
    _currentMouseEnterPicked;
    _startingPosition = new Vector2(Infinity, Infinity);
    _delayedTimeout;
    _doubleClickOccurred = 0;
    constructor(scene) {
      this._scene = scene;
    }
    // mouseleave,mouseenter
    mouseLeaveEnterHandler(o4, evt) {
      if (o4 === null || o4 === void 0) {
        this._currentMouseEnterPicked?.triggerPointerLeave(evt);
        this._currentMouseEnterPicked = null;
      } else if (o4 !== this._currentMouseEnterPicked) {
        const previousPicked = this._currentMouseEnterPicked;
        this._currentMouseEnterPicked = o4;
        previousPicked?.triggerPointerLeave(evt);
        o4?.triggerPointerEnter(evt);
      }
    }
    attachControl(hasDown = true, hasUp = true, hasMove = true, hasWheel = true) {
      const engine = this._scene.getEngine();
      if (!engine) {
        return;
      }
      this._onPointerMove = (evt) => {
        if (evt.pointerId === void 0) {
          evt.pointerId = 0;
        }
        const currentObject = this._getCurrentObject(evt.offsetX, evt.offsetY);
        const isStop = currentObject?.triggerPointerMove(evt);
        this.mouseLeaveEnterHandler(currentObject, evt);
        if (this._checkDirectSceneEventTrigger(!isStop, currentObject)) {
          if (this._scene.onPointerMoveObserver.hasObservers()) {
            this._scene.onPointerMoveObserver.notifyObservers(evt);
          }
        }
      };
      this._onPointerDown = (evt) => {
        if (evt.pointerId === void 0) {
          evt.pointerId = 0;
        }
        const currentObject = this._getCurrentObject(evt.offsetX, evt.offsetY);
        const isStop = currentObject?.triggerPointerDown(evt);
        if (this._checkDirectSceneEventTrigger(!isStop, currentObject)) {
          if (this._scene.onPointerDownObserver.hasObservers()) {
            this._scene.onPointerDownObserver.notifyObservers(evt);
          }
        }
      };
      this._onPointerUp = (evt) => {
        if (evt.pointerId === void 0) {
          evt.pointerId = 0;
        }
        const currentObject = this._getCurrentObject(evt.offsetX, evt.offsetY);
        const isStop = currentObject?.triggerPointerUp(evt);
        if (this._checkDirectSceneEventTrigger(!isStop, currentObject)) {
          if (this._scene.onPointerUpObserver.hasObservers()) {
            this._scene.onPointerUpObserver.notifyObservers(evt);
          }
        }
        this._prePointerDoubleClick(evt);
      };
      this._onMouseWheel = (evt) => {
        const currentObject = this._getCurrentObject(evt.offsetX, evt.offsetY);
        const isStop = currentObject?.triggerMouseWheel(evt);
        this._scene.getViewports().forEach((vp) => {
          if (vp.onMouseWheelObserver.hasObservers()) {
            vp.onMouseWheelObserver.notifyObservers(evt);
          }
        });
        if (this._checkDirectSceneEventTrigger(!isStop, currentObject)) {
          if (this._scene.onMouseWheelObserver.hasObservers()) {
            this._scene.onMouseWheelObserver.notifyObservers(evt);
          }
        }
      };
      this._onKeyDown = (evt) => {
        if (this._scene.onKeyDownObservable.hasObservers()) {
          this._scene.onKeyDownObservable.notifyObservers(evt);
        }
      };
      this._onKeyUp = (evt) => {
        if (this._scene.onKeyUpObservable.hasObservers()) {
          this._scene.onKeyUpObservable.notifyObservers(evt);
        }
      };
      this._onInputObserver = engine.onInputChangedObservable.add((eventData) => {
        const evt = eventData;
        if (eventData.deviceType === 1 /* Keyboard */) {
          if (eventData.currentState === 1) {
            this._onKeyDown(evt);
          }
          if (eventData.currentState === 0) {
            this._onKeyUp(evt);
          }
        }
        if (eventData.deviceType === 2 /* Mouse */ || eventData.deviceType === 3 /* Touch */) {
          if (hasDown && eventData.inputIndex >= 2 /* LeftClick */ && eventData.inputIndex <= 4 /* RightClick */ && eventData.currentState === 1) {
            this._onPointerDown(evt);
          }
          if (hasUp && eventData.inputIndex >= 2 /* LeftClick */ && eventData.inputIndex <= 4 /* RightClick */ && eventData.currentState === 0) {
            this._onPointerUp(evt);
          }
          if (hasMove && (eventData.inputIndex === 0 /* Horizontal */ || eventData.inputIndex === 1 /* Vertical */ || eventData.inputIndex === 10 /* DeltaHorizontal */ || eventData.inputIndex === 11 /* DeltaVertical */)) {
            this._onPointerMove(evt);
          } else if (hasWheel && (eventData.inputIndex === 7 /* MouseWheelX */ || eventData.inputIndex === 8 /* MouseWheelY */ || eventData.inputIndex === 9 /* MouseWheelZ */)) {
            this._onMouseWheel(evt);
          }
        }
      });
      this._alreadyAttached = true;
    }
    /**
     * Detaches all event handlers
     */
    detachControl() {
      if (!this._alreadyAttached) {
        return;
      }
      const engine = this._scene.getEngine();
      if (!engine) {
        return;
      }
      engine.onInputChangedObservable.remove(this._onInputObserver);
      this._alreadyAttached = false;
    }
    _getCurrentObject(offsetX, offsetY) {
      return this._scene?.pick(Vector2.FromArray([offsetX, offsetY]));
    }
    _checkDirectSceneEventTrigger(isTrigger, currentObject) {
      let notObject = false;
      if (currentObject == null) {
        notObject = true;
      }
      let isNotInSceneViewer = true;
      if (currentObject && currentObject.classType === "BaseObject" /* BASE_OBJECT */) {
        const scene = currentObject.getScene();
        if (scene) {
          const parent = scene.getParent();
          isNotInSceneViewer = parent.classType !== "SceneViewer" /* SCENE_VIEWER */;
        }
      }
      return !this._scene.evented && isTrigger && isNotInSceneViewer || notObject;
    }
    /**
     * @hidden
     * @returns Boolean if delta for pointer exceeds drag movement threshold
     */
    _isPointerSwiping(pointerX, pointerY) {
      return Math.abs(this._startingPosition.x - pointerX) > _InputManager.DragMovementThreshold || Math.abs(this._startingPosition.y - pointerY) > _InputManager.DragMovementThreshold;
    }
    _prePointerDoubleClick(evt) {
      const { clientX, clientY } = evt;
      if (this._doubleClickOccurred === 0) {
        this._startingPosition.x = clientX;
        this._startingPosition.y = clientY;
      }
      this._doubleClickOccurred += 1;
      this._delayedTimeout = window.setTimeout(() => {
        this._resetDoubleClickParam();
      }, _InputManager.DoubleClickDelay);
      if (this._doubleClickOccurred < 2) {
        return;
      }
      const isMoveThreshold = this._isPointerSwiping(clientX, clientY);
      if (isMoveThreshold) {
        this._resetDoubleClickParam();
        return;
      }
      this._scene?.pick(Vector2.FromArray([evt.offsetX, evt.offsetY]))?.triggerDblclick(evt);
      if (this._scene.onDblclickObserver.hasObservers()) {
        this._scene.onDblclickObserver.notifyObservers(evt);
      }
      this._resetDoubleClickParam();
      console.log("_prePointerDoubleClick", evt);
    }
    _resetDoubleClickParam() {
      this._doubleClickOccurred = 0;
      this._startingPosition.x = Infinity;
      this._startingPosition.y = Infinity;
      window.clearTimeout(this._delayedTimeout);
    }
  };
  var InputManager = _InputManager;
  /** The distance in pixel that you have to move to prevent some events */
  __publicField(InputManager, "DragMovementThreshold", 10);
  // in pixels
  /** Time in milliseconds to wait to raise long press events if button is still pressed */
  __publicField(InputManager, "LongPressDelay", 500);
  // in milliseconds
  /** Time in milliseconds with two consecutive clicks will be considered as a double click */
  __publicField(InputManager, "DoubleClickDelay", 300);
  // in milliseconds
  /** If you need to check double click without raising a single click at first click, enable this flag */
  __publicField(InputManager, "ExclusiveDoubleClickMode", false);

  // ../../packages/base-render/src/Group.ts
  var Group = class extends BaseObject {
    _objects = [];
    constructor(key, ...objects) {
      super(key);
      this.addObjects(...objects);
    }
    get classType() {
      return "Group" /* GROUP */;
    }
    set cursor(val) {
      this.setCursor(val);
    }
    addObjects(...objects) {
      for (const object of objects) {
        this.addObject(object);
      }
    }
    addObject(o4) {
      let object = o4;
      if (isString2(o4)) {
        const scene = this.getScene();
        object = scene?.getObject(o4);
        if (!object) {
          console.info("No object be added");
          return;
        }
        object.parent = this;
        object.isInGroup = true;
        object.groupKey = this.oKey;
        this._objects.push(object);
      } else {
        o4.parent = this;
        o4.isInGroup = true;
        o4.groupKey = this.oKey;
        this._objects.push(o4);
      }
    }
    removeObject(object) {
      const objects = this.getObjects();
      const objectsLength = objects.length;
      if (isString2(object)) {
        for (let i4 = 0; i4 < objectsLength; i4++) {
          const o4 = objects[i4];
          if (o4.oKey === object) {
            objects.splice(i4, 1);
            this.parent.removeObject(o4);
            return;
          }
        }
      } else {
        for (let i4 = 0; i4 < objectsLength; i4++) {
          const o4 = objects[i4];
          if (o4 === object) {
            objects.splice(i4, 1);
            this.parent.removeObject(o4);
            return;
          }
        }
      }
    }
    getObjectsByOrder() {
      const objects = [];
      this._objects.sort(sortRules);
      for (let o4 of this._objects) {
        if (!o4.isInGroup && o4.visible) {
          objects.push(o4);
        }
      }
      return objects;
    }
    getObjects() {
      return this._objects;
    }
    render(ctx, bounds) {
      ctx.save();
      const m4 = this.transform.getMatrix();
      ctx.transform(m4[0], m4[1], m4[2], m4[3], m4[4], m4[5]);
      this._objects.sort(sortRules);
      for (let object of this._objects) {
        object.render(ctx, this._transformBounds(bounds));
      }
      ctx.restore();
    }
    resize(width, height) {
      return this;
    }
    scale(scaleX, scaleY) {
      return this;
    }
    skew(skewX, skewY) {
      return this;
    }
    flip(flipX, flipY) {
      return this;
    }
    // scope
    isHit(coord) {
      return true;
    }
    // 
    pick(coord) {
    }
    dispose() {
      this.getObjects().forEach((o4) => {
        o4.dispose();
      });
      super.dispose();
    }
    _transformBounds(bounds) {
      return bounds;
    }
  };

  // ../../packages/base-render/src/ScrollTimer.ts
  var ScrollTimer = class {
    constructor(_scene, _padding, _smoothRatioX = 0.05, _smoothRatioY = 0.05) {
      this._scene = _scene;
      this._padding = _padding;
      this._smoothRatioX = _smoothRatioX;
      this._smoothRatioY = _smoothRatioY;
      if (!this._padding) {
        this._padding = { t: 20, b: 20, l: 46, r: 60 };
      }
    }
    _requestNewFrameNumber;
    _viewport;
    _offsetX = 0;
    _offsetY = 0;
    _moveX = 0;
    _moveY = 0;
    _scrollX = 0;
    _scrollY = 0;
    _scrollFunction;
    static create(scene, padding) {
      return new ScrollTimer(scene, padding);
    }
    startScroll(offsetX, offsetY) {
      this._offsetX = offsetX;
      this._offsetY = offsetY;
      this._moveX = offsetX;
      this._moveY = offsetY;
      this._viewport = this.getViewportByCoord(this._scene);
      this._runRenderLoop();
    }
    _scroll(viewport) {
      const topBounding = viewport?.top || 0;
      const bottomBounding = topBounding + (viewport?.height || 0);
      const leftBounding = viewport?.left || 0;
      const rightBounding = leftBounding + (viewport?.width || 0);
      const { t: t4 = 0, b: b4 = 0, r: r4 = 0, l: l4 = 0 } = this._padding;
      let x4 = 0;
      let y4 = 0;
      if (this._moveX < leftBounding + l4) {
        x4 = (this._moveX - leftBounding - l4) * this._smoothRatioX;
      }
      if (this._moveX > rightBounding - r4) {
        x4 = (this._moveX - rightBounding + r4) * this._smoothRatioX;
      }
      if (this._moveY < topBounding + t4) {
        y4 = (this._moveY - topBounding - t4) * this._smoothRatioY;
      }
      if (this._moveY > bottomBounding - b4) {
        y4 = (this._moveY - bottomBounding + b4) * this._smoothRatioY;
      }
      const limited = viewport?.scrollBy({
        x: x4,
        y: y4
      });
      const actualScroll = viewport?.getActualScroll(x4, y4);
      this._scrollX = actualScroll?.x || 0;
      this._scrollY = actualScroll?.y || 0;
      if (limited) {
        const ancestorScene = this._findAncestorScene(viewport?.scene);
        const newViewport = this.getViewportByCoord(ancestorScene);
        if (newViewport) {
          this._scroll(newViewport);
        }
      }
    }
    scrolling(offsetX, offsetY, scrollFunction) {
      this._moveX = offsetX;
      this._moveY = offsetY;
      this._scrollFunction = scrollFunction;
    }
    stopScroll() {
      cancelRequestFrame(this._requestNewFrameNumber);
    }
    getViewportByCoord(scene) {
      return scene?.getActiveViewportByRelativeCoord(Vector2.FromArray([this._offsetX, this._offsetY]));
    }
    getScene() {
      return this._scene;
    }
    _runRenderLoop() {
      this._scroll(this._viewport);
      this._scrollFunction && this._scrollFunction(this._scrollX, this._scrollY);
      this._requestNewFrameNumber = requestNewFrame(this._runRenderLoop.bind(this));
    }
    _findAncestorScene(scene) {
      let parent = scene?.getParent();
      while (parent) {
        if (parent.classType === "Scene" /* SCENE */) {
          return parent;
        }
        parent = parent?.getParent && parent?.getParent();
      }
    }
  };

  // ../../packages/base-render/src/Shape/Shape.ts
  var SHAPE_OBJECT_ARRAY = [
    "hoverCursor",
    "moveCursor",
    "fillRule",
    "globalCompositeOperation",
    "allowCache",
    "paintFirst",
    "stroke",
    "strokeScaleEnabled",
    "fill",
    "fillAfterStrokeEnabled",
    "hitStrokeWidth",
    "strokeLineJoin",
    "strokeLineCap",
    "shadowColor",
    "shadowBlur",
    "shadowOffset",
    "shadowOffsetX",
    "shadowOffsetY",
    "shadowOpacity",
    "shadowEnabled",
    "shadowForStrokeEnabled",
    "strokeDashArray",
    "strokeDashOffset",
    "strokeMiterLimit"
  ];
  var Shape = class extends BaseObject {
    _cacheCanvas;
    _hoverCursor;
    _moveCursor = null;
    _fillRule = "nonzero";
    _globalCompositeOperation = "source-over";
    _allowCache = false;
    _paintFirst;
    _stroke;
    _strokeScaleEnabled;
    // strokeUniform: boolean;
    _fill;
    _fillAfterStrokeEnabled;
    _hitStrokeWidth;
    _strokeLineJoin;
    _strokeLineCap;
    _shadowColor;
    _shadowBlur;
    _shadowOffset;
    _shadowOffsetX;
    _shadowOffsetY;
    _shadowOpacity;
    _shadowEnabled;
    _shadowForStrokeEnabled;
    _strokeDashArray;
    _strokeDashOffset;
    _strokeMiterLimit;
    _type;
    constructor(key, props) {
      super(key);
      if (this._allowCache) {
        this._cacheCanvas = new Canvas();
        this.onTransformChangeObservable.add(() => {
          this.resizeCacheCanvas();
        });
      }
      this._initialProps(props);
    }
    get hoverCursor() {
      return this._hoverCursor;
    }
    get moveCursor() {
      return this._moveCursor;
    }
    get fillRule() {
      return this._fillRule;
    }
    get globalCompositeOperation() {
      return this._globalCompositeOperation;
    }
    get allowCache() {
      return this._allowCache;
    }
    get paintFirst() {
      return this._paintFirst;
    }
    get stroke() {
      return this._stroke;
    }
    get strokeScaleEnabled() {
      return this._strokeScaleEnabled;
    }
    get fill() {
      return this._fill;
    }
    get fillAfterStrokeEnabled() {
      return this._fillAfterStrokeEnabled;
    }
    get hitStrokeWidth() {
      return this._hitStrokeWidth;
    }
    get strokeLineJoin() {
      return this._strokeLineJoin;
    }
    get strokeLineCap() {
      return this._strokeLineCap;
    }
    get shadowColor() {
      return this._shadowColor;
    }
    get shadowBlur() {
      return this._shadowBlur;
    }
    get shadowOffset() {
      return this._shadowOffset;
    }
    get shadowOffsetX() {
      return this._shadowOffsetX;
    }
    get shadowOffsetY() {
      return this._shadowOffsetY;
    }
    get shadowOpacity() {
      return this._shadowOpacity;
    }
    get shadowEnabled() {
      return this._shadowEnabled;
    }
    get shadowForStrokeEnabled() {
      return this._shadowForStrokeEnabled;
    }
    get strokeDashArray() {
      return this._strokeDashArray;
    }
    get strokeDashOffset() {
      return this._strokeDashOffset;
    }
    get strokeMiterLimit() {
      return this._strokeMiterLimit;
    }
    static drawWith(ctx, props) {
    }
    static _renderPaintInOrder(ctx, props) {
      if (props.paintFirst === "stroke") {
        this._renderStroke(ctx, props);
        this._renderFill(ctx, props);
      } else {
        this._renderFill(ctx, props);
        this._renderStroke(ctx, props);
      }
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx SheetContext to render on
     */
    static _renderFill(ctx, props) {
      if (!props.fill) {
        return;
      }
      ctx.save();
      this.__setFillStyles(ctx, props);
      if (props.fillRule === "evenodd") {
        ctx.fill("evenodd");
      } else {
        ctx.fill();
      }
      ctx.restore();
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx SheetContext to render on
     */
    static _renderStroke(ctx, props) {
      let { stroke, strokeWidth, shadowEnabled, shadowForStrokeEnabled, strokeScaleEnabled, scaleX, scaleY, parent } = props;
      if (!stroke || strokeWidth === 0) {
        return;
      }
      if (shadowEnabled && !shadowForStrokeEnabled) {
        this.__removeShadow(ctx);
      }
      ctx.save();
      if (strokeScaleEnabled && parent) {
        let scaling = this.__getObjectScaling();
        ctx.scale(1 / scaling.scaleX, 1 / scaling.scaleY);
      } else if (strokeScaleEnabled) {
        scaleX = scaleX ?? 1;
        scaleY = scaleY ?? 1;
        ctx.scale(1 / scaleX, 1 / scaleY);
      }
      this.__setLineDash(ctx);
      this.__setStrokeStyles(ctx, props);
      ctx.stroke();
      ctx.restore();
    }
    static __getObjectScaling() {
      return { scaleX: 1, scaleY: 1 };
    }
    static __removeShadow(ctx) {
    }
    static __setFillStyles(ctx, props) {
      ctx.fillStyle = props.fill;
    }
    static __setStrokeStyles(ctx, props) {
      const { strokeWidth, strokeLineCap, strokeDashOffset, strokeLineJoin, strokeMiterLimit, stroke } = props;
      ctx.lineWidth = strokeWidth;
      ctx.lineCap = strokeLineCap;
      ctx.lineDashOffset = strokeDashOffset;
      ctx.lineJoin = strokeLineJoin;
      ctx.miterLimit = strokeMiterLimit;
      ctx.strokeStyle = stroke;
    }
    static __setLineDash(ctx) {
    }
    render(mainCtx, bounds) {
      if (!this.visible) {
        this.makeDirty(false);
        return this;
      }
      if (this.isRender()) {
        const { minX, maxX, minY, maxY } = transformBoundingCoord(this, bounds);
        if (this.width + this.strokeWidth < minX || maxX < 0 || this.height + this.strokeWidth < minY || maxY < 0) {
          return this;
        }
      }
      const m4 = this.transform.getMatrix();
      mainCtx.save();
      mainCtx.transform(m4[0], m4[1], m4[2], m4[3], m4[4], m4[5]);
      if (this._allowCache) {
        if (this.isDirty()) {
          const ctx = this._cacheCanvas.getContext();
          this._cacheCanvas.clear();
          ctx.save();
          ctx.translate(this.strokeWidth / 2, this.strokeWidth / 2);
          this._draw(ctx);
          ctx.restore();
        }
        this._applyCache(mainCtx);
      } else {
        this._draw(mainCtx);
      }
      mainCtx.restore();
      this.makeDirty(false);
      return this;
    }
    setProps(props) {
      if (!props) {
        return;
      }
      const themeKeys = Object.keys(props);
      if (themeKeys.length === 0) {
        return;
      }
      themeKeys.forEach((key) => {
        if (props[key] === void 0) {
          return true;
        }
        if (BASE_OBJECT_ARRAY.indexOf(key) === -1) {
          this[`_${key}`] = props[key];
        }
      });
      this.makeDirty(true);
      return this;
    }
    resizeCacheCanvas() {
      this._cacheCanvas?.setSize(this.width + this.strokeWidth, this.height + this.strokeWidth);
      this.makeDirty(true);
    }
    scaleCacheCanvas() {
      let scaleX = this.getParent()?.ancestorScaleX || 1;
      let scaleY = this.getParent()?.ancestorScaleX || 1;
      this._cacheCanvas?.setPixelRatio(Math.max(scaleX, scaleY) * getDevicePixelRatio());
      this.makeDirty(true);
    }
    toJson() {
      const props = {};
      SHAPE_OBJECT_ARRAY.forEach((key) => {
        if (this[key]) {
          props[key] = this[key];
        }
      });
      return {
        ...super.toJson(),
        ...props
      };
    }
    _applyCache(ctx) {
      if (!ctx || !this._cacheCanvas) {
        return;
      }
      const pixelRatio = this._cacheCanvas.getPixelRatio();
      const width = this._cacheCanvas.getWidth() * pixelRatio;
      const height = this._cacheCanvas.getHeight() * pixelRatio;
      ctx.drawImage(
        this._cacheCanvas.getCanvasEle(),
        0,
        0,
        width,
        height,
        -this.strokeWidth / 2,
        -this.strokeWidth / 2,
        this.width + this.strokeWidth,
        this.height + this.strokeWidth
      );
    }
    _draw(ctx) {
    }
    _initialProps(props) {
      if (!props) {
        return;
      }
      const themeKeys = Object.keys(props);
      if (themeKeys.length === 0) {
        return;
      }
      const transformState = {};
      let hasTransformState = false;
      themeKeys.forEach((key) => {
        if (props[key] === void 0) {
          return true;
        }
        if (BASE_OBJECT_ARRAY.indexOf(key) > -1) {
          transformState[key] = props[key];
          hasTransformState = true;
        } else {
          this[`_${key}`] = props[key];
        }
      });
      if (hasTransformState) {
        this.transformByState(transformState);
      }
      this.makeDirty(true);
    }
  };

  // ../../packages/base-render/src/Shape/Rect.ts
  var RECT_OBJECT_ARRAY = ["radius"];
  var Rect = class extends Shape {
    _radius;
    constructor(key, props) {
      super(key, props);
      if (props?.radius) {
        this._radius = props?.radius;
      }
    }
    get radius() {
      return this._radius;
    }
    static drawWith(ctx, props) {
      let { radius, width, height } = props;
      radius = radius ?? 0;
      width = width ?? 30;
      height = height ?? 30;
      ctx.beginPath();
      if (props.strokeDashArray) {
        ctx.setLineDash(props.strokeDashArray);
      }
      if (!radius) {
        ctx.rect(0, 0, width, height);
      } else {
        let topLeft = 0;
        let topRight = 0;
        let bottomLeft = 0;
        let bottomRight = 0;
        topLeft = topRight = bottomLeft = bottomRight = Math.min(radius, width / 2, height / 2);
        ctx.moveTo(topLeft, 0);
        ctx.lineTo(width - topRight, 0);
        ctx.arc(width - topRight, topRight, topRight, Math.PI * 3 / 2, 0, false);
        ctx.lineTo(width, height - bottomRight);
        ctx.arc(width - bottomRight, height - bottomRight, bottomRight, 0, Math.PI / 2, false);
        ctx.lineTo(bottomLeft, height);
        ctx.arc(bottomLeft, height - bottomLeft, bottomLeft, Math.PI / 2, Math.PI, false);
        ctx.lineTo(0, topLeft);
        ctx.arc(topLeft, topLeft, topLeft, Math.PI, Math.PI * 3 / 2, false);
      }
      ctx.closePath();
      this._renderPaintInOrder(ctx, props);
    }
    toJson() {
      const props = {};
      RECT_OBJECT_ARRAY.forEach((key) => {
        if (this[key]) {
          props[key] = this[key];
        }
      });
      return {
        ...super.toJson(),
        ...props
      };
    }
    _draw(ctx) {
      Rect.drawWith(ctx, this);
    }
  };

  // ../../packages/base-render/src/Shape/RegularPolygon.ts
  var REGULAR_POLYGON_OBJECT_ARRAY = ["pointsGroup"];
  var RegularPolygon = class extends Shape {
    _pointsGroup;
    constructor(key, props) {
      super(key, props);
      this._pointsGroup = props?.pointsGroup || [[]];
      this._setFixBoundingBox();
      this.onTransformChangeObservable.add((changeState) => {
        const { type, value, preValue } = changeState;
        if (type === 1 /* resize */ || type === 5 /* all */) {
          this.resizePolygon(preValue);
        }
      });
    }
    get pointsGroup() {
      return this._pointsGroup;
    }
    static drawWith(ctx, props) {
      let { pointsGroup } = props;
      pointsGroup = pointsGroup ?? [[]];
      if (props.strokeDashArray) {
        ctx.setLineDash(props.strokeDashArray);
      }
      ctx.beginPath();
      for (let points of pointsGroup) {
        ctx.moveTo(points[0].x, points[0].y);
        for (let n3 = 1; n3 < points.length; n3++) {
          const point = points[n3];
          ctx.lineTo(point.x, point.y);
        }
      }
      ctx.closePath();
      this._renderPaintInOrder(ctx, props);
    }
    updatePointGroup(pointGroup) {
      this._pointsGroup = pointGroup;
      this._setFixBoundingBox();
    }
    resizePolygon(preValue) {
      const { left, top, width, height } = this._getSelfRect();
      const { width: preWidth, height: preHeight } = preValue;
      let fixX;
      let fixY;
      if (!preWidth) {
        fixX = 0;
      } else {
        fixX = this.width - preWidth;
      }
      if (!preHeight) {
        fixY = 0;
      } else {
        fixY = this.height - preHeight;
      }
      const increaseScaleX = fixX / width;
      const increaseScaleY = fixY / height;
      this.scaleX += increaseScaleX;
      this.scaleY += increaseScaleY;
      this.left = this.left - left * increaseScaleX;
      this.top = this.top - top * increaseScaleY;
      this._setTransForm();
    }
    toJson() {
      const props = {};
      REGULAR_POLYGON_OBJECT_ARRAY.forEach((key) => {
        if (this[key]) {
          props[key] = this[key];
        }
      });
      return {
        ...super.toJson(),
        ...props
      };
    }
    getState() {
      const { left, top, width, height } = this.getRect();
      return {
        left,
        top,
        width,
        height,
        scaleX: this.scaleX,
        scaleY: this.scaleY,
        angle: this.angle,
        skewX: this.skewX,
        skewY: this.skewY,
        flipX: this.flipX,
        flipY: this.flipY
      };
    }
    getRect() {
      const { left, top, width, height } = this._getSelfRect();
      return {
        left: left * this.scaleX + this.left,
        top: top * this.scaleY + this.top,
        width: width * this.scaleX,
        height: height * this.scaleY
      };
    }
    _draw(ctx) {
      RegularPolygon.drawWith(ctx, this);
    }
    _setFixBoundingBox() {
      const { width, height, left, top } = this._getSelfRect();
      this.left = this.left + left;
      this.top = this.top + top;
      this.width = width;
      this.height = height;
      const pointsGroup = this.pointsGroup;
      for (let points of pointsGroup) {
        for (let point of points) {
          point.x -= left;
          point.y -= top;
        }
      }
      this._setTransForm();
    }
    _getSelfRect() {
      const pointsGroup = this.pointsGroup;
      let minX = pointsGroup[0][0].x;
      let maxX = pointsGroup[0][0].x;
      let minY = pointsGroup[0][0].y;
      let maxY = pointsGroup[0][0].y;
      for (let points of pointsGroup) {
        for (let point of points) {
          minX = Math.min(minX, point.x);
          maxX = Math.max(maxX, point.x);
          minY = Math.min(minY, point.y);
          maxY = Math.max(maxY, point.y);
        }
      }
      return {
        left: minX,
        top: minY,
        width: maxX - minX,
        height: maxY - minY
      };
    }
  };

  // ../../packages/base-render/src/Shape/ScrollBar.ts
  var MINI_THUMB_SIZE = 17;
  var ScrollBar = class {
    _view;
    _thumbMargin = 2;
    _thumbLengthRatio = 1;
    _thumbBackgroundColor = getColor(COLORS.black, 0.2);
    _thumbHoverBackgroundColor = getColor(COLORS.black, 0.35);
    _thumbActiveBackgroundColor = getColor(COLORS.black, 0.4);
    _barSize = 14;
    _barBackgroundColor = getColor(COLORS.white);
    _barBorder = 1;
    _barBorderColor = getColor([218, 220, 224]);
    _enableHorizontal = true;
    _horizontalThumbWidth;
    _horizontalBarWidth;
    _horizonBarRect;
    _horizonThumbRect;
    _enableVertical = true;
    _verticalThumbHeight;
    _verticalBarHeight;
    _verticalBarRect;
    _verticalThumbRect;
    _verticalMinusMiniThumb = 0;
    _horizontalMinusMiniThumb = 0;
    _placeholderBarRect;
    _mainScene;
    _lastX;
    _lastY;
    _isHorizonMove = false;
    _isVerticalMove = false;
    constructor(view, props) {
      if (!view) {
        console.warn("Missing viewport");
      }
      this._view = view;
      this.setProps(props);
      this._initialScrollRect();
      this._view.setScrollBar(this);
    }
    get limitX() {
      if (!this._horizonThumbRect.visible) {
        return 0;
      }
      return this._horizontalBarWidth - this._horizontalThumbWidth;
    }
    get limitY() {
      if (!this._verticalThumbRect.visible) {
        return 0;
      }
      return this._verticalBarHeight - this._verticalThumbHeight;
    }
    get horizontalThumbWidth() {
      return this._horizontalThumbWidth;
    }
    get verticalThumbHeight() {
      return this._verticalThumbHeight;
    }
    get ratioScrollX() {
      if (this._horizontalThumbWidth === void 0 || this._horizontalBarWidth === void 0) {
        return 1;
      }
      return (this._horizontalThumbWidth - this._horizontalMinusMiniThumb) / this._horizontalBarWidth;
    }
    get ratioScrollY() {
      if (this._verticalThumbHeight === void 0 || this._verticalBarHeight === void 0) {
        return 1;
      }
      return (this._verticalThumbHeight - this._verticalMinusMiniThumb) / this._verticalBarHeight;
    }
    get barSize() {
      return this._barSize;
    }
    get barBorder() {
      return this._barBorder;
    }
    static attachTo(view, props) {
      return new ScrollBar(view, props);
    }
    setProps(props) {
      if (!props) {
        return;
      }
      const themeKeys = Object.keys(props);
      if (themeKeys.length === 0) {
        return;
      }
      themeKeys.forEach((key) => {
        if (props[key] !== void 0) {
          this[`_${key}`] = props[key];
        }
      });
    }
    render(ctx, left = 0, top = 0) {
      let { scrollX: scrollX2, scrollY: scrollY2 } = this._view;
      ctx.save();
      const transform = new Transform([1, 0, 0, 1, left, top]);
      const m4 = transform.getMatrix();
      ctx.transform(m4[0], m4[1], m4[2], m4[3], m4[4], m4[5]);
      this._horizonBarRect.render(ctx);
      this._horizonThumbRect.translate(scrollX2).render(ctx);
      this._verticalBarRect.render(ctx);
      this._verticalThumbRect.translate(void 0, scrollY2).render(ctx);
      this._placeholderBarRect.render(ctx);
      ctx.restore();
    }
    resize(parentWidth = 0, parentHeight = 0, contentWidth = 0, contentHeight = 0) {
      if (parentWidth === 0 && parentWidth === 0) {
        return;
      }
      if (this._enableHorizontal) {
        this._horizontalMinusMiniThumb = 0;
        this._horizontalBarWidth = parentWidth - this._barSize;
        this._horizontalThumbWidth = this._horizontalBarWidth * (this._horizontalBarWidth - this._barBorder) / contentWidth * this._thumbLengthRatio;
        if (this._horizontalThumbWidth < MINI_THUMB_SIZE) {
          this._horizontalMinusMiniThumb = MINI_THUMB_SIZE - this._horizontalThumbWidth;
          this._horizontalThumbWidth = MINI_THUMB_SIZE;
        }
        this._horizonBarRect?.transformByState({
          left: 0,
          top: parentHeight - this._barSize,
          width: this._horizontalBarWidth,
          height: this._barSize - this._barBorder
        });
        if (this._horizontalThumbWidth >= parentWidth) {
          this._horizonThumbRect?.setProps({
            visible: false
          });
        } else {
          if (!this._horizonThumbRect?.visible) {
            this._horizonThumbRect?.setProps({
              visible: true
            });
          }
          this._horizonThumbRect?.transformByState({
            left: this._view.scrollX,
            top: parentHeight - this._barSize + this._thumbMargin,
            width: this._horizontalThumbWidth,
            height: this._barSize - this._thumbMargin * 2
          });
        }
      }
      if (this._enableVertical) {
        this._verticalMinusMiniThumb = 0;
        this._verticalBarHeight = parentHeight - this._barSize;
        this._verticalThumbHeight = this._verticalBarHeight * (this._verticalBarHeight - this._barBorder) / contentHeight * this._thumbLengthRatio;
        if (this._verticalThumbHeight < MINI_THUMB_SIZE) {
          this._verticalMinusMiniThumb = MINI_THUMB_SIZE - this._verticalThumbHeight;
          this._verticalThumbHeight = MINI_THUMB_SIZE;
        }
        this._verticalBarRect?.transformByState({
          left: parentWidth - this._barSize,
          top: 0,
          width: this._barSize - this._barBorder,
          height: this._verticalBarHeight
        });
        if (this._verticalThumbHeight >= parentHeight) {
          this._verticalThumbRect?.setProps({
            visible: false
          });
        } else {
          if (!this._verticalThumbRect?.visible) {
            this._verticalThumbRect?.setProps({
              visible: true
            });
          }
          this._verticalThumbRect?.transformByState({
            left: parentWidth - this._barSize + this._thumbMargin,
            top: this._view.scrollY,
            width: this._barSize - this._thumbMargin * 2,
            height: this._verticalThumbHeight
          });
        }
      }
      if (this._enableHorizontal && this._enableVertical) {
        this._placeholderBarRect?.transformByState({
          left: parentWidth - this._barSize,
          top: parentHeight - this._barSize,
          width: this._barSize - this._barBorder,
          height: this._barSize - this._barBorder
        });
      }
    }
    makeDirty(state) {
      this._horizonBarRect?.makeDirty(state);
      this._horizonThumbRect?.makeDirty(state);
      this._verticalBarRect?.makeDirty(state);
      this._verticalThumbRect?.makeDirty(state);
      this._placeholderBarRect?.makeDirty(state);
      this.makeViewDirty(state);
    }
    makeViewDirty(state) {
      this._view.makeDirty(state);
      const parent = this._view.scene.getParent();
      if (parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        parent.makeDirty(true);
      }
    }
    pick(coord) {
      if (this._horizonThumbRect?.isHit(coord)) {
        return this._horizonThumbRect;
      }
      if (this._verticalThumbRect?.isHit(coord)) {
        return this._verticalThumbRect;
      }
      if (this._horizonBarRect?.isHit(coord)) {
        return this._horizonBarRect;
      }
      if (this._verticalBarRect?.isHit(coord)) {
        return this._verticalBarRect;
      }
      return null;
    }
    dispose() {
      this._horizonBarRect.dispose();
      this._horizonThumbRect.dispose();
      this._verticalBarRect.dispose();
      this._verticalThumbRect.dispose();
      this._placeholderBarRect.dispose();
    }
    _initialScrollRect() {
      if (this._enableHorizontal) {
        this._horizonBarRect = new Rect("__horizonBarRect__", {
          fill: this._barBackgroundColor,
          strokeWidth: this._barBorder,
          stroke: this._barBorderColor
        });
        this._horizonThumbRect = new Rect("__horizonThumbRect__", {
          radius: 6,
          fill: this._thumbBackgroundColor
        });
      }
      if (this._enableVertical) {
        this._verticalBarRect = new Rect("__verticalBarRect__", {
          fill: this._barBackgroundColor,
          strokeWidth: this._barBorder,
          stroke: this._barBorderColor
        });
        this._verticalThumbRect = new Rect("__verticalThumbRect__", {
          radius: 6,
          fill: this._thumbBackgroundColor
        });
      }
      if (this._enableHorizontal && this._enableVertical) {
        this._placeholderBarRect = new Rect("__placeholderBarRect__", {
          fill: this._barBackgroundColor,
          strokeWidth: this._barBorder,
          stroke: this._barBorderColor
        });
      }
      this.__initialEvent();
    }
    __initialEvent() {
      const mainScene = this._mainScene || this._view.scene;
      const hoverFunc = (color, object) => (evt, state) => {
        if (this._isHorizonMove || this._isVerticalMove) {
          return;
        }
        const e4 = evt;
        const srcElement = object;
        srcElement.setProps({
          fill: color
        });
        this.makeViewDirty(true);
      };
      if (this._enableHorizontal) {
        this._horizonThumbRect.on("PointerEnter" /* PointerEnter */, hoverFunc(this._thumbHoverBackgroundColor, this._horizonThumbRect));
        this._horizonThumbRect.on("PointerLeave" /* PointerLeave */, hoverFunc(this._thumbBackgroundColor, this._horizonThumbRect));
        this._horizonBarRect.on("PointerDown" /* PointerDown */, (evt, state) => {
          const e4 = evt;
          this._view.scrollTo({
            x: e4.offsetX - this._view.left - this._horizontalThumbWidth / 2
          });
          state.stopPropagation();
        });
        this._horizonThumbRect.on("PointerDown" /* PointerDown */, (evt, state) => {
          const e4 = evt;
          this._isHorizonMove = true;
          this._lastX = e4.offsetX;
          this._lastY = e4.offsetY;
          this._horizonThumbRect.setProps({
            fill: this._thumbActiveBackgroundColor
          });
          this.makeViewDirty(true);
          mainScene.disableEvent();
          state.stopPropagation();
        });
        mainScene.on("PointerMove" /* PointerMove */, (evt, state) => {
          const e4 = evt;
          if (!this._isHorizonMove) {
            return;
          }
          this._view.scrollBy({
            x: e4.offsetX - this._lastX
          });
          this._lastX = e4.offsetX;
        });
        mainScene.on("PointerUp" /* PointerUp */, (evt, state) => {
          const e4 = evt;
          const srcElement = this._horizonThumbRect;
          this._isHorizonMove = false;
          mainScene.enableEvent();
          srcElement.setProps({
            fill: this._thumbBackgroundColor
          });
          this.makeViewDirty(true);
        });
      }
      if (this._enableVertical) {
        this._verticalThumbRect.on("PointerEnter" /* PointerEnter */, hoverFunc(this._thumbHoverBackgroundColor, this._verticalThumbRect));
        this._verticalThumbRect.on("PointerLeave" /* PointerLeave */, hoverFunc(this._thumbBackgroundColor, this._verticalThumbRect));
        this._verticalBarRect.on("PointerDown" /* PointerDown */, (evt, state) => {
          const e4 = evt;
          this._view.scrollTo({
            y: e4.offsetY - this._view.top - this._verticalThumbHeight / 2
          });
          state.stopPropagation();
        });
        this._verticalThumbRect.on("PointerDown" /* PointerDown */, (evt, state) => {
          const e4 = evt;
          const srcElement = this._verticalThumbRect;
          this._isVerticalMove = true;
          this._lastX = e4.offsetX;
          this._lastY = e4.offsetY;
          srcElement.setProps({
            fill: this._thumbActiveBackgroundColor
          });
          mainScene.disableEvent();
          this.makeViewDirty(true);
          state.stopPropagation();
        });
        mainScene.on("PointerMove" /* PointerMove */, (evt, state) => {
          const e4 = evt;
          if (!this._isVerticalMove) {
            return;
          }
          this._view.scrollBy({
            y: e4.offsetY - this._lastY
          });
          this._lastY = e4.offsetY;
        });
        mainScene.on("PointerUp" /* PointerUp */, (evt, state) => {
          const e4 = evt;
          const srcElement = this._verticalThumbRect;
          this._isVerticalMove = false;
          mainScene.enableEvent();
          srcElement.setProps({
            fill: this._thumbBackgroundColor
          });
          this.makeViewDirty(true);
        });
      }
    }
  };

  // ../../packages/base-render/src/Component/Docs/Common/Tools.ts
  function getLastPage(pages) {
    return pages?.[pages.length - 1];
  }
  function getLastSection(page) {
    return page?.sections?.[page.sections.length - 1];
  }
  function getLastLine(page) {
    const lines = getLastNotFullColumnInfo(page)?.column.lines;
    return lines?.[lines.length - 1];
  }
  function getLastLineByColumn(column) {
    return column.lines[column.lines.length - 1];
  }
  function getPageContentWidth(page) {
    const { width: pageWidth, marginLeft: pageMarginLeft, marginRight: pageMarginRight } = page;
    const pageContentWidth = pageWidth - pageMarginLeft - pageMarginRight;
    return pageContentWidth;
  }
  function getColumnByDivide(divide) {
    const column = divide.parent?.parent;
    if (column) {
      return column;
    }
  }
  function getLastNotFullColumnInfo(page) {
    const section = getLastSection(page);
    for (let i4 = 0; i4 < section.columns.length; i4++) {
      const column = section.columns[i4];
      if (!column.isFull) {
        return {
          column,
          isLast: i4 === section.columns.length - 1,
          index: i4
        };
      }
    }
  }
  function getLastNotFullDivideInfo(page) {
    const line = getLastLine(page);
    if (!line) {
      return;
    }
    for (let i4 = 0; i4 < line.divides.length; i4++) {
      const divide = line.divides[i4];
      if (!divide.isFull) {
        return {
          divide,
          isLast: i4 === line.divides.length - 1,
          index: i4
        };
      }
    }
  }
  function isColumnFull(page) {
    const section = getLastSection(page);
    const columnsLen = section.columns.length;
    for (let i4 = 0; i4 < columnsLen; i4++) {
      const column = section.columns[i4];
      if (!column.isFull) {
        return false;
      }
    }
    return true;
  }
  function isBlankPage(page) {
    if (page.sections.length > 1) {
      return false;
    }
    const section = getLastSection(page);
    const columnsLen = section.columns.length;
    for (let i4 = 0; i4 < columnsLen; i4++) {
      const column = section.columns[i4];
      const state = isBlankColumn(column);
      if (!state) {
        return false;
      }
    }
    return true;
  }
  function isBlankColumn(column) {
    const lines = column.lines;
    if (lines.length > 1) {
      return false;
    }
    const line = lines[lines.length - 1];
    return isLineBlank(line);
  }
  function isLineBlank(line) {
    if (!line) {
      return true;
    }
    for (let i4 = 0; i4 < line.divides.length; i4++) {
      const spanCount = line.divides[i4].spanGroup.length;
      if (spanCount > 1) {
        return false;
      }
      if (spanCount === 1) {
        const lastSpan = line.divides[i4].spanGroup[0];
        const { spanType } = lastSpan;
        if (spanType !== 3 /* TAB */ && spanType !== 2 /* LIST */) {
          return false;
        }
      }
    }
    return true;
  }
  function getNumberUnitValue(unitValue, benchMark) {
    if (unitValue instanceof Object) {
      const { v: value, u: unit } = unitValue;
      if (unit === 0 /* POINT */) {
        return value;
      }
      return value * benchMark;
    }
    return unitValue;
  }
  function getCharSpaceApply(charSpace = 0, defaultTabStop, gridType = 1 /* LINES */, snapToGrid = 1 /* TRUE */) {
    let charSpaceApply = 1;
    if (validationGrid(gridType, snapToGrid)) {
      charSpaceApply = charSpace;
    }
    charSpaceApply *= defaultTabStop;
    return charSpaceApply;
  }
  function validationGrid(gridType = 1 /* LINES */, snapToGrid = 0 /* FALSE */) {
    return snapToGrid === 1 /* TRUE */ && (gridType === 2 /* LINES_AND_CHARS */ || gridType === 3 /* SNAP_TO_CHARS */);
  }
  function getLineHeightConfig(sectionBreakConfig, paragraphConfig) {
    const { paragraphStyle = {} } = paragraphConfig;
    const { linePitch = 15.6, gridType = 1 /* LINES */, paragraphLineGapDefault = 0 } = sectionBreakConfig;
    const { lineSpacing = 1, spacingRule = 0 /* AUTO */, snapToGrid = 1 /* TRUE */ } = paragraphStyle;
    return { paragraphLineGapDefault, linePitch, gridType, lineSpacing, spacingRule, snapToGrid };
  }
  function getCharSpaceConfig(sectionBreakConfig, paragraphConfig) {
    const { paragraphStyle = {} } = paragraphConfig;
    const { charSpace = 0, gridType = 1 /* LINES */, defaultTabStop = 36, documentTextStyle = {} } = sectionBreakConfig;
    const { fs: documentFontSize = DEFAULT_DOCUMENT_FONTSIZE } = documentTextStyle;
    const { snapToGrid = 1 /* TRUE */ } = paragraphStyle;
    return {
      charSpace,
      documentFontSize,
      defaultTabStop,
      gridType,
      snapToGrid
    };
  }
  function updateBlockIndex(pages, start = -1) {
    const firstPage = pages[0];
    const { st: firstPageStartIndex } = firstPage;
    let prePageStartIndex = start;
    for (let page of pages) {
      const { sections } = page;
      let pageStartIndex = prePageStartIndex;
      let pageEndIndex = pageStartIndex;
      let preSectionStartIndex = pageStartIndex;
      let maxPageWidth = -Infinity;
      let pageHeight = 0;
      for (let section of sections) {
        const { columns } = section;
        let sectionStartIndex = preSectionStartIndex;
        let sectionEndIndex = pageStartIndex;
        let preColumnStartIndex = sectionStartIndex;
        let maxSectionHeight = -Infinity;
        for (let column of columns) {
          const { lines } = column;
          let columStartIndex = preColumnStartIndex;
          let columnEndIndex = columStartIndex;
          let preLineStartIndex = columStartIndex;
          let columnHeight = 0;
          let maxColumnWidth = -Infinity;
          let preLine = null;
          for (let line of lines) {
            const { divides, lineHeight } = line;
            let lineStartIndex = preLineStartIndex;
            let lineEndIndex = lineStartIndex;
            let preDivideStartIndex = lineStartIndex;
            let actualWidth = 0;
            let maxLineAsc = 0;
            columnHeight += lineHeight;
            const divideLength = divides.length;
            for (let i4 = 0; i4 < divideLength; i4++) {
              const divide = divides[i4];
              const { spanGroup } = divide;
              if (spanGroup.length === 0) {
                continue;
              }
              let divStartIndex = preDivideStartIndex;
              let divEndIndex = divStartIndex;
              for (let span of spanGroup) {
                const increaseValue = span.spanType === 2 /* LIST */ ? 0 : span.count || 1;
                divEndIndex += increaseValue;
                const bBox = span.bBox;
                const { ba } = bBox;
                maxLineAsc = Math.max(maxLineAsc, ba);
                if (i4 === divideLength - 1 && divide.width === Infinity) {
                  actualWidth += span.width;
                }
              }
              if (i4 === divideLength - 1) {
                if (divide.width === Infinity) {
                  divide.width = actualWidth;
                } else {
                  actualWidth += divide.width;
                }
                actualWidth += divide.left;
              }
              divide.st = divStartIndex === 0 ? 0 : divStartIndex + 1;
              divide.ed = divEndIndex >= divide.st ? divEndIndex : divide.st;
              preDivideStartIndex = divide.ed;
            }
            line.st = lineStartIndex === 0 ? 0 : lineStartIndex + 1;
            line.ed = preDivideStartIndex >= line.st ? preDivideStartIndex : line.st;
            line.width = actualWidth;
            line.asc = maxLineAsc;
            maxColumnWidth = Math.max(maxColumnWidth, actualWidth);
            line.top = (preLine?.top || 0) + (preLine?.lineHeight || 0);
            preLine = line;
            preLineStartIndex = line.ed;
          }
          column.st = columStartIndex === 0 ? 0 : columStartIndex + 1;
          column.ed = preLineStartIndex >= column.st ? preLineStartIndex : column.st;
          column.height = columnHeight;
          if (column.width === Infinity) {
            column.width = maxColumnWidth;
          }
          maxPageWidth = Math.max(maxPageWidth, maxColumnWidth);
          maxSectionHeight = Math.max(maxSectionHeight, column.height);
          preColumnStartIndex = column.ed;
        }
        section.st = sectionStartIndex === 0 ? 0 : sectionStartIndex + 1;
        section.ed = preColumnStartIndex >= section.st ? preColumnStartIndex : section.st;
        section.height = maxSectionHeight;
        pageHeight += maxSectionHeight;
        preSectionStartIndex = section.ed;
      }
      page.st = pageStartIndex === 0 ? 0 : pageStartIndex + 1;
      page.ed = preSectionStartIndex >= page.st ? preSectionStartIndex : page.st;
      page.height = pageHeight;
      page.width = maxPageWidth;
      prePageStartIndex = page.ed;
    }
  }
  function lineIterator(pages, iteratorFunction) {
    for (let page of pages) {
      const { sections } = page;
      for (let section of sections) {
        const { columns } = section;
        for (let column of columns) {
          const { lines } = column;
          for (let line of lines) {
            if (iteratorFunction && isFunction(iteratorFunction)) {
              iteratorFunction(line);
            }
          }
        }
      }
    }
  }
  function columnIterator(pages, iteratorFunction) {
    for (let page of pages) {
      const { sections } = page;
      for (let section of sections) {
        const { columns } = section;
        for (let column of columns) {
          if (iteratorFunction && isFunction(iteratorFunction)) {
            iteratorFunction(column);
          }
        }
      }
    }
  }
  function getPositionHorizon(positionH, column, page, objectWidth, isPageBreak = false) {
    const { relativeFrom, align, posOffset, percent } = positionH;
    if (align != null) {
      if (align === 1 /* INSIDE */ || align === 3 /* OUTSIDE */) {
        if (relativeFrom === 4 /* MARGIN */) {
        } else if (relativeFrom === 6 /* PAGE */) {
        }
      } else {
        if (relativeFrom === 1 /* COLUMN */) {
          const { width, left } = column;
          let absoluteLeft = 0;
          if (align === 2 /* LEFT */) {
            absoluteLeft = left;
          } else if (align === 4 /* RIGHT */) {
            absoluteLeft = left + width - objectWidth;
          } else if (align === 0 /* CENTER */) {
            absoluteLeft = left + width / 2 - objectWidth / 2;
          }
          return absoluteLeft;
        }
        if (relativeFrom === 3 /* LEFT_MARGIN */) {
        } else if (relativeFrom === 4 /* MARGIN */) {
        } else if (relativeFrom === 7 /* RIGHT_MARGIN */) {
        } else if (relativeFrom === 2 /* INSIDE_MARGIN */) {
        } else if (relativeFrom === 5 /* OUTSIDE_MARGIN */) {
        } else if (relativeFrom === 6 /* PAGE */) {
          const { width } = page;
          let absoluteLeft = 0;
          if (align === 4 /* RIGHT */) {
            absoluteLeft = width - objectWidth;
          } else if (align === 0 /* CENTER */) {
            absoluteLeft = width / 2 - objectWidth / 2;
          }
          return absoluteLeft;
        }
      }
    } else if (posOffset) {
      const { width: pageWidth, marginLeft, marginRight } = page;
      const boundaryLeft = marginLeft;
      const boundaryRight = pageWidth - marginRight;
      let absoluteLeft = 0;
      if (relativeFrom === 1 /* COLUMN */) {
        absoluteLeft = (isPageBreak ? 0 : column?.left || 0) + posOffset;
      } else if (relativeFrom === 3 /* LEFT_MARGIN */) {
      } else if (relativeFrom === 4 /* MARGIN */) {
        absoluteLeft = posOffset + marginLeft;
      } else if (relativeFrom === 7 /* RIGHT_MARGIN */) {
      } else if (relativeFrom === 2 /* INSIDE_MARGIN */) {
      } else if (relativeFrom === 5 /* OUTSIDE_MARGIN */) {
      } else if (relativeFrom === 6 /* PAGE */) {
        absoluteLeft = posOffset;
      }
      if (absoluteLeft + objectWidth > boundaryRight) {
        absoluteLeft = boundaryRight - objectWidth;
      }
      return absoluteLeft;
    } else if (percent) {
      const { width: pageWidth, marginLeft, marginRight } = page;
      if (relativeFrom === 3 /* LEFT_MARGIN */) {
      } else if (relativeFrom === 4 /* MARGIN */) {
      } else if (relativeFrom === 7 /* RIGHT_MARGIN */) {
      } else if (relativeFrom === 2 /* INSIDE_MARGIN */) {
      } else if (relativeFrom === 5 /* OUTSIDE_MARGIN */) {
      } else if (relativeFrom === 6 /* PAGE */) {
        return percent * pageWidth;
      }
    }
  }
  function getPositionVertical(positionV, page, lineTop, lineHeight, objectHeight, blockAnchorTop, isPageBreak = false) {
    const { relativeFrom, align, posOffset, percent } = positionV;
    if (align != null) {
      if (relativeFrom === 2 /* LINE */) {
        let absoluteTop = 0;
        if (align === 0 /* BOTTOM */) {
          absoluteTop = lineTop + lineHeight - objectHeight;
        } else if (align === 4 /* TOP */) {
          absoluteTop = lineTop;
        } else if (align === 1 /* CENTER */) {
          absoluteTop = lineTop + lineHeight / 2 - objectHeight / 2;
        }
        return absoluteTop;
      }
      if (relativeFrom === 7 /* TOP_MARGIN */) {
      } else if (relativeFrom === 3 /* MARGIN */) {
      } else if (relativeFrom === 0 /* BOTTOM_MARGIN */) {
      } else if (relativeFrom === 1 /* INSIDE_MARGIN */) {
      } else if (relativeFrom === 4 /* OUTSIDE_MARGIN */) {
      } else if (relativeFrom === 5 /* PAGE */) {
        const { height } = page;
        let absoluteTop = 0;
        if (align === 0 /* BOTTOM */) {
          absoluteTop = height - objectHeight;
        } else if (align === 1 /* CENTER */) {
          absoluteTop = height / 2 - objectHeight / 2;
        }
        return absoluteTop;
      }
    } else if (posOffset) {
      let absoluteTop = 0;
      if (relativeFrom === 2 /* LINE */) {
        absoluteTop = lineTop || 0 + posOffset;
      } else if (relativeFrom === 7 /* TOP_MARGIN */) {
      } else if (relativeFrom === 3 /* MARGIN */) {
      } else if (relativeFrom === 0 /* BOTTOM_MARGIN */) {
      } else if (relativeFrom === 1 /* INSIDE_MARGIN */) {
      } else if (relativeFrom === 4 /* OUTSIDE_MARGIN */) {
      } else if (relativeFrom === 5 /* PAGE */) {
        absoluteTop = posOffset;
      } else if (relativeFrom === 6 /* PARAGRAPH */) {
        absoluteTop = (isPageBreak ? 0 : blockAnchorTop == null ? lineTop : blockAnchorTop) + posOffset;
      }
      return absoluteTop;
    } else if (percent) {
      const { height: pageHeight, marginBottom, marginTop } = page;
      if (relativeFrom === 7 /* TOP_MARGIN */) {
      } else if (relativeFrom === 3 /* MARGIN */) {
      } else if (relativeFrom === 0 /* BOTTOM_MARGIN */) {
      } else if (relativeFrom === 1 /* INSIDE_MARGIN */) {
      } else if (relativeFrom === 4 /* OUTSIDE_MARGIN */) {
      } else if (relativeFrom === 5 /* PAGE */) {
        return percent * pageHeight;
      }
    }
  }
  function getSpanGroupWidth(divide) {
    const spanGroup = divide.spanGroup;
    let width = 0;
    for (let span of spanGroup) {
      width += span.width;
    }
    return width;
  }

  // ../../packages/base-render/src/Component/Docs/Common/Section.ts
  function createSkeletonSection(columnProperties = [], columnSeparatorType = 1 /* NONE */, top = 0, left = 0, sectionWidth = Infinity, sectionHeight = Infinity) {
    const columns = [];
    let colWidth = 0;
    let spaceWidth = 0;
    if (columnProperties.length === 0) {
      columns.push(_getSkeletonColumn(left, sectionWidth, 0, 1 /* NONE */));
    } else {
      for (let i4 = 0; i4 < columnProperties.length; i4++) {
        const { width, paddingEnd } = columnProperties[i4];
        spaceWidth = paddingEnd;
        colWidth = width;
        columns.push(_getSkeletonColumn(left, colWidth, spaceWidth, columnSeparatorType));
        left += colWidth + spaceWidth;
        if (i4 === columnProperties.length - 1) {
          colWidth = sectionWidth !== Infinity ? sectionWidth - colWidth : width;
          spaceWidth = 0;
          columns.push(_getSkeletonColumn(left, colWidth, spaceWidth, columnSeparatorType));
        }
      }
    }
    const newSection = {
      columns,
      colCount: columnProperties?.length || 1,
      height: sectionHeight,
      top,
      st: 0,
      ed: 0
    };
    columns.forEach((column) => {
      column.parent = newSection;
    });
    return newSection;
  }
  function setColumnFullState(column, state) {
    column.isFull = state;
  }
  function _getSkeletonColumn(left, width, spaceWidth, columnSeparatorType) {
    return {
      lines: [],
      // columnsection
      left,
      width,
      height: 0,
      spaceWidth,
      separator: columnSeparatorType,
      st: 0,
      ed: 0,
      drawingLRIds: [],
      isFull: false
    };
  }

  // ../../packages/base-render/src/Component/Docs/Block/Paragraph/Bullet.Ruler.ts
  function getBulletOrderedSymbol(startIndex, startNumber, glyphType, context) {
    if (!(glyphType in GlyphType)) {
      return dealWidthCustomBulletOrderedSymbol(startIndex, startNumber, glyphType, context);
    }
    return generateOrderedSymbol(startIndex, startNumber, glyphType);
  }
  function generateOrderedSymbol(startIndex, startNumber, glyphType) {
    if (glyphType === 2 /* DECIMAL */) {
      return decimal(startIndex, startNumber);
    }
    if (glyphType === 3 /* ZERO_DECIMAL */) {
      return zeroDecimal(startIndex, startNumber);
    }
    if (glyphType === 4 /* UPPER_ALPHA */) {
      return upperAlpha(startIndex, startNumber);
    }
    if (glyphType === 5 /* ALPHA */) {
      return alpha(startIndex, startNumber);
    }
    if (glyphType === 6 /* UPPER_ROMAN */) {
      return upperRoman(startIndex, startNumber);
    }
    if (glyphType === 7 /* ROMAN */) {
      return roman(startIndex, startNumber);
    }
    return decimal(startIndex, startNumber);
  }
  function decimal(startIndex, startNumber) {
    const currentIndex = startIndex + startNumber;
    return currentIndex.toString();
  }
  function zeroDecimal(startIndex, startNumber) {
    const currentIndex = startIndex + startNumber;
    if (currentIndex < 10) {
      return `0${currentIndex}`;
    }
    return currentIndex.toString();
  }
  function upperAlpha(startIndex, startNumber) {
    return numberToListABC(startIndex + startNumber - 1, true);
  }
  function alpha(startIndex, startNumber) {
    return numberToListABC(startIndex + startNumber - 1, false);
  }
  function upperRoman(startIndex, startNumber) {
    return _convertRoman(startIndex + startNumber, true);
  }
  function roman(startIndex, startNumber) {
    return _convertRoman(startIndex + startNumber, false);
  }
  function _convertRoman(num, uppercase = false) {
    const upperLookup = { M: 1e3, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1 };
    const lowerLookup = { m: 1e3, cm: 900, d: 500, cd: 400, c: 100, xc: 90, l: 50, xl: 40, x: 10, ix: 9, v: 5, iv: 4, i: 1 };
    let lookup = lowerLookup;
    if (uppercase) {
      lookup = upperLookup;
    }
    let romanStr = "";
    for (let i4 in lookup) {
      while (num >= lookup[i4]) {
        romanStr += i4;
        num -= lookup[i4];
      }
    }
    return romanStr;
  }

  // ../../packages/base-render/src/Component/Docs/Block/Paragraph/Bullet.ts
  function dealWidthBullet(bullet, lists, listLevelAncestors, fontLocale, context) {
    if (!bullet || !lists) {
      return;
    }
    const { listId, nestingLevel = 0, textStyle } = bullet;
    const list = lists[listId];
    if (!list || !list.nestingLevel) {
      return getDefaultBulletSke(listId, listLevelAncestors?.[nestingLevel]?.startIndexItem, fontLocale);
    }
    const nesting = list.nestingLevel[nestingLevel];
    if (!nesting) {
      return getDefaultBulletSke(listId, listLevelAncestors?.[nestingLevel]?.startIndexItem, fontLocale);
    }
    const bulletSke = _getBulletSke(listId, nestingLevel, list.nestingLevel, listLevelAncestors, textStyle, fontLocale, context);
    return bulletSke;
  }
  function getDefaultBulletSke(listId, startIndex = 1, fontLocale) {
    return {
      listId,
      symbol: "\u25CF",
      // symbol 
      ts: {
        ff: fontLocale?.fontList[0] || "Arial",
        fs: fontLocale?.defaultFontSize || 9
      },
      // 
      startIndexItem: startIndex,
      bBox: {
        width: 8.4560546875,
        ba: 7,
        bd: -1,
        aba: 7,
        abd: -1,
        sp: -2,
        sbr: 0.5,
        sbo: 0,
        spr: 0.5,
        spo: 0
      },
      indentFirstLine: 0,
      hanging: 21,
      indentStart: 0
    };
  }
  function _getBulletSke(listId, nestingLevel, nestings, listLevelAncestors, textStyleConfig, fontLocale, context) {
    const nesting = nestings[nestingLevel];
    const { bulletAlignment, glyphFormat, textStyle: textStyleFirst, startNumber, glyphType, glyphSymbol, indentFirstLine, hanging, indentStart } = nesting;
    const textStyle = { ...textStyleConfig, ...textStyleFirst };
    const fontStyle = getFontStyleString(textStyle, fontLocale);
    let symbolContent;
    if (glyphSymbol) {
      symbolContent = glyphSymbol;
    } else {
      symbolContent = __generateOrderedListSymbol(glyphFormat, nestingLevel, nestings, listLevelAncestors, context);
    }
    const bBox = FontCache.getTextSize(symbolContent, fontStyle);
    const startIndex = listLevelAncestors?.[nestingLevel]?.startIndexItem ?? 1;
    return {
      listId,
      symbol: symbolContent,
      // symbol 
      ts: textStyle,
      // 
      fontStyle,
      //
      startIndexItem: startIndex + 1,
      bBox,
      nestingLevel: nesting,
      bulletAlign: bulletAlignment,
      bulletType: glyphSymbol ? false : !!glyphType,
      // glyphSymbolglyphType
      indentFirstLine,
      hanging,
      indentStart
    };
  }
  function __generateOrderedListSymbol(glyphFormat, nestingLevel, nestings, listLevelAncestors, context) {
    const glyphFormatSplit = glyphFormat.split("%");
    const prefix = glyphFormatSplit[0];
    const resultSymbol = [prefix];
    for (let i4 = 1; i4 < glyphFormatSplit.length; i4++) {
      const levelAndSuffixPre = glyphFormatSplit[i4];
      const { level, suffix } = ___getLevelAndSuffix(levelAndSuffixPre);
      let startIndexItem = listLevelAncestors?.[level]?.startIndexItem || 1;
      if (level !== nestingLevel && listLevelAncestors?.[level] !== null) {
        startIndexItem -= 1;
      }
      const singleSymbol = ___getSymbolByBesting(startIndexItem, nestings[level], context);
      resultSymbol.push(singleSymbol, suffix);
    }
    return resultSymbol.join("");
  }
  function ___getSymbolByBesting(startIndex = 1, nesting, context) {
    const { startNumber, glyphType, glyphSymbol } = nesting;
    if (glyphSymbol) {
      return glyphSymbol;
    }
    if (!glyphType) {
      return "\u25CF";
    }
    return getBulletOrderedSymbol(startIndex, startNumber, glyphType, context);
  }
  function ___getLevelAndSuffix(levelAndSuffixPre) {
    if (levelAndSuffixPre === "") {
      return {
        level: 0,
        suffix: ""
      };
    }
    const levelAndSuffixPreSpit = levelAndSuffixPre.split("");
    let level = "";
    let suffix = "";
    let isSuffixState = false;
    const digitReg = /[0-9]/g;
    levelAndSuffixPreSpit.forEach((w4) => {
      if (!isSuffixState && digitReg.test(`${level}${w4}`)) {
        level += w4;
      } else {
        isSuffixState = true;
        suffix += w4;
      }
    });
    return {
      level: parseInt(level) - 1,
      suffix
    };
  }

  // ../../packages/base-render/src/Component/Docs/Block/Paragraph/InlineDrawing.ts
  function dealWidthInlineDrawing(drawing, elementIndex, sectionBreakConfig, currentPage, paragraphConfig, fontLocale) {
    return [];
  }

  // ../../packages/base-render/src/Component/Docs/Common/Span.ts
  function createSkeletonWordSpan(content, config, spanWidth) {
    return _createSkeletonWordOrLetter(1 /* WORD */, content, config, spanWidth);
  }
  function createSkeletonLetterSpan(content, config, spanWidth) {
    return _createSkeletonWordOrLetter(0 /* LETTER */, content, config, spanWidth);
  }
  function createSkeletonTabSpan(config, spanWidth) {
    return _createSkeletonWordOrLetter(3 /* TAB */, " ", config, spanWidth);
  }
  function _createSkeletonWordOrLetter(spanType, content, config, spanWidth) {
    const { fontStyle, textStyle, charSpace = 1, gridType = 1 /* LINES */, snapToGrid = 0 /* FALSE */ } = config;
    const bBox = FontCache.getTextSize(content, fontStyle);
    const { width: contentWidth = 0 } = bBox;
    let width = spanWidth ?? contentWidth;
    let paddingLeft = 0;
    if (validationGrid(gridType, snapToGrid)) {
      const multiple = Math.ceil(contentWidth / charSpace);
      width = multiple * charSpace;
      if (gridType === 2 /* LINES_AND_CHARS */) {
        paddingLeft = (width - contentWidth) / 2;
      }
    }
    return {
      content,
      ts: textStyle,
      fontStyle,
      width,
      bBox,
      paddingLeft,
      left: 0,
      spanType
    };
  }
  function createSkeletonBulletSpan(span, bulletSkeleton, charSpaceApply) {
    const { bBox: boundingBox, symbol: content, ts: textStyle, fontStyle, bulletAlign = 1 /* START */, bulletType = false } = bulletSkeleton;
    const contentWidth = boundingBox.width;
    const multiple = Math.ceil(contentWidth / charSpaceApply);
    let width = (multiple < 2 ? 2 : multiple) * charSpaceApply;
    let left = 0;
    if (bulletType) {
      if (bulletAlign === 2 /* CENTER */) {
        left = -contentWidth / 2;
        width -= left;
      } else if (bulletAlign === 3 /* END */) {
        left = -contentWidth;
        width -= left;
      }
    }
    const bBox = _getMaxBoundingBox(span, bulletSkeleton);
    return {
      content,
      ts: textStyle,
      fontStyle,
      width,
      paddingLeft: 0,
      bBox,
      left,
      spanType: 2 /* LIST */
    };
  }
  function setSpanGroupLeft(spanGroup, left = 0) {
    const spanGroupLen = spanGroup.length;
    let preSpan;
    for (let i4 = 0; i4 < spanGroupLen; i4++) {
      const span = spanGroup[i4];
      span.left = preSpan ? preSpan.left + preSpan.width : left;
      preSpan = span;
    }
  }
  function _getMaxBoundingBox(span, bulletSkeleton) {
    const { ba: spanAscent, bd: spanDescent } = span.bBox;
    const { ba: bulletAscent, bd: bulletDescent } = bulletSkeleton.bBox;
    if (spanAscent + spanDescent > bulletAscent + bulletDescent) {
      return span.bBox;
    }
    return bulletSkeleton.bBox;
  }

  // ../../packages/base-render/src/Component/Docs/Block/Paragraph/Language.Ruler.ts
  function composeCharForLanguage(char, charIndex, charArray, config) {
    if (hasArabic(char)) {
      return ArabicHandler(char, charIndex, charArray, config);
    }
    if (hasTibetan(char)) {
      return TibetanHandler(char, charIndex, charArray, config);
    }
    if (!hasCJK(char)) {
      return notCJKHandler(char, charIndex, charArray, config);
    }
  }
  function notCJKHandler(char, charIndex, charArray, config) {
    const { pageWidth = Infinity } = config;
    const charSke = createSkeletonLetterSpan(char, config);
    const spanGroup = [charSke];
    let allWidth = charSke.width;
    let newCharIndex = charIndex;
    for (let i4 = charIndex + 1; i4 < charArray.length; i4++) {
      const newChar = charArray[i4];
      if (!hasCJK(newChar) && !hasSpaceAndTab(newChar)) {
        const newSpan = createSkeletonLetterSpan(newChar, config);
        const newCharWidth = newSpan.width;
        if (allWidth + newCharWidth > pageWidth) {
          break;
        }
        spanGroup.push(newSpan);
        allWidth += newCharWidth;
        newCharIndex = i4;
      } else {
        break;
      }
    }
    return {
      charIndex: newCharIndex,
      spanGroup
    };
  }
  function ArabicHandler(char, charIndex, charArray, config) {
    const span = [char];
    let newCharIndex = charIndex;
    for (let i4 = charIndex + 1; i4 < charArray.length; i4++) {
      const newChar = charArray[i4];
      if (hasArabic(newChar)) {
        span.unshift(newChar);
        newCharIndex = i4;
      } else {
        break;
      }
    }
    return {
      charIndex: newCharIndex,
      spanGroup: [createSkeletonLetterSpan(span.join(""), config)]
    };
  }
  function TibetanHandler(char, charIndex, charArray, config) {
    const span = [char];
    let newCharIndex = charIndex;
    for (let i4 = charIndex + 1; i4 < charArray.length; i4++) {
      const newChar = charArray[i4];
      if (hasTibetan(newChar)) {
        span.push(newChar);
        newCharIndex = i4;
      } else {
        break;
      }
    }
    return {
      charIndex: newCharIndex,
      spanGroup: [createSkeletonWordSpan(span.join(""), config)]
    };
  }

  // ../../packages/base-render/src/Component/Docs/Common/Line.ts
  function createSkeletonLine(blockId, lineType, lineBoundingBox, columnWidth, lineIndex = 0, elementIndex = 0, isFirstSpan = false, affectSkeDrawings, headersDrawings, footersDrawings) {
    const {
      lineHeight = 15.6,
      lineTop = 0,
      contentHeight = 0,
      paddingLeft = 0,
      paddingRight = 0,
      paddingTop = 0,
      paddingBottom = 0,
      marginTop = 0,
      spaceBelowApply = 0
    } = lineBoundingBox;
    const lineSke = _getLineSke(lineType, blockId);
    lineSke.lineIndex = lineIndex;
    lineSke.paragraphStart = isParagraphStart(elementIndex, isFirstSpan);
    lineSke.contentHeight = contentHeight;
    lineSke.top = lineTop;
    lineSke.lineHeight = lineHeight;
    lineSke.paddingTop = paddingTop;
    lineSke.paddingBottom = paddingBottom;
    lineSke.marginTop = marginTop;
    lineSke.spaceBelowApply = spaceBelowApply;
    lineSke.divides = _calculateDividesByDrawings(lineHeight, lineTop, columnWidth, paddingLeft, paddingRight, affectSkeDrawings, headersDrawings, footersDrawings);
    for (let divide of lineSke.divides) {
      divide.parent = lineSke;
    }
    return lineSke;
  }
  function calculateLineTopByDrawings(lineHeight = 15.6, lineTop = 0, elementIndex = 0, pageSkeDrawings, headersDrawings, footersDrawings) {
    let maxTop = lineTop;
    headersDrawings?.forEach((drawing) => {
      const top = _getLineTopWidthWrapTopBottom(drawing, lineHeight, lineTop);
      if (top) {
        maxTop = Math.max(maxTop, top);
      }
    });
    footersDrawings?.forEach((drawing) => {
      const top = _getLineTopWidthWrapTopBottom(drawing, lineHeight, lineTop);
      if (top) {
        maxTop = Math.max(maxTop, top);
      }
    });
    pageSkeDrawings?.forEach((drawing) => {
      const top = _getLineTopWidthWrapTopBottom(drawing, lineHeight, lineTop, elementIndex);
      if (top) {
        maxTop = Math.max(maxTop, top);
      }
    });
    return maxTop;
  }
  function _getLineTopWidthWrapTopBottom(drawing, lineHeight, lineTop, elementIndex) {
    const { aTop, height, aLeft, width, angle = 0, drawingOrigin } = drawing;
    const { layoutType, distT = 0, distB = 0 } = drawingOrigin;
    if (layoutType !== 6 /* WRAP_TOP_AND_BOTTOM */) {
      return;
    }
    if (angle === 0) {
      const newAtop = aTop - distT;
      const newHeight = height + distB;
      if (newAtop + newHeight < lineTop || newAtop > lineHeight + lineTop) {
        return;
      }
      return newAtop + height;
    }
    let { top: sTop = 0, height: sHeight = 0 } = __getBoundingBox(angle, aLeft, width, aTop, height);
    sTop -= distT;
    sHeight += distB;
    if (sTop + sHeight < lineTop || sTop > lineHeight + lineTop) {
      return;
    }
    return sTop + sHeight;
  }
  function _calculateDividesByDrawings(lineHeight, lineTop, columnWidth, paddingLeft, paddingRight, paragraphAffectSkeDrawings, headersDrawings, footersDrawings) {
    const drawingsMix = [];
    drawingsMix.push(
      {
        left: 0,
        width: paddingLeft
      },
      {
        left: columnWidth - paddingRight,
        width: paddingRight
      }
    );
    headersDrawings?.forEach((drawing, drawingId) => {
      const split = _calculateSplit(drawing, lineHeight, lineTop, columnWidth);
      if (split) {
        drawingsMix.push(split);
      }
    });
    footersDrawings?.forEach((drawing, drawingId) => {
      const split = _calculateSplit(drawing, lineHeight, lineTop, columnWidth);
      if (split) {
        drawingsMix.push(split);
      }
    });
    paragraphAffectSkeDrawings?.forEach((drawing, drawingId) => {
      const split = _calculateSplit(drawing, lineHeight, lineTop, columnWidth);
      if (split) {
        drawingsMix.push(split);
      }
    });
    return _calculateDivideByDrawings(columnWidth, drawingsMix);
  }
  function setDivideFullState(divide, state) {
    divide.isFull = state;
  }
  function _calculateSplit(drawing, lineHeight, lineTop, columnWidth) {
    const { aTop, height, aLeft, width, angle = 0, drawingOrigin } = drawing;
    const { layoutType } = drawingOrigin;
    if (layoutType === 1 /* WRAP_NONE */ || layoutType === 6 /* WRAP_TOP_AND_BOTTOM */) {
      return;
    }
    if (layoutType === 2 /* WRAP_POLYGON */) {
      const { start = [0, 0], lineTo } = drawingOrigin;
      if (!lineTo) {
        return;
      }
      let points = [];
      points.push(new Vector2(start[0], start[1]));
      for (let i4 = 0; i4 < lineTo.length; i4++) {
        const point = lineTo[i4];
        points.push(new Vector2(point[0], point[1]));
      }
      if (angle !== 0) {
        const transform = new Transform().rotate(angle);
        for (let i4 = 0; i4 < points.length; i4++) {
          const point = points[i4];
          points[i4] = transform.applyPoint(point);
        }
      }
      return __getCrossPoint(points, lineTop, lineHeight, columnWidth);
    }
    if (angle === 0) {
      return __getSplitWidthNoAngle(aTop, height, aLeft, width, lineTop, lineHeight, columnWidth, drawingOrigin);
    }
    const boundingBox = __getBoundingBox(angle, aLeft, width, aTop, height);
    if (layoutType === 3 /* WRAP_SQUARE */) {
      const { left: sLeft, width: sWidth, top: sTop, height: sHeight } = boundingBox;
      return __getSplitWidthNoAngle(sTop, sHeight, sLeft, sWidth, lineTop, lineHeight, columnWidth, drawingOrigin);
    }
    return __getCrossPoint(boundingBox.points, lineTop, lineHeight, columnWidth);
  }
  function __getBoundingBox(angle, left, width, top, height) {
    const transform = new Transform().rotate(angle);
    const lt = new Vector2(left, top);
    const lb = new Vector2(left, top + height);
    const rt = new Vector2(left + width, top);
    const rb = new Vector2(left + width, top + height);
    const boundingBox = transform.makeBoundingBoxFromPoints([lt, lb, rt, rb]);
    return boundingBox;
  }
  function __getCrossPoint(points, lineTop, lineHeight, columnWidth) {
    const path = new Path2(points);
    const crossPointTop = path.intersection([new Vector2(0, lineTop), new Vector2(columnWidth, lineTop)]);
    const crossPointBottom = path.intersection([new Vector2(0, lineTop + lineHeight), new Vector2(columnWidth, lineTop + lineHeight)]);
    if (!crossPointTop && !crossPointBottom) {
      return;
    }
    const range2 = ___getMaxAndMinAxis([...points, ...crossPointTop || [], ...crossPointBottom || []]);
    return {
      left: range2.min,
      width: range2.max
    };
  }
  function ___getMaxAndMinAxis(points, axis = 0 /* X */) {
    const result = [];
    for (let i4 = 0; i4 < points.length; i4++) {
      const point = points[i4];
      if (axis === 0 /* X */) {
        result.push(point.x);
      } else {
        result.push(point.y);
      }
    }
    return {
      max: Math.max(...result),
      min: Math.min(...result)
    };
  }
  function __getSplitWidthNoAngle(top, height, left, width, lineTop, lineHeight, columnWidth, drawingOrigin) {
    const { layoutType, wrapText = 0 /* BOTH_SIDES */, distL = 0, distR = 0, distT = 0, distB = 0 } = drawingOrigin;
    const newAtop = top - (layoutType === 3 /* WRAP_SQUARE */ ? distT : 0);
    const newHeight = height + (layoutType === 3 /* WRAP_SQUARE */ ? distB : 0);
    if (newAtop + newHeight < lineTop || newAtop > lineHeight + lineTop) {
      return;
    }
    let resultLeft = left - distL;
    let resultWidth = width + distR;
    let ruler = ___getWrapTextRuler(wrapText, resultLeft, resultWidth, columnWidth);
    if (ruler === 1 /* LEFT */) {
      resultWidth = columnWidth - resultLeft;
    } else if (ruler === 2 /* RIGHT */) {
      resultLeft = 0;
      resultWidth = left + width + distR;
    }
    return {
      left: resultLeft,
      width: resultWidth
    };
  }
  function ___getWrapTextRuler(wrapText, resultLeft, resultWidth, columnWidth) {
    let ruler = 0 /* BOTH */;
    if (wrapText === 1 /* LEFT */) {
      ruler = 1 /* LEFT */;
    } else if (wrapText === 2 /* RIGHT */) {
      ruler = 2 /* RIGHT */;
    } else if (wrapText === 3 /* LARGEST */) {
      if (resultLeft > columnWidth - resultLeft - resultWidth) {
        ruler = 1 /* LEFT */;
      } else {
        ruler = 2 /* RIGHT */;
      }
    }
    return ruler;
  }
  function _calculateDivideByDrawings(columnWidth, drawingSplit) {
    drawingSplit.sort((pre, next) => {
      if (pre.left > next.left) {
        return 1;
      }
      return -1;
    });
    const divideSkeleton = [];
    let start = 0;
    const splitLength = drawingSplit.length;
    for (let i4 = 0; i4 < splitLength; i4++) {
      const split = drawingSplit[i4];
      const { left, width } = split;
      if (left > start) {
        let width2 = left - start;
        width2 = width2 < columnWidth ? width2 : columnWidth - start;
        const divide = __getDivideSKe(start, width2);
        divideSkeleton.push(divide);
      }
      start = Math.max(left + width, start);
      if (i4 === splitLength - 1 && left + width < columnWidth) {
        const divide = __getDivideSKe(left + width, columnWidth - left - width);
        divideSkeleton.push(divide);
      }
    }
    return divideSkeleton;
  }
  function __getDivideSKe(left, width) {
    return {
      // divide 
      spanGroup: [],
      // spanGroup
      width,
      // width 
      left,
      // left  | d1 | | d2 |
      paddingLeft: 0,
      // paddingLeft horizonAlignwidth
      isFull: false,
      // isFull // 
      st: 0,
      // startIndex
      ed: 0
      // endIndex
    };
  }
  function _getLineSke(lineType, blockId) {
    return {
      blockId,
      type: lineType,
      divides: [],
      // /divides N
      lineHeight: 0,
      // lineHeight =max(span.fontBoundingBoxAscent + span.fontBoundingBoxDescent, span2.....) + space
      contentHeight: 0,
      // contentHeight =max(span.fontBoundingBoxAscent + span.fontBoundingBoxDescent, span2.....)
      top: 0,
      // top paragraph(spaceAbove, spaceBelow, lineSpacing*PreLineHeight)
      asc: 0,
      // =max(span.textMetrics.asc) alphaBeta
      paddingTop: 0,
      // paddingTop 
      paddingBottom: 0,
      // paddingBottom 
      marginTop: 0,
      // marginTop spaceAbove
      marginBottom: 0,
      // marginBottom spaceBlow
      spaceBelowApply: 0,
      // lineSpacingApply
      divideLen: 0,
      // divideLen 
      st: -1,
      // startIndex 
      ed: -1,
      // endIndex 
      lineIndex: 0,
      // lineIndex 
      paragraphStart: false
    };
  }
  function isParagraphStart(elementIndex, isFirstSpan) {
    return elementIndex === 0 && isFirstSpan === true;
  }
  function createAndUpdateBlockAnchor(blockId, line, top, blockAnchor) {
    if (!blockAnchor) {
      return;
    }
    if (blockAnchor.has(blockId)) {
      const anchor = blockAnchor.get(blockId);
      anchor?.elements.push(line);
    } else {
      blockAnchor.set(blockId, {
        elements: [line],
        blockId,
        top
      });
    }
  }
  function addSpanToDivide(divide, spanGroup) {
    const line = divide.parent;
    if (line != null) {
      const isFirstLine = line.divides[0].spanGroup[0] == null;
      const firstSpan = spanGroup[0];
      const firstSpanContent = firstSpan.content || " ";
      if (isFirstLine && firstSpanContent === " ") {
        const width = firstSpan.width;
        firstSpan.width = 0;
        for (let span of spanGroup) {
          if (span === firstSpan) {
            continue;
          }
          span.left -= width;
        }
      }
    }
    divide.spanGroup.push(...spanGroup);
  }

  // ../../packages/base-render/src/Component/Docs/Block/Paragraph/Layout.Ruler.ts
  function calculateParagraphLayout(spanGroup, pages, sectionBreakConfig, paragraphConfig, elementIndex = 0, isFirstSpan = false) {
    if (isParagraphStart(elementIndex, isFirstSpan)) {
      if (paragraphConfig.bulletSkeleton) {
        const { bulletSkeleton, paragraphStyle = {} } = paragraphConfig;
        const { gridType = 1 /* LINES */, charSpace = 0, defaultTabStop = 1 } = sectionBreakConfig;
        const { snapToGrid = 1 /* TRUE */ } = paragraphStyle;
        const charSpaceApply = getCharSpaceApply(charSpace, defaultTabStop, gridType, snapToGrid);
        __bulletIndentHandler(paragraphStyle, bulletSkeleton, charSpaceApply);
        const bulletSpan = createSkeletonBulletSpan(spanGroup[0], bulletSkeleton, charSpaceApply);
        _lineOperator([bulletSpan, ...spanGroup], pages, sectionBreakConfig, paragraphConfig, elementIndex, isFirstSpan);
      } else {
        _lineOperator(spanGroup, pages, sectionBreakConfig, paragraphConfig, elementIndex, isFirstSpan);
      }
    } else {
      _divideOperator(spanGroup, pages, sectionBreakConfig, paragraphConfig, elementIndex, isFirstSpan);
    }
    return [...pages];
  }
  function _divideOperator(spanGroup, pages, sectionBreakConfig, paragraphConfig, elementIndex = 0, isFirstSpan = false, defaultSpanLineHeight) {
    const lastPage = getLastPage(pages);
    const divideInfo = getLastNotFullDivideInfo(lastPage);
    if (divideInfo) {
      const width = __getSpanGroupWidth(spanGroup);
      const divide = divideInfo.divide;
      const lastSpan = divide?.spanGroup?.[divide.spanGroup.length - 1];
      const preWidth = lastSpan?.width || 0;
      const preLeft = lastSpan?.left || 0;
      const pageContentWidth = getPageContentWidth(lastPage);
      if (preWidth + preLeft + width > divide.width) {
        setDivideFullState(divide, true);
        const column = getColumnByDivide(divide);
        if (width > pageContentWidth) {
          if (isBlankPage(lastPage)) {
            addSpanToDivide(divide, spanGroup);
            __makeColumnsFull(column?.parent?.columns);
          } else {
            _pageOperator(spanGroup, pages, sectionBreakConfig, paragraphConfig, elementIndex, isFirstSpan, defaultSpanLineHeight);
          }
        } else if (column && width > column.width) {
          setColumnFullState(column, true);
          if (isBlankColumn(column)) {
            console.log(spanGroup);
            addSpanToDivide(divide, spanGroup);
          } else {
            _columnOperator(spanGroup, pages, sectionBreakConfig, paragraphConfig, elementIndex, isFirstSpan, defaultSpanLineHeight);
          }
        } else if (divideInfo.isLast) {
          _lineOperator(spanGroup, pages, sectionBreakConfig, paragraphConfig, elementIndex, isFirstSpan, defaultSpanLineHeight);
        } else {
          _divideOperator(spanGroup, pages, sectionBreakConfig, paragraphConfig, elementIndex, isFirstSpan, defaultSpanLineHeight);
        }
      } else {
        const currentLine = divide.parent;
        const maxBox = __maxFontBoundingBoxBySpanGroup(spanGroup);
        if (currentLine && maxBox) {
          const { paragraphLineGapDefault, linePitch, lineSpacing, spacingRule, snapToGrid, gridType } = getLineHeightConfig(sectionBreakConfig, paragraphConfig);
          const { boundingBoxAscent, boundingBoxDescent } = maxBox;
          const spanLineHeight = boundingBoxAscent + boundingBoxDescent;
          const { contentHeight } = __getLineHeight(spanLineHeight, paragraphLineGapDefault, linePitch, gridType, lineSpacing, spacingRule, snapToGrid);
          if (currentLine.contentHeight < contentHeight) {
            const spanGroupCached = __getSpanGroupByLine(currentLine);
            const spanGroupCachedLen = spanGroupCached.length;
            let newSpanGroup = [];
            let startIndex = 1;
            if (spanGroupCached[0].spanType === 2 /* LIST */ && spanGroupCachedLen > 2) {
              newSpanGroup = [spanGroupCached[0], spanGroupCached[1]];
              startIndex = 2;
            } else {
              newSpanGroup = [spanGroupCached[0]];
            }
            const column = currentLine.parent;
            column?.lines.pop();
            _lineOperator(newSpanGroup, pages, sectionBreakConfig, paragraphConfig, elementIndex, isFirstSpan, boundingBoxAscent + boundingBoxDescent);
            for (let i4 = startIndex; i4 < spanGroupCached.length; i4++) {
              _divideOperator([spanGroupCached[i4]], pages, sectionBreakConfig, paragraphConfig, elementIndex, isFirstSpan);
            }
            _divideOperator(spanGroup, pages, sectionBreakConfig, paragraphConfig, elementIndex, isFirstSpan);
            return;
          }
        }
        setSpanGroupLeft(spanGroup, preWidth + preLeft);
        for (let span of spanGroup) {
          span.parent = divide;
        }
        addSpanToDivide(divide, spanGroup);
      }
    } else {
      _lineOperator(spanGroup, pages, sectionBreakConfig, paragraphConfig, elementIndex, isFirstSpan, defaultSpanLineHeight);
    }
  }
  function _lineOperator(spanGroup, pages, sectionBreakConfig, paragraphConfig, elementIndex = 0, isFirstSpan = false, defaultSpanLineHeight) {
    let lastPage = getLastPage(pages);
    let columnInfo = getLastNotFullColumnInfo(lastPage);
    if (!columnInfo || !columnInfo.column) {
      _pageOperator(spanGroup, pages, sectionBreakConfig, paragraphConfig, elementIndex);
      lastPage = getLastPage(pages);
      columnInfo = getLastNotFullColumnInfo(lastPage);
    }
    if (!columnInfo)
      return;
    const column = columnInfo.column;
    const line = getLastLineByColumn(column);
    const { ba: ascent, bd: descent } = spanGroup[0].bBox;
    const spanLineHeight = defaultSpanLineHeight || ascent + descent;
    const { paragraphStyle = {}, paragraphAffectSkeDrawings, skeHeaders, skeFooters, blockAnchor, blockId } = paragraphConfig;
    const {
      namedStyleType = 0 /* NAMED_STYLE_TYPE_UNSPECIFIED */,
      horizontalAlign = 0 /* UNSPECIFIED */,
      direction,
      spaceAbove = 0,
      spaceBelow = 0,
      borderBetween,
      borderTop,
      borderBottom,
      borderLeft,
      borderRight,
      indentFirstLine = 0,
      hanging = 0,
      indentStart = 0,
      indentEnd = 0,
      tabStops = [],
      keepLines = 0 /* FALSE */,
      keepNext = 0 /* FALSE */,
      wordWrap = 0 /* FALSE */,
      widowControl = 0 /* FALSE */,
      shading
    } = paragraphStyle;
    const { paragraphLineGapDefault, linePitch, lineSpacing, spacingRule, snapToGrid, gridType } = getLineHeightConfig(sectionBreakConfig, paragraphConfig);
    const paragraphStart = isParagraphStart(elementIndex, isFirstSpan);
    const { paddingTop, paddingBottom, contentHeight, lineSpacingApply } = __getLineHeight(
      spanLineHeight,
      paragraphLineGapDefault,
      linePitch,
      gridType,
      lineSpacing,
      spacingRule,
      snapToGrid
    );
    const { marginTop, spaceBelowApply } = __getParagraphSpace(lineSpacingApply, spaceAbove, spaceBelow, paragraphStart, line);
    const lineHeight = marginTop + paddingTop + contentHeight + paddingBottom;
    let section = column.parent;
    if (!section) {
      section = getLastSection(lastPage);
    }
    const preLineHeight = line?.lineHeight || 0;
    const preTop = line?.top || 0;
    const lineTop = preLineHeight + preTop;
    const { width, headerId, footerId } = lastPage;
    const headersDrawings = skeHeaders?.get(headerId)?.get(width)?.skeDrawings;
    const footersDrawings = skeFooters?.get(footerId)?.get(width)?.skeDrawings;
    __updateDrawingPosition(lineTop, lineHeight, column, blockAnchor?.get(blockId)?.top, paragraphAffectSkeDrawings);
    const newLineTop = calculateLineTopByDrawings(lineHeight, lineTop, elementIndex, lastPage.skeDrawings, headersDrawings, footersDrawings);
    if (lineHeight + newLineTop > section.height && column.lines.length > 0 && lastPage.sections.length > 0) {
      setColumnFullState(column, true);
      _columnOperator(spanGroup, pages, sectionBreakConfig, paragraphConfig, elementIndex, isFirstSpan, defaultSpanLineHeight);
      return;
    }
    const lineIndex = line ? line.lineIndex + 1 : 0;
    const { charSpace, defaultTabStop } = getCharSpaceConfig(sectionBreakConfig, paragraphConfig);
    const charSpaceApply = getCharSpaceApply(charSpace, defaultTabStop, gridType, snapToGrid);
    const { paddingLeft, paddingRight, changeBulletWidth } = __getIndentPadding(spanGroup[0], indentFirstLine, hanging, indentStart, indentEnd, charSpaceApply);
    if (changeBulletWidth.state) {
      spanGroup[0].width = changeBulletWidth.hangingNumber;
    }
    const newLine = createSkeletonLine(
      blockId,
      0 /* PARAGRAPH */,
      {
        lineHeight,
        contentHeight,
        lineTop: newLineTop,
        paddingLeft,
        paddingRight,
        paddingTop,
        paddingBottom,
        marginTop,
        spaceBelowApply
      },
      column.width,
      lineIndex,
      elementIndex,
      isFirstSpan,
      lastPage.skeDrawings,
      headersDrawings,
      footersDrawings
    );
    column.lines.push(newLine);
    newLine.parent = column;
    createAndUpdateBlockAnchor(blockId, newLine, lineTop, blockAnchor);
    _divideOperator(spanGroup, pages, sectionBreakConfig, paragraphConfig, elementIndex, isFirstSpan, defaultSpanLineHeight);
  }
  function _columnOperator(spanGroup, pages, sectionBreakConfig, paragraphConfig, elementIndex = 0, isFirstSpan = false, defaultSpanLineHeight) {
    const lastPage = getLastPage(pages);
    const column = isColumnFull(lastPage);
    if (column === true) {
      _pageOperator(spanGroup, pages, sectionBreakConfig, paragraphConfig, elementIndex, isFirstSpan, defaultSpanLineHeight);
    } else {
      _lineOperator(spanGroup, pages, sectionBreakConfig, paragraphConfig, elementIndex, isFirstSpan, defaultSpanLineHeight);
    }
  }
  function _pageOperator(spanGroup, pages, sectionBreakConfig, paragraphConfig, elementIndex = 0, isFirstSpan = false, defaultSpanLineHeight) {
    const curSkeletonPage = getLastPage(pages);
    const { skeHeaders, skeFooters } = paragraphConfig;
    pages.push(createSkeletonPage(sectionBreakConfig, { skeHeaders, skeFooters }, curSkeletonPage?.pageNumber));
    _columnOperator(spanGroup, pages, sectionBreakConfig, paragraphConfig, elementIndex, isFirstSpan, defaultSpanLineHeight);
  }
  function __getIndentPadding(span, indentFirstLine = 0, hanging = 0, indentStart = 0, indentEnd = 0, charSpaceApply) {
    const { spanType = 0 /* LETTER */, bBox } = span;
    let indentFirstLineNumber = getNumberUnitValue(indentFirstLine, charSpaceApply);
    let hangingNumber = getNumberUnitValue(hanging, charSpaceApply);
    let indentStartNumber = getNumberUnitValue(indentStart, charSpaceApply);
    let indentEndNumber = getNumberUnitValue(indentEnd, charSpaceApply);
    let paddingLeft = indentStartNumber;
    let paddingRight = indentEndNumber;
    let changeBulletWidth = {
      state: false,
      hangingNumber: 0
    };
    if (spanType === 2 /* LIST */) {
      const { width: fontWidth } = bBox;
      if (indentFirstLineNumber > 0) {
        paddingLeft += indentFirstLineNumber;
      } else if (hangingNumber > 0 && hangingNumber > fontWidth) {
        changeBulletWidth.state = true;
        changeBulletWidth.hangingNumber = hangingNumber;
      }
    } else {
      paddingLeft += hangingNumber;
    }
    return {
      paddingLeft,
      paddingRight,
      changeBulletWidth
    };
  }
  function __getParagraphSpace(lineSpacing = 0, spaceAbove = 0, spaceBelow = 0, paragraphStart, preLine) {
    let marginTop = 0;
    let spaceBelowApply = 0;
    if (!paragraphStart) {
      return {
        marginTop,
        spaceBelowApply
      };
    }
    marginTop = getNumberUnitValue(spaceAbove, lineSpacing);
    spaceBelowApply = getNumberUnitValue(spaceBelow, lineSpacing);
    if (preLine) {
      const { spaceBelowApply: PreSpaceBelowApply } = preLine;
      if (PreSpaceBelowApply > marginTop) {
        marginTop = 0;
        preLine.lineHeight += PreSpaceBelowApply;
        preLine.marginBottom = PreSpaceBelowApply;
      }
    }
    return {
      marginTop,
      spaceBelowApply
    };
  }
  function __makeColumnsFull(columns = []) {
    for (let i4 = 0; i4 < columns.length; i4++) {
      const column = columns[i4];
      setColumnFullState(column, true);
    }
  }
  function __getLineHeight(spanLineHeight, paragraphLineGapDefault, linePitch, gridType, lineSpacing, spacingRule, snapToGrid) {
    let paddingTop = paragraphLineGapDefault;
    let paddingBottom = paragraphLineGapDefault;
    if (gridType === 0 /* DEFAULT */ || snapToGrid === 0 /* FALSE */) {
      if (spacingRule === 0 /* AUTO */) {
        return {
          paddingTop,
          paddingBottom,
          contentHeight: lineSpacing * spanLineHeight,
          lineSpacingApply: spanLineHeight
        };
      }
      return {
        paddingTop,
        paddingBottom,
        contentHeight: Math.max(lineSpacing, spanLineHeight),
        lineSpacingApply: lineSpacing
      };
    }
    let lineSpacingApply = 0;
    if (spacingRule === 0 /* AUTO */) {
      lineSpacingApply = lineSpacing * linePitch;
    } else {
      lineSpacingApply = lineSpacing;
    }
    if (spanLineHeight + paragraphLineGapDefault * 2 < lineSpacingApply) {
      paddingTop = paddingBottom = (lineSpacingApply - spanLineHeight) / 2;
    }
    return {
      paddingTop,
      paddingBottom,
      contentHeight: spanLineHeight,
      lineSpacingApply
    };
  }
  function __updateDrawingPosition(lineTop, lineHeight, column, blockAnchorTop, paragraphAffectSkeDrawings) {
    if (!paragraphAffectSkeDrawings) {
      return;
    }
    const page = column.parent?.parent;
    if (!page) {
      return;
    }
    const drawings = /* @__PURE__ */ new Map();
    const isPageBreak = __checkPageBreak(column);
    paragraphAffectSkeDrawings.forEach((drawing) => {
      if (!drawing) {
        return;
      }
      const { initialState, drawingOrigin } = drawing;
      if (initialState || !drawingOrigin) {
        return;
      }
      const { objectProperties } = drawingOrigin;
      const { positionH, positionV, size, angle } = objectProperties;
      const { width = 0, height = 0 } = size;
      drawing.aLeft = getPositionHorizon(positionH, column, page, width, isPageBreak) || 0;
      drawing.aTop = getPositionVertical(positionV, page, lineTop, lineHeight, height, blockAnchorTop, isPageBreak) || 0;
      drawing.width = width;
      drawing.height = height;
      drawing.angle = angle;
      drawing.initialState = true;
      drawings.set(drawing.objectId, drawing);
    });
    page.skeDrawings = new Map([...page.skeDrawings, ...drawings]);
  }
  function __checkPageBreak(column) {
    const section = column.parent;
    if (!section) {
      return false;
    }
    const columns = section?.columns;
    if (!columns) {
      return false;
    }
    const columnLength = columns.length;
    for (let c4 = columnLength - 1; c4 >= 0; c4--) {
      const curColumn = columns[c4];
      const lines = curColumn.lines;
      const lineLength = lines.length;
      if (lineLength <= 0) {
        continue;
      }
      for (let i4 = lineLength - 1; i4 >= 0; i4--) {
        const line = lines[i4];
        if (line.paragraphStart) {
          return false;
        }
      }
    }
    return true;
  }
  function __getSpanGroupWidth(spanGroup) {
    const spanGroupLen = spanGroup.length;
    let width = 0;
    for (let i4 = 0; i4 < spanGroupLen; i4++) {
      const span = spanGroup[i4];
      width += span.width;
    }
    return width;
  }
  function __maxFontBoundingBoxBySpanGroup(spanGroup) {
    const spanGroupLen = spanGroup.length;
    let height = -Infinity;
    let maxBox;
    for (let i4 = 0; i4 < spanGroupLen; i4++) {
      const span = spanGroup[i4];
      const { ba: boundingBoxAscent, bd: boundingBoxDescent } = span.bBox;
      if (height < boundingBoxAscent + boundingBoxDescent) {
        maxBox = { boundingBoxAscent, boundingBoxDescent };
      }
      height = boundingBoxAscent + boundingBoxDescent;
    }
    return maxBox;
  }
  function __getSpanGroupByLine(line) {
    const divides = line.divides;
    const dividesLen = divides.length;
    const spanGroup = [];
    for (let i4 = 0; i4 < dividesLen; i4++) {
      const divide = divides[i4];
      spanGroup.push(...divide.spanGroup);
    }
    return spanGroup;
  }
  function __bulletIndentHandler(paragraphStyle, bulletSkeleton, charSpaceApply) {
    const { hanging, indentStart } = paragraphStyle;
    const { hanging: hangingBullet, indentStart: indentStartBullet } = bulletSkeleton;
    if (hanging === void 0) {
      paragraphStyle.hanging = hangingBullet;
    }
    if (indentStart === void 0) {
      paragraphStyle.indentStart = getNumberUnitValue(indentStartBullet || 0, charSpaceApply) - getNumberUnitValue(hangingBullet || 0, charSpaceApply);
    }
  }

  // ../../packages/base-render/src/Component/Docs/Block/Paragraph/TextRun.ts
  function dealWidthTextRun(textRun, elementIndex = 0, sectionBreakConfig, currentPage, paragraphConfig, fontLocale) {
    const { ct: content = "", ts: textStyle = {}, tab = false } = textRun;
    const fontStyle = getFontStyleString(textStyle, fontLocale);
    const { paragraphStyle = {} } = paragraphConfig;
    const {
      gridType = 1 /* LINES */,
      charSpace = 0,
      documentTextStyle = {},
      defaultTabStop = 10.5,
      pageSize = {
        width: Infinity,
        height: Infinity
      },
      marginLeft = 0,
      marginRight = 0
    } = sectionBreakConfig;
    const {
      namedStyleType = 0 /* NAMED_STYLE_TYPE_UNSPECIFIED */,
      horizontalAlign = 0 /* UNSPECIFIED */,
      lineSpacing = 1,
      spacingRule = 0 /* AUTO */,
      snapToGrid = 1 /* TRUE */,
      direction,
      spaceAbove = 0,
      spaceBelow = 0,
      borderBetween,
      borderTop,
      borderBottom,
      borderLeft,
      borderRight,
      indentFirstLine = 0,
      hanging = 0,
      indentStart = 0,
      indentEnd = 0,
      tabStops = [],
      keepLines = 0 /* FALSE */,
      keepNext = 0 /* FALSE */,
      wordWrap = 0 /* FALSE */,
      widowControl = 0 /* FALSE */,
      shading
    } = paragraphStyle;
    let allPages = [currentPage];
    const pageWidth = pageSize.width || Infinity - marginLeft - marginRight;
    const mixTextStyle = {
      ...documentTextStyle,
      ...textStyle
    };
    const fontCreateConfig = {
      fontStyle,
      textStyle: mixTextStyle,
      charSpace,
      gridType,
      snapToGrid,
      pageWidth
    };
    if (tab) {
      const charSpaceApply = getCharSpaceApply(charSpace, defaultTabStop, gridType, snapToGrid);
      const tabSpan = createSkeletonTabSpan(fontCreateConfig, charSpaceApply);
      allPages = calculateParagraphLayout([tabSpan], allPages, sectionBreakConfig, paragraphConfig, elementIndex, true);
      return allPages;
    }
    const arrayText = content.split("");
    for (let charIndex = 0; charIndex < arrayText.length; charIndex++) {
      const char = arrayText[charIndex];
      const isFirstSpan = charIndex === 0;
      const languageHandlerResult = composeCharForLanguage(char, charIndex, arrayText, fontCreateConfig);
      let newSpanGroup = [];
      if (languageHandlerResult) {
        const { charIndex: newCharIndex, spanGroup } = languageHandlerResult;
        charIndex = newCharIndex;
        newSpanGroup = spanGroup;
      } else {
        const span = createSkeletonWordSpan(char, fontCreateConfig);
        newSpanGroup.push(span);
      }
      allPages = calculateParagraphLayout(newSpanGroup, allPages, sectionBreakConfig, paragraphConfig, elementIndex, isFirstSpan);
    }
    lineIterator(allPages, (line) => {
      horizontalAlignHandler(line, horizontalAlign);
    });
    return allPages;
  }
  function horizontalAlignHandler(line, horizontalAlign) {
    if (horizontalAlign === 0 /* UNSPECIFIED */ || horizontalAlign === 1 /* LEFT */) {
      return;
    }
    const { divides } = line;
    const divideLength = divides.length;
    for (let i4 = 0; i4 < divideLength; i4++) {
      const divide = divides[i4];
      const { width, spanGroup } = divide;
      const spanGroupWidth = getSpanGroupWidth(divide);
      if (width === Infinity) {
        continue;
      }
      if (horizontalAlign === 2 /* CENTER */) {
        divide.paddingLeft = (width - spanGroupWidth) / 2;
      } else if (horizontalAlign === 3 /* RIGHT */) {
        divide.paddingLeft = width - spanGroupWidth;
      } else if (horizontalAlign === 4 /* JUSTIFIED */) {
      }
    }
  }

  // ../../packages/base-render/src/Component/Docs/Block/Paragraph/Paragraph.ts
  function dealWidthParagraph(blockId, paragraph, curPage, sectionBreakConfig, skeletonResourceReference, context) {
    const {
      pageNumberStart,
      pageSize = {
        w: Infinity,
        h: Infinity
      },
      marginRight = 0,
      marginLeft = 0,
      columnProperties = [],
      columnSeparatorType = 1 /* NONE */,
      contentDirection,
      sectionType,
      sectionTypeNext,
      textDirection,
      lists,
      drawings = {},
      fontLocale
    } = sectionBreakConfig;
    const { elements, paragraphStyle = {}, bullet } = paragraph;
    const { skeHeaders, skeFooters, skeListLevel, blockAnchor } = skeletonResourceReference;
    const paragraphConfig = {
      blockId,
      paragraphStyle,
      // paragraphAffectSkeDrawings,
      skeHeaders,
      skeFooters,
      blockAnchor
    };
    const pages = [curPage];
    let lastPage = curPage;
    const paragraphAffectSkeDrawings = /* @__PURE__ */ new Map();
    const listLevelAncestors = _getListLevelAncestors(bullet, skeListLevel);
    const bulletSkeleton = dealWidthBullet(bullet, lists, listLevelAncestors, fontLocale, context);
    _updateListLevelAncestors(bullet, bulletSkeleton, skeListLevel);
    paragraphConfig.bulletSkeleton = bulletSkeleton;
    elements.forEach((element, elementIndex) => {
      const { eId: elementId, et: paragraphElementType } = element;
      let currentPages = [];
      if (paragraphElementType === 7 /* DRAWING */) {
        const drawingOrigin = drawings[elementId];
        if (drawingOrigin.layoutType === 0 /* INLINE */) {
          currentPages = dealWidthInlineDrawing(drawingOrigin, elementIndex, sectionBreakConfig, lastPage, paragraphConfig, fontLocale);
        } else {
          paragraphAffectSkeDrawings.set(elementId, _getDrawingSkeletonFormat(drawingOrigin));
        }
      }
    });
    elements.forEach((element, elementIndex) => {
      const { eId: elementId, et: paragraphElementType } = element;
      let currentPages = [];
      if (paragraphElementType === 0 /* TEXT_RUN */) {
        const { tr: textRun, st, ed } = element;
        if (!textRun) {
          return false;
        }
        currentPages = dealWidthTextRun(textRun, elementIndex, sectionBreakConfig, lastPage, { ...paragraphConfig, paragraphAffectSkeDrawings }, fontLocale);
      } else if (paragraphElementType === 2 /* PAGE_BREAK */) {
        currentPages = [createSkeletonPage(sectionBreakConfig, skeletonResourceReference, _getNextPageNumber(lastPage), 1 /* PAGE */)];
        paragraphAffectSkeDrawings.clear();
      } else if (paragraphElementType === 3 /* COLUMN_BREAK */) {
        const columnInfo = getLastNotFullColumnInfo(lastPage);
        if (columnInfo && !columnInfo.isLast) {
          setColumnFullState(columnInfo.column, true);
        } else {
          currentPages = [createSkeletonPage(sectionBreakConfig, skeletonResourceReference, _getNextPageNumber(lastPage), 2 /* COLUMN */)];
        }
      }
      lastPage = _checkAndPush(pages, currentPages);
    });
    return pages;
  }
  function _getListLevelAncestors(bullet, listLevel) {
    if (!bullet || !listLevel) {
      return;
    }
    const { listId, nestingLevel } = bullet;
    const sameList = listLevel?.get(listId);
    let level = nestingLevel;
    if (level < 0) {
      level = 0;
    }
    const listLevelAncestors = [];
    for (let i4 = level; i4 >= 0; i4--) {
      const bs = sameList?.[i4];
      listLevelAncestors[i4] = bs || null;
    }
    return listLevelAncestors;
  }
  function _updateListLevelAncestors(bullet, bulletSkeleton, listLevel) {
    if (!bullet || !bulletSkeleton) {
      return;
    }
    const { listId, nestingLevel } = bullet;
    const cacheItem = [...listLevel?.get(listId) || []];
    cacheItem[nestingLevel] = bulletSkeleton;
    cacheItem.splice(nestingLevel + 1);
    listLevel?.set(listId, cacheItem);
  }
  function _getDrawingSkeletonFormat(drawingOrigin) {
    const objectId = drawingOrigin.objectId;
    return {
      objectId,
      aLeft: 0,
      aTop: 0,
      width: 0,
      height: 0,
      angle: 0,
      initialState: false,
      drawingOrigin
    };
  }
  function _checkAndPush(pages, currentPages) {
    const curLast = pages.slice(-1)[0];
    const newFirst = currentPages[0];
    if (curLast === newFirst) {
      if (currentPages.length === 1) {
        return curLast;
      }
      currentPages.shift();
    }
    pages.push(...currentPages);
    return pages.slice(-1)[0];
  }
  function _getNextPageNumber(lastPage) {
    return lastPage.pageNumber + 1;
  }

  // ../../packages/base-render/src/Component/Docs/Block/BlockError.ts
  function dealWithBlockError() {
    return [];
  }

  // ../../packages/base-render/src/Component/Docs/Block/Block.ts
  function dealWithBlocks(Blocks, curPage, sectionBreakConfig, skeletonResourceReference, preRenderedBlockIdMap, context) {
    const allCurrentSkeletonPages = [];
    const renderedBlockIdMap = /* @__PURE__ */ new Map();
    for (let block of Blocks) {
      const { paragraph, table, tableOfContents, blockType, customBlock, blockId } = block;
      if (preRenderedBlockIdMap?.get(blockId)) {
        continue;
      }
      let blockSkeletonPages = [];
      let currentPageCache = curPage;
      if (allCurrentSkeletonPages.length > 0) {
        currentPageCache = allCurrentSkeletonPages[allCurrentSkeletonPages.length - 1];
      }
      if (blockType === 0 /* PARAGRAPH */ && paragraph) {
        blockSkeletonPages = dealWidthParagraph(block.blockId, paragraph, currentPageCache, sectionBreakConfig, skeletonResourceReference, context);
      } else if (blockType === 1 /* TABLE */ && table) {
      } else if (blockType === 2 /* SECTION_BREAK */ && tableOfContents) {
      } else if (blockType === 3 /* CUSTOM */) {
        blockSkeletonPages = dealWidthCustomBlock(block.blockId, customBlock, currentPageCache, sectionBreakConfig, skeletonResourceReference, context);
      }
      if (blockSkeletonPages.length === 0) {
        blockSkeletonPages = dealWithBlockError();
      }
      _pushPage(allCurrentSkeletonPages, blockSkeletonPages);
      renderedBlockIdMap.set(blockId, true);
    }
    return {
      pages: allCurrentSkeletonPages,
      renderedBlockIdMap
    };
  }
  function _pushPage(allCurrentSkeletonPages, blockSkeletonPages) {
    const lastIndex = allCurrentSkeletonPages.length - 1;
    const lastOldPage = allCurrentSkeletonPages[lastIndex];
    const firstNewPage = blockSkeletonPages[0];
    if (lastOldPage === firstNewPage) {
      blockSkeletonPages.splice(0, 1);
    }
    allCurrentSkeletonPages.push(...blockSkeletonPages);
  }

  // ../../packages/base-render/src/Component/Docs/Common/Page.ts
  function createSkeletonPage(sectionBreakConfig, skeletonResourceReference, pageNumber = 1, breakType = 0 /* SECTION */) {
    const page = _getNullPage();
    const {
      pageNumberStart = 1,
      pageSize = { width: Infinity, height: Infinity },
      pageOrient = 0 /* PORTRAIT */,
      headerIds = {},
      footerIds = {},
      useFirstPageHeaderFooter,
      useEvenPageHeaderFooter,
      footers,
      headers,
      columnProperties = [],
      columnSeparatorType,
      marginTop = 0,
      marginBottom = 0,
      marginHeader = 0,
      marginFooter = 0,
      marginLeft = 0,
      marginRight = 0,
      renderConfig = {}
    } = sectionBreakConfig;
    const { skeHeaders, skeFooters } = skeletonResourceReference;
    const { width: pageWidth = Infinity, height: pageHeight = Infinity } = pageSize;
    page.pageNumber = pageNumber;
    page.pageNumberStart = pageNumberStart;
    page.renderConfig = renderConfig;
    page.marginLeft = marginLeft;
    page.marginRight = marginRight;
    page.breakType = breakType;
    page.width = page.pageWidth = pageWidth;
    page.height = page.pageHeight = pageHeight;
    page.pageOrient = pageOrient;
    const { defaultHeaderId, evenPageHeaderId, firstPageHeaderId } = headerIds;
    const { defaultFooterId, evenPageFooterId, firstPageFooterId } = footerIds;
    let headerId = defaultHeaderId ?? "";
    let footerId = defaultFooterId ?? "";
    if (pageNumber === pageNumberStart && useFirstPageHeaderFooter) {
      headerId = firstPageHeaderId ?? "";
      footerId = firstPageFooterId ?? "";
    } else if (pageNumber % 2 === 0 && useEvenPageHeaderFooter) {
      headerId = evenPageHeaderId ?? "";
      footerId = evenPageFooterId ?? "";
    }
    let header;
    let footer;
    if (headerId) {
      if (skeHeaders.get(headerId)?.has(pageWidth)) {
        header = skeHeaders.get(headerId)?.get(pageWidth);
      } else if (headers) {
        header = _createSkeletonHeader(headers[headerId], sectionBreakConfig, skeletonResourceReference);
        skeHeaders.set(headerId, /* @__PURE__ */ new Map([[pageWidth, header]]));
      }
      page.headerId = headerId;
    }
    if (footerId) {
      if (skeFooters.get(footerId)?.has(pageWidth)) {
        footer = skeFooters.get(footerId)?.get(pageWidth);
      } else if (footers) {
        footer = _createSkeletonHeader(footers[footerId], sectionBreakConfig, skeletonResourceReference);
        skeFooters.set(headerId, /* @__PURE__ */ new Map([[pageWidth, footer]]));
      }
      page.footerId = footerId;
    }
    page.marginTop = _getVerticalMargin(marginTop, marginHeader, header);
    page.marginBottom = _getVerticalMargin(marginBottom, marginFooter, footer);
    const sections = page.sections;
    const lastSection = sections[sections.length - 1];
    const { marginTop: curPageMT, marginBottom: curPageMB, marginLeft: curPageML, marginRight: curPageMR } = page;
    const pageContentWidth = pageWidth - curPageML - curPageMR;
    const pageContentHeight = pageHeight - curPageMT - curPageMB;
    let lastSectionBottom = 0;
    if (lastSection) {
      lastSectionBottom = lastSection.top + lastSection.height;
    }
    const newSection = createSkeletonSection(columnProperties, columnSeparatorType, lastSectionBottom, 0, pageContentWidth, pageContentHeight - lastSectionBottom);
    newSection.parent = page;
    sections.push(newSection);
    return page;
  }
  function _getNullPage() {
    return {
      sections: [],
      headerId: "",
      footerId: "",
      // page
      pageWidth: 0,
      pageHeight: 0,
      pageOrient: 0 /* PORTRAIT */,
      pageNumber: 1,
      pageNumberStart: 1,
      verticalAlign: false,
      angle: 0,
      width: 0,
      height: 0,
      marginLeft: 0,
      marginRight: 0,
      marginTop: 0,
      marginBottom: 0,
      breakType: 0 /* SECTION */,
      st: 0,
      ed: 0,
      skeDrawings: /* @__PURE__ */ new Map()
    };
  }
  function _createSkeletonHeader(headerOrFooter, sectionBreakConfig, skeletonResourceReference, isHeader = true) {
    const { body: headerOrFooterBody } = headerOrFooter;
    const {
      lists,
      headers,
      footers,
      fontLocale,
      pageSize,
      marginLeft = 0,
      marginRight = 0,
      drawings,
      marginTop = 0,
      marginBottom = 0,
      marginHeader = 0,
      marginFooter = 0
    } = sectionBreakConfig;
    const pageWidth = pageSize?.width || Infinity;
    const headerConfig = {
      lists,
      headers,
      footers,
      pageSize: {
        width: pageWidth - marginLeft - marginRight,
        height: Infinity
      },
      fontLocale,
      drawings
    };
    const { blockElements } = headerOrFooterBody;
    const blockElementArray = [];
    blockElements.forEach((dcd) => {
      blockElementArray.push(dcd);
    });
    const areaPage = createSkeletonPage(headerConfig, skeletonResourceReference);
    const page = dealWithBlocks(blockElementArray, areaPage, headerConfig, skeletonResourceReference).pages[0];
    updateBlockIndex([page]);
    const column = page.sections[0].columns[0];
    const height = column.height || 0;
    const { skeDrawings, st, ed } = page;
    const headerOrFooterSke = {
      lines: column.lines,
      skeDrawings,
      height,
      st,
      ed,
      marginLeft,
      marginRight
    };
    if (isHeader) {
      return {
        ...headerOrFooterSke,
        marginTop: __getHeaderMarginTop(marginTop, marginHeader, height)
      };
    }
    return {
      ...headerOrFooterSke,
      marginBottom: __getHeaderMarginBottom(marginBottom, marginFooter, height)
    };
  }
  function _getVerticalMargin(marginTB, marginHF, headerOrFooter) {
    if (!headerOrFooter || headerOrFooter.lines.length === 0) {
      return marginTB;
    }
    return Math.max(marginTB, marginHF, headerOrFooter?.height || 0);
  }
  function __getHeaderMarginTop(marginTop, marginHeader, height) {
    const maxMargin = Math.max(marginTop, marginHeader);
    if (height > maxMargin) {
      return 0;
    }
    return maxMargin - height;
  }
  function __getHeaderMarginBottom(marginBottom, marginFooter, height) {
    const maxMargin = Math.max(marginBottom, marginFooter);
    if (height > maxMargin) {
      return 0;
    }
    return maxMargin - height;
  }

  // ../../packages/base-render/src/Component/Skeleton.ts
  var Skeleton = class {
    _context;
    _fontLocale;
    _dirty = true;
    constructor(context) {
      this._context = context;
      this._localeInitial();
    }
    get dirty() {
      return this._dirty;
    }
    getFontLocale() {
      return this._fontLocale;
    }
    getContext() {
      return this._context;
    }
    makeDirty(state) {
      this._dirty = state;
    }
    _localeInitial() {
      if (!this._context) {
        return;
      }
      const locale = this._context.getUniver().getGlobalContext().getLocale();
      const renderFont = locale.getObject("renderFont");
      if (!renderFont) {
        locale.load({
          en: en_default,
          zh: zh_default
        });
      }
      this._fontLocale = renderFont;
    }
  };

  // ../../packages/base-render/src/Component/Docs/DocSkeleton.ts
  var DocumentSkeleton = class extends Skeleton {
    onRecalculateChangeObservable = new Observable();
    _documentData;
    _skeletonData;
    _renderedBlockIdMap = /* @__PURE__ */ new Map();
    constructor(documentData, context) {
      super(context);
      this._documentData = documentData;
    }
    static create(documentData, context) {
      return new DocumentSkeleton(documentData, context);
    }
    updateDrawing(id, config) {
      const drawings = this._documentData.drawings;
      if (!drawings) {
        return;
      }
      const drawing = drawings[id];
      if (!drawing) {
        return;
      }
      const objectProperties = drawing.objectProperties;
      objectProperties.size.width = config.width;
      objectProperties.size.height = config.height;
      objectProperties.positionH.posOffset = config.left;
      objectProperties.positionV.posOffset = config.top;
    }
    calculate(bounds) {
      if (!this.dirty) {
        return;
      }
      this._skeletonData = this._createSkeleton(bounds);
      this.onRecalculateChangeObservable.notifyObservers(this._skeletonData);
    }
    getSkeletonData() {
      return this._skeletonData;
    }
    getPageSize() {
      return this._documentData.documentStyle.pageSize;
    }
    updateDocumentDataPageSize(width, height) {
      const documentStyle = this._documentData.documentStyle;
      if (!documentStyle.pageSize) {
        width = width ?? Infinity;
        height = height ?? Infinity;
        documentStyle.pageSize = {
          width,
          height
        };
        return;
      }
      if (width !== void 0) {
        documentStyle.pageSize.width = width;
      }
      if (height !== void 0) {
        documentStyle.pageSize.height = height;
      }
    }
    __getContentMapArr() {
      const { body } = this._documentData;
      if (!body) {
        return [];
      }
      const { blockElements } = body;
      if (blockElements.length === 0) {
        return [];
      }
      const documentContentMapArr = [];
      let documentContentMap = {
        blockElements: [],
        sectionBreak: void 0
      };
      blockElements.forEach((dcd) => {
        const { sectionBreak: sSectionBreak } = dcd;
        if (sSectionBreak) {
          documentContentMap.sectionBreak = sSectionBreak;
          documentContentMapArr.push(documentContentMap);
          documentContentMap = {
            blockElements: [],
            sectionBreak: void 0
          };
        } else {
          documentContentMap.blockElements.push(dcd);
        }
      });
      if (!documentContentMap.sectionBreak) {
        documentContentMap.sectionBreak = {
          columnProperties: [],
          columnSeparatorType: 1 /* NONE */,
          sectionType: 0 /* SECTION_TYPE_UNSPECIFIED */
        };
        if (documentContentMap.blockElements.length > 0) {
          documentContentMapArr.push(documentContentMap);
        }
      }
      return documentContentMapArr;
    }
    _createSkeleton(bounds) {
      const documentContentMapArr = this.__getContentMapArr();
      const DEFAULT_PAGE_SIZE = { width: Infinity, height: Infinity };
      const { documentStyle, footers, headers, lists, drawings } = this._documentData;
      const {
        pageNumberStart: global_pageNumberStart = 1,
        // pageNumberStart
        pageSize: global_pageSize = DEFAULT_PAGE_SIZE,
        pageOrient: global_pageOrient = 0 /* PORTRAIT */,
        defaultHeaderId: global_defaultHeaderId,
        defaultFooterId: global_defaultFooterId,
        evenPageHeaderId: global_evenPageHeaderId,
        evenPageFooterId: global_evenPageFooterId,
        firstPageHeaderId: global_firstPageHeaderId,
        firstPageFooterId: global_firstPageFooterId,
        useFirstPageHeaderFooter: global_useFirstPageHeaderFooter,
        useEvenPageHeaderFooter: global_useEvenPageHeaderFooter,
        marginTop: global_marginTop = 0,
        marginBottom: global_marginBottom = 0,
        marginRight: global_marginRight = 0,
        marginLeft: global_marginLeft = 0,
        marginHeader: global_marginHeader = 0,
        marginFooter: global_marginFooter = 0,
        charSpace = 0,
        // charSpace
        linePitch = 15.6,
        // linePitch pt
        gridType = 1 /* LINES */,
        // gridType
        paragraphLineGapDefault = 0,
        defaultTabStop = 10.5,
        textStyle = {
          fs: 14
        },
        renderConfig: global_renderConfig = {
          horizontalAlign: 0 /* UNSPECIFIED */,
          verticalAlign: 0 /* UNSPECIFIED */,
          centerAngle: 0,
          vertexAngle: 0,
          wrapStrategy: 0 /* UNSPECIFIED */
        }
      } = documentStyle;
      const skeleton = this.__getNullSke();
      if (documentContentMapArr.length === 0) {
        return skeleton;
      }
      const fontLocale = this.getFontLocale();
      const docsConfig = {
        footers,
        headers,
        lists,
        drawings,
        charSpace,
        linePitch,
        gridType,
        fontLocale,
        paragraphLineGapDefault,
        defaultTabStop,
        documentTextStyle: textStyle
      };
      const { skeHeaders, skeFooters, skeListLevel, blockAnchor } = skeleton;
      const skeletonResourceReference = {
        skeHeaders,
        skeFooters,
        skeListLevel,
        blockAnchor
      };
      const allSkeletonPages = [];
      skeleton.pages = allSkeletonPages;
      for (let i4 = 0; i4 < documentContentMapArr.length; i4++) {
        const documentContentMap = documentContentMapArr[i4];
        if (!documentContentMap.sectionBreak) {
          continue;
        }
        const {
          pageNumberStart = global_pageNumberStart,
          pageSize = global_pageSize,
          pageOrient = global_pageOrient,
          marginTop = global_marginTop,
          marginBottom = global_marginBottom,
          marginRight = global_marginRight,
          marginLeft = global_marginLeft,
          marginHeader = global_marginHeader,
          marginFooter = global_marginFooter,
          defaultHeaderId = global_defaultHeaderId,
          defaultFooterId = global_defaultFooterId,
          evenPageHeaderId = global_evenPageHeaderId,
          evenPageFooterId = global_evenPageFooterId,
          firstPageHeaderId = global_firstPageHeaderId,
          firstPageFooterId = global_firstPageFooterId,
          useFirstPageHeaderFooter = global_useFirstPageHeaderFooter,
          useEvenPageHeaderFooter = global_useEvenPageHeaderFooter,
          columnProperties = [],
          columnSeparatorType = 1 /* NONE */,
          contentDirection,
          sectionType,
          textDirection,
          renderConfig = global_renderConfig
        } = documentContentMap.sectionBreak;
        const dcmNext = documentContentMapArr[i4 + 1];
        const sectionTypeNext = dcmNext?.sectionBreak?.sectionType;
        const headerIds = { defaultHeaderId, evenPageHeaderId, firstPageHeaderId };
        const footerIds = { defaultFooterId, evenPageFooterId, firstPageFooterId };
        if (pageSize.width === null) {
          pageSize.width = Infinity;
        }
        if (pageSize.height === null) {
          pageSize.height = Infinity;
        }
        const sectionBreakConfig = {
          pageNumberStart,
          pageSize,
          pageOrient,
          marginTop,
          marginBottom,
          marginRight,
          marginLeft,
          marginHeader,
          marginFooter,
          headerIds,
          footerIds,
          useFirstPageHeaderFooter,
          useEvenPageHeaderFooter,
          columnProperties,
          columnSeparatorType,
          contentDirection,
          sectionType,
          sectionTypeNext,
          textDirection,
          renderConfig,
          ...docsConfig
        };
        let curSkeletonPage = getLastPage(allSkeletonPages);
        let isContinuous = false;
        if (sectionType === 1 /* CONTINUOUS */) {
          updateBlockIndex(allSkeletonPages);
          this.__addNewSectionByContinuous(curSkeletonPage, columnProperties, columnSeparatorType);
          isContinuous = true;
        } else {
          curSkeletonPage = createSkeletonPage(sectionBreakConfig, skeletonResourceReference, curSkeletonPage?.pageNumber);
        }
        const context = this.getContext();
        const blockInfo = dealWithBlocks(documentContentMap.blockElements, curSkeletonPage, sectionBreakConfig, skeletonResourceReference, this._renderedBlockIdMap, context);
        if (sectionTypeNext === 1 /* CONTINUOUS */ && columnProperties.length > 0) {
        }
        const { pages, renderedBlockIdMap } = blockInfo;
        if (isContinuous) {
          pages.splice(0, 1);
        }
        allSkeletonPages.push(...pages);
      }
      updateBlockIndex(allSkeletonPages);
      return skeleton;
    }
    // sectionSectionType.CONTINUOUS
    __addNewSectionByContinuous(curSkeletonPage, columnProperties, columnSeparatorType) {
      const sections = curSkeletonPage.sections;
      const lastSection = sections[sections.length - 1];
      const { pageWidth, pageHeight, marginTop: curPageMT, marginBottom: curPageMB, marginLeft: curPageML, marginRight: curPageMR } = curSkeletonPage;
      const pageContentWidth = pageWidth - curPageML - curPageMR;
      const pageContentHeight = pageHeight - curPageMT - curPageMB;
      const lastSectionBottom = (lastSection?.top || 0) + (lastSection?.height || 0);
      const newSection = createSkeletonSection(columnProperties, columnSeparatorType, lastSectionBottom, 0, pageContentWidth, pageContentHeight - lastSectionBottom);
      newSection.parent = curSkeletonPage;
      sections.push(newSection);
    }
    __getNullSke() {
      return {
        pages: [],
        left: 0,
        top: 0,
        st: 0,
        skeHeaders: /* @__PURE__ */ new Map(),
        skeFooters: /* @__PURE__ */ new Map(),
        skeListLevel: /* @__PURE__ */ new Map(),
        blockAnchor: /* @__PURE__ */ new Map()
      };
    }
  };

  // ../../packages/base-render/src/Component/Component.ts
  var RenderComponent = class extends BaseObject {
    _extensions = /* @__PURE__ */ new Map();
    get extensions() {
      return this._extensions;
    }
    register(...extensions) {
      for (let extension of extensions) {
        extension.parent = this;
        this._extensions.set(extension.uKey, extension);
      }
    }
    unRegister(...uKeys) {
      for (let uKey of uKeys) {
        this._extensions.delete(uKey);
      }
    }
    getExtensionsByOrder() {
      const extensionArray = Array.from(this._extensions.values());
      extensionArray.sort(sortRules);
      return extensionArray;
    }
    getExtensionByKey(uKey) {
      return this._extensions.get(uKey);
    }
    draw(ctx, bounds) {
    }
  };

  // ../../packages/base-render/src/Component/Docs/DocComponent.ts
  var DocComponent = class extends RenderComponent {
    constructor(oKey, _skeleton, _allowCache = false) {
      super(oKey);
      this._skeleton = _skeleton;
      this._allowCache = _allowCache;
      if (this._allowCache) {
        this._cacheCanvas = new Canvas();
      }
      this.onIsAddedToParentObserver.add((parent) => {
        parent?.getEngine()?.onTransformChangeObservable.add((change) => {
          this.resizeCacheCanvas();
        });
        this.resizeCacheCanvas();
      });
    }
    _cacheCanvas;
    getSkeleton() {
      return this._skeleton;
    }
    setSkeleton(skeleton) {
      this._skeleton = skeleton;
    }
    render(mainCtx, bounds) {
      if (!this.visible) {
        this.makeDirty(false);
        return this;
      }
      if (!this._skeleton) {
        return;
      }
      const m4 = this.transform.getMatrix();
      mainCtx.save();
      mainCtx.transform(m4[0], m4[1], m4[2], m4[3], m4[4], m4[5]);
      this._draw(mainCtx, bounds);
      mainCtx.restore();
    }
    getParentScale() {
      if (!this.parent) {
        return { scaleX: 1, scaleY: 1 };
      }
      let { scaleX = 1, scaleY = 1 } = this.parent;
      if (this.parent.classType === "Scene" /* SCENE */) {
        scaleX = this.parent.ancestorScaleX || 1;
        scaleY = this.parent.ancestorScaleY || 1;
      }
      return {
        scaleX,
        scaleY
      };
    }
    _getBounding(bounds) {
    }
    _draw(ctx, bounds) {
    }
  };

  // ../../packages/base-render/src/Component/Extension.ts
  var ComponentExtension = class {
    uKey;
    type;
    zIndex;
    parent;
    translateX = 0;
    translateY = 0;
    extensionOffset;
    draw(ctx, parentScale, skeleton) {
    }
    clearCache() {
    }
    _getScale(parentScale) {
      return getScale(parentScale);
    }
  };
  var SpreadsheetExtensionRegistry = Registry2.create();
  var SheetRowTitleExtensionRegistry = Registry2.create();
  var SheetColumnTitleExtensionRegistry = Registry2.create();
  var DocumentsSpanAndLineExtensionRegistry = Registry2.create();

  // ../../packages/base-render/src/Component/Docs/DocExtension.ts
  var docExtension = class extends ComponentExtension {
    type = 0 /* SPAN */;
    translateX = 0;
    translateY = 0;
  };

  // ../../packages/base-render/src/Component/Docs/Extensions/FontAndBaseLine.ts
  var UNIQUE_KEY = "DefaultDocsFontAndBaseLineExtension";
  var FontAndBaseLine = class extends docExtension {
    uKey = UNIQUE_KEY;
    zIndex = 20;
    _preFontString = "";
    _preFontColor = "";
    draw(ctx, parentScale, span) {
      const line = span.parent?.parent;
      if (!line) {
        return;
      }
      const { asc = 0, marginTop: lineMarginTop = 0, paddingTop: linePaddingTop = 0 } = line;
      let maxLineAsc = asc + lineMarginTop + linePaddingTop;
      const { ts: textStyle, content, fontStyle, bBox } = span;
      let { spanPointWithFont = Vector2.create(0, 0) } = this.extensionOffset;
      if (!textStyle) {
        if (content != null) {
          ctx.fillText(content, spanPointWithFont.x, spanPointWithFont.y);
        }
        return;
      }
      if (content == null) {
        return;
      }
      if (this._preFontString !== fontStyle?.fontString) {
        ctx.font = this._preFontString = fontStyle?.fontString || "";
      }
      const { cl: colorStyle, va: baselineOffset } = textStyle;
      const fontColor = getColorStyle(colorStyle) || COLOR_BLACK_RGB;
      if (fontColor && this._preFontColor !== fontColor) {
        ctx.fillStyle = fontColor;
      }
      if (baselineOffset === 1 /* SUBSCRIPT */ || baselineOffset === 2 /* SUPERSCRIPT */) {
        let offset = bBox.spo;
        if (baselineOffset === 2 /* SUPERSCRIPT */) {
          offset = -bBox.sbo;
        }
        spanPointWithFont.y += offset;
      }
      ctx.fillText(content, spanPointWithFont.x, spanPointWithFont.y);
    }
    clearCache() {
      this._preFontString = "";
      this._preFontColor = "";
    }
  };
  DocumentsSpanAndLineExtensionRegistry.add(new FontAndBaseLine());

  // ../../packages/base-render/src/Component/Docs/Extensions/Background.ts
  var UNIQUE_KEY2 = "DefaultDocsBackgroundExtension";
  var Background = class extends docExtension {
    uKey = UNIQUE_KEY2;
    zIndex = 10;
    _preBackgroundColor = "";
    draw(ctx, parentScale, span) {
      const line = span.parent?.parent;
      if (!line) {
        return;
      }
      const { lineHeight = 0 } = line;
      const { ts: textStyle, width, content } = span;
      if (!textStyle) {
        return;
      }
      const { bg } = textStyle;
      if (!bg) {
        return;
      }
      const background = getColorStyle(bg);
      const { spanStartPoint = Vector2.create(0, 0) } = this.extensionOffset;
      if (background) {
        ctx.fillStyle = background;
        ctx.fillRect(spanStartPoint.x - 0.5, spanStartPoint.y, width + 1, lineHeight);
      }
    }
    clearCache() {
      this._preBackgroundColor = "";
    }
  };
  DocumentsSpanAndLineExtensionRegistry.add(new Background());

  // ../../packages/base-render/src/Component/Docs/Extensions/Line.ts
  var UNIQUE_KEY3 = "DefaultDocsLineExtension";
  var Line = class extends docExtension {
    uKey = UNIQUE_KEY3;
    zIndex = 40;
    _preBackgroundColor = "";
    draw(ctx, parentScale, span) {
      const line = span.parent?.parent;
      if (!line) {
        return;
      }
      const { asc: maxLineAsc = 0, lineHeight = 0 } = line;
      const { ts: textStyle, left, width, bBox } = span;
      if (!textStyle) {
        return;
      }
      const { sp: strikeoutPosition } = bBox;
      const scale = getScale(parentScale);
      const { ul: underline, st: strikethrough, ol: overline } = textStyle;
      const { originTranslate = Vector2.create(0, 0), centerPoint = Vector2.create(0, 0), alignOffset = Vector2.create(0, 0), renderConfig = {} } = this.extensionOffset;
      const { centerAngle = 0, vertexAngle = 0 } = renderConfig;
      if (underline) {
        const { s: show, cl: colorStyle, t: lineType } = underline;
        if (show === 1 /* TRUE */) {
          ctx.beginPath();
          const color = getColorStyle(colorStyle) || COLOR_BLACK_RGB;
          ctx.strokeStyle = color;
          this._setLineType(ctx, lineType || 12 /* SINGLE */);
          const startY = fixLineWidthByScale(lineHeight + DEFAULT_OFFSET_SPACING - 0.5, scale);
          const start = calculateRectRotate(originTranslate.addByPoint(left, startY), centerPoint, centerAngle, vertexAngle, alignOffset);
          const end = calculateRectRotate(originTranslate.addByPoint(left + width, startY), centerPoint, centerAngle, vertexAngle, alignOffset);
          ctx.moveTo(start.x, start.y);
          ctx.lineTo(end.x, end.y);
          ctx.stroke();
        }
      }
      if (strikethrough) {
        const { s: show, cl: colorStyle, t: lineType } = strikethrough;
        if (show === 1 /* TRUE */) {
          ctx.beginPath();
          const color = getColorStyle(colorStyle) || COLOR_BLACK_RGB;
          ctx.strokeStyle = color;
          this._setLineType(ctx, lineType || 12 /* SINGLE */);
          const startY = fixLineWidthByScale(strikeoutPosition - 0.5, scale);
          const start = calculateRectRotate(originTranslate.addByPoint(left, startY), centerPoint, centerAngle, vertexAngle, alignOffset);
          const end = calculateRectRotate(originTranslate.addByPoint(left + width, startY), centerPoint, centerAngle, vertexAngle, alignOffset);
          ctx.moveTo(start.x, start.y);
          ctx.lineTo(end.x, end.y);
          ctx.stroke();
        }
      }
      if (overline) {
        const { s: show, cl: colorStyle, t: lineType } = overline;
        if (show === 1 /* TRUE */) {
          ctx.beginPath();
          const color = getColorStyle(colorStyle) || COLOR_BLACK_RGB;
          ctx.strokeStyle = color;
          this._setLineType(ctx, lineType || 12 /* SINGLE */);
          const startY = fixLineWidthByScale(-DEFAULT_OFFSET_SPACING - 0.5, scale);
          const start = calculateRectRotate(originTranslate.addByPoint(left, startY), centerPoint, centerAngle, vertexAngle, alignOffset);
          const end = calculateRectRotate(originTranslate.addByPoint(left + width, startY), centerPoint, centerAngle, vertexAngle, alignOffset);
          ctx.moveTo(start.x, start.y);
          ctx.lineTo(end.x, end.y);
          ctx.stroke();
        }
      }
    }
    clearCache() {
      this._preBackgroundColor = "";
    }
    _setLineType(ctx, style) {
      if (style === 1 /* DASH_DOT_DOT_HEAVY */ || style === 7 /* DOT_DOT_DASH */) {
        ctx.setLineDash([2, 2, 5, 2, 2]);
      } else if (style === 2 /* DASH_DOT_HEAVY */ || style === 6 /* DOT_DASH */) {
        ctx.setLineDash([2, 5, 2]);
      } else if (style === 8 /* DOTTED */ || style === 9 /* DOTTED_HEAVY */) {
        ctx.setLineDash([2]);
      } else if (style === 0 /* DASH */ || style === 3 /* DASHED_HEAVY */) {
        ctx.setLineDash([3]);
      } else if (style === 4 /* DASH_LONG */ || style === 5 /* DASH_LONG_HEAVY */) {
        ctx.setLineDash([6]);
      } else {
        ctx.setLineDash([0]);
      }
    }
    _getLineWidth(style) {
      let lineWidth = 1;
      if (style === 16 /* WAVY_HEAVY */ || style === 3 /* DASHED_HEAVY */ || style === 9 /* DOTTED_HEAVY */ || style === 2 /* DASH_DOT_HEAVY */ || style === 5 /* DASH_LONG_HEAVY */ || style === 1 /* DASH_DOT_DOT_HEAVY */) {
        lineWidth = 2;
      } else if (style === 13 /* THICK */) {
        lineWidth = 3;
      }
      return lineWidth;
    }
  };
  DocumentsSpanAndLineExtensionRegistry.add(new Line());

  // ../../packages/base-render/src/Component/Docs/Extensions/Border.ts
  var UNIQUE_KEY4 = "DefaultDocsBorderExtension";
  var Border = class extends docExtension {
    uKey = UNIQUE_KEY4;
    zIndex = 30;
    _preBorderStyle;
    _preBorderColor = "";
    draw(ctx, parentScale, span) {
      const line = span.parent?.parent;
      if (!line) {
        return;
      }
      const { asc: maxLineAsc = 0, lineHeight = 0 } = line;
      const { ts: textStyle, left, width: spanWidth } = span;
      if (!textStyle) {
        return;
      }
      const { bd: borderData } = textStyle;
      if (!borderData) {
        return;
      }
      const scale = this._getScale(parentScale);
      const borderCache = this._createBorderCache(borderData);
      const { spanStartPoint = Vector2.create(0, 0) } = this.extensionOffset;
      for (let type of borderCache.keys()) {
        const borderCacheValue = borderCache.get(type);
        if (!borderCacheValue) {
          continue;
        }
        const { s: style, cl: colorStyle } = borderCacheValue;
        const color = getColorStyle(colorStyle) || COLOR_BLACK_RGB;
        if (style !== this._preBorderStyle) {
          setLineType(ctx, style);
          ctx.lineWidth = getLineWidth(style) / scale;
          this._preBorderStyle = style;
        }
        if (color !== this._preBorderColor) {
          ctx.strokeStyle = color || COLOR_BLACK_RGB;
          this._preBorderColor = color;
        }
        drawLineByBorderType(ctx, type, {
          startX: spanStartPoint.x,
          startY: spanStartPoint.y,
          endX: spanStartPoint.x + spanWidth,
          endY: spanStartPoint.y + lineHeight
        });
      }
    }
    clearCache() {
      this._preBorderStyle = null;
      this._preBorderColor = "";
    }
    _createBorderCache(borderData) {
      const { t: t4, b: b4, l: l4, r: r4 } = borderData;
      const borderCache = /* @__PURE__ */ new Map();
      t4 && borderCache.set("t" /* TOP */, t4);
      b4 && borderCache.set("b" /* BOTTOM */, b4);
      l4 && borderCache.set("l" /* LEFT */, l4);
      r4 && borderCache.set("r" /* RIGHT */, r4);
      return borderCache;
    }
  };
  DocumentsSpanAndLineExtensionRegistry.add(new Border());

  // ../../packages/base-render/src/Component/Docs/Common/Liquid.ts
  var Liquid = class {
    _translateX = 0;
    _translateY = 0;
    _translateSaveList = [];
    get x() {
      return this._translateX;
    }
    get y() {
      return this._translateY;
    }
    reset() {
      this.translateBy(0, 0);
      this._translateSaveList = [];
    }
    translateBy(x4 = 0, y4 = 0) {
      this._translateX = x4;
      this._translateY = y4;
    }
    translate(x4 = 0, y4 = 0) {
      this._translateX += x4;
      this._translateY += y4;
    }
    translateSave() {
      this._translateSaveList.push({
        x: this._translateX,
        y: this._translateY
      });
    }
    translateRestore() {
      const save = this._translateSaveList.pop();
      if (save) {
        this._translateX = save.x;
        this._translateY = save.y;
      }
    }
    translatePagePadding(page) {
      const { marginTop: pagePaddingTop = 0, marginBottom: pagePaddingBottom = 0, marginLeft: pagePaddingLeft = 0, marginRight: pagePaddingRight = 0 } = page;
      this.translate(pagePaddingLeft, pagePaddingTop);
    }
    restorePagePadding(page) {
      const { marginTop: pagePaddingTop = 0, marginBottom: pagePaddingBottom = 0, marginLeft: pagePaddingLeft = 0, marginRight: pagePaddingRight = 0 } = page;
      this.translate(-pagePaddingLeft, -pagePaddingTop);
    }
    translatePage(page, type = 0 /* VERTICAL */, left = 0, top = 0, right = 0, bottom = 0) {
      const {
        sections,
        marginTop: pagePaddingTop = 0,
        marginBottom: pagePaddingBottom = 0,
        marginLeft: pagePaddingLeft = 0,
        marginRight: pagePaddingRight = 0,
        pageWidth,
        pageHeight,
        width,
        height,
        pageNumber = 1,
        renderConfig = {}
      } = page;
      let pageTop = 0;
      let pageLeft = 0;
      if (type === 0 /* VERTICAL */) {
        pageTop = pageHeight + top;
      } else if (type === 1 /* HORIZONTAL */) {
        pageLeft = pageWidth + left;
      }
      this.translate(pageLeft, pageTop);
      return {
        x: pageLeft,
        y: pageTop
      };
    }
    translateSection(section) {
      const { top: sectionTop = 0 } = section;
      this.translate(0, sectionTop);
      return {
        x: 0,
        y: sectionTop
      };
    }
    translateColumn(column) {
      const { left: columnLeft } = column;
      this.translate(columnLeft, 0);
      return {
        x: columnLeft,
        y: 0
      };
    }
    translateLine(line, isDraw = false) {
      const { top: lineTop, marginBottom: lineMarginBottom = 0, marginTop: lineMarginTop = 0, paddingTop: linePaddingTop = 0, paddingBottom: linePaddingBottom = 0 } = line;
      const lineOffset = lineTop + (isDraw === true ? lineMarginTop : 0) + linePaddingTop;
      this.translate(0, lineOffset);
      return {
        x: 0,
        y: lineOffset
      };
    }
    translateDivide(divide) {
      const { left: divideLeft, paddingLeft: dividePaddingLeft } = divide;
      const left = divideLeft + dividePaddingLeft;
      this.translate(left, 0);
      return {
        x: left,
        y: 0
      };
    }
    translateSpan(span) {
      const { left: spanLeft } = span;
      this.translate(spanLeft, 0);
      return {
        x: spanLeft,
        y: 0
      };
    }
  };

  // ../../packages/base-render/src/Component/Docs/Common/TextSelection.ts
  var NodePositionType = /* @__PURE__ */ ((NodePositionType2) => {
    NodePositionType2[NodePositionType2["page"] = 0] = "page";
    NodePositionType2[NodePositionType2["section"] = 1] = "section";
    NodePositionType2[NodePositionType2["column"] = 2] = "column";
    NodePositionType2[NodePositionType2["line"] = 3] = "line";
    NodePositionType2[NodePositionType2["divide"] = 4] = "divide";
    NodePositionType2[NodePositionType2["span"] = 5] = "span";
    return NodePositionType2;
  })(NodePositionType || {});
  var NodePositionMap = {
    page: 0,
    section: 1,
    column: 2,
    line: 3,
    divide: 4,
    span: 5
  };
  var TEXT_RANGE_KEY_PREFIX = "__TestSelectionRange__";
  var TEXT_ANCHOR_KEY_PREFIX = "__TestSelectionAnchor__";
  var TextSelection = class {
    constructor(_scene, startNodePosition, endNodePosition, segmentId) {
      this._scene = _scene;
      this.startNodePosition = startNodePosition;
      this.endNodePosition = endNodePosition;
      this.segmentId = segmentId;
    }
    _current = false;
    _Liquid = new Liquid();
    _rangeShape;
    _anchorShape;
    _rangeList;
    _currentStartState = {
      page: 0 /* NORMAL */,
      section: 0 /* NORMAL */,
      column: 0 /* NORMAL */,
      line: 0 /* NORMAL */,
      divide: 0 /* NORMAL */,
      span: 0 /* NORMAL */
    };
    _currentEndState = {
      page: 0 /* NORMAL */,
      section: 0 /* NORMAL */,
      column: 0 /* NORMAL */,
      line: 0 /* NORMAL */,
      divide: 0 /* NORMAL */,
      span: 0 /* NORMAL */
    };
    getRange() {
      const cursorList = this._rangeList;
      const firstCursor = cursorList[0];
      const lastCursor = cursorList[cursorList.length - 1];
      let isCollapse = cursorList.length === 1 && firstCursor.isCollapse;
      return {
        cursorStart: firstCursor.cursorStart,
        cursorEnd: lastCursor.cursorEnd,
        isStartBack: firstCursor.isStartBack,
        isEndBack: lastCursor.isEndBack,
        isCollapse
      };
    }
    getRangeList() {
      return this._rangeList;
    }
    getAnchor() {
      return this._anchorShape;
    }
    activeStatic() {
      this._anchorShape?.setProps({
        stroke: getColor(COLORS.black, 1)
      });
    }
    deactivateStatic() {
      this._anchorShape?.setProps({
        stroke: getColor(COLORS.black, 0)
      });
    }
    isActive() {
      return this._current === true;
    }
    activate() {
      this._current = true;
    }
    deactivate() {
      this._current = false;
    }
    isEmpty() {
      return this.startNodePosition == null && this.endNodePosition == null;
    }
    isCollapsed() {
      if (this.startNodePosition != null && this.endNodePosition == null) {
        return true;
      }
      if (this.isSamePosition()) {
        return true;
      }
      return false;
    }
    isRange() {
      const start = this.startNodePosition;
      const end = this.endNodePosition;
      if (start == null || end == null) {
        return false;
      }
      if (this.isSamePosition()) {
        return false;
      }
      return true;
    }
    dispose() {
      this._rangeShape?.dispose();
      this._rangeShape = null;
      this._anchorShape?.dispose();
      this._anchorShape = null;
    }
    isIntersection(textSelection) {
      const activeRange = this.getRange();
      const compareRange = textSelection.getRange();
      const activeStart = this._getCursorPosition(activeRange.cursorStart, activeRange.isStartBack);
      const activeEnd = this._getCursorPosition(activeRange.cursorEnd, activeRange.isEndBack);
      const compareStart = this._getCursorPosition(compareRange.cursorStart, compareRange.isStartBack);
      const compareEnd = this._getCursorPosition(compareRange.cursorEnd, compareRange.isEndBack);
      if (activeStart > compareEnd || activeEnd < compareStart) {
        return false;
      }
      return true;
    }
    refresh(documents) {
      const start = this.startNodePosition;
      const end = this.endNodePosition;
      this._anchorShape?.hide();
      this._rangeShape?.hide();
      if (this.isEmpty()) {
        return;
      }
      if (this.isCollapsed()) {
        const data2 = this._getRangePointData(start, start, documents);
        const { pointGroup: pointGroup2, cursorList: cursorList2 } = data2;
        this._setRangeList(cursorList2);
        pointGroup2.length > 0 && this._createAndUpdateAnchor(pointGroup2, documents.left, documents.top);
        return;
      }
      const data = this._getRangePointData(start, end, documents);
      const { pointGroup, cursorList } = data;
      this._setRangeList(cursorList);
      pointGroup.length > 0 && this._createAndUpdateRange(pointGroup, documents.left, documents.top);
    }
    getStart() {
      if (this.startNodePosition == null) {
        return this.endNodePosition;
      }
      if (this.endNodePosition == null) {
        return this.startNodePosition;
      }
      const { start } = this._compareNodePosition(this.startNodePosition, this.endNodePosition);
      return start;
    }
    _resetCurrentNodePositionState() {
      this._currentStartState = {
        page: 0 /* NORMAL */,
        section: 0 /* NORMAL */,
        column: 0 /* NORMAL */,
        line: 0 /* NORMAL */,
        divide: 0 /* NORMAL */,
        span: 0 /* NORMAL */
      };
      this._currentEndState = {
        page: 0 /* NORMAL */,
        section: 0 /* NORMAL */,
        column: 0 /* NORMAL */,
        line: 0 /* NORMAL */,
        divide: 0 /* NORMAL */,
        span: 0 /* NORMAL */
      };
    }
    _compareNodePositionLogic(pos1, pos2) {
      if (pos1.page > pos2.page) {
        return false;
      }
      if (pos1.page < pos2.page) {
        return true;
      }
      if (pos1.section > pos2.section) {
        return false;
      }
      if (pos1.section < pos2.section) {
        return true;
      }
      if (pos1.column > pos2.column) {
        return false;
      }
      if (pos1.column < pos2.column) {
        return true;
      }
      if (pos1.line > pos2.line) {
        return false;
      }
      if (pos1.line < pos2.line) {
        return true;
      }
      if (pos1.divide > pos2.divide) {
        return false;
      }
      if (pos1.divide < pos2.divide) {
        return true;
      }
      if (pos1.span > pos2.span) {
        return false;
      }
      if (pos1.span < pos2.span) {
        return true;
      }
      return true;
    }
    _compareNodePosition(pos1, pos2) {
      const compare = this._compareNodePositionLogic(pos1, pos2);
      if (compare) {
        return {
          start: pos1,
          end: pos2
        };
      }
      return {
        start: pos2,
        end: pos1
      };
    }
    _setNodePositionState(type = 0 /* page */, start, end, current) {
      if (current === start) {
        this._currentStartState[type] = 1 /* START */;
      } else {
        this._currentStartState[type] = 0 /* NORMAL */;
      }
      if (current === end) {
        this._currentEndState[type] = 2 /* END */;
      } else {
        this._currentEndState[type] = 0 /* NORMAL */;
      }
    }
    _checkPreviousNodePositionState(typeIndex, isStart = true) {
      let index = typeIndex;
      let resultState;
      while (index >= 0) {
        const type = NodePositionType[index];
        let state;
        if (isStart) {
          state = this._currentStartState[type];
        } else {
          state = this._currentEndState[type];
        }
        if (state === void 0) {
          return;
        }
        if (resultState === void 0) {
          resultState = state;
        }
        if (state !== resultState) {
          return 0 /* NORMAL */;
        }
        index--;
      }
      return resultState;
    }
    _getSelectionRuler(typeIndex, startPosition, endPosition, nextLength, current) {
      let start_next = 0;
      let end_next = nextLength;
      const type = NodePositionType[typeIndex];
      const nextType = NodePositionType[typeIndex + 1];
      if (nextType === null || type === null) {
        return {
          start_next,
          end_next
        };
      }
      const start = startPosition[type];
      const end = endPosition[type];
      this._setNodePositionState(type, start, end, current);
      const preStartNestType = this._checkPreviousNodePositionState(typeIndex);
      const preEndNestType = this._checkPreviousNodePositionState(typeIndex, false);
      if (preStartNestType === 1 /* START */) {
        start_next = startPosition[nextType];
      }
      if (preEndNestType === 2 /* END */) {
        end_next = endPosition[nextType];
      }
      return {
        start_next,
        end_next
      };
    }
    _pushToPoints(position) {
      const { startX, startY, endX, endY } = position;
      const points = [];
      points.push({
        x: startX,
        y: startY
      });
      points.push({
        x: endX,
        y: startY
      });
      points.push({
        x: endX,
        y: endY
      });
      points.push({
        x: startX,
        y: endY
      });
      points.push({
        x: startX,
        y: startY
      });
      return points;
    }
    isSamePosition() {
      const start = this.startNodePosition;
      const end = this.endNodePosition;
      if (start == null || end == null) {
        return false;
      }
      const keys = Object.keys(NodePositionMap);
      for (let key of keys) {
        const startNodeValue = start[key];
        const endNodeValue = end[key];
        if (startNodeValue !== endNodeValue) {
          return false;
        }
      }
      if (start.isBack !== end.isBack) {
        return false;
      }
      return true;
    }
    _createAndUpdateRange(pointsGroup, left, top) {
      if (this._rangeShape) {
        this._rangeShape.translate(left, top);
        this._rangeShape.updatePointGroup(pointsGroup);
        this._rangeShape.show();
        return;
      }
      const polygon = new RegularPolygon(TEXT_RANGE_KEY_PREFIX + Tools.generateRandomId(6), {
        pointsGroup,
        fill: getColor(COLORS.black, 0.2),
        left,
        top,
        evented: false
      });
      this._rangeShape = polygon;
      this._scene.addObject(polygon, 2);
    }
    _getAnchorBounding(pointsGroup) {
      const points = pointsGroup[0];
      const startPoint = points[0];
      const endPoint = points[2];
      const { x: startX, y: startY } = startPoint;
      const { x: endX, y: endY } = endPoint;
      return {
        left: startX,
        top: startY,
        width: endX - startX,
        height: endY - startY
      };
    }
    _createAndUpdateAnchor(pointsGroup, docsLeft, docsTop) {
      const bounding = this._getAnchorBounding(pointsGroup);
      const { left, top, width, height } = bounding;
      if (this._anchorShape) {
        this._anchorShape.transformByState({ left: left + docsLeft, top: top + docsTop, height });
        this._anchorShape.show();
        return;
      }
      const anchor = new Rect(TEXT_ANCHOR_KEY_PREFIX + Tools.generateRandomId(6), {
        left: left + docsLeft,
        top: top + docsTop,
        height,
        strokeWidth: 1,
        stroke: getColor(COLORS.black),
        evented: false
      });
      this._anchorShape = anchor;
      this._scene.addObject(anchor, 2);
    }
    _getRangePointData(startOrigin, endOrigin, documents) {
      const pointGroup = [];
      const cursorList = [];
      if (startOrigin == null || endOrigin == null) {
        return {
          pointGroup,
          cursorList
        };
      }
      const { start, end } = this._compareNodePosition(startOrigin, endOrigin);
      this._selectionIterator(start, end, documents, (start_sp, end_sp, isFirst, isLast, divide, line) => {
        const { lineHeight } = line;
        const { spanGroup, st } = divide;
        const { x: startX, y: startY } = this._Liquid;
        let position;
        const firstSpan = spanGroup[start_sp];
        const lastSpan = spanGroup[end_sp];
        const firstSpanLeft = firstSpan?.left || 0;
        const firstSpanWidth = firstSpan?.width || 0;
        const lastSpanLeft = lastSpan?.left || 0;
        const lastSpanWidth = lastSpan?.width || 0;
        let isCurrentList = firstSpan?.spanType === 2 /* LIST */;
        let hasList = spanGroup[0]?.spanType === 2 /* LIST */;
        let cursorStart = start_sp + st;
        let cursorEnd = end_sp + st;
        const isStartBack = start.span === start_sp && isFirst ? start.isBack : true;
        const isEndBack = end.span === end_sp && isLast ? end.isBack : false;
        const isCollapse = start === end;
        if (start_sp === 0 && end_sp === spanGroup.length - 1) {
          cursorEnd -= hasList ? 1 : 0;
          position = {
            startX: startX + firstSpanLeft + (isCurrentList ? firstSpanWidth : 0),
            startY,
            endX: startX + lastSpanLeft + lastSpanWidth,
            endY: startY + lineHeight
          };
        } else {
          const isStartBackFin = isStartBack && !isCurrentList;
          cursorStart -= hasList && !isCurrentList ? 1 : 0;
          cursorEnd -= hasList && !isCurrentList ? 1 : 0;
          position = {
            startX: startX + firstSpanLeft + (isStartBackFin ? 0 : firstSpanWidth),
            startY,
            endX: startX + lastSpanLeft + (isEndBack ? 0 : lastSpanWidth),
            endY: startY + lineHeight
          };
        }
        pointGroup.push(this._pushToPoints(position));
        cursorList.push({
          isStartBack,
          isEndBack,
          cursorStart,
          cursorEnd,
          isCollapse
        });
      });
      return {
        pointGroup,
        cursorList
      };
    }
    _selectionIterator(startPosition, endPosition, documents, func) {
      const skeleton = documents.getSkeleton();
      if (!skeleton) {
        return [];
      }
      this._Liquid.reset();
      const skeletonData = skeleton.getSkeletonData();
      const pages = skeletonData.pages;
      const { page: pageIndex } = startPosition;
      const { page: endPageIndex } = endPosition;
      this._resetCurrentNodePositionState();
      for (let p4 = 0; p4 <= pageIndex - 1; p4++) {
        const page = pages[p4];
        this._Liquid.translatePage(page, documents.pageLayoutType, documents.pageMarginLeft, documents.pageMarginTop);
      }
      for (let p4 = pageIndex; p4 <= endPageIndex; p4++) {
        const page = pages[p4];
        const sections = page.sections;
        const { start_next: start_s, end_next: end_s } = this._getSelectionRuler(NodePositionMap.page, startPosition, endPosition, sections.length - 1, p4);
        this._Liquid.translateSave();
        this._Liquid.translatePagePadding(page);
        for (let s4 = start_s; s4 <= end_s; s4++) {
          const section = sections[s4];
          const columns = section.columns;
          const { start_next: start_c, end_next: end_c } = this._getSelectionRuler(NodePositionMap.section, startPosition, endPosition, columns.length - 1, s4);
          this._Liquid.translateSection(section);
          for (let c4 = start_c; c4 <= end_c; c4++) {
            const column = columns[c4];
            const lines = column.lines;
            const { start_next: start_l, end_next: end_l } = this._getSelectionRuler(NodePositionMap.column, startPosition, endPosition, lines.length - 1, c4);
            this._Liquid.translateColumn(column);
            for (let l4 = start_l; l4 <= end_l; l4++) {
              const line = lines[l4];
              const { divides, type, lineHeight = 0 } = line;
              const { start_next: start_d, end_next: end_d } = this._getSelectionRuler(NodePositionMap.line, startPosition, endPosition, divides.length - 1, l4);
              this._Liquid.translateSave();
              this._Liquid.translateLine(line);
              for (let d4 = start_d; d4 <= end_d; d4++) {
                const divide = divides[d4];
                this._Liquid.translateSave();
                this._Liquid.translateDivide(divide);
                const spanGroup = divide.spanGroup;
                const { start_next: start_sp, end_next: end_sp } = this._getSelectionRuler(NodePositionMap.divide, startPosition, endPosition, spanGroup.length - 1, d4);
                let isFirst = false;
                let isLast = false;
                if (p4 === pageIndex && s4 === start_s && c4 === start_c && l4 === start_l && d4 === start_d) {
                  isFirst = true;
                }
                if (p4 === endPageIndex && s4 === end_s && c4 === end_c && l4 === end_l && d4 === end_d) {
                  isLast = true;
                }
                func && func(start_sp, end_sp, isFirst, isLast, divide, line, column, section, page);
                this._Liquid.translateRestore();
              }
              this._Liquid.translateRestore();
            }
          }
        }
        this._Liquid.translateRestore();
        this._Liquid.translatePage(page, documents.pageLayoutType, documents.pageMarginLeft, documents.pageMarginTop);
      }
    }
    _setRangeList(rangeList) {
      if (rangeList.length === 0) {
        return;
      }
      this._rangeList = rangeList;
    }
    _getCursorPosition(index, isBack) {
      return index - (isBack === true ? 1 : 0);
    }
  };

  // ../../packages/base-render/src/Component/Docs/Document.Editor.ts
  var DocsEditor = class {
    constructor(_documents) {
      this._documents = _documents;
      this._initialDom();
      this.activeViewport = this._documents?.getFirstViewport();
      if (this._documents) {
        this.changeDocuments(this._documents);
      }
    }
    onKeydownObservable = new Observable();
    onInputObservable = new Observable();
    onCompositionstartObservable = new Observable();
    onCompositionupdateObservable = new Observable();
    onCompositionendObservable = new Observable();
    _container;
    _inputParent;
    _input;
    _cursor;
    _downObserver;
    _moveObserver;
    _upObserver;
    _moveInObserver;
    _moveOutObserver;
    _skeletonObserver;
    _viewportScrollX;
    _viewportScrollY;
    _textSelectionList = [];
    _activeViewport;
    _viewPortObserverMap = /* @__PURE__ */ new Map();
    _isIMEInputApply = false;
    set activeViewport(viewport) {
      this._attachScrollEvent(viewport);
      this._activeViewport = viewport;
    }
    static create(documents) {
      return new DocsEditor(documents);
    }
    getActiveTextSelection() {
      const list = this._textSelectionList;
      for (let textSelection of list) {
        if (textSelection.isActive()) {
          return textSelection;
        }
      }
    }
    getTextSelectionList() {
      return this._textSelectionList;
    }
    add(textSelection) {
      this._addTextSelection(textSelection);
    }
    remain() {
      const activeSelection = this.getActiveTextSelection();
      if (activeSelection == null) {
        return;
      }
      const index = this._textSelectionList.indexOf(activeSelection);
      return this._textSelectionList.splice(index, 1)[0];
    }
    sync() {
      this._syncDomToSelection();
    }
    active(x4, y4) {
      this._container.style.left = `${x4}px`;
      this._container.style.top = `${y4}px`;
      this._cursor.style.animation = "univer_cursor_blinkStyle 1s steps(1) infinite";
      this._cursor.style.display = "revert";
      setTimeout(() => {
        this._input.focus();
      }, 0);
    }
    deactivate() {
      this._container.style.left = `0px`;
      this._container.style.top = `0px`;
      this._cursor.style.animation = "";
      this._cursor.style.display = "none";
      this._input.blur();
    }
    changeDocuments(documents) {
      if (this._documents) {
        this._detachEvent(this._documents);
      }
      this._documents = documents;
      this._skeletonObserver = documents.getSkeleton()?.onRecalculateChangeObservable.add((data) => {
        this._deleteAllTextSelection();
      });
      this._attachSelectionEvent(this._documents);
    }
    dispose() {
      if (this._documents) {
        this._detachEvent(this._documents);
      }
      this._container.remove();
    }
    _initialDom() {
      const container = document.createElement("div");
      container.style.position = "absolute";
      container.style.position = "absolute";
      container.style.left = `0px`;
      container.style.top = `0px`;
      const inputParent = document.createElement("div");
      const inputDom = document.createElement("div");
      const cursorDom = document.createElement("div");
      inputParent.appendChild(inputDom);
      container.appendChild(inputParent);
      container.appendChild(cursorDom);
      this._container = container;
      this._inputParent = inputParent;
      this._input = inputDom;
      this._cursor = cursorDom;
      this._initialInput();
      this._initialCursorDom();
      this._attachInputEvent();
      document.body.appendChild(container);
    }
    _initialInput() {
      this._inputParent.style.cssText = `
            position:absolute;
            height:1px;
            width:1px;
            overflow: hidden;
        `;
      this._input.contentEditable = "true";
      this._input.style.cssText = `
            position: absolute; 
            overflow: hidden; 
            opacity: 1; 
            background: #000; 
            color: transparent; 
            outline: none; 
            z-index: -2; 
            caret-color: transparent; 
            white-space: pre-wrap; 
            user-select: text;
        `;
    }
    _initialCursorDom() {
      this._cursor.style.cssText = `
            visibility: visible;
            position: absolute;
            background: #000;
            left: 0;
            top: 0;
            width: 1px;
            height: 20px;
            opacity: 0;
            z-index: 0;
            pointer-events: none;
            display: none
        `;
      if (!checkStyle("keyframes univer_cursor_blinkStyle")) {
        const styles = [
          `
                @-webkit-keyframes univer_cursor_blinkStyle {
                    0% {
                        opacity: 1;
                    }
                
                    13% {
                        opacity: 0;
                    }

                    50% {
                        opacity: 0;
                    }

                    63% {
                        opacity: 1;
                    }
                
                    100% {
                        opacity: 1;
                    }
                }
            `,
          `
                @keyframes univer_cursor_blinkStyle {
                    0% {
                        opacity: 1;
                    }
                
                    13% {
                        opacity: 0;
                    }

                    50% {
                        opacity: 0;
                    }

                    63% {
                        opacity: 1;
                    }
                
                    100% {
                        opacity: 1;
                    }
                }
            `
        ];
        injectStyle(styles);
      }
    }
    _getSkeletonData() {
      return this._documents?.getSkeleton()?.getSkeletonData();
    }
    _getNodePosition(node) {
      if (node === false) {
        return;
      }
      const { node: span, ratioX, ratioY } = node;
      const position = this._documents?.findPositionBySpan(span);
      if (position == null) {
        return;
      }
      return {
        ...position,
        isBack: ratioX < 0.5
      };
    }
    _interactTextSelection(activeTextSelection) {
      const newTextSelection = [];
      let hasIntersection = false;
      this._textSelectionList.forEach((textSelection) => {
        if (textSelection === activeTextSelection) {
          return true;
        }
        if (!activeTextSelection.isIntersection(textSelection)) {
          newTextSelection.push(textSelection);
        } else {
          hasIntersection = true;
          textSelection.dispose();
        }
      });
      if (!hasIntersection) {
        return;
      }
      newTextSelection.push(activeTextSelection);
      this._textSelectionList = newTextSelection;
    }
    _deleteAllTextSelection() {
      this._textSelectionList.forEach((textSelection) => {
        textSelection.dispose();
      });
      this._textSelectionList = [];
    }
    _deactivateTextSelection() {
      this._textSelectionList.forEach((textSelection) => {
        textSelection.deactivate();
      });
    }
    _addTextSelection(textSelection) {
      this._deactivateTextSelection();
      textSelection.activate();
      this._textSelectionList.push(textSelection);
    }
    _updateTextSelection(position) {
      if (!this._documents) {
        return;
      }
      let lastTextSelection = this._textSelectionList.pop();
      if (!lastTextSelection) {
        lastTextSelection = new TextSelection(this._documents.getScene(), position);
      }
      this._deleteAllTextSelection();
      lastTextSelection.activate();
      lastTextSelection.startNodePosition = position;
      lastTextSelection.endNodePosition = null;
      this._textSelectionList = [lastTextSelection];
    }
    _isEmptyTextSelection() {
      return this._textSelectionList.length === 0;
    }
    _getCanvasOffset() {
      const engine = this._documents?.getEngine();
      const canvas = engine?.getCanvas()?.getCanvasEle();
      if (!canvas) {
        return {
          left: 0,
          top: 0
        };
      }
      const { top, left } = getOffsetRectForDom(canvas);
      return {
        left,
        top
      };
    }
    _syncDomToSelection() {
      const activeTextSelection = this.getActiveTextSelection();
      const anchor = activeTextSelection?.getAnchor();
      if (!anchor || anchor && !anchor.visible) {
        return;
      }
      const { height, left, top } = anchor;
      const absoluteCoord = this._activeViewport?.getAbsoluteVector(Vector2.FromArray([left, top]));
      this._cursor.style.height = `${height}px`;
      let { left: canvasLeft, top: canvasTop } = this._getCanvasOffset();
      canvasLeft += absoluteCoord?.x || 0;
      canvasTop += absoluteCoord?.y || 0;
      this.active(canvasLeft, canvasTop);
    }
    _moving(moveOffsetX, moveOffsetY, scrollTimer) {
      const { scrollX: scrollX2, scrollY: scrollY2 } = getCurrentScrollXY(scrollTimer);
      if (!this._documents) {
        return;
      }
      const endNode = this._documents.findNodeByCoord(moveOffsetX, moveOffsetY);
      const endPosition = this._getNodePosition(endNode);
      console.log("endNode", endNode, endPosition, { moveOffsetX, moveOffsetY, _viewportScrollY: this._viewportScrollY, scrollX: scrollX2 });
      if (!endPosition) {
        return;
      }
      const activeTextSelection = this.getActiveTextSelection();
      if (!activeTextSelection) {
        return;
      }
      activeTextSelection.endNodePosition = endPosition;
      activeTextSelection.refresh(this._documents);
      this._interactTextSelection(activeTextSelection);
    }
    _attachScrollEvent(viewport) {
      if (!viewport) {
        return;
      }
      const key = viewport.viewPortKey;
      if (this._viewPortObserverMap.has(key)) {
        return;
      }
      const scrollBefore = viewport.onScrollBeforeObserver.add((param) => {
        const viewport2 = param.viewport;
        if (!viewport2) {
          return;
        }
        const textSelection = this.getActiveTextSelection();
        textSelection?.activeStatic();
        this._cursor.style.display = "none";
      });
      const scrollStop = viewport.onScrollStopObserver.add((param) => {
        const viewport2 = param.viewport;
        if (!viewport2) {
          return;
        }
        const bounds = viewport2.getBounding();
        const textSelection = this.getActiveTextSelection();
        const anchor = textSelection?.getAnchor();
        if (!anchor || anchor && !anchor.visible) {
          return;
        }
        if (bounds) {
          const { minX, maxX, minY, maxY } = transformBoundingCoord(anchor, bounds);
          if (anchor.strokeWidth < minX || maxX < 0 || anchor.strokeWidth < minY || maxY < 0) {
            return;
          }
        }
        this._syncDomToSelection();
        textSelection?.deactivateStatic();
        this._cursor.style.display = "revert";
      });
      this._viewPortObserverMap.set(key, {
        scrollBefore,
        scrollStop
      });
    }
    _attachInputEvent() {
      this._input.addEventListener("keydown", (e4) => {
        if (this._isIMEInputApply) {
          return;
        }
        const activeSelection = this.getActiveTextSelection();
        const selectionList = this.getTextSelectionList();
        if (this._documents == null) {
          return;
        }
        this._input.innerHTML = "";
        this.onKeydownObservable.notifyObservers({
          event: e4,
          content: "",
          document: this._documents,
          activeSelection,
          selectionList
        });
      });
      this._input.addEventListener("input", (e4) => {
        if (this._isIMEInputApply) {
          return;
        }
        const content = this._input.textContent || "";
        this._input.innerHTML = "";
        const activeSelection = this.getActiveTextSelection();
        const selectionList = this.getTextSelectionList();
        if (this._documents == null) {
          return;
        }
        this.onInputObservable.notifyObservers({
          event: e4,
          content,
          document: this._documents,
          activeSelection,
          selectionList
        });
      });
      this._input.addEventListener("compositionstart", (e4) => {
        this._isIMEInputApply = true;
        const content = this._input.textContent || "";
        this._input.innerHTML = "";
        const activeSelection = this.getActiveTextSelection();
        const selectionList = this.getTextSelectionList();
        if (this._documents == null) {
          return;
        }
        this.onCompositionstartObservable.notifyObservers({
          event: e4,
          content,
          document: this._documents,
          activeSelection,
          selectionList
        });
      });
      this._input.addEventListener("compositionend", (e4) => {
        this._isIMEInputApply = false;
        const content = this._input.textContent || "";
        this._input.innerHTML = "";
        const activeSelection = this.getActiveTextSelection();
        const selectionList = this.getTextSelectionList();
        if (this._documents == null) {
          return;
        }
        this.onCompositionendObservable.notifyObservers({
          event: e4,
          content,
          document: this._documents,
          activeSelection,
          selectionList
        });
      });
      this._input.addEventListener("compositionupdate", (e4) => {
        const content = this._input.textContent || "";
        this._input.innerHTML = "";
        const activeSelection = this.getActiveTextSelection();
        const selectionList = this.getTextSelectionList();
        if (this._documents == null) {
          return;
        }
        this.onCompositionupdateObservable.notifyObservers({
          event: e4,
          content,
          document: this._documents,
          activeSelection,
          selectionList
        });
      });
    }
    _attachSelectionEvent(documents) {
      this._moveInObserver = documents.onPointerEnterObserver.add(() => {
        documents.cursor = "text" /* TEXT */;
      });
      this._moveOutObserver = documents.onPointerLeaveObserver.add(() => {
        documents.cursor = "default" /* DEFAULT */;
        scene.resetCursor();
      });
      const scene = documents.getScene();
      this._downObserver = documents.onPointerDownObserver.add((evt, state) => {
        const { offsetX: evtOffsetX, offsetY: evtOffsetY } = evt;
        if (!this._documents) {
          return;
        }
        this.activeViewport = this._documents.getActiveViewportByCoord(evtOffsetX, evtOffsetY);
        const startNode = this._documents.findNodeByCoord(evtOffsetX, evtOffsetY);
        const position = this._getNodePosition(startNode);
        console.log("startNode", startNode, position, evtOffsetX, evtOffsetY);
        if (!position) {
          this._deleteAllTextSelection();
          return;
        }
        if (evt.ctrlKey || this._isEmptyTextSelection()) {
          const newTextSelection = new TextSelection(this._documents.getScene(), position);
          this._addTextSelection(newTextSelection);
        } else {
          this._updateTextSelection(position);
        }
        this._activeSelectionRefresh();
        this._syncDomToSelection();
        scene.disableEvent();
        const scrollTimer = ScrollTimer.create(scene);
        scrollTimer.startScroll(evtOffsetX, evtOffsetY);
        const { scrollX: scrollX2, scrollY: scrollY2 } = getCurrentScrollXY(scrollTimer);
        this._viewportScrollX = scrollX2;
        this._viewportScrollY = scrollY2;
        this._moveObserver = scene.onPointerMoveObserver.add((moveEvt) => {
          const { offsetX: moveOffsetX, offsetY: moveOffsetY } = moveEvt;
          this._moving(moveOffsetX, moveOffsetY, scrollTimer);
          scrollTimer.scrolling(moveOffsetX, moveOffsetY, () => {
            this._moving(moveOffsetX, moveOffsetY, scrollTimer);
          });
          scene.setCursor("text" /* TEXT */);
        });
        this._upObserver = scene.onPointerUpObserver.add((upEvt) => {
          scene.onPointerMoveObserver.remove(this._moveObserver);
          scene.onPointerUpObserver.remove(this._upObserver);
          scene.enableEvent();
          scrollTimer.stopScroll();
        });
      });
    }
    _detachEvent(documents) {
      documents.onPointerEnterObserver.remove(this._moveInObserver);
      documents.onPointerLeaveObserver.remove(this._moveOutObserver);
      documents.onPointerDownObserver.remove(this._downObserver);
      documents.getSkeleton()?.onRecalculateChangeObservable.remove(this._skeletonObserver);
      this.onKeydownObservable.clear();
      this.onInputObservable.clear();
      this.onCompositionstartObservable.clear();
      this.onCompositionupdateObservable.clear();
      this.onCompositionendObservable.clear();
    }
    _activeSelectionRefresh() {
      if (!this._documents) {
        return;
      }
      const activeSelection = this.getActiveTextSelection();
      activeSelection?.refresh(this._documents);
    }
  };

  // ../../packages/base-render/src/Component/Docs/Document.ts
  var Documents = class extends DocComponent {
    pageWidth;
    pageHeight;
    pageMarginLeft;
    pageMarginTop;
    pageLayoutType;
    isCalculateSkeleton = true;
    onPageRenderObservable = new Observable();
    _drawLiquid;
    _findLiquid;
    _hasEditor = false;
    _editor;
    _skeletonObserver;
    // private _textAngleRotateOffset: number = 0;
    constructor(oKey, documentSkeleton, config) {
      super(oKey, documentSkeleton, config?.allowCache);
      if (config?.pageMarginLeft === void 0) {
        this.pageMarginLeft = 17;
      } else {
        this.pageMarginLeft = config?.pageMarginLeft;
      }
      if (config?.pageMarginTop === void 0) {
        this.pageMarginTop = 14;
      } else {
        this.pageMarginTop = config?.pageMarginTop;
      }
      this.pageLayoutType = config?.pageLayoutType || 0 /* VERTICAL */;
      this._drawLiquid = new Liquid();
      this._findLiquid = new Liquid();
      this._hasEditor = config?.hasEditor || false;
      this._initialDefaultExtension();
      this._addSkeletonChangeObserver(documentSkeleton);
      this.makeDirty(true);
    }
    get hasEditor() {
      return this._hasEditor;
    }
    static create(oKey, documentSkeleton, config) {
      return new Documents(oKey, documentSkeleton, config);
    }
    calculatePagePosition() {
      const scene = this.getScene();
      let parent = scene?.getParent();
      const { width: docsWidth, height: docsHeight, pageMarginLeft, pageMarginTop } = this;
      if (parent == null) {
        return;
      }
      const { width: engineWidth, height: engineHeight } = parent;
      let docsLeft = 0;
      let docsTop = 0;
      let sceneWidth = 0;
      let sceneHeight = 0;
      if (engineWidth > docsWidth) {
        docsLeft = engineWidth / 2 - docsWidth / 2;
        sceneWidth = engineWidth - 30;
      } else {
        docsLeft = pageMarginLeft;
        sceneWidth = docsWidth + pageMarginLeft * 2;
      }
      if (engineHeight > docsHeight) {
        docsTop = engineHeight / 2 - docsHeight / 2;
        sceneHeight = engineHeight - 30;
      } else {
        docsTop = pageMarginTop;
        sceneHeight = docsHeight + pageMarginTop * 2;
      }
      scene.resize(sceneWidth, sceneHeight + 200);
      this.translate(docsLeft, docsTop);
    }
    getFirstViewport() {
      return this.getScene().getViewports()[0];
    }
    getActiveViewportByCoord(offsetX, offsetY) {
      return this.getScene().getActiveViewportByCoord(Vector2.FromArray([offsetX, offsetY]));
    }
    getEngine() {
      return this.getScene().getEngine();
    }
    enableEditor() {
      if (this._hasEditor) {
        return;
      }
      this._editor = DocsEditor.create(this);
      this._hasEditor = true;
    }
    disableEditor() {
      this._editor?.dispose();
      this._hasEditor = false;
    }
    getEditorInputEvent() {
      if (!this._hasEditor) {
        return;
      }
      const { onInputObservable, onCompositionstartObservable, onCompositionupdateObservable, onCompositionendObservable, onKeydownObservable } = this._editor;
      return { onInputObservable, onCompositionstartObservable, onCompositionupdateObservable, onCompositionendObservable, onKeydownObservable };
    }
    remainActiveSelection() {
      if (!this._hasEditor) {
        return;
      }
      return this._editor.remain();
    }
    addSelection(textSelection) {
      if (!this._hasEditor) {
        return;
      }
      return this._editor.add(textSelection);
    }
    syncSelection() {
      if (!this._hasEditor) {
        return;
      }
      return this._editor.sync();
    }
    draw(ctx, bounds) {
      const documentSkeleton = this.getSkeleton();
      if (!documentSkeleton) {
        return;
      }
      this._drawLiquid.reset();
      const skeletonData = documentSkeleton.getSkeletonData();
      const { pages } = skeletonData;
      const parentScale = this.getParentScale();
      const extensions = this.getExtensionsByOrder();
      const scale = getScale(parentScale);
      for (let extension of extensions) {
        extension.clearCache();
      }
      let pageTop = 0;
      let pageLeft = 0;
      for (let i4 = 0, len = pages.length; i4 < len; i4++) {
        const page = pages[i4];
        const {
          sections,
          marginTop: pagePaddingTop = 0,
          marginBottom: pagePaddingBottom = 0,
          marginLeft: pagePaddingLeft = 0,
          marginRight: pagePaddingRight = 0,
          width: pageWidth,
          height: pageHeight,
          renderConfig = {}
        } = page;
        const {
          verticalAlign = 1 /* TOP */,
          horizontalAlign = 1 /* LEFT */,
          centerAngle: centerAngleDeg = 0,
          vertexAngle: vertexAngleDeg = 0,
          wrapStrategy = 0 /* UNSPECIFIED */,
          isRotateNonEastAsian = 0 /* FALSE */
        } = renderConfig;
        const horizontalOffsetNoAngle = this._horizontalHandler(pageWidth, pagePaddingLeft, pagePaddingRight, horizontalAlign);
        const verticalOffsetNoAngle = this._verticalHandler(pageHeight, pagePaddingTop, pagePaddingBottom, verticalAlign);
        const alignOffsetNoAngle = Vector2.create(horizontalOffsetNoAngle, verticalOffsetNoAngle);
        const centerAngle = degToRad(centerAngleDeg);
        const vertexAngle = degToRad(vertexAngleDeg);
        const finalAngle = vertexAngle - centerAngle;
        this.onPageRenderObservable.notifyObservers({
          page,
          pageLeft,
          pageTop,
          ctx
        });
        this._startRotation(ctx, finalAngle);
        for (let section of sections) {
          const { columns } = section;
          this._drawLiquid.translateSection(section);
          for (let column of columns) {
            const { lines, width: columnWidth } = column;
            this._drawLiquid.translateColumn(column);
            const linesCount = lines.length;
            let alignOffset;
            let rotateTranslateXListApply = null;
            if (vertexAngle !== 0) {
              const { rotateTranslateXList, rotatedHeight, rotatedWidth, fixOffsetX, fixOffsetY, rotateTranslateY } = getRotateOffsetAndFarthestHypotenuse(
                lines,
                columnWidth,
                vertexAngle
              );
              let exceedWidthFix = rotatedWidth;
              if (rotatedHeight > this.height && wrapStrategy !== 3 /* WRAP */) {
                if (wrapStrategy === 1 /* OVERFLOW */ || vertexAngle > 0) {
                  exceedWidthFix = this.height / Math.tan(Math.abs(vertexAngle));
                }
              }
              const horizontalOffset = this._horizontalHandler(exceedWidthFix, pagePaddingLeft, pagePaddingRight, horizontalAlign);
              const verticalOffset = this._verticalHandler(rotatedHeight, pagePaddingTop, pagePaddingBottom, verticalAlign);
              let exceedHeightFix = verticalOffset - fixOffsetY;
              if (rotatedHeight > this.height) {
                if (vertexAngle < 0) {
                  exceedHeightFix = this.height - (rotatedHeight + fixOffsetY);
                } else {
                  exceedHeightFix = -fixOffsetY;
                }
              }
              alignOffset = Vector2.create(horizontalOffset + fixOffsetX, exceedHeightFix);
              this._drawLiquid.translate(0, -rotateTranslateY);
              rotateTranslateXListApply = rotateTranslateXList;
            } else {
              alignOffset = alignOffsetNoAngle;
            }
            for (let i5 = 0; i5 < linesCount; i5++) {
              const line = lines[i5];
              const {
                divides,
                asc = 0,
                type,
                lineHeight = 0
              } = line;
              let maxLineAsc = asc;
              const maxLineAscSin = maxLineAsc * Math.sin(centerAngle);
              const maxLineAscCos = maxLineAsc * Math.cos(centerAngle);
              if (type === 1 /* BLOCK */) {
                for (let extension of extensions) {
                  if (extension.type === 1 /* LINE */) {
                    extension.extensionOffset = {
                      alignOffset,
                      renderConfig
                    };
                    extension.draw(ctx, parentScale, line);
                  }
                }
              } else {
                this._drawLiquid.translateSave();
                this._drawLiquid.translateLine(line, true);
                rotateTranslateXListApply && this._drawLiquid.translate(rotateTranslateXListApply[i5]);
                const divideLength = divides.length;
                for (let i6 = 0; i6 < divideLength; i6++) {
                  const divide = divides[i6];
                  const { spanGroup } = divide;
                  this._drawLiquid.translateSave();
                  this._drawLiquid.translateDivide(divide);
                  for (let span of spanGroup) {
                    if (!span.content || span.content.length === 0) {
                      continue;
                    }
                    const { width: spanWidth, left: spanLeft } = span;
                    const { x: translateX, y: translateY } = this._drawLiquid;
                    const originTranslate = Vector2.create(fixLineWidthByScale(translateX, scale), fixLineWidthByScale(translateY, scale));
                    const centerPoint = Vector2.create(fixLineWidthByScale(spanWidth / 2, scale), fixLineWidthByScale(lineHeight / 2, scale));
                    const spanStartPoint = calculateRectRotate(
                      originTranslate.addByPoint(fixLineWidthByScale(spanLeft, scale), 0),
                      centerPoint,
                      centerAngle,
                      vertexAngle,
                      alignOffset
                    );
                    const spanPointWithFont = calculateRectRotate(
                      originTranslate.addByPoint(fixLineWidthByScale(spanLeft + maxLineAscSin, scale), fixLineWidthByScale(maxLineAscCos, scale)),
                      centerPoint,
                      centerAngle,
                      vertexAngle,
                      alignOffset
                    );
                    const extensionOffset = {
                      originTranslate,
                      spanStartPoint,
                      spanPointWithFont,
                      centerPoint,
                      alignOffset,
                      renderConfig
                    };
                    for (let extension of extensions) {
                      if (extension.type === 0 /* SPAN */) {
                        extension.extensionOffset = extensionOffset;
                        extension.draw(ctx, parentScale, span);
                      }
                    }
                  }
                  this._drawLiquid.translateRestore();
                }
                this._drawLiquid.translateRestore();
              }
            }
          }
        }
        this._resetRotation(ctx, finalAngle);
        const { x: x4, y: y4 } = this._drawLiquid.translatePage(page, this.pageLayoutType, this.pageMarginLeft, this.pageMarginTop);
        pageLeft += x4;
        pageTop += y4;
      }
    }
    changeSkeleton(newSkeleton) {
      this._disposeSkeletonChangeObserver(this.getSkeleton());
      this.setSkeleton(newSkeleton);
      this._addSkeletonChangeObserver(newSkeleton);
      return this;
    }
    findPositionBySpan(span) {
      const divide = span.parent;
      const line = divide?.parent;
      const column = line?.parent;
      const section = column?.parent;
      const page = section?.parent;
      const skeletonData = this.getSkeleton()?.getSkeletonData();
      if (!divide || !column || !section || !page || !skeletonData) {
        return;
      }
      let spanIndex = divide.spanGroup.indexOf(span);
      const divideIndex = line.divides.indexOf(divide);
      const lineIndex = column.lines.indexOf(line);
      const columnIndex = section.columns.indexOf(column);
      const sectionIndex = page.sections.indexOf(section);
      const pageIndex = skeletonData.pages.indexOf(page);
      return {
        span: spanIndex,
        divide: divideIndex,
        line: lineIndex,
        column: columnIndex,
        section: sectionIndex,
        page: pageIndex
      };
    }
    findNodeByCharIndex(charIndex) {
      const skeleton = this.getSkeleton();
      if (!skeleton) {
        return;
      }
      const skeletonData = skeleton.getSkeletonData();
      const pages = skeletonData.pages;
      for (let page of pages) {
        const { sections, st, ed } = page;
        if (charIndex < st || charIndex > ed) {
          continue;
        }
        for (let section of sections) {
          const { columns, st: st2, ed: ed2 } = section;
          if (charIndex < st2 || charIndex > ed2) {
            continue;
          }
          for (let column of columns) {
            const { lines, st: st3, ed: ed3 } = column;
            if (charIndex < st3 || charIndex > ed3) {
              continue;
            }
            for (let line of lines) {
              const { divides, lineHeight, st: st4, ed: ed4 } = line;
              const divideLength = divides.length;
              if (charIndex < st4 || charIndex > ed4) {
                continue;
              }
              for (let i4 = 0; i4 < divideLength; i4++) {
                const divide = divides[i4];
                const { spanGroup, st: st5, ed: ed5 } = divide;
                if (charIndex < st5 || charIndex > ed5) {
                  continue;
                }
                const span = spanGroup[charIndex - st5];
                if (span) {
                  return span;
                }
              }
            }
          }
        }
      }
    }
    findNodeByCoord(offsetX, offsetY) {
      const scene = this.getScene();
      const originCoord = scene.transformToSceneCoord(Vector2.FromArray([offsetX, offsetY]));
      if (!originCoord) {
        return false;
      }
      const coord = this._getInverseCoord(originCoord);
      let { x: x4, y: y4 } = coord;
      const skeleton = this.getSkeleton();
      if (!skeleton) {
        return false;
      }
      this._findLiquid.reset();
      const skeletonData = skeleton.getSkeletonData();
      const pages = skeletonData.pages;
      for (let i4 = 0, len = pages.length; i4 < len; i4++) {
        const page = pages[i4];
        const { startX, startY, endX, endY } = this._getPageBoundingBox(page);
        if (!(x4 >= startX && x4 <= endX && y4 >= startY && y4 <= endY)) {
          this._translatePage(page);
          continue;
        }
        this._findLiquid.translatePagePadding(page);
        const sections = page.sections;
        for (let section of sections) {
          const { columns, height } = section;
          this._findLiquid.translateSection(section);
          const { y: startY2 } = this._findLiquid;
          if (!(y4 >= startY2 && y4 <= startY2 + height)) {
            continue;
          }
          for (let column of columns) {
            const { lines, width: columnWidth } = column;
            this._findLiquid.translateColumn(column);
            const { x: startX2 } = this._findLiquid;
            if (!(x4 >= startX2 && x4 <= startX2 + columnWidth)) {
              continue;
            }
            const linesCount = lines.length;
            for (let i5 = 0; i5 < linesCount; i5++) {
              const line = lines[i5];
              const { divides, type, lineHeight = 0 } = line;
              if (type === 1 /* BLOCK */) {
                continue;
              } else {
                this._findLiquid.translateSave();
                this._findLiquid.translateLine(line);
                const { y: startY3 } = this._findLiquid;
                const startY_fin = startY3;
                const endY_fin = startY3 + lineHeight;
                if (!(y4 >= startY_fin && y4 <= endY_fin)) {
                  this._findLiquid.translateRestore();
                  continue;
                }
                const divideLength = divides.length;
                for (let i6 = 0; i6 < divideLength; i6++) {
                  const divide = divides[i6];
                  const { spanGroup, width: divideWidth } = divide;
                  this._findLiquid.translateSave();
                  this._findLiquid.translateDivide(divide);
                  const { x: startX3 } = this._findLiquid;
                  if (!(x4 >= startX3 && x4 <= startX3 + divideWidth)) {
                    this._findLiquid.translateRestore();
                    continue;
                  }
                  for (let span of spanGroup) {
                    if (!span.content || span.content.length === 0) {
                      continue;
                    }
                    const { width: spanWidth, left: spanLeft } = span;
                    const startX_fin = startX3 + spanLeft;
                    const endX_fin = startX3 + spanLeft + spanWidth;
                    if (!(x4 >= startX_fin && x4 <= endX_fin)) {
                      continue;
                    }
                    return {
                      node: span,
                      ratioX: x4 / (startX_fin + endX_fin),
                      ratioY: y4 / (startY_fin + endY_fin)
                    };
                  }
                  this._findLiquid.translateRestore();
                }
                this._findLiquid.translateRestore();
              }
            }
          }
        }
        this._findLiquid.restorePagePadding(page);
        this._translatePage(page);
      }
      return false;
    }
    _draw(ctx, bounds) {
      this.draw(ctx, bounds);
    }
    _horizontalHandler(pageWidth, pagePaddingLeft, pagePaddingRight, horizontalAlign) {
      let offsetLeft = 0;
      if (horizontalAlign === 2 /* CENTER */) {
        offsetLeft = (this.width - pageWidth) / 2;
      } else if (horizontalAlign === 3 /* RIGHT */) {
        offsetLeft = this.width - pageWidth - pagePaddingRight;
      } else {
        offsetLeft = pagePaddingLeft;
      }
      return offsetLeft;
    }
    _verticalHandler(pageHeight, pagePaddingTop, pagePaddingBottom, verticalAlign) {
      let offsetTop = 0;
      if (verticalAlign === 2 /* MIDDLE */) {
        offsetTop = (this.height - pageHeight) / 2;
      } else if (verticalAlign === 3 /* BOTTOM */) {
        offsetTop = this.height - pageHeight - pagePaddingBottom;
      } else {
        offsetTop = pagePaddingTop;
      }
      return offsetTop;
    }
    _startRotation(ctx, textAngle) {
      ctx.rotate(textAngle || 0);
    }
    _resetRotation(ctx, textAngle) {
      ctx.rotate(-textAngle || 0);
    }
    _initialDefaultExtension() {
      DocumentsSpanAndLineExtensionRegistry.getData().forEach((extension) => {
        this.register(extension);
      });
    }
    _addSkeletonChangeObserver(skeleton) {
      if (!skeleton) {
        return;
      }
      this._skeletonObserver = skeleton.onRecalculateChangeObservable.add((data) => {
        const pages = data.pages;
        let width = 0;
        let height = 0;
        for (let i4 = 0, len = pages.length; i4 < len; i4++) {
          const page = pages[i4];
          const { pageWidth, pageHeight } = page;
          if (this.pageLayoutType === 0 /* VERTICAL */) {
            height += pageHeight;
            if (i4 !== len - 1) {
              height += this.pageMarginTop;
            }
            width = Math.max(width, pageWidth);
          } else if (this.pageLayoutType === 1 /* HORIZONTAL */) {
            width += pageWidth;
            if (i4 !== len - 1) {
              width += this.pageMarginLeft;
            }
            height = Math.max(height, pageHeight);
          }
        }
        this.resize(width, height);
        this.calculatePagePosition();
      });
    }
    _disposeSkeletonChangeObserver(skeleton) {
      if (!skeleton) {
        return;
      }
      skeleton.onRecalculateChangeObservable.remove(this._skeletonObserver);
    }
    _getPageBoundingBox(page) {
      const { pageWidth, pageHeight } = page;
      let { x: startX, y: startY } = this._findLiquid;
      let endX = -1;
      let endY = -1;
      if (this.pageLayoutType === 0 /* VERTICAL */) {
        endX = pageWidth;
        endY = startY + pageHeight;
      } else if (this.pageLayoutType === 1 /* HORIZONTAL */) {
        endX = startX + pageWidth;
        endY = pageHeight;
      }
      return {
        startX,
        startY,
        endX,
        endY
      };
    }
    _translatePage(page) {
      this._findLiquid.translatePage(page, this.pageLayoutType, this.pageMarginLeft, this.pageMarginTop);
    }
  };

  // ../../packages/base-render/src/Scene.Transformer.ts
  var TransformerManagerTypeArray = [
    "__SpreadsheetTransformerResizeLT__" /* RESIZE_LT */,
    "__SpreadsheetTransformerResizeCT__" /* RESIZE_CT */,
    "__SpreadsheetTransformerResizeRT__" /* RESIZE_RT */,
    "__SpreadsheetTransformerResizeLM__" /* RESIZE_LM */,
    "__SpreadsheetTransformerResizeRM__" /* RESIZE_RM */,
    "__SpreadsheetTransformerResizeLB__" /* RESIZE_LB */,
    "__SpreadsheetTransformerResizeCB__" /* RESIZE_CB */,
    "__SpreadsheetTransformerResizeRB__" /* RESIZE_RB */
  ];
  var Transformer = class {
    constructor(_scene, config) {
      this._scene = _scene;
      this._initialProps(config);
    }
    hoverEnabled = false;
    hoverEnterFunc;
    hoverLeaveFunc;
    resizeEnabled = true;
    rotateEnabled = true;
    rotationSnaps = [];
    rotationSnapTolerance = 5;
    rotateAnchorOffset = 50;
    rotateSize = 10;
    rotateCornerRadius = 10;
    borderEnabled = true;
    borderStroke = "rgb(97, 97, 97)";
    borderStrokeWidth = 1;
    borderDash = [];
    borderSpacing = 10;
    anchorFill = "rgb(255,255,255)";
    anchorStroke = "rgb(185,185,185)";
    anchorStrokeWidth = 1;
    anchorSize = 10;
    anchorCornerRadius = 10;
    keepRatio = true;
    centeredScaling = false;
    /**
     * leftTop centerTop rightTop
     * leftMiddle rightMiddle
     * leftBottom centerBottom rightBottom
     */
    enabledAnchors = [1, 1, 1, 1, 1, 1, 1, 1];
    flipEnabled = false;
    ignoreStroke = false;
    boundBoxFunc;
    useSingleNodeRotation;
    shouldOverdrawWholeArea;
    onChangeStartObservable = new Observable();
    onChangingObservable = new Observable();
    onChangeEndObservable = new Observable();
    onClearControlObservable = new Observable();
    onCreateControlObservable = new Observable();
    _startOffsetX;
    _startOffsetY;
    _viewportScrollX;
    _viewportScrollY;
    _moveObserver;
    _upObserver;
    _cancelFocusObserver;
    _transformerControlMap = /* @__PURE__ */ new Map();
    _selectedObjectMap = /* @__PURE__ */ new Map();
    getScene() {
      return this._scene;
    }
    attachTo(applyObject) {
      if (!applyObject.isTransformer) {
        return;
      }
      if (this.hoverEnabled) {
        this.hoverEnterFunc && applyObject.onPointerEnterObserver.add(this.hoverEnterFunc);
        this.hoverLeaveFunc && applyObject.onPointerLeaveObserver.add(this.hoverLeaveFunc);
      }
      applyObject.onPointerDownObserver.add((evt, state) => {
        const { offsetX: evtOffsetX, offsetY: evtOffsetY } = evt;
        this._startOffsetX = evtOffsetX;
        this._startOffsetY = evtOffsetY;
        const scene = this._getTopScene();
        if (!scene) {
          return;
        }
        this._addCancelObserver(scene);
        scene.disableEvent();
        const scrollTimer = ScrollTimer.create(scene);
        scrollTimer.startScroll(evtOffsetX, evtOffsetY);
        const { scrollX: scrollX2, scrollY: scrollY2 } = getCurrentScrollXY(scrollTimer);
        this._viewportScrollX = scrollX2;
        this._viewportScrollY = scrollY2;
        this._updateActiveObjectList(applyObject, evt);
        this._moveObserver = scene.onPointerMoveObserver.add((moveEvt) => {
          const { offsetX: moveOffsetX, offsetY: moveOffsetY } = moveEvt;
          this._moving(moveOffsetX, moveOffsetY, scrollTimer);
          this._hiddenControl();
          scrollTimer.scrolling(moveOffsetX, moveOffsetY, () => {
            this._moving(moveOffsetX, moveOffsetY, scrollTimer);
          });
        });
        this._upObserver = scene.onPointerUpObserver.add((upEvt) => {
          scene.onPointerMoveObserver.remove(this._moveObserver);
          scene.onPointerUpObserver.remove(this._upObserver);
          scene.enableEvent();
          this._updateControl();
          scrollTimer.stopScroll();
          this.onChangeEndObservable.notifyObservers({
            objects: this._selectedObjectMap,
            type: 2 /* MOVE_END */
          });
        });
        state.stopPropagation();
      });
      return applyObject;
    }
    dispose() {
      this._moveObserver = null;
      this._upObserver = null;
      this._transformerControlMap.forEach((control) => {
        control.dispose();
      });
      this._selectedObjectMap.forEach((control) => {
        control.dispose();
      });
      this.onChangeStartObservable.clear();
      this.onChangingObservable.clear();
      this.onChangeEndObservable.clear();
    }
    _initialProps(props) {
      if (!props) {
        return;
      }
      const propsKeys = Object.keys(props);
      if (propsKeys.length === 0) {
        return;
      }
      propsKeys.forEach((key) => {
        if (props[key] === void 0) {
          return true;
        }
        this[key] = props[key];
      });
    }
    _updateControlChildren() {
      this._updateControlIterator((control, applyObject) => {
        const { left, top, width, height, scaleX, scaleY } = applyObject.getState();
        const children = control.getObjects();
        children.forEach((o4) => {
          const key = o4.oKey;
          const type = this._checkTransformerType(key);
          if (!type) {
            return true;
          }
          if (type === "__SpreadsheetTransformerOutline__" /* OUTLINE */) {
            o4.transformByState(this._getOutlinePosition(width, height, scaleX, scaleY));
          } else {
            const { left: left2, top: top2 } = this._getRotateAnchorPosition(type, height, width, scaleX, scaleY);
            o4.transformByState({
              left: left2,
              top: top2
            });
          }
        });
        control.transformByState({
          left,
          top
        });
      });
    }
    _anchorMoving(type, moveOffsetX, moveOffsetY, scrollTimer) {
      const { scrollX: scrollX2, scrollY: scrollY2 } = getCurrentScrollXY(scrollTimer);
      const x4 = moveOffsetX - this._viewportScrollX + scrollX2;
      const y4 = moveOffsetY - this._viewportScrollY + scrollY2;
      const moveLeft = x4 - this._startOffsetX;
      const moveTop = y4 - this._startOffsetY;
      this._selectedObjectMap.forEach((moveObject) => {
        const { left, top, width, height } = moveObject;
        const state = {};
        switch (type) {
          case "__SpreadsheetTransformerResizeLT__" /* RESIZE_LT */:
            state.left = left + moveLeft;
            state.top = top + moveTop;
            state.width = width - moveLeft;
            state.height = height - moveTop;
            break;
          case "__SpreadsheetTransformerResizeCT__" /* RESIZE_CT */:
            state.top = top + moveTop;
            state.height = height - moveTop;
            break;
          case "__SpreadsheetTransformerResizeRT__" /* RESIZE_RT */:
            state.top = top + moveTop;
            state.width = width + moveLeft;
            state.height = height - moveTop;
            break;
          case "__SpreadsheetTransformerResizeLM__" /* RESIZE_LM */:
            state.left = left + moveLeft;
            state.width = width - moveLeft;
            break;
          case "__SpreadsheetTransformerResizeRM__" /* RESIZE_RM */:
            state.width = moveLeft + width;
            break;
          case "__SpreadsheetTransformerResizeLB__" /* RESIZE_LB */:
            state.left = left + moveLeft;
            state.width = width - moveLeft;
            state.height = height + moveTop;
            break;
          case "__SpreadsheetTransformerResizeCB__" /* RESIZE_CB */:
            state.height = moveTop + height;
            break;
          case "__SpreadsheetTransformerResizeRB__" /* RESIZE_RB */:
            state.width = moveLeft + width;
            state.height = moveTop + height;
            break;
        }
        moveObject.transformByState(state);
      });
      this._updateControlChildren();
      this.onChangingObservable.notifyObservers({
        objects: this._selectedObjectMap,
        moveX: moveLeft,
        moveY: moveTop,
        type: 1 /* MOVING */
      });
      this._startOffsetX = x4;
      this._startOffsetY = y4;
    }
    _attachEventToAnchor(anchor, type = "__SpreadsheetTransformerResizeLT__" /* RESIZE_LT */) {
      anchor.onPointerDownObserver.add((evt, state) => {
        const { offsetX: evtOffsetX, offsetY: evtOffsetY } = evt;
        this._startOffsetX = evtOffsetX;
        this._startOffsetY = evtOffsetY;
        const scene = this._getTopScene();
        if (scene == null) {
          return;
        }
        scene.disableEvent();
        const scrollTimer = ScrollTimer.create(scene);
        scrollTimer.startScroll(evtOffsetX, evtOffsetY);
        const { scrollX: scrollX2, scrollY: scrollY2 } = getCurrentScrollXY(scrollTimer);
        this._viewportScrollX = scrollX2;
        this._viewportScrollY = scrollY2;
        const cursor = this._getRotateAnchorCursor(type);
        this._moveObserver = scene.onPointerMoveObserver.add((moveEvt) => {
          const { offsetX: moveOffsetX, offsetY: moveOffsetY } = moveEvt;
          this._anchorMoving(type, moveOffsetX, moveOffsetY, scrollTimer);
          scrollTimer.scrolling(moveOffsetX, moveOffsetY, () => {
            this._anchorMoving(type, moveOffsetX, moveOffsetY, scrollTimer);
          });
          scene.setCursor(cursor);
        });
        this._upObserver = scene.onPointerUpObserver.add((upEvt) => {
          scene.onPointerMoveObserver.remove(this._moveObserver);
          scene.onPointerUpObserver.remove(this._upObserver);
          scene.enableEvent();
          scene.resetCursor();
          scrollTimer.stopScroll();
        });
        state.stopPropagation();
      });
    }
    _attachEventToRotate(rotateControl) {
      rotateControl.onPointerDownObserver.add((evt, state) => {
        const { offsetX: evtOffsetX, offsetY: evtOffsetY } = evt;
        this._startOffsetX = evtOffsetX;
        this._startOffsetY = evtOffsetY;
        const scene = this._getTopScene();
        if (scene == null) {
          return;
        }
        scene.disableEvent();
        this._viewportScrollX = scrollX;
        this._viewportScrollY = scrollY;
        this._moveObserver = scene.onPointerMoveObserver.add((moveEvt) => {
          const { offsetX: moveOffsetX, offsetY: moveOffsetY } = moveEvt;
        });
        this._upObserver = scene.onPointerUpObserver.add((upEvt) => {
          scene.onPointerMoveObserver.remove(this._moveObserver);
          scene.onPointerUpObserver.remove(this._upObserver);
          scene.enableEvent();
        });
        state.stopPropagation();
      });
    }
    _getOutlinePosition(width, height, scaleX, scaleY) {
      return {
        left: -this.borderSpacing - this.borderStrokeWidth,
        top: -this.borderSpacing - this.borderStrokeWidth,
        width: width + this.borderSpacing * 2,
        height: height + this.borderSpacing * 2
      };
    }
    _getRotateAnchorCursor(type) {
      let cursor = "nw-resize" /* NORTH_WEST_RESIZE */;
      switch (type) {
        case "__SpreadsheetTransformerRotate__" /* ROTATE */:
          cursor = "move" /* MOVE */;
          break;
        case "__SpreadsheetTransformerRotateLine__" /* ROTATE_LINE */:
          cursor = "move" /* MOVE */;
          break;
        case "__SpreadsheetTransformerResizeLT__" /* RESIZE_LT */:
          break;
        case "__SpreadsheetTransformerResizeCT__" /* RESIZE_CT */:
          cursor = "n-resize" /* NORTH_RESIZE */;
          break;
        case "__SpreadsheetTransformerResizeRT__" /* RESIZE_RT */:
          cursor = "ne-resize" /* NORTH_EAST_RESIZE */;
          break;
        case "__SpreadsheetTransformerResizeLM__" /* RESIZE_LM */:
          cursor = "w-resize" /* WEST_RESIZE */;
          break;
        case "__SpreadsheetTransformerResizeRM__" /* RESIZE_RM */:
          cursor = "e-resize" /* EAST_RESIZE */;
          break;
        case "__SpreadsheetTransformerResizeLB__" /* RESIZE_LB */:
          cursor = "sw-resize" /* SOUTH_WEST_RESIZE */;
          break;
        case "__SpreadsheetTransformerResizeCB__" /* RESIZE_CB */:
          cursor = "s-resize" /* SOUTH_RESIZE */;
          break;
        case "__SpreadsheetTransformerResizeRB__" /* RESIZE_RB */:
          cursor = "se-resize" /* SOUTH_EAST_RESIZE */;
          break;
      }
      return cursor;
    }
    _getRotateAnchorPosition(type, height, width, scaleX, scaleY) {
      let left = -this.anchorSize / 2;
      let top = -this.anchorSize / 2;
      switch (type) {
        case "__SpreadsheetTransformerRotate__" /* ROTATE */:
          left = width / 2 - this.rotateSize / 2;
          top = -this.rotateAnchorOffset - this.borderSpacing - this.borderStrokeWidth * 2 - this.rotateSize;
          break;
        case "__SpreadsheetTransformerRotateLine__" /* ROTATE_LINE */:
          left = width / 2;
          top = -this.rotateAnchorOffset - this.borderSpacing - this.borderStrokeWidth;
          break;
        case "__SpreadsheetTransformerResizeLT__" /* RESIZE_LT */:
          left += -this.borderSpacing - this.borderStrokeWidth;
          top += -this.borderSpacing - this.borderStrokeWidth;
          break;
        case "__SpreadsheetTransformerResizeCT__" /* RESIZE_CT */:
          left += width / 2;
          top += -this.borderSpacing - this.borderStrokeWidth;
          break;
        case "__SpreadsheetTransformerResizeRT__" /* RESIZE_RT */:
          left += width + this.borderSpacing - this.borderStrokeWidth;
          top += -this.borderSpacing - this.borderStrokeWidth;
          break;
        case "__SpreadsheetTransformerResizeLM__" /* RESIZE_LM */:
          left += -this.borderSpacing - this.borderStrokeWidth;
          top += height / 2;
          break;
        case "__SpreadsheetTransformerResizeRM__" /* RESIZE_RM */:
          left += width + this.borderSpacing - this.borderStrokeWidth;
          top += height / 2;
          break;
        case "__SpreadsheetTransformerResizeLB__" /* RESIZE_LB */:
          left += -this.borderSpacing - this.borderStrokeWidth;
          top += height + this.borderSpacing - this.borderStrokeWidth;
          break;
        case "__SpreadsheetTransformerResizeCB__" /* RESIZE_CB */:
          left += width / 2;
          top += height + this.borderSpacing - this.borderStrokeWidth;
          break;
        case "__SpreadsheetTransformerResizeRB__" /* RESIZE_RB */:
          left += width + this.borderSpacing - this.borderStrokeWidth;
          top += height + this.borderSpacing - this.borderStrokeWidth;
          break;
      }
      return {
        left,
        top
      };
    }
    _createResizeAnchor(type, applyObject, zIndex) {
      let { height, width, scaleX, scaleY } = applyObject.getState();
      const { left, top } = this._getRotateAnchorPosition(type, height, width, scaleX, scaleY);
      const cursor = this._getRotateAnchorCursor(type);
      const anchor = new Rect(`${type}_${zIndex}`, {
        zIndex: zIndex - 1,
        fill: this.anchorFill,
        stroke: this.anchorStroke,
        strokeWidth: this.anchorStrokeWidth,
        width: this.anchorSize,
        height: this.anchorSize,
        radius: this.anchorCornerRadius,
        left,
        top
      });
      this._attachHover(anchor, cursor, "default" /* DEFAULT */);
      return anchor;
    }
    _checkTransformerType(oKey) {
      if (oKey.indexOf("__SpreadsheetTransformerOutline__" /* OUTLINE */) > -1) {
        return "__SpreadsheetTransformerOutline__" /* OUTLINE */;
      }
      if (oKey.indexOf("__SpreadsheetTransformerRotate__" /* ROTATE */) > -1) {
        return "__SpreadsheetTransformerRotate__" /* ROTATE */;
      }
      if (oKey.indexOf("__SpreadsheetTransformerRotateLine__" /* ROTATE_LINE */) > -1) {
        return "__SpreadsheetTransformerRotateLine__" /* ROTATE_LINE */;
      }
      if (oKey.indexOf("__SpreadsheetTransformerResizeLT__" /* RESIZE_LT */) > -1) {
        return "__SpreadsheetTransformerResizeLT__" /* RESIZE_LT */;
      }
      if (oKey.indexOf("__SpreadsheetTransformerResizeCT__" /* RESIZE_CT */) > -1) {
        return "__SpreadsheetTransformerResizeCT__" /* RESIZE_CT */;
      }
      if (oKey.indexOf("__SpreadsheetTransformerResizeRT__" /* RESIZE_RT */) > -1) {
        return "__SpreadsheetTransformerResizeRT__" /* RESIZE_RT */;
      }
      if (oKey.indexOf("__SpreadsheetTransformerResizeLM__" /* RESIZE_LM */) > -1) {
        return "__SpreadsheetTransformerResizeLM__" /* RESIZE_LM */;
      }
      if (oKey.indexOf("__SpreadsheetTransformerResizeRM__" /* RESIZE_RM */) > -1) {
        return "__SpreadsheetTransformerResizeRM__" /* RESIZE_RM */;
      }
      if (oKey.indexOf("__SpreadsheetTransformerResizeLB__" /* RESIZE_LB */) > -1) {
        return "__SpreadsheetTransformerResizeLB__" /* RESIZE_LB */;
      }
      if (oKey.indexOf("__SpreadsheetTransformerResizeCB__" /* RESIZE_CB */) > -1) {
        return "__SpreadsheetTransformerResizeCB__" /* RESIZE_CB */;
      }
      if (oKey.indexOf("__SpreadsheetTransformerResizeRB__" /* RESIZE_RB */) > -1) {
        return "__SpreadsheetTransformerResizeRB__" /* RESIZE_RB */;
      }
    }
    _updateControlIterator(func) {
      this._transformerControlMap.forEach((control, oKey) => {
        const applyObject = this._selectedObjectMap.get(oKey);
        if (!applyObject) {
          return true;
        }
        func(control, applyObject);
      });
    }
    _updateControl() {
      this._updateControlIterator((control, applyObject) => {
        const { left, top } = applyObject.getState();
        control.transformByState({
          left,
          top
        });
        control.show();
        control.makeDirty(true);
      });
    }
    _hiddenControl() {
      this._transformerControlMap.forEach((control) => {
        control.hide();
        control.makeDirty(true);
      });
    }
    _attachHover(o4, cursorIn, cursorOut) {
      o4.onPointerEnterObserver.add(() => {
        o4.cursor = cursorIn;
      });
      o4.onPointerLeaveObserver.add(() => {
        o4.cursor = cursorOut;
      });
    }
    _clearControl() {
      this._transformerControlMap.forEach((control) => {
        control.dispose();
      });
      this._transformerControlMap.clear();
      this.onClearControlObservable.notifyObservers(null);
    }
    _createControl(applyObject) {
      let { left, top, height, width, angle, scaleX, scaleY, skewX, skewY, flipX, flipY } = applyObject.getState();
      const oKey = applyObject.oKey;
      const zIndex = this._selectedObjectMap.size;
      const groupElements = [];
      if (this.borderEnabled) {
        const outline = new Rect(`${"__SpreadsheetTransformerOutline__" /* OUTLINE */}_${zIndex}`, {
          zIndex: zIndex - 1,
          evented: false,
          strokeWidth: this.borderStrokeWidth,
          stroke: this.borderStroke,
          ...this._getOutlinePosition(width, height, scaleX, scaleY)
        });
        groupElements.push(outline);
      }
      if (this.resizeEnabled) {
        const { left: lineLeft, top: lineTop } = this._getRotateAnchorPosition("__SpreadsheetTransformerRotateLine__" /* ROTATE_LINE */, height, width, scaleX, scaleY);
        const rotateLine = new Rect(`${"__SpreadsheetTransformerRotateLine__" /* ROTATE_LINE */}_${zIndex}`, {
          zIndex: zIndex - 1,
          evented: false,
          left: lineLeft,
          top: lineTop,
          height: this.rotateAnchorOffset,
          width: 1,
          strokeWidth: this.borderStrokeWidth,
          stroke: this.borderStroke
        });
        const { left: left2, top: top2 } = this._getRotateAnchorPosition("__SpreadsheetTransformerRotate__" /* ROTATE */, height, width, scaleX, scaleY);
        const cursor = this._getRotateAnchorCursor("__SpreadsheetTransformerRotate__" /* ROTATE */);
        const rotate = new Rect(`${"__SpreadsheetTransformerRotate__" /* ROTATE */}_${zIndex}`, {
          zIndex: zIndex - 1,
          left: left2,
          top: top2,
          height: this.rotateSize,
          width: this.rotateSize,
          radius: this.rotateCornerRadius,
          strokeWidth: this.borderStrokeWidth * 2,
          stroke: this.borderStroke
        });
        this._attachEventToRotate(rotate);
        this._attachHover(rotate, cursor, "default" /* DEFAULT */);
        groupElements.push(rotateLine, rotate);
      }
      if (this.resizeEnabled) {
        for (let i4 = 0, len = this.enabledAnchors.length; i4 < len; i4++) {
          const isEnable = this.enabledAnchors[i4];
          if (isEnable !== 1) {
            continue;
          }
          const type = TransformerManagerTypeArray[i4];
          const anchor = this._createResizeAnchor(type, applyObject, zIndex);
          this._attachEventToAnchor(anchor, type);
          groupElements.push(anchor);
        }
      }
      const transformerControl = new Group(`${"__SpreadsheetTransformer__" /* GROUP */}_${zIndex}`, ...groupElements);
      transformerControl.zIndex = zIndex;
      transformerControl.evented = false;
      transformerControl.transformByState({
        left,
        top
      });
      const scene = this.getScene();
      scene.addObject(transformerControl, 2);
      console.log(scene, applyObject);
      this._transformerControlMap.set(oKey, transformerControl);
      this.onCreateControlObservable.notifyObservers(transformerControl);
      return transformerControl;
    }
    _getTopScene() {
      const currentScene = this.getScene();
      return currentScene.getEngine()?.activeScene;
    }
    _moving(moveOffsetX, moveOffsetY, scrollTimer) {
      const { scrollX: scrollX2, scrollY: scrollY2 } = getCurrentScrollXY(scrollTimer);
      const x4 = moveOffsetX - this._viewportScrollX + scrollX2;
      const y4 = moveOffsetY - this._viewportScrollY + scrollY2;
      const moveLeft = x4 - this._startOffsetX;
      const moveTop = y4 - this._startOffsetY;
      this._selectedObjectMap.forEach((moveObject) => {
        moveObject.translate(moveLeft + moveObject.left, moveTop + moveObject.top);
      });
      this.onChangingObservable.notifyObservers({
        objects: this._selectedObjectMap,
        moveX: moveLeft,
        moveY: moveTop,
        type: 1 /* MOVING */
      });
      this._startOffsetX = x4;
      this._startOffsetY = y4;
    }
    _updateActiveObjectList(applyObject, evt) {
      if (this._selectedObjectMap.has(applyObject.oKey)) {
        return;
      }
      if (!evt.ctrlKey) {
        this._selectedObjectMap.clear();
        this._clearControl();
      }
      this._selectedObjectMap.set(applyObject.oKey, applyObject);
      this._createControl(applyObject);
    }
    _addCancelObserver(scene) {
      scene.onPointerDownObserver.remove(this._cancelFocusObserver);
      this._cancelFocusObserver = scene.onPointerDownObserver.add((moveEvt) => {
        this._selectedObjectMap.clear();
        this._clearControl();
        scene.onPointerDownObserver.remove(this._cancelFocusObserver);
      });
    }
  };

  // ../../packages/base-render/src/Scene.ts
  var Scene = class {
    constructor(sceneKey, _parent, state) {
      this._parent = _parent;
      this._sceneKey = sceneKey;
      if (state) {
        this.transformByState(state);
      }
      if (this._parent.classType === "Engine" /* ENGINE */) {
        const parent = this._parent;
        parent.addScene(this);
        if (!parent.hasActiveScene()) {
          parent.setActiveScene(sceneKey);
        }
        this._inputManager = new InputManager(this);
      } else if (this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        const parent = this._parent;
        parent.addSubScene(this);
      }
      this._parent?.onTransformChangeObservable.add((change) => {
        this._resetViewportSize();
        this._setTransForm();
      });
    }
    // onPointerMove: (evt: IPointerEvent | IMouseEvent) => void;
    // onPointerDown: (evt: IPointerEvent | IMouseEvent) => void;
    // onPointerUp: (evt: IPointerEvent | IMouseEvent) => void;
    // onDblclick: (evt: IPointerEvent | IMouseEvent) => void;
    // onMouseWheel: (evt: IWheelEvent) => void;
    onPointerDownObserver = new Observable();
    onPointerMoveObserver = new Observable();
    onPointerUpObserver = new Observable();
    onDblclickObserver = new Observable();
    onMouseWheelObserver = new Observable();
    onKeyDownObservable = new Observable();
    onKeyUpObservable = new Observable();
    onTransformChangeObservable = new Observable();
    // private _ObjectsForward = new Array<BaseObject>();
    // private _ObjectsBack = new Array<BaseObject>();
    _layers = [];
    _sceneKey = "";
    _viewports = [];
    _width = 100;
    _height = 100;
    _scaleX = 1;
    _scaleY = 1;
    _transform = new Transform();
    _isFirstDirty = true;
    _maxZIndex;
    _evented = true;
    _cursor = "default" /* DEFAULT */;
    /**
     * Transformer constructor.  Transformer is a special type of group that allow you transform
     * primitives and shapes. Transforming tool is not changing `width` and `height` properties of nodes
     * when you resize them. Instead it changes `scaleX` and `scaleY` properties.
     */
    _transformer;
    _transformerOpenState = false;
    /** @hidden */
    _inputManager;
    get classType() {
      return "Scene" /* SCENE */;
    }
    get transform() {
      return this._transform;
    }
    get width() {
      return this._width;
    }
    get height() {
      return this._height;
    }
    get scaleX() {
      return this._scaleX;
    }
    get scaleY() {
      return this._scaleY;
    }
    get ancestorScaleX() {
      const p4 = this.getParent();
      let pScale = 1;
      if (p4.classType === "SceneViewer" /* SCENE_VIEWER */) {
        pScale = p4.ancestorScaleX;
      }
      return this._scaleX * pScale;
    }
    get ancestorScaleY() {
      const p4 = this.getParent();
      let pScale = 1;
      if (p4.classType === "SceneViewer" /* SCENE_VIEWER */) {
        pScale = p4.ancestorScaleY;
      }
      return this._scaleY * pScale;
    }
    get cursor() {
      return this._cursor;
    }
    get sceneKey() {
      return this._sceneKey;
    }
    get evented() {
      return this._evented;
    }
    set transform(trans) {
      this._transform = trans;
    }
    set cursor(val) {
      this.setCursor(val);
    }
    set width(num) {
      this._width = num;
    }
    set height(num) {
      this._height = num;
    }
    set scaleX(scaleX) {
      this._scaleX = scaleX;
    }
    set scaleY(scaleY) {
      this._scaleY = scaleY;
    }
    attachControl(hasDown = true, hasUp = true, hasMove = true, hasWheel = true) {
      if (!(this._parent.classType === "Engine" /* ENGINE */)) {
        return;
      }
      this._inputManager?.attachControl(hasDown, hasUp, hasMove, hasWheel);
      return this;
    }
    detachControl() {
      this._inputManager?.detachControl();
      return this;
    }
    makeDirty(state = true) {
      this._viewports.forEach((vp) => {
        vp.makeDirty(state);
      });
      if (this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        this._parent?.makeDirty(state);
      }
      return this;
    }
    makeDirtyNoParent(state = true) {
      this._viewports.forEach((vp) => {
        vp.makeDirty(state);
      });
      return this;
    }
    isDirty() {
      for (let i4 = 0; i4 < this._viewports.length; i4++) {
        const vp = this._viewports[i4];
        if (vp.isDirty() === true) {
          return true;
        }
      }
      return false;
    }
    resetCursor() {
      this.setCursor("default" /* DEFAULT */);
    }
    setCursor(val) {
      this._cursor = val;
      const engine = this.getEngine();
      if (!engine) {
        return;
      }
      const canvasEl = engine.getCanvas().getCanvasEle();
      canvasEl.style.cursor = val;
    }
    resize(width, height) {
      const preWidth = this.width;
      if (width !== void 0) {
        this.width = width;
      }
      const preHeight = this.height;
      if (height !== void 0) {
        this.height = height;
      }
      this._setTransForm();
      this.onTransformChangeObservable.notifyObservers({
        type: 1 /* resize */,
        value: {
          width: this.width,
          height: this.height
        },
        preValue: { width: preWidth, height: preHeight }
      });
      return this;
    }
    scale(scaleX, scaleY) {
      const preScaleX = this.scaleX;
      if (scaleX !== void 0) {
        this.scaleX = scaleX;
      }
      const preScaleY = this.scaleY;
      if (scaleY !== void 0) {
        this.scaleY = scaleY;
      }
      this._setTransForm();
      this.onTransformChangeObservable.notifyObservers({
        type: 2 /* scale */,
        value: {
          scaleX: this.scaleX,
          scaleY: this.scaleY
        },
        preValue: { scaleX: preScaleX, scaleY: preScaleY }
      });
      return this;
    }
    scaleBy(scaleX, scaleY) {
      const preScaleX = this.scaleX;
      if (scaleX !== void 0) {
        this.scaleX += scaleX;
      }
      const preScaleY = this.scaleY;
      if (scaleY !== void 0) {
        this.scaleY += scaleY;
      }
      this.scaleX = precisionTo(this.scaleX, 1);
      this.scaleY = precisionTo(this.scaleY, 1);
      this._setTransForm();
      this.onTransformChangeObservable.notifyObservers({
        type: 2 /* scale */,
        value: {
          scaleX: this.scaleX,
          scaleY: this.scaleY
        },
        preValue: { scaleX: preScaleX, scaleY: preScaleY }
      });
      return this;
    }
    transformByState(state) {
      const optionKeys = Object.keys(state);
      const preKeys = {};
      if (optionKeys.length === 0) {
        return;
      }
      optionKeys.forEach((pKey) => {
        if (state[pKey] !== void 0) {
          preKeys[pKey] = this[pKey];
          this[pKey] = state[pKey];
        }
      });
      this._setTransForm();
      this.onTransformChangeObservable.notifyObservers({
        type: 5 /* all */,
        value: state,
        preValue: preKeys
      });
    }
    getParent() {
      return this._parent;
    }
    getEngine() {
      if (this._parent.classType === "Engine" /* ENGINE */) {
        return this._parent;
      }
      let parent = this._parent;
      while (parent) {
        if (parent.classType === "Engine" /* ENGINE */) {
          return parent;
        }
        parent = parent?.getParent();
      }
      return null;
    }
    getLayers() {
      return this._layers;
    }
    getLayer(zIndex = 1) {
      for (let layer of this._layers) {
        if (layer.zIndex === zIndex) {
          return layer;
        }
      }
      return this._createDefaultLayer(zIndex);
    }
    getLayerMaxZIndex() {
      let maxIndex = Number.MIN_VALUE;
      for (let i4 = 0; i4 < this._layers.length; i4++) {
        const layer = this._layers[i4];
        if (layer.zIndex >= maxIndex) {
          maxIndex = layer.zIndex;
        }
      }
      return maxIndex;
    }
    addLayer(...argument) {
      this._layers.push(...argument);
    }
    // getBackObjects() {
    //     return [...this._ObjectsBack];
    // }
    // getForwardObjects() {
    //     return [...this._ObjectsForward];
    // }
    addObject(o4, zIndex = 1) {
      this.getLayer(zIndex)?.addObject(o4);
      return this;
    }
    // addObjectForward(o: BaseObject) {
    //     this._ObjectsForward.push(o);
    //     this._setObjectBehavior(o);
    //     return this;
    // }
    // addObjectBack(o: BaseObject) {
    //     this._ObjectsBack.push(o);
    //     this._setObjectBehavior(o);
    //     return this;
    // }
    setObjectBehavior(o4) {
      if (!o4.parent) {
        o4.parent = this;
      }
      this.onTransformChangeObservable.add((state) => {
        o4.scaleCacheCanvas();
      });
      o4.onIsAddedToParentObserver.notifyObservers(this);
    }
    addObjects(objects, zIndex = 1) {
      this.getLayer(zIndex)?.addObjects(objects);
      return this;
    }
    removeObject(object) {
      if (object == null) {
        return;
      }
      const layers = this.getLayers();
      for (let layer of layers) {
        layer.removeObject(object);
      }
      return this;
    }
    removeObjects(objects) {
      if (objects == null) {
        return;
      }
      const layers = this.getLayers();
      for (let layer of layers) {
        layer.removeObjects(objects);
      }
      return this;
    }
    // addBackObjects(...argument: BaseObject[]) {
    //     argument.forEach((o: BaseObject) => {
    //         this.addObjectBack(o);
    //     });
    //     return this;
    // }
    // addForwardObjects(...argument: BaseObject[]) {
    //     argument.forEach((o: BaseObject) => {
    //         this.addObjectForward(o);
    //     });
    //     return this;
    // }
    getAllObjects() {
      const objects = [];
      this._layers.sort(sortRules);
      for (let layer of this._layers) {
        objects.push(...layer.getObjectsByOrder());
      }
      return objects;
    }
    getAllObjectsByOrder(isDesc = false) {
      const objects = [];
      const useSortRules = isDesc ? sortRulesByDesc : sortRules;
      this._layers.sort(useSortRules);
      for (let layer of this._layers) {
        objects.push(...layer.getObjectsByOrder().sort(useSortRules));
      }
      return objects;
    }
    getAllObjectsByOrderForPick(isDesc = false) {
      const objects = [];
      const useSortRules = isDesc ? sortRulesByDesc : sortRules;
      this._layers.sort(useSortRules);
      for (let layer of this._layers) {
        objects.push(...layer.getObjectsByOrderForPick().sort(useSortRules));
      }
      return objects;
    }
    getObject(oKey) {
      for (let layer of this._layers) {
        const objects = layer.getObjectsByOrder();
        for (let object of objects) {
          if (object.oKey === oKey) {
            return object;
          }
        }
      }
    }
    fuzzyMathObjects(oKey) {
      const objects = [];
      for (let layer of this._layers) {
        const objects2 = layer.getObjectsByOrder();
        for (let object of objects2) {
          if (object.oKey.indexOf(oKey) > -1) {
            objects2.push(object);
          }
        }
      }
      return objects;
    }
    addViewport(...viewport) {
      this._viewports.push(...viewport);
      return this;
    }
    removeViewport() {
    }
    getViewports() {
      return this._viewports;
    }
    getViewport(key) {
      for (let viewport of this._viewports) {
        if (viewport.viewPortKey === key) {
          return viewport;
        }
      }
    }
    changeObjectOrder() {
    }
    renderObjects(ctx, bounds) {
      this.getAllObjectsByOrder().forEach((o4) => {
        o4.render(ctx, bounds);
      });
      return this;
    }
    render(parentCtx) {
      if (!this.isDirty()) {
        return;
      }
      !parentCtx && this.getEngine()?.getCanvas().clear();
      this.getViewports()?.forEach((vp) => vp.render(parentCtx));
    }
    enableEvent() {
      this._evented = true;
    }
    disableEvent() {
      this._evented = false;
    }
    async requestRender(parentCtx) {
      return new Promise((resolve, reject) => {
        this.render(parentCtx);
        requestNewFrame(resolve);
      });
    }
    openTransformer(config) {
      if (!this._transformer) {
        this._transformer = new Transformer(this, config);
      }
      this._transformerOpenState = true;
    }
    closeTransformer(isDestroyed = false) {
      if (isDestroyed) {
        this._transformer = null;
      }
      this._transformerOpenState = false;
    }
    applyTransformer(o4) {
      if (!this._transformerOpenState) {
        return;
      }
      this._transformer?.attachTo(o4);
    }
    getTransformer() {
      return this._transformer;
    }
    getActiveViewportByRelativeCoord(coord) {
      return this._viewports.find((vp) => vp.isHit(coord));
    }
    getActiveViewportByCoord(coord) {
      coord = this.getRelativeCoord(coord);
      return this.getActiveViewportByRelativeCoord(coord);
    }
    getRelativeCoord(coord) {
      let parent = this.getParent();
      const parentList = [];
      while (parent) {
        if (parent.classType === "Scene" /* SCENE */ || parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
          parentList.push(parent);
        }
        parent = parent?.getParent && parent?.getParent();
      }
      parentList.reverse();
      for (let parent2 of parentList) {
        if (parent2.classType === "Scene" /* SCENE */) {
          const scene = parent2;
          const viewPort = scene.getActiveViewportByCoord(coord);
          if (viewPort) {
            const actualX = viewPort.actualScrollX || 0;
            const actualY = viewPort.actualScrollY || 0;
            coord = coord.addByPoint(actualX, actualY);
          }
        } else if (parent2.classType === "SceneViewer" /* SCENE_VIEWER */) {
          const sv = parent2;
          const transform = sv.transform.clone().invert();
          coord = transform.applyPoint(coord);
        }
      }
      return coord;
    }
    transformToSceneCoord(coord) {
      const pickedViewport = this.getActiveViewportByCoord(coord);
      return pickedViewport?.getRelativeVector(coord);
    }
    clearLayer() {
      this._layers = [];
    }
    clearViewports() {
      this._viewports = [];
    }
    dispose() {
      this.getLayers().forEach((layer) => {
        layer.dispose();
      });
      this.getViewports().forEach((viewport) => {
        viewport.dispose();
      });
      this.clearLayer();
      this.clearViewports();
      this.detachControl();
      this._transformer?.dispose();
      this.onPointerDownObserver.clear();
      this.onPointerMoveObserver.clear();
      this.onPointerUpObserver.clear();
      this.onDblclickObserver.clear();
      this.onMouseWheelObserver.clear();
      this.onKeyDownObservable.clear();
      this.onKeyUpObservable.clear();
    }
    // Determine the only object selected
    pick(coord) {
      let pickedViewport = this.getActiveViewportByCoord(coord);
      if (!pickedViewport) {
        pickedViewport = this._viewports[0];
      }
      if (!this._evented || !pickedViewport) {
        return;
      }
      const scrollBarRect = pickedViewport.pickScrollBar(coord);
      if (scrollBarRect) {
        return scrollBarRect;
      }
      const svCoordOrigin = pickedViewport.getRelativeVector(coord);
      let isPickedObject = null;
      const objectOrder = this.getAllObjectsByOrderForPick().reverse();
      const objectLength = objectOrder.length;
      for (let i4 = 0; i4 < objectLength; i4++) {
        const o4 = objectOrder[i4];
        if (!o4.visible || !o4.evented || o4.classType === "Group" /* GROUP */) {
          continue;
        }
        let svCoord = svCoordOrigin;
        if (o4.isInGroup && o4.parent.classType === "Group" /* GROUP */) {
          const { cumLeft, cumTop } = this._getGroupCumLeftRight(o4);
          svCoord = svCoord.clone().add(Vector2.FromArray([-cumLeft, -cumTop]));
        }
        if (o4.isHit(svCoord)) {
          if (o4.classType === "SceneViewer" /* SCENE_VIEWER */) {
            const pickedObject = o4.pick(svCoord);
            if (pickedObject) {
              isPickedObject = pickedObject;
            } else {
              isPickedObject = o4.getActiveSubScene();
            }
          } else {
            isPickedObject = o4;
          }
          break;
        } else if (o4.classType === "SceneViewer" /* SCENE_VIEWER */ && o4.allowSelectedClipElement()) {
          const pickedObject = o4.pick(svCoord);
          if (pickedObject) {
            isPickedObject = pickedObject;
            break;
          }
        }
      }
      if (!isPickedObject && this._parent.classType === "Engine" /* ENGINE */) {
        return this;
      }
      return isPickedObject;
    }
    on(eventType, func) {
      const observable = this[`on${eventType}Observer`];
      const observer = observable.add(func.bind(this));
      return observer;
    }
    off(eventType, observer) {
      const observable = this[`on${eventType}Observer`];
      observable.remove(observer);
    }
    remove(eventType) {
      const observable = this[`on${eventType}Observer`];
      observable.clear();
    }
    triggerKeyDown(evt) {
      this.onKeyDownObservable.notifyObservers(evt);
    }
    triggerKeyUp(evt) {
      this.onKeyUpObservable.notifyObservers(evt);
    }
    triggerPointerUp(evt) {
      if (!this.onPointerUpObserver.notifyObservers(evt)?.stopPropagation && this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        this._parent?.triggerPointerUp(evt);
        return false;
      }
      return true;
    }
    triggerMouseWheel(evt) {
      if (!this.onMouseWheelObserver.notifyObservers(evt)?.stopPropagation && this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        this._parent?.triggerMouseWheel(evt);
        return false;
      }
      return true;
    }
    triggerPointerMove(evt) {
      if (!this.onPointerMoveObserver.notifyObservers(evt)?.stopPropagation && this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        this._parent?.triggerPointerMove(evt);
        return false;
      }
      return true;
    }
    triggerDblclick(evt) {
      if (!this.onDblclickObserver.notifyObservers(evt)?.stopPropagation && this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        this._parent?.triggerDblclick(evt);
        return false;
      }
      return true;
    }
    triggerPointerDown(evt) {
      if (!this.onPointerDownObserver.notifyObservers(evt)?.stopPropagation && this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        this._parent?.triggerPointerDown(evt);
        return false;
      }
      return true;
    }
    triggerPointerOut(evt) {
      if (this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        this._parent?.triggerPointerOut(evt);
        return false;
      }
      return true;
    }
    triggerPointerLeave(evt) {
      if (this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        this._parent?.triggerPointerLeave(evt);
        return false;
      }
      return true;
    }
    triggerPointerOver(evt) {
      if (this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        this._parent?.triggerPointerOver(evt);
        return false;
      }
      return true;
    }
    triggerPointerEnter(evt) {
      if (this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        this._parent?.triggerPointerEnter(evt);
        return false;
      }
      return true;
    }
    _createDefaultLayer(zIndex = 1) {
      const defaultLayer = Layer.create(this, [], zIndex);
      this.addLayer(defaultLayer);
      return defaultLayer;
    }
    _resetViewportSize() {
      this.getViewports().forEach((vp) => {
        vp.resetSize();
      });
    }
    _setTransForm() {
      const composeResult = Transform.create().composeMatrix({
        scaleX: this.scaleX,
        scaleY: this.scaleY
      });
      this.transform = composeResult;
      this.getViewports().forEach((vp) => {
        vp.resizeScrollBar();
      });
      this.makeDirty(true);
    }
    _getGroupCumLeftRight(object) {
      let parent = object.parent;
      let cumLeft = 0;
      let cumTop = 0;
      while (parent.classType === "Group" /* GROUP */) {
        const { left, top } = parent;
        cumLeft += left;
        cumTop += top;
        parent = parent.parent;
      }
      return { cumLeft, cumTop };
    }
  };

  // ../../packages/base-render/src/Viewport.ts
  var Viewport = class {
    scrollX = 0;
    scrollY = 0;
    actualScrollX;
    actualScrollY;
    onMouseWheelObserver = new Observable();
    onScrollAfterObserver = new Observable();
    onScrollBeforeObserver = new Observable();
    onScrollStopObserver = new Observable();
    _viewPortKey;
    _dirty = true;
    _topOrigin = 0;
    _leftOrigin = 0;
    _bottomOrigin = 0;
    _rightOrigin = 0;
    _widthOrigin;
    _heightOrigin;
    _top = 0;
    _left = 0;
    _bottom = 0;
    _right = 0;
    _width;
    _height;
    _scene;
    _cacheCanvas;
    _scrollBar;
    _isWheelPreventDefaultX = false;
    _isWheelPreventDefaultY = false;
    _allowCache = false;
    _scrollStopNum;
    _preScrollX = 0;
    _preScrollY = 0;
    _renderClipState = true;
    constructor(viewPortKey, scene, props) {
      this._viewPortKey = viewPortKey;
      this._scene = scene;
      this.top = props?.top || 0;
      this.left = props?.left || 0;
      this.bottom = props?.bottom || 0;
      this.right = props?.right || 0;
      if (props?.width) {
        this.width = props?.width;
        this._widthOrigin = this.width;
      }
      if (props?.height) {
        this.height = props?.height;
        this._heightOrigin = this.height;
      }
      if (this._allowCache) {
        this._cacheCanvas = new Canvas();
      }
      this._isWheelPreventDefaultX = props?.isWheelPreventDefaultX || false;
      this._isWheelPreventDefaultY = props?.isWheelPreventDefaultY || false;
      this._resizeCacheCanvasAndScrollBar();
      this._scene?.getParent().onTransformChangeObservable.add(() => {
        this._resizeCacheCanvasAndScrollBar();
      });
    }
    get scene() {
      return this._scene;
    }
    get width() {
      return this._width;
    }
    get height() {
      return this._height;
    }
    get viewPortKey() {
      return this._viewPortKey;
    }
    get topOrigin() {
      return this._topOrigin;
    }
    get leftOrigin() {
      return this._leftOrigin;
    }
    get bottomOrigin() {
      return this._bottomOrigin;
    }
    get rightOrigin() {
      return this._rightOrigin;
    }
    get top() {
      return this._top;
    }
    get left() {
      return this._left;
    }
    get bottom() {
      return this._bottom;
    }
    get right() {
      return this._right;
    }
    set width(w4) {
      this._width = w4;
    }
    set height(h4) {
      this._height = h4;
    }
    set top(num) {
      this._topOrigin = num;
      this._top = toPx(num, this._scene?.getParent()?.height);
    }
    set left(num) {
      this._leftOrigin = num;
      this._left = toPx(num, this.scene.getParent()?.width);
    }
    set bottom(num) {
      this._bottomOrigin = num;
      this._bottom = toPx(num, this.scene.getParent()?.height);
    }
    set right(num) {
      this._rightOrigin = num;
      this._right = toPx(num, this.scene.getParent()?.width);
    }
    resetSize() {
      this._resizeCacheCanvasAndScrollBar(true);
    }
    setScrollBar(instance) {
      if (this._scrollBar) {
        console.warn("Old scrollBar will be replaced ");
      }
      this._scrollBar = instance;
      this._resizeCacheCanvasAndScrollBar();
    }
    resize(position) {
      const positionKeys = Object.keys(position);
      if (positionKeys.length === 0) {
        return;
      }
      this._width = void 0;
      this._height = void 0;
      positionKeys.forEach((pKey) => {
        if (position[pKey] !== void 0) {
          this[pKey] = position[pKey];
        }
      });
      this._resizeCacheCanvasAndScrollBar();
    }
    resizeScrollBar() {
      this._resizeCacheCanvasAndScrollBar();
    }
    makeDirty(state = true) {
      this._dirty = state;
    }
    isDirty() {
      return this._dirty;
    }
    scrollTo(pos) {
      return this._scroll(0 /* scrollTo */, pos);
    }
    scrollBy(pos) {
      return this._scroll(1 /* scrollBy */, pos);
    }
    getBarScroll(actualX, actualY) {
      let x4 = actualX;
      let y4 = actualY;
      if (this._scrollBar) {
        x4 *= this._scrollBar.ratioScrollX;
        y4 *= this._scrollBar.ratioScrollY;
        const { scaleX, scaleY } = this.scene;
        x4 = Math.round(x4) * scaleX;
        y4 = Math.round(y4) * scaleY;
      } else {
        if (this.scrollX !== void 0) {
          x4 = this.scrollX;
        }
        if (this.scrollY !== void 0) {
          y4 = this.scrollY;
        }
      }
      return {
        x: x4,
        y: y4
      };
    }
    getActualScroll(scrollX2, scrollY2) {
      let x4 = scrollX2;
      let y4 = scrollY2;
      if (this._scrollBar) {
        x4 /= this._scrollBar.ratioScrollX;
        y4 /= this._scrollBar.ratioScrollY;
        const { scaleX, scaleY } = this.scene;
        x4 = Math.round(x4) / scaleX;
        y4 = Math.round(y4) / scaleY;
      } else {
        if (this.actualScrollX !== void 0) {
          x4 = this.actualScrollX;
        }
        if (this.actualScrollY !== void 0) {
          y4 = this.actualScrollY;
        }
      }
      return {
        x: x4,
        y: y4
      };
    }
    transformScroll() {
      let x4 = this.scrollX;
      let y4 = this.scrollY;
      return this.getActualScroll(x4, y4);
    }
    getScrollBar() {
      return this._scrollBar;
    }
    updateScroll(param) {
      this._preScrollX = this.scrollX;
      this._preScrollY = this.scrollY;
      const { scrollX: scrollX2, scrollY: scrollY2, actualScrollX, actualScrollY } = param;
      if (scrollX2 !== void 0) {
        this.scrollX = scrollX2;
      }
      if (scrollY2 !== void 0) {
        this.scrollY = scrollY2;
      }
      if (actualScrollX !== void 0) {
        this.actualScrollX = actualScrollX;
      }
      if (actualScrollY !== void 0) {
        this.actualScrollY = actualScrollY;
      }
      return this;
    }
    getScrollBarTransForm(isMouseFix = false) {
      const composeResult = Transform.create();
      if (isMouseFix || !this._allowCache) {
        composeResult.multiply(Transform.create([1, 0, 0, 1, this._left, this._top]));
      }
      return composeResult;
    }
    render(parentCtx) {
      const mainCtx = parentCtx || this._scene.getEngine()?.getCanvas().getContext();
      if (!this.isDirty() && this._allowCache) {
        this._applyCache(mainCtx);
        return;
      }
      let sceneTrans = this._scene.transform.clone();
      sceneTrans.multiply(Transform.create([1, 0, 0, 1, -this.actualScrollX || 0, -this.actualScrollY || 0]));
      let ctx = mainCtx;
      if (!ctx) {
        return;
      }
      const applyCanvasState = this._getApplyCanvasState();
      if (applyCanvasState) {
        sceneTrans.multiply(Transform.create([1, 0, 0, 1, -this.left / this._scene.scaleX, -this.top / this._scene.scaleY]));
        ctx = this._cacheCanvas.getContext();
        this._cacheCanvas.clear();
      }
      const m4 = sceneTrans.getMatrix();
      const n3 = this.getScrollBarTransForm().getMatrix();
      ctx.save();
      if (!applyCanvasState && this._renderClipState) {
        ctx.beginPath();
        ctx.rect(this.left, this.top, this.width || 0, this.height || 0);
        ctx.clip();
      }
      ctx.transform(m4[0], m4[1], m4[2], m4[3], m4[4], m4[5]);
      this._scene.renderObjects(ctx, this._calViewportRelativeBounding());
      ctx.restore();
      if (this._scrollBar) {
        ctx.save();
        ctx.transform(n3[0], n3[1], n3[2], n3[3], n3[4], n3[5]);
        this.drawScrollbar(ctx);
        ctx.restore();
      }
      if (applyCanvasState)
        this._applyCache(mainCtx);
      this.makeDirty(false);
      this._scrollRendered();
    }
    getBounding() {
      return this._calViewportRelativeBounding();
    }
    getRelativeVector(coord) {
      const sceneTrans = this.scene.transform.clone().invert();
      const scroll = this.transformScroll();
      const svCoord = sceneTrans.applyPoint(coord).add(Vector2.FromArray([scroll.x, scroll.y]));
      return svCoord;
    }
    getAbsoluteVector(coord) {
      const sceneTrans = this.scene.transform.clone();
      const scroll = this.transformScroll();
      const svCoord = sceneTrans.applyPoint(coord).subtract(Vector2.FromArray([scroll.x, scroll.y]));
      return svCoord;
    }
    onMouseWheel(evt, state) {
      if (!this._scrollBar) {
        return;
      }
      let isLimitedStore;
      if (evt.inputIndex === 7 /* MouseWheelX */) {
        const deltaFactor = Math.abs(evt.deltaX);
        const allWidth = this._scene.width;
        const viewWidth = this.width || 1;
        let scrollNum = viewWidth / allWidth * deltaFactor;
        if (evt.deltaX > 0) {
          isLimitedStore = this.scrollBy({
            x: scrollNum
          });
        } else {
          isLimitedStore = this.scrollBy({
            x: -scrollNum
          });
        }
        if (this._scene.getParent().classType === "SceneViewer" /* SCENE_VIEWER */) {
          if (!isLimitedStore?.isLimitedX) {
            state.stopPropagation();
          }
        } else if (this._isWheelPreventDefaultX) {
          evt.preventDefault();
        } else if (!isLimitedStore?.isLimitedX) {
          evt.preventDefault();
        }
      }
      if (evt.inputIndex === 8 /* MouseWheelY */) {
        const deltaFactor = Math.abs(evt.deltaY);
        const allHeight = this._scene.height;
        const viewHeight = this.height || 1;
        let scrollNum = viewHeight / allHeight * deltaFactor;
        if (evt.shiftKey) {
          if (evt.deltaY > 0) {
            isLimitedStore = this.scrollBy({
              x: scrollNum
            });
          } else {
            isLimitedStore = this.scrollBy({
              x: -scrollNum
            });
          }
          if (this._scene.getParent().classType === "SceneViewer" /* SCENE_VIEWER */) {
            if (!isLimitedStore?.isLimitedX) {
              state.stopPropagation();
            }
          } else if (this._isWheelPreventDefaultX) {
            evt.preventDefault();
          } else if (!isLimitedStore?.isLimitedX) {
            evt.preventDefault();
          }
        } else {
          if (evt.deltaY > 0) {
            isLimitedStore = this.scrollBy({
              y: scrollNum
            });
          } else {
            isLimitedStore = this.scrollBy({
              y: -scrollNum
            });
          }
          if (this._scene.getParent().classType === "SceneViewer" /* SCENE_VIEWER */) {
            if (!isLimitedStore?.isLimitedY) {
              state.stopPropagation();
            }
          } else if (this._isWheelPreventDefaultY) {
            evt.preventDefault();
          } else if (!isLimitedStore?.isLimitedY) {
            evt.preventDefault();
          }
        }
      }
      if (evt.inputIndex === 9 /* MouseWheelZ */) {
      }
    }
    // 
    isHit(coord) {
      const { width, height } = this._getViewPortSize();
      if (coord.x >= this.left && coord.x <= this.left + width && coord.y >= this.top && coord.y <= this.top + height) {
        return true;
      }
      return false;
    }
    pickScrollBar(coord) {
      if (!this._scrollBar) {
        return;
      }
      const scrollBarTrans = this.getScrollBarTransForm(true);
      const svCoord = scrollBarTrans.invert().applyPoint(coord);
      return this._scrollBar.pick(svCoord);
    }
    openClip() {
      this._renderClipState = true;
    }
    closeClip() {
      this._renderClipState = false;
    }
    dispose() {
      this.onMouseWheelObserver.clear();
      this.onScrollAfterObserver.clear();
      this.onScrollBeforeObserver.clear();
      this.onScrollStopObserver.clear();
      this._scrollBar?.dispose();
    }
    _resizeCacheCanvasAndScrollBar(forceCalculate = false) {
      const { width, height } = this._getViewPortSize(forceCalculate);
      this.width = width;
      this.height = height;
      const contentWidth = this._scene.width * this._scene.scaleX;
      const contentHeight = this._scene.height * this._scene.scaleY;
      this._scrollBar?.resize(width, height, contentWidth, contentHeight);
      this.makeDirty(true);
    }
    _getViewPortSize(forceCalculate = false) {
      const parent = this._scene?.getParent();
      let width;
      let height;
      if (!forceCalculate && this._widthOrigin !== void 0) {
        width = this._widthOrigin;
      } else {
        const referenceWidth = parent.width;
        let containerWidth = parent.classType === "SceneViewer" /* SCENE_VIEWER */ ? referenceWidth * parent.scaleX : referenceWidth;
        width = containerWidth - (this._left + this._right);
      }
      if (!forceCalculate && this._heightOrigin !== void 0) {
        height = this._heightOrigin;
      } else {
        const referenceHeight = parent.height;
        let containerHeight = parent.classType === "SceneViewer" /* SCENE_VIEWER */ ? referenceHeight * parent.scaleY : referenceHeight;
        height = containerHeight - (this._top + this._bottom);
      }
      return {
        width,
        height
      };
    }
    _getApplyCanvasState() {
      return this._allowCache && this._renderClipState;
    }
    _scrollRendered() {
      this._preScrollX = this.scrollX;
      this._preScrollY = this.scrollY;
    }
    _limitedScroll() {
      if (!this._scrollBar) {
        return;
      }
      const limitX = this._scrollBar?.limitX || Infinity;
      const limitY = this._scrollBar?.limitY || Infinity;
      let isLimitedX = true;
      let isLimitedY = true;
      if (this.scrollX < 0) {
        this.scrollX = 0;
      } else if (this.scrollX > limitX) {
        this.scrollX = limitX;
      } else {
        isLimitedX = false;
      }
      if (this.scrollY < 0) {
        this.scrollY = 0;
      } else if (this.scrollY > limitY) {
        this.scrollY = limitY;
      } else {
        isLimitedY = false;
      }
      return {
        isLimitedX,
        isLimitedY
      };
    }
    _triggerScrollStop(scroll, x4, y4) {
      window.clearTimeout(this._scrollStopNum);
      this._scrollStopNum = window.setTimeout(() => {
        this.onScrollStopObserver.notifyObservers({
          viewport: this,
          scrollX: this.scrollX,
          scrollY: this.scrollY,
          x: x4,
          y: y4,
          actualScrollX: scroll.x,
          actualScrollY: scroll.y,
          limitX: this._scrollBar?.limitX,
          limitY: this._scrollBar?.limitY
        });
      }, 0);
    }
    _scroll(scrollType, pos) {
      const { x: x4, y: y4 } = pos;
      if (x4 !== void 0) {
        if (scrollType === 1 /* scrollBy */) {
          this.scrollX += x4;
        } else {
          this.scrollX = x4;
        }
      }
      if (y4 !== void 0) {
        if (scrollType === 1 /* scrollBy */) {
          this.scrollY += y4;
        } else {
          this.scrollY = y4;
        }
      }
      const limited = this._limitedScroll();
      this.onScrollBeforeObserver.notifyObservers({
        viewport: this,
        scrollX: this.scrollX,
        scrollY: this.scrollY,
        x: x4,
        y: y4,
        limitX: this._scrollBar?.limitX,
        limitY: this._scrollBar?.limitY
      });
      if (this._scrollBar) {
        this._scrollBar.makeDirty(true);
      } else {
        this.makeDirty(true);
      }
      const scroll = this.transformScroll();
      this.actualScrollX = scroll.x;
      this.actualScrollY = scroll.y;
      this.onScrollAfterObserver.notifyObservers({
        viewport: this,
        scrollX: this.scrollX,
        scrollY: this.scrollY,
        x: x4,
        y: y4,
        actualScrollX: scroll.x,
        actualScrollY: scroll.y,
        limitX: this._scrollBar?.limitX,
        limitY: this._scrollBar?.limitY
      });
      this._triggerScrollStop(scroll, x4, y4);
      return limited;
    }
    _calViewportRelativeBounding() {
      let ratioScrollX = this._scrollBar?.ratioScrollX ?? 1;
      let ratioScrollY = this._scrollBar?.ratioScrollY ?? 1;
      let xFrom = this.left;
      let xTo = (this.width || 0) + this.left;
      let yFrom = this.top;
      let yTo = (this.height || 0) + this.top;
      let differenceX = 0;
      let differenceY = 0;
      if (this._preScrollX != null) {
        differenceX = (this._preScrollX - this.scrollX) / ratioScrollX;
      }
      if (this._preScrollY != null) {
        differenceY = (this._preScrollY - this.scrollY) / ratioScrollY;
      }
      const bounding = {
        tl: Vector2.FromArray([xFrom, yFrom]),
        tr: Vector2.FromArray([xTo, yFrom]),
        bl: Vector2.FromArray([xFrom, yTo]),
        br: Vector2.FromArray([xTo, yTo]),
        dx: differenceX,
        dy: differenceY
      };
      bounding.tl = this.getRelativeVector(bounding.tl);
      bounding.tr = this.getRelativeVector(bounding.tr);
      bounding.bl = this.getRelativeVector(bounding.bl);
      bounding.br = this.getRelativeVector(bounding.br);
      return bounding;
    }
    drawScrollbar(ctx) {
      if (!this._scrollBar) {
        return;
      }
      const parent = this._scene.getParent();
      if (parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        this._scrollBar.render(ctx);
      } else if (parent.classType === "Engine" /* ENGINE */) {
        this._scrollBar.render(ctx);
      }
    }
    _applyCache(ctx) {
      if (!ctx) {
        return;
      }
      const pixelRatio = this._cacheCanvas.getPixelRatio();
      const width = this._cacheCanvas.getWidth() * pixelRatio;
      const height = this._cacheCanvas.getHeight() * pixelRatio;
      ctx.drawImage(this._cacheCanvas.getCanvasEle(), 0, 0, width, height, this.left, this.top, this.width || 0, this.height || 0);
    }
  };

  // ../../packages/base-render/src/Component/Sheets/SheetComponent.ts
  var SheetComponent = class extends RenderComponent {
    // protected _cacheCanvas = new Canvas();
    constructor(oKey, _skeleton) {
      super(oKey);
      this._skeleton = _skeleton;
    }
    getSkeleton() {
      return this._skeleton;
    }
    updateSkeleton(spreadsheetSkeleton) {
      this._skeleton = spreadsheetSkeleton;
    }
    render(mainCtx, bounds) {
      if (!this.visible) {
        this.makeDirty(false);
        return this;
      }
      mainCtx.save();
      this._draw(mainCtx, bounds);
      mainCtx.restore();
    }
    getParentScale() {
      let { scaleX = 1, scaleY = 1 } = this.parent;
      if (this.parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        scaleX = this.parent.ancestorScaleX || 1;
        scaleY = this.parent.ancestorScaleY || 1;
      }
      return {
        scaleX,
        scaleY
      };
    }
    /**
     *
     * @param rowHeightAccumulation Row layout information
     * @param columnWidthAccumulation Column layout information
     * @param bounds The range of the visible area of the canvas
     * @returns The range cell index of the canvas visible area
     */
    _getBounding(rowHeightAccumulation, columnWidthAccumulation, bounds) {
      const rhaLength = rowHeightAccumulation.length;
      const cwaLength = columnWidthAccumulation.length;
      if (!bounds) {
        return {
          startRow: 0,
          endRow: rhaLength - 1,
          startColumn: 0,
          endColumn: cwaLength - 1
        };
      }
      let dataset_row_st = -1;
      let dataset_row_ed = -1;
      let dataset_col_st = -1;
      let dataset_col_ed = -1;
      dataset_row_st = searchArray(rowHeightAccumulation, bounds.tl.y);
      dataset_row_ed = searchArray(rowHeightAccumulation, bounds.bl.y);
      if (dataset_row_st === -1) {
        dataset_row_st = 0;
      }
      if (dataset_row_ed === -1) {
        dataset_row_ed = rhaLength - 1;
      }
      if (dataset_row_ed >= rhaLength) {
        dataset_row_ed = rhaLength - 1;
      }
      dataset_col_st = searchArray(columnWidthAccumulation, bounds.tl.x);
      dataset_col_ed = searchArray(columnWidthAccumulation, bounds.tr.x);
      if (dataset_col_st === -1) {
        dataset_col_st = 0;
      }
      if (dataset_col_ed === -1) {
        dataset_col_ed = cwaLength - 1;
      }
      if (dataset_col_ed >= cwaLength) {
        dataset_col_ed = cwaLength - 1;
      }
      return {
        startRow: dataset_row_st - 1,
        endRow: dataset_row_ed + 1,
        startColumn: dataset_col_st - 1,
        endColumn: dataset_col_ed + 1
      };
    }
    _draw(ctx, bounds) {
    }
  };
  var SpreadsheetTitle = class extends SheetComponent {
    _draw(ctx, bounds) {
      this.draw(ctx, bounds);
    }
  };

  // ../../packages/base-render/src/Component/Sheets/Extensions/SheetExtension.ts
  var SheetExtension = class extends ComponentExtension {
    type = 0 /* GRID */;
    getCellIndex(rowIndex, columnIndex, rowHeightAccumulation, columnWidthAccumulation, dataMergeCache) {
      return getCellByIndex(rowIndex, columnIndex, rowHeightAccumulation, columnWidthAccumulation, dataMergeCache);
    }
  };

  // ../../packages/base-render/src/Component/Sheets/Extensions/Background.ts
  var UNIQUE_KEY5 = "DefaultBackgroundExtension";
  var Background2 = class extends SheetExtension {
    uKey = UNIQUE_KEY5;
    zIndex = 20;
    draw(ctx, parentScale, spreadsheetSkeleton) {
      const { rowTitleWidth, columnTitleHeight, dataMergeCache, stylesCache } = spreadsheetSkeleton;
      const { background } = stylesCache;
      if (!spreadsheetSkeleton) {
        return;
      }
      const { rowHeightAccumulation, columnTotalWidth, columnWidthAccumulation, rowTotalHeight } = spreadsheetSkeleton;
      if (!rowHeightAccumulation || !columnWidthAccumulation || columnTotalWidth === void 0 || rowTotalHeight === void 0) {
        return;
      }
      ctx.save();
      const { scaleX = 1, scaleY = 1 } = parentScale;
      const fixPointFive = 0;
      background && Object.keys(background).forEach((rgb) => {
        const backgroundCache = background[rgb];
        ctx.fillStyle = rgb || getColor([255, 255, 255]);
        ctx.beginPath();
        backgroundCache.forEach((rowIndex, backgroundRow) => {
          backgroundRow.forEach((columnIndex) => {
            let { isMerged, startY, endY, startX, endX } = this.getCellIndex(rowIndex, columnIndex, rowHeightAccumulation, columnWidthAccumulation, dataMergeCache);
            if (isMerged) {
              return true;
            }
            startY = fixLineWidthByScale(startY, scaleY);
            endY = fixLineWidthByScale(endY, scaleY);
            startX = fixLineWidthByScale(startX, scaleX);
            endX = fixLineWidthByScale(endX, scaleX);
            ctx.moveTo(startX, startY);
            ctx.lineTo(startX, endY);
            ctx.lineTo(endX, endY);
            ctx.lineTo(endX, startY);
          });
        });
        ctx.closePath();
        ctx.fill();
      });
      ctx.restore();
    }
  };
  SpreadsheetExtensionRegistry.add(new Background2());

  // ../../packages/base-render/src/Component/Sheets/Extensions/Border.ts
  var UNIQUE_KEY6 = "DefaultBorderExtension";
  var Border2 = class extends SheetExtension {
    uKey = UNIQUE_KEY6;
    zIndex = 30;
    draw(ctx, parentScale, spreadsheetSkeleton) {
      const { rowColumnSegment, rowTitleWidth, columnTitleHeight, dataMergeCache, stylesCache, overflowCache } = spreadsheetSkeleton;
      const { border: border2 } = stylesCache;
      if (!spreadsheetSkeleton) {
        return;
      }
      const { rowHeightAccumulation, columnTotalWidth, columnWidthAccumulation, rowTotalHeight } = spreadsheetSkeleton;
      if (!rowHeightAccumulation || !columnWidthAccumulation || columnTotalWidth === void 0 || rowTotalHeight === void 0) {
        return;
      }
      ctx.save();
      const { scaleX = 1, scaleY = 1 } = parentScale;
      const scale = this._getScale(parentScale);
      let preStyle;
      let preColor;
      border2?.forEach((rowIndex, borderColumns) => {
        borderColumns?.forEach((columnIndex, borderCaches) => {
          if (!borderCaches) {
            return true;
          }
          let { isMerged, startY, endY, startX, endX } = this.getCellIndex(rowIndex, columnIndex, rowHeightAccumulation, columnWidthAccumulation, dataMergeCache);
          if (isMerged) {
            return true;
          }
          startY = fixLineWidthByScale(startY, scaleY);
          endY = fixLineWidthByScale(endY, scaleY);
          startX = fixLineWidthByScale(startX, scaleX);
          endX = fixLineWidthByScale(endX, scaleX);
          for (let key in borderCaches) {
            const { type, style, color } = borderCaches[key];
            if (this._getOverflowExclusion(overflowCache, type, rowIndex, columnIndex)) {
              continue;
            }
            if (style !== preStyle) {
              setLineType(ctx, style);
              ctx.lineWidth = getLineWidth(style) / scale;
              preStyle = style;
            }
            if (color !== preColor) {
              ctx.strokeStyle = color || COLOR_BLACK_RGB;
              preColor = color;
            }
            drawLineByBorderType(ctx, type, { startX, startY, endX, endY });
          }
        });
      });
      ctx.closePath();
      ctx.restore();
    }
    _getOverflowExclusion(overflowCache, type, borderRow, borderColumn) {
      let isDraw = false;
      if (type === "t" /* TOP */ || type === "b" /* BOTTOM */) {
        return isDraw;
      }
      overflowCache && overflowCache.forEach((row, rowArray) => {
        if (row !== borderRow) {
          return true;
        }
        rowArray.forEach((column, rectangle) => {
          const { startColumn, endColumn } = rectangle;
          if (type === "l" /* LEFT */ && column > startColumn && column <= endColumn) {
            isDraw = true;
            return false;
          }
          if (type === "r" /* RIGHT */ && column >= startColumn && column < endColumn) {
            isDraw = true;
            return false;
          }
        });
      });
      return isDraw;
    }
  };
  SpreadsheetExtensionRegistry.add(new Border2());

  // ../../packages/base-render/src/Component/Sheets/Extensions/BorderAuxiliary.ts
  var UNIQUE_KEY7 = "DefaultBorderAuxiliaryExtension";
  var BorderAuxiliary = class extends SheetExtension {
    uKey = UNIQUE_KEY7;
    zIndex = 10;
    draw(ctx, parentScale, spreadsheetSkeleton) {
      const { rowColumnSegment, rowTitleWidth = 0, columnTitleHeight = 0, dataMergeCache, overflowCache, stylesCache, showGridlines } = spreadsheetSkeleton;
      const { startRow, endRow, startColumn, endColumn } = rowColumnSegment;
      if (!spreadsheetSkeleton || showGridlines === 0 /* FALSE */) {
        return;
      }
      const { rowHeightAccumulation, columnTotalWidth, columnWidthAccumulation, rowTotalHeight } = spreadsheetSkeleton;
      if (!rowHeightAccumulation || !columnWidthAccumulation || columnTotalWidth === void 0 || rowTotalHeight === void 0) {
        return;
      }
      ctx.save();
      const scale = this._getScale(parentScale);
      ctx.beginPath();
      ctx.lineWidth = 1 / scale;
      ctx.strokeStyle = getColor([217, 217, 217]);
      let width = fixLineWidthByScale(columnTotalWidth, scale);
      let height = fixLineWidthByScale(rowTotalHeight, scale);
      const columnWidthAccumulationLength = columnWidthAccumulation.length;
      const rowHeightAccumulationLength = rowHeightAccumulation.length;
      for (let r4 = startRow - 1; r4 <= endRow; r4++) {
        if (r4 < 0 || r4 > rowHeightAccumulationLength - 1) {
          continue;
        }
        const rowEndPosition = fixLineWidthByScale(rowHeightAccumulation[r4], scale);
        ctx.moveTo(0, rowEndPosition);
        ctx.lineTo(width, rowEndPosition);
      }
      for (let c4 = startColumn; c4 <= endColumn; c4++) {
        if (c4 < 0 || c4 > columnWidthAccumulationLength - 1) {
          continue;
        }
        const columnEndPosition = fixLineWidthByScale(columnWidthAccumulation[c4], scale);
        ctx.moveTo(columnEndPosition, 0);
        ctx.lineTo(columnEndPosition, height);
      }
      ctx.stroke();
      ctx.closePath();
      this._clearRectangle(ctx, scale, rowHeightAccumulation, columnWidthAccumulation, dataMergeCache);
      this._clearRectangle(ctx, scale, rowHeightAccumulation, columnWidthAccumulation, overflowCache);
      ctx.restore();
    }
    _clearRectangle(ctx, scale, rowHeightAccumulation, columnWidthAccumulation, dataMergeCache) {
      dataMergeCache?.forEach((r4, dataMergeRow) => {
        dataMergeRow?.forEach((c4, dataCache) => {
          const { startRow, endRow, startColumn, endColumn } = dataCache;
          const startY = fixLineWidthByScale(rowHeightAccumulation[startRow - 1] || 0, scale);
          const endY = fixLineWidthByScale(rowHeightAccumulation[endRow], scale);
          const startX = fixLineWidthByScale(columnWidthAccumulation[startColumn - 1] || 0, scale);
          const endX = fixLineWidthByScale(columnWidthAccumulation[endColumn], scale);
          ctx.clearRect(startX, startY, endX - startX, endY - startY);
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(endX, startY);
          ctx.lineTo(endX, endY);
          ctx.lineTo(startX, endY);
          ctx.lineTo(startX, startY);
          ctx.stroke();
          ctx.closePath();
        });
      });
    }
  };
  SpreadsheetExtensionRegistry.add(new BorderAuxiliary());

  // ../../packages/base-render/src/Component/Sheets/Extensions/Font.ts
  var UNIQUE_KEY8 = "DefaultFontExtension";
  var Font = class extends SheetExtension {
    uKey = UNIQUE_KEY8;
    zIndex = 40;
    changeFontColor;
    getDocuments() {
      const parent = this.parent;
      return parent.getDocuments();
    }
    setChangeFontColor(r4, c4, color) {
      this.changeFontColor.setValue(r4, c4, color);
    }
    draw(ctx, parentScale, spreadsheetSkeleton) {
      const { rowColumnSegment, rowTitleWidth, columnTitleHeight, stylesCache, dataMergeCache, overflowCache } = spreadsheetSkeleton;
      const { font: fontList } = stylesCache;
      if (!spreadsheetSkeleton) {
        return;
      }
      const { rowHeightAccumulation, columnTotalWidth, columnWidthAccumulation, rowTotalHeight } = spreadsheetSkeleton;
      if (!rowHeightAccumulation || !columnWidthAccumulation || columnTotalWidth === void 0 || rowTotalHeight === void 0) {
        return;
      }
      ctx.save();
      const scale = this._getScale(parentScale);
      const { scaleX = 1, scaleY = 1 } = parentScale;
      fontList && Object.keys(fontList).forEach((fontFormat) => {
        const fontObjectArray = fontList[fontFormat];
        fontObjectArray.forEach((rowIndex, fontArray) => {
          fontArray.forEach((columnIndex, docsConfig) => {
            let { isMerged, isMergedMainCell, startY, endY, startX, endX, mergeInfo } = this.getCellIndex(
              rowIndex,
              columnIndex,
              rowHeightAccumulation,
              columnWidthAccumulation,
              dataMergeCache
            );
            if (isMerged) {
              return true;
            }
            startY = fixLineWidthByScale(startY, scaleY);
            endY = fixLineWidthByScale(endY, scaleY);
            startX = fixLineWidthByScale(startX, scaleX);
            endX = fixLineWidthByScale(endX, scaleX);
            const cellWidth = endX - startX;
            const cellHeight = endY - startY;
            const overflowRectangle = overflowCache.getValue(rowIndex, columnIndex);
            const { horizontalAlign } = docsConfig;
            ctx.save();
            ctx.beginPath();
            if (overflowRectangle) {
              const { startColumn, startRow, endColumn, endRow } = overflowRectangle;
              if (startColumn === endColumn && startColumn === columnIndex) {
                ctx.rect(startX, startY, cellWidth, cellHeight);
              } else {
                if (horizontalAlign === 2 /* CENTER */) {
                  this._clipRectangle(ctx, startRow, endRow, startColumn, endColumn, scale, rowHeightAccumulation, columnWidthAccumulation);
                } else if (horizontalAlign === 3 /* RIGHT */) {
                  this._clipRectangle(ctx, startRow, rowIndex, startColumn, columnIndex, scale, rowHeightAccumulation, columnWidthAccumulation);
                } else {
                  this._clipRectangle(ctx, rowIndex, endRow, columnIndex, endColumn, scale, rowHeightAccumulation, columnWidthAccumulation);
                }
              }
            } else {
              ctx.rect(startX, startY, cellWidth, cellHeight);
            }
            ctx.clip();
            ctx.translate(startX, startY);
            this._renderDocuments(ctx, docsConfig, startX, startY, endX, endY, rowIndex, columnIndex);
            ctx.restore();
          });
        });
      });
      ctx.restore();
    }
    _renderDocuments(ctx, docsConfig, startX, startY, endX, endY, row, column) {
      const documents = this.getDocuments();
      const { documentSkeleton, angle, verticalAlign, horizontalAlign, wrapStrategy, content } = docsConfig;
      const cellWidth = endX - startX;
      const cellHeight = endY - startY;
      if (wrapStrategy === 3 /* WRAP */ && angle === 0) {
        documentSkeleton.updateDocumentDataPageSize(cellWidth);
        documentSkeleton.calculate();
      }
      documentSkeleton.makeDirty(false);
      documents.resize(cellWidth, cellHeight);
      documents.changeSkeleton(documentSkeleton).render(ctx);
    }
    _clipRectangle(ctx, startRow, endRow, startColumn, endColumn, scale, rowHeightAccumulation, columnWidthAccumulation) {
      const startY = fixLineWidthByScale(rowHeightAccumulation[startRow - 1] || 0, scale);
      const endY = fixLineWidthByScale(rowHeightAccumulation[endRow], scale);
      const startX = fixLineWidthByScale(columnWidthAccumulation[startColumn - 1] || 0, scale);
      const endX = fixLineWidthByScale(columnWidthAccumulation[endColumn], scale);
      ctx.rect(startX, startY, endX - startX, endY - startY);
    }
  };
  SpreadsheetExtensionRegistry.add(new Font());

  // ../../packages/base-render/src/Component/Sheets/Extensions/RowTitleLayout.ts
  var UNIQUE_KEY9 = "DefaultRowTitleLayoutExtension";
  var RowTitleLayout = class extends SheetExtension {
    uKey = UNIQUE_KEY9;
    zIndex = 10;
    draw(ctx, parentScale, spreadsheetSkeleton) {
      const { rowColumnSegment, rowTitleWidth = 0, columnTitleHeight = 0 } = spreadsheetSkeleton;
      const { startRow, endRow, startColumn, endColumn } = rowColumnSegment;
      if (!spreadsheetSkeleton) {
        return;
      }
      const { rowHeightAccumulation, columnTotalWidth, columnWidthAccumulation, rowTotalHeight } = spreadsheetSkeleton;
      if (!rowHeightAccumulation || !columnWidthAccumulation || columnTotalWidth === void 0 || rowTotalHeight === void 0) {
        return;
      }
      const scale = this._getScale(parentScale);
      ctx.fillStyle = getColor([248, 249, 250]);
      ctx.fillRect(0, 0, rowTitleWidth, rowTotalHeight);
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = getColor([0, 0, 0]);
      ctx.beginPath();
      ctx.lineWidth = 1 / scale;
      ctx.strokeStyle = getColor([217, 217, 217]);
      let preRowPosition = 0;
      const rowHeightAccumulationLength = rowHeightAccumulation.length;
      for (let r4 = startRow - 1; r4 <= endRow; r4++) {
        if (r4 < 0 || r4 > rowHeightAccumulationLength - 1) {
          continue;
        }
        const rowEndPosition = fixLineWidthByScale(rowHeightAccumulation[r4], scale);
        if (preRowPosition === rowEndPosition) {
          continue;
        }
        ctx.moveTo(0, rowEndPosition);
        ctx.lineTo(rowTitleWidth, rowEndPosition);
        const middleCellPos = preRowPosition + (rowEndPosition - preRowPosition) / 2;
        ctx.fillText(`${r4 + 1}`, rowTitleWidth / 2, middleCellPos + MIDDLE_CELL_POS_MAGIC_NUMBER);
        preRowPosition = rowEndPosition;
      }
      ctx.moveTo(fixLineWidthByScale(rowTitleWidth, scale), 0);
      ctx.lineTo(fixLineWidthByScale(rowTitleWidth, scale), rowTotalHeight);
      ctx.stroke();
    }
  };
  SheetRowTitleExtensionRegistry.add(new RowTitleLayout());

  // ../../packages/base-render/src/Component/Sheets/Extensions/ColumnTitleLayout.ts
  var UNIQUE_KEY10 = "DefaultColumnTitleLayoutExtension";
  var ColumnTitleLayout = class extends SheetExtension {
    uKey = UNIQUE_KEY10;
    zIndex = 10;
    draw(ctx, parentScale, spreadsheetSkeleton) {
      const { rowColumnSegment, rowTitleWidth = 0, columnTitleHeight = 0 } = spreadsheetSkeleton;
      const { startRow, endRow, startColumn, endColumn } = rowColumnSegment;
      if (!spreadsheetSkeleton) {
        return;
      }
      const { rowHeightAccumulation, columnTotalWidth, columnWidthAccumulation, rowTotalHeight } = spreadsheetSkeleton;
      if (!rowHeightAccumulation || !columnWidthAccumulation || columnTotalWidth === void 0 || rowTotalHeight === void 0) {
        return;
      }
      const scale = this._getScale(parentScale);
      ctx.fillStyle = getColor([248, 249, 250]);
      ctx.fillRect(0, 0, columnTotalWidth, columnTitleHeight);
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = getColor([0, 0, 0]);
      ctx.beginPath();
      ctx.lineWidth = 1 / scale;
      ctx.strokeStyle = getColor([217, 217, 217]);
      let preColumnPosition = 0;
      const columnWidthAccumulationLength = columnWidthAccumulation.length;
      for (let c4 = startColumn - 1; c4 <= endColumn; c4++) {
        if (c4 < 0 || c4 > columnWidthAccumulationLength - 1) {
          continue;
        }
        const columnEndPosition = fixLineWidthByScale(columnWidthAccumulation[c4], scale);
        if (preColumnPosition === columnEndPosition) {
          continue;
        }
        ctx.moveTo(columnEndPosition, 0);
        ctx.lineTo(columnEndPosition, columnTitleHeight);
        const middleCellPos = preColumnPosition + (columnEndPosition - preColumnPosition) / 2;
        ctx.fillText(numberToABC(c4), middleCellPos, columnTitleHeight / 2 + MIDDLE_CELL_POS_MAGIC_NUMBER);
        preColumnPosition = columnEndPosition;
      }
      const columnTitleHeightFix = fixLineWidthByScale(columnTitleHeight, scale);
      ctx.moveTo(0, columnTitleHeightFix);
      ctx.lineTo(columnTotalWidth, columnTitleHeightFix);
      ctx.stroke();
    }
  };
  SheetColumnTitleExtensionRegistry.add(new ColumnTitleLayout());

  // ../../packages/base-render/src/Component/Sheets/Selection/SelectionModel.ts
  var SelectionModel = class {
    _startColumn;
    _startRow;
    _endColumn;
    _endRow;
    _startX;
    _startY;
    _endX;
    _endY;
    _type;
    _currentCell;
    constructor(type = 0 /* NORMAL */) {
      this._type = type;
    }
    get startColumn() {
      return this._startColumn;
    }
    get startRow() {
      return this._startRow;
    }
    get endColumn() {
      return this._endColumn;
    }
    get endRow() {
      return this._endRow;
    }
    get startX() {
      return this._startX;
    }
    get startY() {
      return this._startY;
    }
    get endX() {
      return this._endX;
    }
    get endY() {
      return this._endY;
    }
    get type() {
      return this._type;
    }
    get currentCell() {
      return this._currentCell;
    }
    isEqual(selectionRange) {
      const { startColumn, startRow, endColumn, endRow, type } = this;
      const { startColumn: newStartColumn, startRow: newStartRow, endColumn: newEndColumn, endRow: newEndRow } = selectionRange;
      if (startColumn === newStartColumn && startRow === newStartRow && endColumn === newEndColumn && endRow === newEndRow) {
        return true;
      }
      return false;
    }
    isInclude(selectionRange) {
      const { startColumn, startRow, endColumn, endRow, type } = this;
      const { startColumn: newStartColumn, startRow: newStartRow, endColumn: newEndColumn, endRow: newEndRow } = selectionRange;
      if (!(newEndColumn < startColumn || newStartColumn > endColumn || newStartRow > endRow || newEndRow < startRow)) {
        return true;
      }
      return false;
    }
    highlightToSelection() {
      return makeCellToSelection(this._currentCell);
    }
    getValue() {
      return {
        selection: {
          startColumn: this._startColumn,
          startRow: this._startRow,
          endColumn: this._endColumn,
          endRow: this._endRow,
          startX: this._startX,
          startY: this._startY,
          endX: this._endX,
          endY: this._endY
        },
        cell: this._currentCell
      };
    }
    setValue(newSelectionRange, currentCell) {
      const {
        startColumn,
        startRow,
        endColumn,
        endRow,
        startX,
        startY,
        endX,
        endY
      } = newSelectionRange;
      this._startColumn = startColumn;
      this._startRow = startRow;
      this._endColumn = endColumn;
      this._endRow = endRow;
      this._startX = startX;
      this._startY = startY;
      this._endX = endX;
      this._endY = endY;
      this.setCurrentCell(currentCell);
    }
    setCurrentCell(currentCell) {
      if (currentCell) {
        this._currentCell = currentCell;
      }
    }
    clearCurrentCell() {
      this._currentCell = null;
    }
  };

  // ../../packages/base-render/src/Component/Sheets/Selection/SelectionControl.ts
  var DEFAULT_SELECTION_CONFIG = {
    strokeColor: "rgb(1,136,251)",
    backgroundColor: "rgba(1,136,251, 0.1)",
    strokeWidth: 2,
    fillSideLength: 6,
    fillStrokeLength: 1,
    fillStrokeColor: "rgb(255,255,255)"
  };
  var SelectionControl = class {
    constructor(_scene, _zIndex) {
      this._scene = _scene;
      this._zIndex = _zIndex;
      this._initialize();
    }
    _leftControl;
    _rightControl;
    _topControl;
    _bottomControl;
    _backgroundControlTop;
    _backgroundControlBottom;
    _backgroundControlMiddleLeft;
    _backgroundControlMiddleRight;
    _fillControl;
    _selectionShape;
    _selectionModel;
    get zIndex() {
      return this._zIndex;
    }
    get leftControl() {
      return this._leftControl;
    }
    get rightControl() {
      return this._rightControl;
    }
    get topControl() {
      return this._topControl;
    }
    get bottomControl() {
      return this._bottomControl;
    }
    get fillControl() {
      return this._fillControl;
    }
    get backgroundControlTop() {
      return this._backgroundControlTop;
    }
    get backgroundControlBottom() {
      return this._backgroundControlBottom;
    }
    get backgroundControlMiddleLeft() {
      return this._backgroundControlMiddleLeft;
    }
    get backgroundControlMiddleRight() {
      return this._backgroundControlMiddleRight;
    }
    get selectionShape() {
      return this._selectionShape;
    }
    get model() {
      return this._selectionModel;
    }
    static create(scene, zIndex) {
      return new this(scene, zIndex);
    }
    static fromJson(scene, zIndex, newSelectionRange) {
      const control = SelectionControl.create(scene, zIndex);
      control.update(newSelectionRange);
      return control;
    }
    /**
     * just handle the view
     *
     * inner update
     */
    _updateControl() {
      const { startX, startY, endX, endY } = this._selectionModel;
      this.leftControl.resize(void 0, endY - startY);
      this.rightControl.transformByState({
        height: endY - startY,
        left: endX - startX - DEFAULT_SELECTION_CONFIG.strokeWidth / 2
      });
      this.topControl.resize(endX - startX + DEFAULT_SELECTION_CONFIG.strokeWidth);
      this.bottomControl.transformByState({
        width: endX - startX + DEFAULT_SELECTION_CONFIG.strokeWidth,
        top: endY - startY - DEFAULT_SELECTION_CONFIG.strokeWidth / 2
      });
      this.fillControl.translate(endX - startX - DEFAULT_SELECTION_CONFIG.fillSideLength / 2, endY - startY - DEFAULT_SELECTION_CONFIG.fillSideLength / 2);
      this._updateBackgroundControl();
      this.selectionShape.show();
      this.selectionShape.translate(startX, startY);
      this.selectionShape.makeDirty(true);
    }
    update(newSelectionRange, highlight) {
      this._selectionModel.setValue(newSelectionRange, highlight);
      this._updateControl();
    }
    clearHighlight() {
      this._selectionModel.clearCurrentCell();
      this._updateControl();
    }
    getScene() {
      return this._scene;
    }
    dispose() {
      this._leftControl?.dispose();
      this._rightControl?.dispose();
      this._topControl?.dispose();
      this._bottomControl?.dispose();
      this._backgroundControlTop?.dispose();
      this._backgroundControlMiddleLeft?.dispose();
      this._backgroundControlMiddleRight?.dispose();
      this._backgroundControlBottom?.dispose();
      this._fillControl?.dispose();
      this._selectionShape?.dispose();
    }
    /**
     * Get the cell information of the current selection, considering the case of merging cells
     */
    getCurrentCellInfo() {
      const currentCell = this.model.currentCell;
      if (currentCell) {
        let currentRangeData;
        if (currentCell.isMerged) {
          const mergeInfo = currentCell.mergeInfo;
          currentRangeData = {
            startRow: mergeInfo.startRow,
            endRow: mergeInfo.endRow,
            startColumn: mergeInfo.startColumn,
            endColumn: mergeInfo.endColumn,
            startX: mergeInfo.startX,
            endX: mergeInfo.endX,
            startY: mergeInfo.startY,
            endY: mergeInfo.endY
          };
        } else {
          const { row, column, startX, endX, startY, endY } = currentCell;
          currentRangeData = {
            startRow: row,
            endRow: row,
            startColumn: column,
            endColumn: column,
            startX,
            endX,
            startY,
            endY
          };
        }
        return currentRangeData;
      }
    }
    _initialize() {
      this._selectionModel = new SelectionModel(0 /* NORMAL */);
      const zIndex = this._zIndex;
      this._leftControl = new Rect("__SpreadsheetSelectionShapeLeftControl__" /* left */ + zIndex, {
        top: 0,
        left: -DEFAULT_SELECTION_CONFIG.strokeWidth / 2,
        width: DEFAULT_SELECTION_CONFIG.strokeWidth,
        fill: DEFAULT_SELECTION_CONFIG.strokeColor,
        zIndex
      });
      this._rightControl = new Rect("__SpreadsheetSelectionShapeRightControl__" /* right */ + zIndex, {
        width: DEFAULT_SELECTION_CONFIG.strokeWidth,
        fill: DEFAULT_SELECTION_CONFIG.strokeColor,
        zIndex
      });
      this._topControl = new Rect("__SpreadsheetSelectionTopControl__" /* top */ + zIndex, {
        top: -DEFAULT_SELECTION_CONFIG.strokeWidth / 2,
        left: -DEFAULT_SELECTION_CONFIG.strokeWidth / 2,
        height: DEFAULT_SELECTION_CONFIG.strokeWidth,
        fill: DEFAULT_SELECTION_CONFIG.strokeColor,
        zIndex
      });
      this._bottomControl = new Rect("__SpreadsheetSelectionBottomControl__" /* bottom */ + zIndex, {
        height: DEFAULT_SELECTION_CONFIG.strokeWidth,
        fill: DEFAULT_SELECTION_CONFIG.strokeColor,
        left: -DEFAULT_SELECTION_CONFIG.strokeWidth / 2,
        zIndex
      });
      this._backgroundControlTop = new Rect("__SpreadsheetSelectionBackgroundControlTop__" /* backgroundTop */ + zIndex, {
        fill: DEFAULT_SELECTION_CONFIG.backgroundColor,
        zIndex: zIndex - 1,
        evented: false
      });
      this._backgroundControlBottom = new Rect("__SpreadsheetSelectionBackgroundControlBottom__" /* backgroundBottom */ + zIndex, {
        fill: DEFAULT_SELECTION_CONFIG.backgroundColor,
        zIndex: zIndex - 1,
        evented: false
      });
      this._backgroundControlMiddleLeft = new Rect("__SpreadsheetSelectionBackgroundControlMiddleLeft__" /* backgroundMiddleLeft */ + zIndex, {
        fill: DEFAULT_SELECTION_CONFIG.backgroundColor,
        zIndex: zIndex - 1,
        evented: false
      });
      this._backgroundControlMiddleRight = new Rect("__SpreadsheetSelectionBackgroundControlMiddleRight__" /* backgroundMiddleRight */ + zIndex, {
        fill: DEFAULT_SELECTION_CONFIG.backgroundColor,
        zIndex: zIndex - 1,
        evented: false
      });
      const fillSideLength = DEFAULT_SELECTION_CONFIG.fillSideLength - DEFAULT_SELECTION_CONFIG.fillStrokeLength;
      this._fillControl = new Rect("__SpreadsheetSelectionFillControl__" /* fill */ + zIndex, {
        width: fillSideLength,
        height: fillSideLength,
        fill: DEFAULT_SELECTION_CONFIG.strokeColor,
        strokeWidth: DEFAULT_SELECTION_CONFIG.fillStrokeLength,
        stroke: DEFAULT_SELECTION_CONFIG.fillStrokeColor,
        zIndex: zIndex + 1
      });
      this._selectionShape = new Group(
        "__SpreadsheetSelectionShape__" /* Selection */ + zIndex,
        this._fillControl,
        this._leftControl,
        this._rightControl,
        this._topControl,
        this._bottomControl,
        this._backgroundControlTop,
        this._backgroundControlMiddleLeft,
        this._backgroundControlMiddleRight,
        this._backgroundControlBottom
      );
      this._selectionShape.hide();
      this._selectionShape.evented = false;
      this._selectionShape.zIndex = zIndex;
      const scene = this.getScene();
      scene.addObject(this._selectionShape);
    }
    _updateBackgroundControl() {
      const {
        startColumn,
        startRow,
        endColumn,
        endRow,
        startX,
        startY,
        endX,
        endY
      } = this._selectionModel;
      const highlightSelection = this._selectionModel.highlightToSelection();
      if (!highlightSelection) {
        this._backgroundControlTop.resize(endX - startX, endY - startY);
        this._backgroundControlBottom.resize(0, 0);
        this._backgroundControlMiddleLeft.resize(0, 0);
        this._backgroundControlMiddleRight.resize(0, 0);
        return;
      }
      const { startX: h_startX, startY: h_startY, endX: h_endX, endY: h_endY } = highlightSelection;
      const strokeOffset = DEFAULT_SELECTION_CONFIG.strokeWidth / 2;
      const topConfig = {
        left: -strokeOffset,
        top: -strokeOffset,
        width: endX - startX + strokeOffset * 2,
        height: h_startY - startY + strokeOffset
      };
      if (topConfig.height < 0) {
        topConfig.width = 0;
        topConfig.height = 0;
      }
      this._backgroundControlTop.transformByState(topConfig);
      const middleLeftConfig = {
        left: -strokeOffset,
        top: h_startY - startY,
        width: h_startX - startX + strokeOffset,
        height: h_endY - h_startY
      };
      if (middleLeftConfig.width < 0) {
        middleLeftConfig.width = 0;
        middleLeftConfig.height = 0;
      }
      this._backgroundControlMiddleLeft.transformByState(middleLeftConfig);
      const middleRightConfig = {
        left: h_endX - startX - strokeOffset,
        top: h_startY - startY,
        width: endX - h_endX + strokeOffset * 2,
        height: h_endY - h_startY
      };
      if (middleRightConfig.width < 0) {
        middleRightConfig.width = 0;
        middleRightConfig.height = 0;
      }
      this._backgroundControlMiddleRight.transformByState(middleRightConfig);
      const middleBottomConfig = {
        left: -strokeOffset,
        top: h_endY - startY,
        width: endX - startX + strokeOffset * 2,
        height: endY - h_endY + strokeOffset
      };
      if (middleBottomConfig.height < 0) {
        middleBottomConfig.width = 0;
        middleBottomConfig.height = 0;
      }
      this._backgroundControlBottom.transformByState(middleBottomConfig);
    }
  };

  // ../../packages/base-render/src/Component/Sheets/Selection/SelectionManager.ts
  var SelectionManager = class {
    constructor(_spreadsheet) {
      this._spreadsheet = _spreadsheet;
      this._mainEventInitial();
    }
    hasSelection = false;
    _moveObserver;
    _upObserver;
    _selectionControls = [];
    // sheetID:Controls
    _startSelectionRange;
    _startOffsetX = 0;
    _startOffsetY = 0;
    _scrollTimer;
    _cancelDownObserver;
    _cancelUpObserver;
    static create(spreadsheet) {
      return new SelectionManager(spreadsheet);
    }
    /**
     * add a selection
     * @param selectionRange
     * @param curCellRange
     * @returns
     */
    addControlToCurrentByRangeData(selectionRange, curCellRange) {
      const currentControls = this.getCurrentControls();
      if (!currentControls) {
        return;
      }
      const main = this._spreadsheet;
      const control = SelectionControl.create(this.getScene(), currentControls.length);
      let cellInfo = null;
      if (curCellRange) {
        cellInfo = main.getCellByIndex(curCellRange.row, curCellRange.column);
      }
      const { startRow, startColumn, endRow, endColumn } = selectionRange;
      const startCell = main.getNoMergeCellPositionByIndex(startRow, startColumn);
      const endCell = main.getNoMergeCellPositionByIndex(endRow, endColumn);
      control.update(
        {
          startColumn,
          startRow,
          endColumn,
          endRow,
          startY: startCell?.startY || 0,
          endY: endCell?.endY || 0,
          startX: startCell?.startX || 0,
          endX: endCell?.endX || 0
        },
        cellInfo
      );
      currentControls.push(control);
    }
    getSpreadsheet() {
      return this._spreadsheet;
    }
    getMaxIndex() {
      return this._spreadsheet.zIndex + 1;
    }
    getScene() {
      return this._spreadsheet.getScene();
    }
    getSkeleton() {
      return this._spreadsheet.getSkeleton();
    }
    getRowAndColumnCount() {
      const skeleton = this.getSkeleton();
      return {
        rowCount: skeleton?.getRowCount() || 1e3,
        columnCount: skeleton?.getColumnCount() || 50
      };
    }
    getCurrentControls() {
      return this._selectionControls;
    }
    getCurrentControl() {
      const controls = this.getCurrentControls();
      if (controls && controls.length > 0) {
        for (const control of controls) {
          const currentCell = control.model.currentCell;
          if (currentCell) {
            return control;
          }
        }
      }
    }
    clearSelectionControls() {
      let curControls = this.getCurrentControls();
      if (curControls.length > 0) {
        for (let control of curControls) {
          control.dispose();
        }
        curControls.length = 0;
      }
    }
    /**
     * Returns the list of active ranges in the active sheet or null if there are no active ranges.
     * If there is a single range selected, this behaves as a getActiveRange() call.
     *
     * @returns
     */
    getActiveRangeList() {
      const controls = this.getCurrentControls();
      if (controls && controls.length > 0) {
        const selections = controls?.map((control) => {
          const model = control.model;
          return {
            startRow: model.startRow,
            startColumn: model.startColumn,
            endRow: model.endRow,
            endColumn: model.endColumn
          };
        });
        return selections;
      }
    }
    /**
     * Returns the selected range in the active sheet, or null if there is no active range. If multiple ranges are selected this method returns only the last selected range.
     * TODO: 
     * @returns
     */
    getActiveRange() {
      const controls = this.getCurrentControls();
      const model = controls && controls[controls.length - 1].model;
      return model && {
        startRow: model.startRow,
        startColumn: model.startColumn,
        endRow: model.endRow,
        endColumn: model.endColumn
      };
    }
    /**
     * get active selection control
     * @returns
     */
    getActiveSelection() {
      const controls = this.getCurrentControls();
      return controls && controls[controls.length - 1];
    }
    dispose() {
      this.clearSelectionControls();
      this._moveObserver = null;
      this._upObserver = null;
    }
    /**
     * When mousedown and mouseup need to go to the coordination and undo stack, when mousemove does not need to go to the coordination and undo stack
     * @param moveEvt
     * @param selectionControl
     * @returns
     */
    _moving(moveOffsetX, moveOffsetY, selectionControl) {
      const main = this._spreadsheet;
      const { startRow, startColumn, endRow, endColumn } = this._startSelectionRange;
      const scrollXY = main.getScrollXYByRelativeCoords(Vector2.FromArray([this._startOffsetX, this._startOffsetY]));
      const moveCellInfo = main.calculateCellIndexByPosition(moveOffsetX, moveOffsetY, scrollXY);
      const moveActualSelection = makeCellToSelection(moveCellInfo);
      if (!moveActualSelection) {
        return false;
      }
      const { startRow: moveStartRow, startColumn: moveStartColumn, endColumn: moveEndColumn, endRow: moveEndRow } = moveActualSelection;
      const newStartRow = Math.min(moveStartRow, startRow);
      const newStartColumn = Math.min(moveStartColumn, startColumn);
      const newEndRow = Math.max(moveEndRow, endRow);
      const newEndColumn = Math.max(moveEndColumn, endColumn);
      const newBounding = main.getSelectionBounding(newStartRow, newStartColumn, newEndRow, newEndColumn);
      if (!newBounding) {
        return false;
      }
      const { startRow: finalStartRow, startColumn: finalStartColumn, endRow: finalEndRow, endColumn: finalEndColumn } = newBounding;
      const startCell = main.getNoMergeCellPositionByIndex(finalStartRow, finalStartColumn);
      const endCell = main.getNoMergeCellPositionByIndex(finalEndRow, finalEndColumn);
      const newSelectionRange = {
        startColumn: finalStartColumn,
        startRow: finalStartRow,
        endColumn: finalEndColumn,
        endRow: finalEndRow,
        startY: startCell?.startY || 0,
        endY: endCell?.endY || 0,
        startX: startCell?.startX || 0,
        endX: endCell?.endX || 0
      };
      const {
        startRow: oldStartRow,
        endRow: oldEndRow,
        startColumn: oldStartColumn,
        endColumn: oldEndColumn
      } = selectionControl?.model || { startRow: -1, endRow: -1, startColumn: -1, endColumn: -1 };
      if (oldStartColumn !== finalStartColumn || oldStartRow !== finalStartRow || oldEndColumn !== finalEndColumn || oldEndRow !== finalEndRow) {
        selectionControl && selectionControl.update(newSelectionRange);
      }
    }
    _endSelection(scene) {
      scene.onPointerMoveObserver.remove(this._moveObserver);
      scene.onPointerUpObserver.remove(this._upObserver);
      scene.enableEvent();
      this._scrollTimer?.stopScroll();
      const mainScene = scene.getEngine()?.activeScene;
      mainScene?.onPointerDownObserver.remove(this._cancelDownObserver);
      mainScene?.onPointerUpObserver.remove(this._cancelUpObserver);
    }
    _addCancelObserver() {
      const scene = this.getScene();
      const mainScene = scene.getEngine()?.activeScene;
      if (mainScene == null || mainScene === scene) {
        return;
      }
      mainScene.onPointerDownObserver.remove(this._cancelDownObserver);
      mainScene.onPointerUpObserver.remove(this._cancelUpObserver);
      this._cancelDownObserver = mainScene.onPointerDownObserver.add((moveEvt) => {
        this._endSelection(scene);
      });
      this._cancelUpObserver = mainScene.onPointerUpObserver.add((moveEvt) => {
        this._endSelection(scene);
      });
    }
    _mainEventInitial() {
      const main = this._spreadsheet;
      main.onPointerDownObserver.add((evt, state) => {
        const { offsetX: evtOffsetX, offsetY: evtOffsetY } = evt;
        const scene = this.getScene();
        const relativeCoords = scene.getRelativeCoord(Vector2.FromArray([evtOffsetX, evtOffsetY]));
        const { x: newEvtOffsetX, y: newEvtOffsetY } = relativeCoords;
        this._startOffsetX = newEvtOffsetX;
        this._startOffsetY = newEvtOffsetY;
        const scrollXY = main.getScrollXYByRelativeCoords(relativeCoords);
        const cellInfo = main.calculateCellIndexByPosition(newEvtOffsetX, newEvtOffsetY, scrollXY);
        const actualSelection = makeCellToSelection(cellInfo);
        if (!actualSelection) {
          return false;
        }
        const { startRow, startColumn, endColumn, endRow, startY, endY, startX, endX } = actualSelection;
        const startSelectionRange = {
          startColumn,
          startRow,
          endColumn,
          endRow,
          startY,
          endY,
          startX,
          endX
        };
        this._startSelectionRange = startSelectionRange;
        let selectionControl = this.getCurrentControl();
        let curControls = this.getCurrentControls();
        if (!curControls) {
          return false;
        }
        for (let control of curControls) {
          if (evt.button === 2 && control.model.isInclude(startSelectionRange)) {
            selectionControl = control;
            return;
          }
          if (control.model.isEqual(startSelectionRange)) {
            selectionControl = control;
            break;
          }
          if (!evt.shiftKey) {
            control.clearHighlight();
          }
        }
        if (curControls.length > 0 && !evt.ctrlKey && !evt.shiftKey) {
          for (let control of curControls) {
            control.dispose();
          }
          curControls.length = 0;
        }
        const currentCell = selectionControl && selectionControl.model.currentCell;
        if (selectionControl && evt.shiftKey && currentCell) {
          const { row, column } = currentCell;
          const startCell = main.getNoMergeCellPositionByIndex(row, column);
          const endCell = main.getNoMergeCellPositionByIndex(endRow, endColumn);
          const newSelectionRange = {
            startColumn: column,
            startRow: row,
            endColumn: startSelectionRange.startColumn,
            endRow: startSelectionRange.startRow,
            startY: startCell?.startY || 0,
            endY: endCell?.endY || 0,
            startX: startCell?.startX || 0,
            endX: endCell?.endX || 0
          };
          selectionControl.update(newSelectionRange, currentCell);
        } else {
          selectionControl = SelectionControl.create(scene, curControls.length + this.getMaxIndex());
          selectionControl.update(startSelectionRange, cellInfo);
          curControls.push(selectionControl);
        }
        this.hasSelection = true;
        scene.disableEvent();
        this._endSelection(scene);
        const scrollTimer = ScrollTimer.create(this.getScene());
        scrollTimer.startScroll(newEvtOffsetX, newEvtOffsetY);
        this._scrollTimer = scrollTimer;
        this._addCancelObserver();
        this._moveObserver = scene.onPointerMoveObserver.add((moveEvt) => {
          const { offsetX: moveOffsetX, offsetY: moveOffsetY } = moveEvt;
          const { x: newMoveOffsetX, y: newMoveOffsetY } = scene.getRelativeCoord(Vector2.FromArray([moveOffsetX, moveOffsetY]));
          this._moving(newMoveOffsetX, newMoveOffsetY, selectionControl);
          scrollTimer.scrolling(newMoveOffsetX, newMoveOffsetY, () => {
            this._moving(newMoveOffsetX, newMoveOffsetY, selectionControl);
          });
        });
        this._upObserver = scene.onPointerUpObserver.add((upEvt) => {
          this._endSelection(scene);
        });
        state.stopPropagation();
      });
    }
  };

  // ../../packages/base-render/src/Component/Sheets/Spreadsheet.ts
  var OBJECT_KEY = "__SHEET_EXTENSION_FONT_DOCUMENT_INSTANCE__";
  var Spreadsheet = class extends SheetComponent {
    constructor(oKey, spreadsheetSkeleton, _allowCache = true) {
      super(oKey, spreadsheetSkeleton);
      this._allowCache = _allowCache;
      if (this._allowCache) {
        this._cacheCanvas = new Canvas();
      }
      this.onIsAddedToParentObserver.add((parent) => {
        parent?.getEngine()?.onTransformChangeObservable.add((change) => {
          this.resizeCacheCanvas();
        });
        this.resizeCacheCanvas();
        this._addMakeDirtyToScroll();
      });
      this._initialDefaultExtension();
      this.makeDirty(true);
    }
    _borderAuxiliaryExtension;
    _backgroundExtension;
    _borderExtension;
    _fontExtension;
    _cacheCanvas;
    _boundsCache;
    _cacheOffsetX = 0;
    _cacheOffsetY = 0;
    _hasSelection = false;
    _selection;
    _documents = new Documents(OBJECT_KEY, void 0, {
      pageMarginLeft: 0,
      pageMarginTop: 0
    });
    get borderAuxiliaryExtension() {
      return this._borderAuxiliaryExtension;
    }
    get backgroundExtension() {
      return this._backgroundExtension;
    }
    get borderExtension() {
      return this._borderExtension;
    }
    get fontExtension() {
      return this._fontExtension;
    }
    getDocuments() {
      return this._documents;
    }
    draw(ctx, bounds) {
      const spreadsheetSkeleton = this.getSkeleton();
      if (!spreadsheetSkeleton) {
        return;
      }
      const parentScale = this.getParentScale();
      spreadsheetSkeleton.calculate(bounds);
      const scale = getScale(parentScale);
      const { rowTitleWidth, columnTitleHeight } = spreadsheetSkeleton;
      ctx.translate(fixLineWidthByScale(rowTitleWidth, scale) - 0.5 / scale, fixLineWidthByScale(columnTitleHeight, scale) - 0.5 / scale);
      this._calculateOverflow();
      const extensions = this.getExtensionsByOrder();
      for (let extension of extensions) {
        extension.draw(ctx, parentScale, spreadsheetSkeleton);
      }
    }
    isHit(coord) {
      const oCoord = this._getInverseCoord(coord);
      const skeleton = this.getSkeleton();
      if (!skeleton) {
        return false;
      }
      const { rowTitleWidth, columnTitleHeight } = skeleton;
      if (oCoord.x > rowTitleWidth && oCoord.y > columnTitleHeight) {
        return true;
      }
      return false;
    }
    getNoMergeCellPositionByIndex(rowIndex, columnIndex) {
      const spreadsheetSkeleton = this.getSkeleton();
      if (!spreadsheetSkeleton) {
        return;
      }
      const { rowHeightAccumulation, columnWidthAccumulation, rowTitleWidth, columnTitleHeight } = spreadsheetSkeleton;
      const { scaleX = 1, scaleY = 1 } = this.getParentScale();
      let { startY, endY, startX, endX } = getCellPositionByIndex(rowIndex, columnIndex, rowHeightAccumulation, columnWidthAccumulation);
      startY = fixLineWidthByScale(startY + columnTitleHeight, scaleY);
      endY = fixLineWidthByScale(endY + columnTitleHeight, scaleY);
      startX = fixLineWidthByScale(startX + rowTitleWidth, scaleX);
      endX = fixLineWidthByScale(endX + rowTitleWidth, scaleX);
      return {
        startY,
        endY,
        startX,
        endX
      };
    }
    calculateCellIndexByPosition(offsetX, offsetY, scrollXY) {
      const spreadsheetSkeleton = this.getSkeleton();
      if (!spreadsheetSkeleton) {
        return;
      }
      const { x: scrollX2, y: scrollY2 } = scrollXY;
      const { rowHeightAccumulation, columnWidthAccumulation, rowTitleWidth, columnTitleHeight, dataMergeCacheAll } = spreadsheetSkeleton;
      offsetX += scrollX2 - rowTitleWidth;
      offsetY += scrollY2 - columnTitleHeight;
      let row = searchArray(rowHeightAccumulation, offsetY);
      let column = searchArray(columnWidthAccumulation, offsetX);
      if (row === -1) {
        const rowLength = rowHeightAccumulation.length - 1;
        const lastRowValue = rowHeightAccumulation[rowLength];
        if (lastRowValue <= offsetY) {
          row = rowHeightAccumulation.length - 1;
        } else {
          row = 0;
        }
      }
      if (column === -1) {
        const columnLength = columnWidthAccumulation.length - 1;
        const lastColumnValue = columnWidthAccumulation[columnLength];
        if (lastColumnValue <= offsetX) {
          column = columnWidthAccumulation.length - 1;
        } else {
          column = 0;
        }
      }
      const { scaleX = 1, scaleY = 1 } = this.getParentScale();
      let { isMerged, startY, endY, startX, endX, mergeInfo, isMergedMainCell } = getCellByIndex(row, column, rowHeightAccumulation, columnWidthAccumulation, dataMergeCacheAll);
      startY = fixLineWidthByScale(startY + columnTitleHeight, scaleY);
      endY = fixLineWidthByScale(endY + columnTitleHeight, scaleY);
      startX = fixLineWidthByScale(startX + rowTitleWidth, scaleX);
      endX = fixLineWidthByScale(endX + rowTitleWidth, scaleX);
      mergeInfo = mergeInfoOffset(mergeInfo, rowTitleWidth, columnTitleHeight, scaleX, scaleY);
      return {
        row,
        column,
        startY,
        endY,
        startX,
        endX,
        isMerged,
        isMergedMainCell,
        mergeInfo
      };
    }
    getCellByIndex(row, column) {
      const spreadsheetSkeleton = this.getSkeleton();
      if (!spreadsheetSkeleton) {
        return;
      }
      const { scaleX = 1, scaleY = 1 } = this.getParentScale();
      const { rowHeightAccumulation, columnWidthAccumulation, rowTitleWidth, columnTitleHeight, dataMergeCacheAll } = spreadsheetSkeleton;
      let { isMerged, startY, endY, startX, endX, mergeInfo, isMergedMainCell } = getCellByIndex(row, column, rowHeightAccumulation, columnWidthAccumulation, dataMergeCacheAll);
      startY = fixLineWidthByScale(startY + columnTitleHeight, scaleY);
      endY = fixLineWidthByScale(endY + columnTitleHeight, scaleY);
      startX = fixLineWidthByScale(startX + rowTitleWidth, scaleX);
      endX = fixLineWidthByScale(endX + rowTitleWidth, scaleX);
      mergeInfo = mergeInfoOffset(mergeInfo, rowTitleWidth, columnTitleHeight, scaleX, scaleY);
      return {
        row,
        column,
        startY,
        endY,
        startX,
        endX,
        isMerged,
        isMergedMainCell,
        mergeInfo
      };
    }
    getScrollXYByRelativeCoords(coord) {
      let scene = this.getParent();
      let x4 = 0;
      let y4 = 0;
      const viewPort = scene.getActiveViewportByRelativeCoord(coord);
      if (viewPort) {
        const actualX = viewPort.actualScrollX || 0;
        const actualY = viewPort.actualScrollY || 0;
        x4 += actualX;
        y4 += actualY;
      }
      return {
        x: x4,
        y: y4
      };
    }
    getAncestorScrollXY(offsetX, offsetY) {
      let parent = this.getParent();
      let x4 = 0;
      let y4 = 0;
      let coord = Vector2.FromArray([offsetX, offsetY]);
      while (parent) {
        if (parent.classType === "Scene" /* SCENE */) {
          const scene = parent;
          const viewPort = scene.getActiveViewportByCoord(coord);
          if (viewPort) {
            const actualX = viewPort.actualScrollX || 0;
            const actualY = viewPort.actualScrollY || 0;
            x4 += actualX;
            y4 += actualY;
          }
        }
        parent = parent?.getParent && parent?.getParent();
      }
      return {
        x: x4,
        y: y4
      };
    }
    getSelectionBounding(startRow, startColumn, endRow, endColumn) {
      return this.getSkeleton()?.getMergeBounding(startRow, startColumn, endRow, endColumn);
    }
    render(mainCtx, bounds) {
      if (!this.visible) {
        this.makeDirty(false);
        return this;
      }
      if (this._allowCache) {
        this._cacheOffsetX = 0;
        this._cacheOffsetY = 0;
        if (this.isDirty()) {
          let newBounds = bounds;
          const ctx = this._cacheCanvas.getContext();
          if (newBounds) {
            const { dx = 0, dy = 0 } = newBounds;
            this._cacheOffsetX = dx;
            this._cacheOffsetY = dy;
          }
          this._cacheCanvas.clear();
          ctx.save();
          ctx.setTransform(mainCtx.getTransform());
          this._draw(ctx, newBounds);
          ctx.restore();
          this._boundsCache = bounds;
        }
        this._applyCache(mainCtx);
      } else {
        mainCtx.save();
        this._draw(mainCtx, bounds);
        mainCtx.restore();
      }
      this.makeDirty(false);
      return this;
    }
    resizeCacheCanvas() {
      const parentSize = this._getAncestorSize();
      if (!parentSize || this._cacheCanvas == null) {
        return;
      }
      const { width, height } = parentSize;
      const skeleton = this.getSkeleton();
      let rowTitleWidth = 0;
      let columnTitleHeight = 0;
      if (skeleton) {
        rowTitleWidth = skeleton.rowTitleWidth;
        columnTitleHeight = skeleton.columnTitleHeight;
      }
      this._cacheCanvas.setSize(width, height);
      this.makeDirty(true);
    }
    enableSelection() {
      if (this._hasSelection) {
        return;
      }
      this._selection = SelectionManager.create(this);
      this._hasSelection = true;
    }
    disableSelection() {
      this._selection?.dispose();
      this._hasSelection = false;
    }
    getDocsSkeletonPageSize(documentSkeleton, angle = 0) {
      const skeletonData = documentSkeleton?.getSkeletonData();
      if (!skeletonData) {
        return;
      }
      const { pages } = skeletonData;
      const lastPage = pages[pages.length - 1];
      if (angle === 0) {
        const { width, height } = lastPage;
        return { width, height };
      }
      let allRotatedWidth = 0;
      let allRotatedHeight = 0;
      const orientation = getRotateOrientation(angle);
      const widthArray = [];
      columnIterator([lastPage], (column) => {
        const { lines, width: columnWidth, spaceWidth } = column;
        const { rotatedHeight, rotatedWidth } = getRotateOffsetAndFarthestHypotenuse(lines, columnWidth, angle);
        allRotatedHeight += rotatedHeight;
        widthArray.push({ rotatedWidth, spaceWidth });
      });
      const tanTheta = Math.tan(angle);
      const sinTheta = Math.sin(angle);
      const widthCount = widthArray.length;
      for (let i4 = 0; i4 < widthCount; i4++) {
        const { rotatedWidth, spaceWidth } = widthArray[i4];
        if (i4 === 0) {
          allRotatedWidth += rotatedWidth;
        }
        if (orientation === 0 /* UP */ && i4 === 0 || orientation === 1 /* DOWN */ && i4 === widthCount - 1) {
          allRotatedWidth += (rotatedWidth + spaceWidth / sinTheta) / tanTheta;
        }
      }
      return {
        width: allRotatedWidth,
        height: allRotatedHeight
      };
    }
    // scaleCacheCanvas() {
    //     let scaleX = this.getParent()?.ancestorScaleX || 1;
    //     let scaleY = this.getParent()?.ancestorScaleX || 1;
    //     this._cacheCanvas?.setPixelRatio(Math.max(scaleX, scaleY) * getDevicePixelRatio());
    //     this.makeDirty(true);
    // }
    _applyCache(ctx) {
      if (!ctx) {
        return;
      }
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.drawImage(this._cacheCanvas.getCanvasEle(), 0, 0);
      ctx.restore();
    }
    _draw(ctx, bounds) {
      this.draw(ctx, bounds);
    }
    _getAncestorSize() {
      const parent = this._getAncestorParent();
      if (!parent) {
        return;
      }
      if (parent.classType === "Engine" /* ENGINE */) {
        const mainCanvas = parent.getCanvas();
        return {
          width: mainCanvas.getWidth(),
          height: mainCanvas.getHeight()
        };
      }
      if (parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        return {
          width: parent.width,
          height: parent.height
        };
      }
    }
    _getAncestorParent() {
      let parent = this.parent;
      while (parent) {
        if (parent.classType === "Engine" /* ENGINE */ || parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
          return parent;
        }
        parent = parent?.getParent && parent?.getParent();
      }
    }
    _initialDefaultExtension() {
      SpreadsheetExtensionRegistry.getData().sort(sortRules).forEach((extension) => {
        this.register(extension);
      });
      this._borderAuxiliaryExtension = this.getExtensionByKey("DefaultBorderAuxiliaryExtension");
      this._backgroundExtension = this.getExtensionByKey("DefaultBackgroundExtension");
      this._borderExtension = this.getExtensionByKey("DefaultBorderExtension");
      this._fontExtension = this.getExtensionByKey("DefaultFontExtension");
    }
    _addMakeDirtyToScroll() {
      this._hasScrollViewportOperator(this, (viewport) => {
        viewport.onScrollBeforeObserver.add(() => {
          this.makeDirty(true);
        });
      });
    }
    _hasScrollViewportOperator(object, fn) {
      let parent = object.getParent();
      while (parent) {
        if (parent.classType === "Scene" /* SCENE */) {
          const viewports = parent.getViewports();
          const viewPorts = this._getHasScrollViewports(viewports);
          for (let viewport of viewports) {
            if (viewport) {
              fn(viewport);
            }
          }
        }
        parent = parent?.getParent && parent?.getParent();
      }
    }
    _getHasScrollViewports(viewports) {
      const newViewports = [];
      for (let viewport of viewports) {
        const scrollBar = viewport.getScrollBar();
        if (scrollBar) {
          newViewports.push(viewport);
        }
      }
      return newViewports;
    }
    // getOverflowRevertHorizontalAlign(row: number, column: number, docsConfig: fontCacheItem) {
    //     const spreadsheetSkeleton = this.getSkeleton();
    //     let { documentSkeleton, angle = 0, horizontalAlign, wrapStrategy } = docsConfig;
    //     if (!spreadsheetSkeleton) {
    //         return horizontalAlign;
    //     }
    //     const { rowHeightAccumulation, columnWidthAccumulation, dataMergeCache } = spreadsheetSkeleton;
    //     const cell = spreadsheetSkeleton.getCellData().getValue(row, column);
    //     if (wrapStrategy === WrapStrategy.OVERFLOW && angle !== 0 && cell?.n !== BooleanNumber.TRUE && horizontalAlign !== HorizontalAlign.JUSTIFIED) {
    //         let contentSize = documentSkeleton.getLastPageSize(angle);
    //         if (!contentSize) {
    //             return horizontalAlign;
    //         }
    //         let { startY, endY, startX, endX } = getCellByIndex(row, column, rowHeightAccumulation, columnWidthAccumulation, dataMergeCache);
    //         const cellWidth = endX - startX;
    //         const cellHeight = endY - startY;
    //         if (contentSize.height > cellHeight) {
    //             contentSize = {
    //                 width: cellHeight / Math.tan(Math.abs(angle)) + cellWidth,
    //                 height: cellHeight,
    //             };
    //             if (angle > 0) {
    //                 return HorizontalAlign.LEFT;
    //             } else {
    //                 return HorizontalAlign.RIGHT;
    //             }
    //         }
    //     }
    //     return horizontalAlign;
    // }
    _calculateOverflow() {
      const overflowCache = new ObjectMatrix();
      const spreadsheetSkeleton = this.getSkeleton();
      if (!spreadsheetSkeleton) {
        return;
      }
      const columnCount = spreadsheetSkeleton.getColumnCount();
      const { stylesCache, rowHeightAccumulation, columnWidthAccumulation, dataMergeCache } = spreadsheetSkeleton;
      const { font: fontList } = stylesCache;
      fontList && Object.keys(fontList).forEach((fontFormat) => {
        const fontObjectArray = fontList[fontFormat];
        fontObjectArray.forEach((row, fontArray) => {
          fontArray.forEach((column, docsConfig) => {
            let { documentSkeleton, angle = 0, verticalAlign, horizontalAlign, wrapStrategy } = docsConfig;
            const cell = spreadsheetSkeleton.getCellData().getValue(row, column);
            const sheetSkeleton = this.getSkeleton();
            if (!sheetSkeleton) {
              return true;
            }
            const { t: cellValueType = 0 /* STRING */ } = cell || {};
            if (wrapStrategy === 1 /* OVERFLOW */ && cellValueType !== 1 /* NUMBER */ && cellValueType !== 2 /* BOOLEAN */ && horizontalAlign !== 4 /* JUSTIFIED */) {
              let contentSize = this.getDocsSkeletonPageSize(documentSkeleton, angle);
              if (!contentSize) {
                return true;
              }
              if (angle !== 0) {
                let { startY, endY, startX, endX } = getCellByIndex(row, column, rowHeightAccumulation, columnWidthAccumulation, dataMergeCache);
                const cellWidth = endX - startX;
                const cellHeight = endY - startY;
                if (contentSize.height > cellHeight) {
                  contentSize = {
                    width: cellHeight / Math.tan(Math.abs(angle)) + cellWidth,
                    height: cellHeight
                  };
                }
              }
              const position = spreadsheetSkeleton.getOverflowPosition(contentSize, horizontalAlign, row, column, columnCount);
              const { startColumn, endColumn } = position;
              overflowCache.setValue(row, column, {
                startRow: row,
                endRow: row,
                startColumn,
                endColumn
              });
            } else if (wrapStrategy === 3 /* WRAP */ && angle !== 0) {
              let { startY, endY } = getCellByIndex(row, column, rowHeightAccumulation, columnWidthAccumulation, dataMergeCache);
              const cellHeight = endY - startY;
              documentSkeleton.updateDocumentDataPageSize(cellHeight);
              documentSkeleton.calculate();
              const contentSize = this.getDocsSkeletonPageSize(documentSkeleton, angle);
              if (!contentSize) {
                return true;
              }
              const { startColumn, endColumn } = sheetSkeleton.getOverflowPosition(contentSize, horizontalAlign, row, column, sheetSkeleton.getColumnCount());
              overflowCache.setValue(row, column, { startRow: row, endRow: row, startColumn, endColumn });
            }
          });
        });
      });
      spreadsheetSkeleton.setOverflowCache(overflowCache);
    }
    _differentBounds(bounds) {
      if (!this._boundsCache) {
        return bounds;
      }
      const { tl, tr, bl, br, dx, dy } = bounds;
      const { tl: cacheTL, tr: cacheTR, bl: cacheBL, br: cacheBR, dx: cacheDX, dy: cacheDY } = this._boundsCache;
      const newBounds = {
        tl,
        tr,
        bl,
        br,
        dx: 0,
        dy: 0
      };
      if (tl.x === cacheTL.x) {
        if (tl.y > cacheTL.y) {
          newBounds.tl = cacheBL;
          newBounds.tr = cacheBR;
        } else {
          newBounds.bl = cacheTL;
          newBounds.br = cacheTR;
        }
        newBounds.dy = cacheTL.y - tl.y;
      } else if (tl.y === cacheTL.y) {
        if (tl.x > cacheTL.x) {
          newBounds.tl = cacheTR;
          newBounds.bl = cacheBR;
        } else {
          newBounds.tr = cacheTL;
          newBounds.br = cacheBL;
        }
        newBounds.dx = cacheTL.x - tl.x;
      }
      return newBounds;
    }
    _checkSheetDifferentBounds(bounds1, bounds2) {
      const { tl, tr, bl, br } = bounds1;
      const { tl: cacheTL, tr: cacheTR, bl: cacheBL, br: cacheBR } = bounds2;
      if (tl.x === cacheTL.x && tr.x === cacheTR.x && bl.x === cacheBL.x && br.x === cacheBR.x) {
        if (tl.y >= cacheTL.y && tl.y <= cacheBL.y) {
          return true;
        }
        if (bl.y >= cacheTL.y && bl.y <= cacheBL.y) {
          return true;
        }
        return false;
      }
      if (tl.y === cacheTL.y && tr.y === cacheTR.y && bl.y === cacheBL.y && br.y === cacheBR.y) {
        if (tl.x >= cacheTL.x && tl.x <= cacheTR.x) {
          return true;
        }
        if (tr.x >= cacheTL.x && tr.x <= cacheTR.x) {
          return true;
        }
        return true;
      }
      return false;
    }
  };

  // ../../packages/base-render/src/Component/Sheets/RowTitle.ts
  var SpreadsheetRowTitle = class extends SpreadsheetTitle {
    _rowTitleLayoutExtension;
    constructor(oKey, spreadsheetSkeleton) {
      super(oKey, spreadsheetSkeleton);
      this._initialDefaultExtension();
      this.makeDirty(true);
    }
    get rowTitleLayoutExtension() {
      return this._rowTitleLayoutExtension;
    }
    draw(ctx, bounds) {
      const spreadsheetSkeleton = this.getSkeleton();
      if (!spreadsheetSkeleton) {
        return;
      }
      const parentScale = this.getParentScale();
      spreadsheetSkeleton.calculate(bounds);
      const scale = getScale(parentScale);
      const { columnTitleHeight } = spreadsheetSkeleton;
      ctx.translate(-0.5 / scale, fixLineWidthByScale(columnTitleHeight, scale) - 0.5 / scale);
      const extensions = this.getExtensionsByOrder();
      for (let extension of extensions) {
        extension.draw(ctx, parentScale, spreadsheetSkeleton);
      }
    }
    isHit(coord) {
      const oCoord = this._getInverseCoord(coord);
      const skeleton = this.getSkeleton();
      if (!skeleton) {
        return false;
      }
      const { rowTitleWidth, columnTitleHeight } = skeleton;
      if (oCoord.x >= 0 && oCoord.x <= rowTitleWidth && oCoord.y > columnTitleHeight) {
        return true;
      }
      return false;
    }
    _initialDefaultExtension() {
      SheetRowTitleExtensionRegistry.getData().forEach((extension) => {
        this.register(extension);
      });
      this._rowTitleLayoutExtension = this.getExtensionByKey("DefaultRowTitleLayoutExtension");
    }
  };

  // ../../packages/base-render/src/Component/Sheets/ColumnTitle.ts
  var SpreadsheetColumnTitle = class extends SpreadsheetTitle {
    _columnTitleLayoutExtension;
    constructor(oKey, spreadsheetSkeleton) {
      super(oKey, spreadsheetSkeleton);
      this._initialDefaultExtension();
      this.makeDirty(true);
    }
    get columnTitleLayoutExtension() {
      return this._columnTitleLayoutExtension;
    }
    draw(ctx, bounds) {
      const spreadsheetSkeleton = this.getSkeleton();
      if (!spreadsheetSkeleton) {
        return;
      }
      const parentScale = this.getParentScale();
      spreadsheetSkeleton.calculate(bounds);
      const scale = getScale(parentScale);
      const { rowTitleWidth } = spreadsheetSkeleton;
      ctx.translate(fixLineWidthByScale(rowTitleWidth, scale) - 0.5 / scale, -0.5 / scale);
      const extensions = this.getExtensionsByOrder();
      for (let extension of extensions) {
        extension.draw(ctx, parentScale, spreadsheetSkeleton);
      }
    }
    isHit(coord) {
      const oCoord = this._getInverseCoord(coord);
      const skeleton = this.getSkeleton();
      if (!skeleton) {
        return false;
      }
      const { rowTitleWidth, columnTitleHeight } = skeleton;
      if (oCoord.x > rowTitleWidth && oCoord.y >= 0 && oCoord.y <= columnTitleHeight) {
        return true;
      }
      return false;
    }
    _initialDefaultExtension() {
      SheetColumnTitleExtensionRegistry.getData().forEach((extension) => {
        this.register(extension);
      });
      this._columnTitleLayoutExtension = this.getExtensionByKey("DefaultColumnTitleLayoutExtension");
    }
  };

  // ../../packages/base-render/src/Component/Sheets/SheetSkeleton.ts
  var SpreadsheetSkeleton = class extends Skeleton {
    constructor(_config, _cellData, _styles, context) {
      super(context);
      this._config = _config;
      this._cellData = _cellData;
      this._styles = _styles;
      this.updateLayout();
      this.updateDataMerge();
    }
    _rowHeightAccumulation;
    _rowTotalHeight;
    _columnWidthAccumulation;
    _columnTotalWidth;
    _rowTitleWidth = 0;
    _columnTitleHeight = 0;
    _rowColumnSegment;
    _dataMergeCache;
    _dataMergeCacheAll;
    _overflowCache;
    _stylesCache;
    _showGridlines;
    get rowHeightAccumulation() {
      return this._rowHeightAccumulation;
    }
    get rowTotalHeight() {
      return this._rowTotalHeight;
    }
    get columnWidthAccumulation() {
      return this._columnWidthAccumulation;
    }
    get columnTotalWidth() {
      return this._columnTotalWidth;
    }
    get rowTitleWidth() {
      return this._rowTitleWidth;
    }
    get columnTitleHeight() {
      return this._columnTitleHeight;
    }
    get rowColumnSegment() {
      return this._rowColumnSegment;
    }
    get dataMergeCache() {
      return this._dataMergeCache;
    }
    get stylesCache() {
      return this._stylesCache;
    }
    get overflowCache() {
      return this._overflowCache;
    }
    get showGridlines() {
      return this._showGridlines;
    }
    get dataMergeCacheAll() {
      return this._dataMergeCacheAll;
    }
    static create(config, cellData, styles, context) {
      return new SpreadsheetSkeleton(config, cellData, styles, context);
    }
    getWorksheetConfig() {
      return this._config;
    }
    getCellData() {
      return this._cellData;
    }
    getsStyles() {
      return this._styles;
    }
    setOverflowCache(value) {
      this._overflowCache = value;
    }
    calculate(bounds) {
      if (!this._config) {
        return;
      }
      this.updateLayout();
      if (!this._rowHeightAccumulation || !this._columnWidthAccumulation) {
        return;
      }
      const { mergeData } = this._config;
      this._rowColumnSegment = this.getRowColumnSegment(bounds);
      this._dataMergeCache = mergeData && this._getMergeCells(mergeData, this._rowColumnSegment);
      this._stylesCache = this._calculateStylesCache();
      return this;
    }
    updateLayout() {
      if (!this.dirty) {
        return;
      }
      const { rowData, columnData, defaultRowHeight, defaultColumnWidth, rowCount, columnCount, rowTitle, columnTitle, showGridlines } = this._config;
      const { rowTotalHeight, rowHeightAccumulation } = this._generateRowMatrixCache(rowCount, rowData, defaultRowHeight);
      const { columnTotalWidth, columnWidthAccumulation } = this._generateColumnMatrixCache(columnCount, columnData, defaultColumnWidth);
      this._rowTitleWidth = rowTitle.hidden !== 1 /* TRUE */ ? rowTitle.width : 0;
      this._columnTitleHeight = columnTitle.hidden !== 1 /* TRUE */ ? columnTitle.height : 0;
      this._rowTotalHeight = rowTotalHeight;
      this._rowHeightAccumulation = rowHeightAccumulation;
      this._columnTotalWidth = columnTotalWidth;
      this._columnWidthAccumulation = columnWidthAccumulation;
      this._showGridlines = showGridlines;
      this.makeDirty(true);
      return this;
    }
    updateDataMerge() {
      const { mergeData } = this._config;
      this._dataMergeCacheAll = mergeData && this._getMergeCells(mergeData);
    }
    getRowColumnSegment(bounds) {
      return this._getBounding(this._rowHeightAccumulation, this._columnWidthAccumulation, bounds);
    }
    getMergeBounding(startRow, startColumn, endRow, endColumn) {
      const dataMergeCache = this._dataMergeCacheAll;
      if (!dataMergeCache) {
        return {
          startRow,
          startColumn,
          endRow,
          endColumn
        };
      }
      let isSearching = true;
      let searchedMarge = new ObjectMatrix();
      while (isSearching) {
        isSearching = false;
        dataMergeCache.forEach((row, rowArray) => {
          rowArray.forEach((column, mainCell) => {
            if (!mainCell || searchedMarge.getValue(row, column)) {
              return true;
            }
            const { startRow: mainStartRow, startColumn: mainStartColumn, endRow: mainEndRow, endColumn: mainEndColumn } = mainCell;
            const rect1 = {
              left: startColumn,
              top: startRow,
              right: endColumn,
              bottom: endRow
            };
            const rect2 = {
              left: mainStartColumn,
              top: mainStartRow,
              right: mainEndColumn,
              bottom: mainEndRow
            };
            if (isRectIntersect(rect1, rect2)) {
              startRow = Math.min(startRow, mainStartRow);
              startColumn = Math.min(startColumn, mainStartColumn);
              endRow = Math.max(endRow, mainEndRow);
              endColumn = Math.max(endColumn, mainEndColumn);
              searchedMarge.setValue(row, column, true);
              isSearching = true;
            }
          });
        });
      }
      return {
        startRow,
        startColumn,
        endRow,
        endColumn
      };
    }
    appendToOverflowCache(row, column, startColumn, endColumn) {
      this._overflowCache.setValue(row, column, {
        startRow: row,
        endRow: row,
        startColumn,
        endColumn
      });
    }
    getColumnCount() {
      return this._columnWidthAccumulation.length;
    }
    getRowCount() {
      return this._rowHeightAccumulation.length;
    }
    getOverflowPosition(contentSize, horizontalAlign, row, column, columnCount) {
      const { width: contentWidth, height: contentHeight } = contentSize;
      let startColumn = column;
      let endColumn = column;
      if (horizontalAlign === 2 /* CENTER */) {
        startColumn = this._getOverflowBound(row, column, 0, contentWidth / 2);
        endColumn = this._getOverflowBound(row, column, columnCount - 1, contentWidth / 2);
      } else if (horizontalAlign === 3 /* RIGHT */) {
        startColumn = this._getOverflowBound(row, column, 0, contentWidth);
      } else {
        endColumn = this._getOverflowBound(row, column, columnCount - 1, contentWidth);
      }
      return {
        startColumn,
        endColumn
      };
    }
    /**
     *
     * @param rowHeightAccumulation Row layout information
     * @param columnWidthAccumulation Column layout information
     * @param bounds The range of the visible area of the canvas
     * @returns The range cell index of the canvas visible area
     */
    _getBounding(rowHeightAccumulation, columnWidthAccumulation, bounds) {
      const rhaLength = rowHeightAccumulation.length;
      const cwaLength = columnWidthAccumulation.length;
      if (!bounds) {
        return {
          startRow: 0,
          endRow: rhaLength - 1,
          startColumn: 0,
          endColumn: cwaLength - 1
        };
      }
      let dataset_row_st = -1;
      let dataset_row_ed = -1;
      let dataset_col_st = -1;
      let dataset_col_ed = -1;
      dataset_row_st = searchArray(rowHeightAccumulation, bounds.tl.y - this.columnTitleHeight);
      dataset_row_ed = searchArray(rowHeightAccumulation, bounds.bl.y - this.columnTitleHeight);
      if (dataset_row_st === -1) {
        dataset_row_st = 0;
      }
      if (dataset_row_ed === -1) {
        dataset_row_ed = rhaLength - 1;
      }
      if (dataset_row_ed >= rhaLength) {
        dataset_row_ed = rhaLength - 1;
      }
      dataset_col_st = searchArray(columnWidthAccumulation, bounds.tl.x - this.rowTitleWidth);
      dataset_col_ed = searchArray(columnWidthAccumulation, bounds.tr.x - this.rowTitleWidth);
      if (dataset_col_st === -1) {
        dataset_col_st = 0;
      }
      if (dataset_col_ed === -1) {
        dataset_col_ed = cwaLength - 1;
      }
      if (dataset_col_ed >= cwaLength) {
        dataset_col_ed = cwaLength - 1;
      }
      return {
        startRow: dataset_row_st - 1,
        endRow: dataset_row_ed + 1,
        startColumn: dataset_col_st - 1,
        endColumn: dataset_col_ed + 1
      };
    }
    _generateRowMatrixCache(rowCount, rowData, defaultRowHeight) {
      let rowTotalHeight = 0;
      const rowHeightAccumulation = [];
      const data = new ObjectArray(rowData);
      for (let r4 = 0; r4 < rowCount; r4++) {
        let rowHeight = defaultRowHeight;
        if (data.get(r4) != null) {
          const rowDataItem = data.get(r4);
          if (!rowDataItem) {
            continue;
          }
          if (rowDataItem.h != null) {
            rowHeight = rowDataItem.h;
          } else if (rowDataItem.ah != null) {
            rowHeight = rowDataItem.ah;
          }
          if (rowDataItem.hd === 1 /* TRUE */) {
            rowHeight = 0;
          }
        }
        rowTotalHeight += rowHeight;
        rowHeightAccumulation.push(rowTotalHeight);
      }
      return {
        rowTotalHeight,
        rowHeightAccumulation
      };
    }
    _generateColumnMatrixCache(colCount, columnData, defaultColumnWidth) {
      let columnTotalWidth = 0;
      const columnWidthAccumulation = [];
      const data = new ObjectArray(columnData);
      for (let c4 = 0; c4 < colCount; c4++) {
        let columnWidth = defaultColumnWidth;
        if (data.get(c4) != null) {
          const columnDataItem = data.get(c4);
          if (!columnDataItem) {
            continue;
          }
          if (columnDataItem.w != null) {
            columnWidth = columnDataItem.w;
          }
          if (columnDataItem.hd === 1 /* TRUE */) {
            columnWidth = 0;
          }
        }
        columnTotalWidth += columnWidth;
        columnWidthAccumulation.push(columnTotalWidth);
      }
      return {
        columnTotalWidth,
        columnWidthAccumulation
      };
    }
    // private _calculateOverflowCache() {
    //     const { font: fontList } = this.stylesCache;
    //     // const mergeRangeCache = this._getMergeRangeCache();
    //     const overflowCache = new ObjectMatrix<IRangeData>();
    //     const columnCount = this.getColumnCount();
    //     fontList &&
    //         Object.keys(fontList).forEach((fontFormat: string) => {
    //             const fontObjectArray = fontList[fontFormat];
    //             fontObjectArray.forEach((row, fontArray) => {
    //                 fontArray.forEach((column, docsSkeleton) => {
    //                     // overflow handler
    //                     const { documentSkeleton, angle, verticalAlign, horizontalAlign, wrapStrategy } = docsSkeleton;
    //                     const cell = this._cellData.getValue(row, column);
    //                     if (wrapStrategy !== WrapStrategy.OVERFLOW || cell?.n === BooleanNumber.TRUE) {
    //                         return true;
    //                     }
    //                     if (horizontalAlign === HorizontalAlign.JUSTIFIED) {
    //                         return true;
    //                     }
    //                     let contentSize = documentSkeleton.getLastPageSize(angle);
    //                     if (!contentSize) {
    //                         return true;
    //                     }
    //                     // if(angle!==0){
    //                     //     contentSize = {
    //                     //         width: contentSize.width,
    //                     //     }
    //                     // }
    //                     const position = this.getOverflowPosition(contentSize, horizontalAlign, row, column, columnCount);
    //                     const { startColumn, endColumn } = position;
    //                     overflowCache.setValue(row, column, {
    //                         startRow: row,
    //                         endRow: row,
    //                         startColumn,
    //                         endColumn,
    //                     });
    //                     // console.log('appendToOverflowCache', angle, contentSize, { row, column, startColumn, endColumn });
    //                 });
    //             });
    //         });
    //     return overflowCache;
    // }
    _getOverflowBound(row, startColumn, endColumn, contentWidth) {
      let cumWidth = 0;
      if (startColumn > endColumn) {
        const columnCount = this._columnWidthAccumulation.length - 1;
        for (let i4 = startColumn; i4 >= endColumn; i4--) {
          const column = i4;
          const cell = this._cellData.getValue(row, column);
          if (!isEmptyCell(cell) && column !== startColumn || this._intersectMergeRange(row, column)) {
            if (column === startColumn) {
              return column;
            }
            return column + 1 > columnCount ? columnCount : column + 1;
          }
          const { startX, endX } = getCellPositionByIndex(row, column, this.rowHeightAccumulation, this.columnWidthAccumulation);
          cumWidth += endX - startX;
          if (contentWidth < cumWidth) {
            return column;
          }
        }
        return startColumn;
      }
      for (let i4 = startColumn; i4 <= endColumn; i4++) {
        const column = i4;
        const cell = this._cellData.getValue(row, column);
        if (!isEmptyCell(cell) && column !== startColumn || this._intersectMergeRange(row, column)) {
          if (column === startColumn) {
            return column;
          }
          return column - 1 < 0 ? 0 : column - 1;
        }
        const { startX, endX } = getCellPositionByIndex(row, column, this.rowHeightAccumulation, this.columnWidthAccumulation);
        cumWidth += endX - startX;
        if (contentWidth < cumWidth) {
          return column;
        }
      }
      return endColumn;
    }
    _intersectMergeRange(row, column) {
      const dataMergeCache = this.dataMergeCache;
      let isIntersected = false;
      dataMergeCache?.forEach((r4, dataMergeRow) => {
        dataMergeRow?.forEach((c4, dataCache) => {
          const { startRow: startRowMargeIndex, endRow: endRowMargeIndex, startColumn: startColumnMargeIndex, endColumn: endColumnMargeIndex } = dataCache;
          if (row >= startRowMargeIndex && row <= endRowMargeIndex && column >= startColumnMargeIndex && column <= endColumnMargeIndex) {
            isIntersected = true;
            return false;
          }
        });
      });
      return isIntersected;
    }
    // private _getMergeRangeCache() {
    //     const dataMergeCache = this.dataMergeCache;
    //     const mergeRangeCache = new ObjectMatrix<ObjectMatrix<boolean>>();
    //     dataMergeCache?.forEach((r, dataMergeRow) => {
    //         dataMergeRow?.forEach((c, dataCache) => {
    //             const { startRow: startRowMargeIndex, endRow: endRowMargeIndex, startColumn: startColumnMargeIndex, endColumn: endColumnMargeIndex } = dataCache;
    //             const endObject = new ObjectMatrix<boolean>();
    //             endObject.setValue(endRowMargeIndex, endColumnMargeIndex, true);
    //             mergeRangeCache.setValue(startRowMargeIndex, startColumnMargeIndex, endObject);
    //         });
    //     });
    //     return mergeRangeCache;
    // }
    _calculateStylesCache() {
      const cache = {
        background: {},
        font: {},
        border: new ObjectMatrix()
      };
      const fontLocale = this.getFontLocale();
      const dataMergeCache = this._dataMergeCache;
      const rowColumnSegment = this._rowColumnSegment;
      const columnWidthAccumulation = this.columnWidthAccumulation;
      const styles = this._styles;
      const cellData = this._cellData;
      const { startRow, endRow, startColumn, endColumn } = rowColumnSegment;
      for (let r4 = startRow; r4 <= endRow; r4++) {
        for (let c4 = startColumn; c4 <= endColumn; c4++) {
          this.__setCellCache(
            r4,
            c4,
            {
              cache,
              styles,
              cellData,
              skipBackgroundAndBorder: false
            },
            fontLocale
          );
        }
        for (let c4 = 0; c4 < startColumn; c4++) {
          this.__setCellCache(
            r4,
            c4,
            {
              cache,
              styles,
              cellData,
              skipBackgroundAndBorder: true
            },
            fontLocale
          );
        }
        for (let c4 = endColumn + 1; c4 < columnWidthAccumulation.length; c4++) {
          this.__setCellCache(
            r4,
            c4,
            {
              cache,
              styles,
              cellData,
              skipBackgroundAndBorder: true
            },
            fontLocale
          );
        }
      }
      dataMergeCache && dataMergeCache.forEach((rowIndex, row) => {
        row.forEach((columnIndex, mainCell) => {
          if (!mainCell) {
            return true;
          }
          this.__setCellCache(
            rowIndex,
            columnIndex,
            {
              cache,
              styles,
              cellData,
              skipBackgroundAndBorder: false
            },
            fontLocale
          );
        });
      });
      return cache;
    }
    __setCellCache(r4, c4, props, fontLocale) {
      const { cache, skipBackgroundAndBorder = false, styles, cellData } = props;
      if (!cellData) {
        return true;
      }
      const cell = cellData.getValue(r4, c4);
      if (!cell) {
        return true;
      }
      const style = styles && styles.getStyleByCell(cell);
      if (!skipBackgroundAndBorder && style && style.bg && style.bg.rgb) {
        const rgb = style.bg.rgb;
        if (!cache.background[rgb]) {
          cache.background[rgb] = new ObjectMatrix();
        }
        const bgCache = cache.background[rgb];
        bgCache.setValue(r4, c4, rgb);
      }
      if (!skipBackgroundAndBorder && style && style.bd) {
        this.___setBorderProps(r4, c4, "t" /* TOP */, style, cache);
        this.___setBorderProps(r4, c4, "b" /* BOTTOM */, style, cache);
        this.___setBorderProps(r4, c4, "l" /* LEFT */, style, cache);
        this.___setBorderProps(r4, c4, "r" /* RIGHT */, style, cache);
      }
      const content = cell.m || cell.v;
      let documentData;
      let fontString = "document";
      const cellOtherConfig = this._getOtherStyle(style);
      const textRotation = cellOtherConfig.textRotation || { a: 0, v: 0 /* FALSE */ };
      const horizontalAlign = cellOtherConfig.horizontalAlign || 0 /* UNSPECIFIED */;
      const verticalAlign = cellOtherConfig.verticalAlign || 0 /* UNSPECIFIED */;
      const wrapStrategy = cellOtherConfig.wrapStrategy || 0 /* UNSPECIFIED */;
      if (cell.p) {
        if (!cache.font[fontString]) {
          cache.font[fontString] = new ObjectMatrix();
        }
        let { a: angle2 = 0, v: isVertical2 = 0 /* FALSE */ } = textRotation;
        let centerAngle = 0;
        let vertexAngle = angle2;
        if (isVertical2 === 1 /* TRUE */) {
          centerAngle = 90;
          vertexAngle = 90;
        }
        documentData = this._updateRenderConfigAndHorizon(cell.p, horizontalAlign, {
          horizontalAlign,
          verticalAlign,
          centerAngle,
          vertexAngle,
          wrapStrategy
        });
      } else if (content) {
        const textStyle = this._getFontFormat(style);
        fontString = getFontStyleString(textStyle, fontLocale).fontString;
        if (!cache.font[fontString]) {
          cache.font[fontString] = new ObjectMatrix();
        }
        documentData = this._getDocumentDataByStyle(content.toString(), textStyle, cellOtherConfig);
      }
      const fontCache = cache.font[fontString];
      let { a: angle, v: isVertical = 0 /* FALSE */ } = textRotation;
      if (isVertical === 1 /* TRUE */) {
        angle = 90;
      }
      if (documentData) {
        const documentSkeleton = DocumentSkeleton.create(documentData, this.getContext());
        if (angle === 0 || wrapStrategy !== 3 /* WRAP */) {
          documentSkeleton.calculate();
        }
        fontCache.setValue(r4, c4, {
          documentSkeleton,
          angle,
          verticalAlign,
          horizontalAlign,
          wrapStrategy,
          content: content?.toString()
        });
      }
    }
    _updateRenderConfigAndHorizon(document2, horizontalAlign, renderConfig) {
      if (!renderConfig) {
        return;
      }
      if (!document2.body?.blockElements) {
        return;
      }
      if (!document2.documentStyle) {
        document2.documentStyle = {};
      }
      document2.documentStyle.renderConfig = renderConfig;
      const blockElements = document2.body.blockElements;
      for (let blockElement of blockElements) {
        if (blockElement.blockType === 0 /* PARAGRAPH */) {
          if (!blockElement.paragraph) {
            continue;
          }
          if (!blockElement.paragraph.paragraphStyle) {
            blockElement.paragraph.paragraphStyle = {};
          }
          blockElement.paragraph.paragraphStyle.horizontalAlign = horizontalAlign;
        }
      }
      return document2;
    }
    _getDocumentDataByStyle(content, textStyle, config) {
      const contentLength = content.length - 1;
      const {
        textRotation = { a: 0, v: 0 /* FALSE */ },
        textDirection = 0 /* UNSPECIFIED */,
        paddingData = {
          t: 0,
          r: 2,
          b: 0,
          l: 2
        },
        horizontalAlign = 0 /* UNSPECIFIED */,
        verticalAlign = 0 /* UNSPECIFIED */,
        wrapStrategy = 0 /* UNSPECIFIED */
      } = config;
      const { a: angle = 0, v: isVertical = 0 /* FALSE */ } = textRotation;
      const { t: marginTop, r: marginRight, b: marginBottom, l: marginLeft } = paddingData;
      let textDirectionDocument = 0 /* NORMAL */;
      let centerAngle = 0;
      let vertexAngle = angle;
      if (isVertical === 1 /* TRUE */) {
        centerAngle = 90;
        vertexAngle = 90;
        textDirectionDocument = 1 /* TBRL */;
      }
      const documentData = {
        id: "d",
        body: {
          blockElements: [
            {
              blockId: "oneParagraph",
              st: 0,
              ed: contentLength,
              blockType: 0 /* PARAGRAPH */,
              paragraph: {
                paragraphStyle: {
                  horizontalAlign
                },
                elements: [
                  {
                    eId: "oneElement",
                    st: 0,
                    ed: contentLength,
                    et: 0 /* TEXT_RUN */,
                    tr: {
                      ct: content,
                      ts: textStyle
                    }
                  }
                ]
              }
            }
            // oneSectionBreak: {
            //     blockId: 'oneSectionBreak',
            //     st: 0,
            //     ed: 0,
            //     blockType: BlockType.SECTION_BREAK,
            //     sectionBreak: {
            //         columnProperties: [],
            //         columnSeparatorType: ColumnSeparatorType.NONE,
            //         sectionType: SectionType.SECTION_TYPE_UNSPECIFIED,
            //         // textDirection: textDirectionDocument,
            //         // contentDirection: textDirection!,
            //     },
            // },
          ]
        },
        documentStyle: {
          pageSize: {
            width: Infinity,
            height: Infinity
          },
          marginTop,
          marginBottom,
          marginRight,
          marginLeft,
          renderConfig: {
            horizontalAlign,
            verticalAlign,
            centerAngle,
            vertexAngle,
            wrapStrategy
          }
        }
      };
      return documentData;
    }
    ___setBorderProps(r4, c4, type, style, cache) {
      const props = style.bd?.[type];
      if (!props || !cache.border) {
        return true;
      }
      const rgb = getColorStyle(props.cl) || COLOR_BLACK_RGB;
      const borderCache = cache.border;
      if (!borderCache.getValue(r4, c4)) {
        borderCache.setValue(r4, c4, { [type]: {} });
      }
      borderCache.getValue(r4, c4)[type] = {
        type,
        style: props.s,
        color: rgb
      };
    }
    _getFontFormat(format) {
      if (!format) {
        return {};
      }
      const { ff, fs, it, bl, ul, st, ol, cl, bg, bd } = format;
      return {
        ff,
        fs,
        it,
        bl,
        ul,
        st,
        ol,
        cl
      };
    }
    _getOtherStyle(format) {
      if (!format) {
        return {};
      }
      const {
        tr: textRotation,
        td: textDirection,
        ht: horizontalAlign,
        vt: verticalAlign,
        tb: wrapStrategy,
        pd: paddingData
      } = format;
      return {
        textRotation,
        textDirection,
        horizontalAlign,
        verticalAlign,
        wrapStrategy,
        paddingData
      };
    }
    _getMergeCells(mergeData, rowColumnSegment) {
      const endColumnLast = this.columnWidthAccumulation.length - 1;
      if (!rowColumnSegment) {
        const endRow2 = this.rowHeightAccumulation.length - 1;
        rowColumnSegment = { startRow: 0, startColumn: 0, endRow: endRow2, endColumn: endColumnLast };
      } else {
        rowColumnSegment = { startRow: rowColumnSegment.startRow, endRow: rowColumnSegment.endRow, endColumn: endColumnLast, startColumn: 0 };
      }
      const { startRow, startColumn, endRow, endColumn } = rowColumnSegment;
      const cacheDataMerge = new ObjectMatrix();
      for (let i4 = 0; i4 < mergeData.length; i4++) {
        const { startRow: mergeStartRow, endRow: mergeEndRow, startColumn: mergeStartColumn, endColumn: mergeEndColumn } = mergeData[i4];
        for (let r4 = startRow; r4 <= endRow; r4++) {
          let isBreak = false;
          for (let c4 = startColumn; c4 <= endColumn; c4++) {
            if (r4 >= mergeStartRow && r4 <= mergeEndRow && c4 >= mergeStartColumn && c4 <= mergeEndColumn) {
              cacheDataMerge.setValue(mergeStartRow, mergeStartColumn, {
                startRow: mergeStartRow,
                endRow: mergeEndRow,
                startColumn: mergeStartColumn,
                endColumn: mergeEndColumn
              });
              isBreak = true;
              break;
            }
          }
          if (isBreak) {
            break;
          }
        }
      }
      return cacheDataMerge;
    }
  };

  // ../../packages/base-render/src/RenderEngine.ts
  var RenderEngine = class extends Plugin {
    _engine;
    constructor() {
      super("renderEngine" /* BASE_RENDER */);
      this._engine = new Engine();
    }
    static create() {
      return new RenderEngine();
    }
    installTo(univerInstance) {
      univerInstance.install(this);
    }
    getEngine() {
      return this._engine;
    }
  };

  // ../../packages/base-sheets/src/Basics/Observer.ts
  function uninstall(plugin) {
    plugin.deleteObserve("onDragAndDropStartObserver");
    plugin.deleteObserve("onDragAndDroppingObserver");
    plugin.deleteObserve("onDragAndDropEndEndObserver");
    plugin.deleteObserve("onFillStartObserver");
    plugin.deleteObserve("onFillingObserver");
    plugin.deleteObserve("onFillEndObserver");
    plugin.deleteObserve("onChangeSelectionObserver");
    plugin.deleteObserve("onToolbarDidMountObservable");
    plugin.deleteObserve("onModalGroupDidMountObservable");
    plugin.deleteObserve("onChangeCurrentSheetObserver");
    plugin.deleteObserve("onSheetContainerDidMountObservable");
    plugin.deleteObserve("onCellRangeModalDidMountObservable");
  }
  function install(plugin) {
    plugin.pushToObserve("onDragAndDropStartObserver");
    plugin.pushToObserve("onDragAndDroppingObserver");
    plugin.pushToObserve("onDragAndDropEndEndObserver");
    plugin.pushToObserve("onFillStartObserver");
    plugin.pushToObserve("onFillingObserver");
    plugin.pushToObserve("onFillEndObserver");
    plugin.pushToObserve("onChangeSelectionObserver");
    plugin.pushToObserve("onChangeCurrentSheetObserver");
    plugin.pushToObserve("onToolbarDidMountObservable");
    plugin.pushToObserve("onCellRangeModalDidMountObservable");
    plugin.pushToObserve("onModalGroupDidMountObservable");
    plugin.pushToObserve("onLineColorDidMountObservable");
    plugin.pushToObserve("onLineBoldDidMountObservable");
    plugin.pushToObserve("onColorSelectDidMountObservable");
    plugin.pushToObserve("onSheetBarDidMountObservable");
    plugin.pushToObserve("onCountBarDidMountObservable");
    plugin.pushToObserve("onInfoBarDidMountObservable");
    plugin.pushToObserve("onRightMenuDidMountObservable");
    plugin.pushToObserve("onSheetContainerDidMountObservable");
  }

  // ../../packages/base-sheets/src/View/Render/BaseView.ts
  var BaseView = class {
    viewKey = "";
    _scene;
    _plugin;
    // constructor(private _scene: Scene, private _plugin: Plugin) {
    //     this._initialize();
    // }
    getScene() {
      return this._scene;
    }
    getPlugin() {
      return this._plugin;
    }
    getContext() {
      return this._plugin.getContext();
    }
    updateToSheet(worksheet) {
    }
    _initialize() {
    }
    initialize(scene, plugin) {
      this._scene = scene;
      this._plugin = plugin;
      this._initialize();
      return this;
    }
  };
  var CanvasViewRegistry = Registry2.create();

  // ../../packages/base-sheets/src/Basics/Const/DEFAULT_SPREADSHEET_PLUGIN_DATA.ts
  var DEFAULT_SPREADSHEET_PLUGIN_DATA = {
    selections: {}
  };

  // ../../packages/base-sheets/src/Model/Apply/SetSelectionValue.ts
  function SetSelectionValue(worksheet, selections) {
    const selectionManager = worksheet.getContext().getPluginManager().getRequirePluginByName("spreadsheet" /* SPREADSHEET */).getSelectionManager();
    const result = selectionManager.getCurrentModelsValue();
    selectionManager.setModels(selections);
    return result;
  }

  // ../../packages/base-sheets/src/Model/Action/SetSelectionValueAction.ts
  var SetSelectionValueAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      const selections = this.do();
      this._oldActionData = {
        ...actionData,
        selections
      };
      this.validate();
    }
    do() {
      const { selections } = this._doActionData;
      const worksheet = this.getWorkSheet();
      const result = SetSelectionValue(worksheet, selections);
      this._observers.notifyObservers({
        type: 0 /* REDO */,
        data: this._doActionData,
        action: this
      });
      return result;
    }
    redo() {
      const { sheetId } = this._doActionData;
      const selections = this.do();
      this._oldActionData = {
        actionName: "SetSelectionValueAction" /* SET_SELECTION_VALUE_ACTION */,
        sheetId,
        selections
      };
    }
    undo() {
      const { selections, sheetId } = this._oldActionData;
      const worksheet = this.getWorkSheet();
      this._doActionData = {
        actionName: "SetSelectionValueAction" /* SET_SELECTION_VALUE_ACTION */,
        sheetId,
        selections: SetSelectionValue(worksheet, selections)
      };
      this._observers.notifyObservers({
        type: 1 /* UNDO */,
        data: this._oldActionData,
        action: this
      });
    }
    validate() {
      return false;
    }
  };
  __publicField(SetSelectionValueAction, "NAME", "SetSelectionValueAction");

  // ../../packages/base-sheets/src/Basics/RegisterAction.ts
  CommandManager.register(SetSelectionValueAction.NAME, SetSelectionValueAction);

  // ../../packages/base-sheets/src/Controller/Selection/SelectionControlDragDrop.ts
  var SelectionControlDragAndDrop = class {
    constructor(_control) {
      this._control = _control;
      this._zIndex = _control.zIndex + 1;
      this._model = _control.model;
      this._initialize();
    }
    _leftDragControl;
    _rightDragControl;
    _topDragControl;
    _bottomDragControl;
    _selectionDragShape;
    _zIndex;
    _model;
    _oldSelectionRange;
    _startOffsetX = 0;
    _startOffsetY = 0;
    _cellPositionOffset;
    _moveObserver;
    _upObserver;
    _initialize() {
      const plugin = this._control.getPlugin();
      const main = plugin.getMainComponent();
      const { leftControl, rightControl, topControl, bottomControl, fillControl } = this._control;
      leftControl.onPointerEnterObserver.add((evt) => {
        leftControl.cursor = "move" /* MOVE */;
      });
      leftControl.onPointerLeaveObserver.add((evt) => {
        leftControl.resetCursor();
      });
      rightControl.onPointerEnterObserver.add((evt) => {
        rightControl.cursor = "move" /* MOVE */;
      });
      rightControl.onPointerLeaveObserver.add((evt) => {
        rightControl.resetCursor();
      });
      topControl.onPointerEnterObserver.add((evt) => {
        topControl.cursor = "move" /* MOVE */;
      });
      topControl.onPointerLeaveObserver.add((evt) => {
        topControl.resetCursor();
      });
      bottomControl.onPointerEnterObserver.add((evt) => {
        bottomControl.cursor = "move" /* MOVE */;
      });
      bottomControl.onPointerLeaveObserver.add((evt) => {
        bottomControl.resetCursor();
      });
      bottomControl.onPointerDownObserver.add((evt) => {
        this.dragDown(evt, 3 /* BOTTOM */);
      });
      bottomControl.onPointerUpObserver.add((evt) => {
        bottomControl.resetCursor();
      });
      const zIndex = this._zIndex;
      this._leftDragControl = new Rect("__LeftDragControl__" /* left */ + zIndex, {
        top: 0,
        left: -DEFAULT_SELECTION_CONFIG2.strokeWidth / 2,
        width: DEFAULT_SELECTION_CONFIG2.strokeWidth * 2,
        fill: DEFAULT_SELECTION_CONFIG2.strokeColor,
        zIndex
      });
      this._rightDragControl = new Rect("__RightDragControl__" /* right */ + zIndex, {
        width: DEFAULT_SELECTION_CONFIG2.strokeWidth * 2,
        fill: DEFAULT_SELECTION_CONFIG2.strokeColor,
        zIndex
      });
      this._topDragControl = new Rect("__TopDragControl__" /* top */ + zIndex, {
        top: -DEFAULT_SELECTION_CONFIG2.strokeWidth / 2,
        left: -DEFAULT_SELECTION_CONFIG2.strokeWidth / 2,
        height: DEFAULT_SELECTION_CONFIG2.strokeWidth * 2,
        fill: DEFAULT_SELECTION_CONFIG2.strokeColor,
        zIndex
      });
      this._bottomDragControl = new Rect("__BottomDragControl__" /* bottom */ + zIndex, {
        height: DEFAULT_SELECTION_CONFIG2.strokeWidth * 2,
        fill: DEFAULT_SELECTION_CONFIG2.strokeColor,
        left: -DEFAULT_SELECTION_CONFIG2.strokeWidth / 2,
        zIndex
      });
      this._selectionDragShape = new Group("__SelectionDragShape__" /* Selection */ + zIndex, this._leftDragControl, this._rightDragControl, this._topDragControl, this._bottomDragControl);
      this._selectionDragShape.evented = false;
      this._selectionDragShape.zIndex = zIndex;
      const scene = this._control.getScene();
      scene.addObject(this._selectionDragShape);
    }
    dragEventInitial() {
    }
    dragDown(evt, direction) {
      const main = this._control.getPlugin().getMainComponent();
      const selection = this._model.getValue().selection;
      this._model = new SelectionModel2(0 /* NORMAL */, this._control.getPlugin());
      this._model.setValue(selection);
      this._updateControl();
      const { offsetX: evtOffsetX, offsetY: evtOffsetY } = evt;
      this._startOffsetX = evtOffsetX;
      this._startOffsetY = evtOffsetY;
      const scrollXY = main.getAncestorScrollXY(this._startOffsetX, this._startOffsetY);
      let cellInfo = null;
      switch (direction) {
        case 0 /* LEFT */:
          cellInfo = main.calculateCellIndexByPosition(evtOffsetX + DEFAULT_SELECTION_CONFIG2.strokeWidth, evtOffsetY, scrollXY);
          break;
        case 2 /* TOP */:
          cellInfo = main.calculateCellIndexByPosition(evtOffsetX, evtOffsetY + DEFAULT_SELECTION_CONFIG2.strokeWidth, scrollXY);
          break;
        case 1 /* RIGHT */:
          cellInfo = main.calculateCellIndexByPosition(evtOffsetX - DEFAULT_SELECTION_CONFIG2.strokeWidth, evtOffsetY, scrollXY);
          break;
        case 3 /* BOTTOM */:
          cellInfo = main.calculateCellIndexByPosition(evtOffsetX, evtOffsetY - DEFAULT_SELECTION_CONFIG2.strokeWidth, scrollXY);
          break;
        default:
          break;
      }
      const actualSelection = makeCellToSelection(cellInfo);
      if (!actualSelection) {
        return false;
      }
      const { startRow, startColumn, endColumn, endRow, startY, endY, startX, endX } = actualSelection;
      const startSelectionRange = {
        startColumn,
        startRow,
        endColumn,
        endRow,
        startY,
        endY,
        startX,
        endX
      };
      this._oldSelectionRange = startSelectionRange;
      this._cellPositionOffset = {
        top: startSelectionRange.startRow - this._model.startRow,
        bottom: this._model.endRow - startSelectionRange.endRow,
        left: startSelectionRange.startColumn - this._model.startColumn,
        right: this._model.endColumn - startSelectionRange.endColumn
      };
      const scene = this._control.getScene();
      scene.disableEvent();
      const scrollTimer = ScrollTimer.create(scene);
      scrollTimer.startScroll(evtOffsetX, evtOffsetY);
      this._moveObserver = scene.onPointerMoveObserver.add((moveEvt) => {
        this.dragMoving(moveEvt);
        const { offsetX: moveOffsetX, offsetY: moveOffsetY } = moveEvt;
        scrollTimer.scrolling(moveOffsetX, moveOffsetY, () => {
          this.dragMoving(moveEvt);
        });
      });
      this._upObserver = scene.onPointerUpObserver.add((upEvt) => {
        this.dragUp();
        scene.onPointerMoveObserver.remove(this._moveObserver);
        scene.onPointerUpObserver.remove(this._upObserver);
        scene.enableEvent();
        scrollTimer.stopScroll();
      });
    }
    dragMoving(moveEvt) {
      const main = this._control.getPlugin().getMainComponent();
      const { offsetX: moveOffsetX, offsetY: moveOffsetY, clientX, clientY } = moveEvt;
      const scrollXY = main.getAncestorScrollXY(this._startOffsetX, this._startOffsetY);
      const moveCellInfo = main.calculateCellIndexByPosition(moveOffsetX, moveOffsetY, scrollXY);
      const moveActualSelection = makeCellToSelection(moveCellInfo);
      if (!moveActualSelection) {
        return false;
      }
      const { startRow: moveStartRow, startColumn: moveStartColumn, endColumn: moveEndColumn, endRow: moveEndRow, startX, startY, endX, endY } = moveActualSelection;
      const newSelectionRange = {
        startColumn: moveStartColumn,
        startRow: moveStartRow,
        endColumn: moveEndColumn,
        endRow: moveEndRow,
        startY: startY || 0,
        endY: endY || 0,
        startX: startX || 0,
        endX: endX || 0
      };
      const { startRow: oldStartRow, endRow: oldEndRow, startColumn: oldStartColumn, endColumn: oldEndColumn } = this._oldSelectionRange;
      if (oldStartColumn !== moveStartColumn || oldStartRow !== moveStartRow || oldEndColumn !== moveEndColumn || oldEndRow !== moveEndRow) {
        this._oldSelectionRange = newSelectionRange;
        const { left, right, top, bottom } = this._cellPositionOffset;
        const startRowTop = moveStartRow - top;
        const endRowBottom = moveEndRow + bottom;
        const startColumnLeft = moveStartColumn - left;
        const endColumnRight = moveEndColumn + right;
        if (startRowTop < 0 || endRowBottom < 0 || startColumnLeft < 0 || endColumnRight < 0) {
          return;
        }
        const newSelection = {
          startRow: startRowTop,
          endRow: endRowBottom,
          startColumn: startColumnLeft,
          endColumn: endColumnRight
        };
        const startCell = main.getNoMergeCellPositionByIndex(newSelection.startRow, newSelection.startColumn);
        const endCell = main.getNoMergeCellPositionByIndex(newSelection.endRow, newSelection.endColumn);
        const newSelectionPosition = Object.assign(newSelection, {
          startY: startCell?.startY || 0,
          endY: endCell?.endY || 0,
          startX: startCell?.startX || 0,
          endX: endCell?.endX || 0
        });
        this._model.setValue(newSelectionPosition);
        this._updateControl();
      }
    }
    dragUp() {
      const main = this._control.getPlugin().getMainComponent();
      this.hide();
      const { selection } = this._model.getValue();
      const cell = main.getCellByIndex(selection.startRow, selection.startColumn);
      this._control.update(selection, cell);
    }
    _updateControl() {
      const { startX, startY, endX, endY } = this._model;
      this._leftDragControl.resize(void 0, endY - startY);
      this._rightDragControl.transformByState({
        height: endY - startY,
        left: endX - startX - DEFAULT_SELECTION_CONFIG2.strokeWidth / 2
      });
      this._topDragControl.resize(endX - startX + DEFAULT_SELECTION_CONFIG2.strokeWidth);
      this._bottomDragControl.transformByState({
        width: endX - startX + DEFAULT_SELECTION_CONFIG2.strokeWidth,
        top: endY - startY - DEFAULT_SELECTION_CONFIG2.strokeWidth / 2
      });
      this._selectionDragShape.show();
      this._selectionDragShape.translate(startX, startY);
      this._selectionDragShape.makeDirty(true);
    }
    hide() {
      this._selectionDragShape.hide();
      this._selectionDragShape.makeDirty(true);
    }
    dispose() {
      this._leftDragControl.dispose();
      this._rightDragControl.dispose();
      this._topDragControl.dispose();
      this._bottomDragControl.dispose();
      this._selectionDragShape.dispose();
    }
    remove() {
      const { leftControl, rightControl, topControl, bottomControl } = this._control;
      leftControl.onPointerEnterObserver.clear();
      leftControl.onPointerLeaveObserver.clear();
      rightControl.onPointerEnterObserver.clear();
      rightControl.onPointerLeaveObserver.clear();
      topControl.onPointerEnterObserver.clear();
      topControl.onPointerLeaveObserver.clear();
      bottomControl.onPointerEnterObserver.clear();
      bottomControl.onPointerLeaveObserver.clear();
    }
    static create(control) {
      return new SelectionControlDragAndDrop(control);
    }
  };

  // ../../packages/base-sheets/src/Controller/Selection/SelectionControlFill.ts
  var SelectionControlFill = class {
    constructor(_control) {
      this._control = _control;
      this._initialize();
    }
    _initialize() {
      const { fillControl } = this._control;
      const plugin = this._control.getPlugin();
      fillControl.onPointerEnterObserver.add((evt) => {
        fillControl.cursor = "crosshair" /* CROSSHAIR */;
      });
      fillControl.onPointerLeaveObserver.add((evt) => {
        fillControl.resetCursor();
      });
    }
    remove() {
      const { fillControl } = this._control;
      fillControl.onPointerEnterObserver.clear();
      fillControl.onPointerLeaveObserver.clear();
    }
    static create(control) {
      return new SelectionControlFill(control);
    }
  };

  // ../../packages/base-sheets/src/Controller/Selection/SelectionController.ts
  var DEFAULT_SELECTION_CONFIG2 = {
    strokeColor: "rgb(1,136,251)",
    backgroundColor: "rgba(1,136,251, 0.1)",
    strokeWidth: 2,
    fillSideLength: 6,
    fillStrokeLength: 1,
    fillStrokeColor: "rgb(255,255,255)"
  };
  var SelectionControl3 = class {
    constructor(_manager, _zIndex) {
      this._manager = _manager;
      this._zIndex = _zIndex;
      this._initialize();
    }
    _mainComponent;
    _leftControl;
    _rightControl;
    _topControl;
    _bottomControl;
    _backgroundControlTop;
    _backgroundControlBottom;
    _backgroundControlMiddleLeft;
    _backgroundControlMiddleRight;
    _fillControl;
    _selectionShape;
    _selectionModel;
    _selectionDragAndDrop;
    _selectionControlFill;
    _initialize() {
      this._selectionModel = new SelectionModel2(0 /* NORMAL */, this._manager.getPlugin());
      const zIndex = this._zIndex;
      this._leftControl = new Rect("__SpreadsheetSelectionShapeLeftControl__" /* left */ + zIndex, {
        top: 0,
        left: -DEFAULT_SELECTION_CONFIG2.strokeWidth / 2,
        width: DEFAULT_SELECTION_CONFIG2.strokeWidth,
        fill: DEFAULT_SELECTION_CONFIG2.strokeColor,
        zIndex
      });
      this._rightControl = new Rect("__SpreadsheetSelectionShapeRightControl__" /* right */ + zIndex, {
        width: DEFAULT_SELECTION_CONFIG2.strokeWidth,
        fill: DEFAULT_SELECTION_CONFIG2.strokeColor,
        zIndex
      });
      this._topControl = new Rect("__SpreadsheetSelectionTopControl__" /* top */ + zIndex, {
        top: -DEFAULT_SELECTION_CONFIG2.strokeWidth / 2,
        left: -DEFAULT_SELECTION_CONFIG2.strokeWidth / 2,
        height: DEFAULT_SELECTION_CONFIG2.strokeWidth,
        fill: DEFAULT_SELECTION_CONFIG2.strokeColor,
        zIndex
      });
      this._bottomControl = new Rect("__SpreadsheetSelectionBottomControl__" /* bottom */ + zIndex, {
        height: DEFAULT_SELECTION_CONFIG2.strokeWidth,
        fill: DEFAULT_SELECTION_CONFIG2.strokeColor,
        left: -DEFAULT_SELECTION_CONFIG2.strokeWidth / 2,
        zIndex
      });
      this._backgroundControlTop = new Rect("__SpreadsheetSelectionBackgroundControlTop__" /* backgroundTop */ + zIndex, {
        fill: DEFAULT_SELECTION_CONFIG2.backgroundColor,
        zIndex: zIndex - 1,
        evented: false
      });
      this._backgroundControlBottom = new Rect("__SpreadsheetSelectionBackgroundControlBottom__" /* backgroundBottom */ + zIndex, {
        fill: DEFAULT_SELECTION_CONFIG2.backgroundColor,
        zIndex: zIndex - 1,
        evented: false
      });
      this._backgroundControlMiddleLeft = new Rect("__SpreadsheetSelectionBackgroundControlMiddleLeft__" /* backgroundMiddleLeft */ + zIndex, {
        fill: DEFAULT_SELECTION_CONFIG2.backgroundColor,
        zIndex: zIndex - 1,
        evented: false
      });
      this._backgroundControlMiddleRight = new Rect("__SpreadsheetSelectionBackgroundControlMiddleRight__" /* backgroundMiddleRight */ + zIndex, {
        fill: DEFAULT_SELECTION_CONFIG2.backgroundColor,
        zIndex: zIndex - 1,
        evented: false
      });
      const fillSideLength = DEFAULT_SELECTION_CONFIG2.fillSideLength - DEFAULT_SELECTION_CONFIG2.fillStrokeLength;
      this._fillControl = new Rect("__SpreadsheetSelectionFillControl__" /* fill */ + zIndex, {
        width: fillSideLength,
        height: fillSideLength,
        fill: DEFAULT_SELECTION_CONFIG2.strokeColor,
        strokeWidth: DEFAULT_SELECTION_CONFIG2.fillStrokeLength,
        stroke: DEFAULT_SELECTION_CONFIG2.fillStrokeColor,
        zIndex: zIndex + 1
      });
      this._selectionShape = new Group(
        "__SpreadsheetSelectionShape__" /* Selection */ + zIndex,
        this._fillControl,
        this._leftControl,
        this._rightControl,
        this._topControl,
        this._bottomControl,
        this._backgroundControlTop,
        this._backgroundControlMiddleLeft,
        this._backgroundControlMiddleRight,
        this._backgroundControlBottom
      );
      this._selectionShape.hide();
      this._selectionShape.evented = false;
      this._selectionShape.zIndex = zIndex;
      this._selectionDragAndDrop = SelectionControlDragAndDrop.create(this);
      this._selectionControlFill = SelectionControlFill.create(this);
      const scene = this.getScene();
      scene.addObject(this._selectionShape);
    }
    get zIndex() {
      return this._zIndex;
    }
    /**
     * just handle the view
     *
     * inner update
     */
    _updateControl() {
      const { startX, startY, endX, endY } = this._selectionModel;
      this.leftControl.resize(void 0, endY - startY);
      this.rightControl.transformByState({
        height: endY - startY,
        left: endX - startX - DEFAULT_SELECTION_CONFIG2.strokeWidth / 2
      });
      this.topControl.resize(endX - startX + DEFAULT_SELECTION_CONFIG2.strokeWidth);
      this.bottomControl.transformByState({
        width: endX - startX + DEFAULT_SELECTION_CONFIG2.strokeWidth,
        top: endY - startY - DEFAULT_SELECTION_CONFIG2.strokeWidth / 2
      });
      this.fillControl.translate(endX - startX - DEFAULT_SELECTION_CONFIG2.fillSideLength / 2, endY - startY - DEFAULT_SELECTION_CONFIG2.fillSideLength / 2);
      this._updateBackgroundControl();
      this._updateDragAndFill();
      this.selectionShape.show();
      this.selectionShape.translate(startX, startY);
      this.selectionShape.makeDirty(true);
    }
    _updateBackgroundControl() {
      const {
        startColumn,
        startRow,
        endColumn,
        endRow,
        startX,
        startY,
        endX,
        endY
      } = this._selectionModel;
      const highlightSelection = this._selectionModel.highlightToSelection();
      if (!highlightSelection) {
        this._backgroundControlTop.resize(endX - startX, endY - startY);
        this._backgroundControlBottom.resize(0, 0);
        this._backgroundControlMiddleLeft.resize(0, 0);
        this._backgroundControlMiddleRight.resize(0, 0);
        return;
      }
      const { startX: h_startX, startY: h_startY, endX: h_endX, endY: h_endY } = highlightSelection;
      const strokeOffset = DEFAULT_SELECTION_CONFIG2.strokeWidth / 2;
      const topConfig = {
        left: -strokeOffset,
        top: -strokeOffset,
        width: endX - startX + strokeOffset * 2,
        height: h_startY - startY + strokeOffset
      };
      if (topConfig.height < 0) {
        topConfig.width = 0;
        topConfig.height = 0;
      }
      this._backgroundControlTop.transformByState(topConfig);
      const middleLeftConfig = {
        left: -strokeOffset,
        top: h_startY - startY,
        width: h_startX - startX + strokeOffset,
        height: h_endY - h_startY
      };
      if (middleLeftConfig.width < 0) {
        middleLeftConfig.width = 0;
        middleLeftConfig.height = 0;
      }
      this._backgroundControlMiddleLeft.transformByState(middleLeftConfig);
      const middleRightConfig = {
        left: h_endX - startX - strokeOffset,
        top: h_startY - startY,
        width: endX - h_endX + strokeOffset * 2,
        height: h_endY - h_startY
      };
      if (middleRightConfig.width < 0) {
        middleRightConfig.width = 0;
        middleRightConfig.height = 0;
      }
      this._backgroundControlMiddleRight.transformByState(middleRightConfig);
      const middleBottomConfig = {
        left: -strokeOffset,
        top: h_endY - startY,
        width: endX - startX + strokeOffset * 2,
        height: endY - h_endY + strokeOffset
      };
      if (middleBottomConfig.height < 0) {
        middleBottomConfig.width = 0;
        middleBottomConfig.height = 0;
      }
      this._backgroundControlBottom.transformByState(middleBottomConfig);
    }
    /**
     *  Updated DragAndDrop and fill controls, inactive selections need to hide them
     */
    _updateDragAndFill() {
      const highlightSelection = this._selectionModel.highlightToSelection();
      if (!highlightSelection) {
        this._selectionDragAndDrop.remove();
        this._fillControl.resize(0, 0);
        this._selectionControlFill.remove();
      }
    }
    update(newSelectionRange, highlight) {
      this._selectionModel.setValue(newSelectionRange, highlight);
      this._updateControl();
    }
    // /**
    //  *When switching to the current sheet
    //  *
    //  * 1. Reinitialize the rendering component
    //  * 2. Calculate the position based on the current skeleton
    //  * 3. Update data
    //  * 4. Trigger rendering
    //  */
    // render() {
    //     this._initialize();
    //     let cellInfo = null;
    //     const main = this._manager.getMainComponent();
    //     const curCellRange = this._selectionModel.currentCell;
    //     if (curCellRange) {
    //         cellInfo = main.getCellByIndex(curCellRange.row, curCellRange.column);
    //     }
    //     const { startRow: finalStartRow, startColumn: finalStartColumn, endRow: finalEndRow, endColumn: finalEndColumn } = this._selectionModel;
    //     const startCell = main.getNoMergeCellPositionByIndex(finalStartRow, finalStartColumn);
    //     const endCell = main.getNoMergeCellPositionByIndex(finalEndRow, finalEndColumn);
    //     this._manager.updateSelectionValue(
    //         this,
    //         {
    //             startColumn: finalStartColumn,
    //             startRow: finalStartRow,
    //             endColumn: finalEndColumn,
    //             endRow: finalEndRow,
    //             startY: startCell?.startY || 0,
    //             endY: endCell?.endY || 0,
    //             startX: startCell?.startX || 0,
    //             endX: endCell?.endX || 0,
    //         },
    //         cellInfo
    //     );
    //     this._updateControl();
    // }
    clearHighlight() {
      this._selectionModel.clearCurrentCell();
      this._updateControl();
    }
    dispose() {
      this._leftControl?.dispose();
      this._rightControl?.dispose();
      this._topControl?.dispose();
      this._bottomControl?.dispose();
      this._backgroundControlTop?.dispose();
      this._backgroundControlMiddleLeft?.dispose();
      this._backgroundControlMiddleRight?.dispose();
      this._backgroundControlBottom?.dispose();
      this._fillControl?.dispose();
      this._selectionShape?.dispose();
      this._selectionDragAndDrop.dispose();
    }
    getScene() {
      return this._manager.getScene();
    }
    getPlugin() {
      return this._manager.getPlugin();
    }
    get leftControl() {
      return this._leftControl;
    }
    get rightControl() {
      return this._rightControl;
    }
    get topControl() {
      return this._topControl;
    }
    get bottomControl() {
      return this._bottomControl;
    }
    get fillControl() {
      return this._fillControl;
    }
    get backgroundControlTop() {
      return this._backgroundControlTop;
    }
    get backgroundControlBottom() {
      return this._backgroundControlBottom;
    }
    get backgroundControlMiddleLeft() {
      return this._backgroundControlMiddleLeft;
    }
    get backgroundControlMiddleRight() {
      return this._backgroundControlMiddleRight;
    }
    get selectionShape() {
      return this._selectionShape;
    }
    get model() {
      return this._selectionModel;
    }
    /**
     * Get the cell information of the current selection, considering the case of merging cells
     */
    getCurrentCellInfo() {
      const currentCell = this.model.currentCell;
      if (currentCell) {
        let currentRangeData;
        if (currentCell.isMerged) {
          const mergeInfo = currentCell.mergeInfo;
          currentRangeData = {
            startRow: mergeInfo.startRow,
            endRow: mergeInfo.endRow,
            startColumn: mergeInfo.startColumn,
            endColumn: mergeInfo.endColumn,
            startX: mergeInfo.startX,
            endX: mergeInfo.endX,
            startY: mergeInfo.startY,
            endY: mergeInfo.endY
          };
        } else {
          const { row, column, startX, endX, startY, endY } = currentCell;
          currentRangeData = {
            startRow: row,
            endRow: row,
            startColumn: column,
            endColumn: column,
            startX,
            endX,
            startY,
            endY
          };
        }
        return currentRangeData;
      }
    }
    static create(manager, zIndex) {
      return new this(manager, zIndex);
    }
    static fromJson(manager, zIndex, newSelectionRange) {
      const control = SelectionControl3.create(manager, zIndex);
      control.update(newSelectionRange);
      return control;
    }
  };

  // ../../packages/base-sheets/src/Model/SelectionModel.ts
  var SelectionModel2 = class {
    _startColumn;
    _startRow;
    _endColumn;
    _endRow;
    _startX;
    _startY;
    _endX;
    _endY;
    _type;
    _currentCell;
    _plugin;
    constructor(type = 0 /* NORMAL */, plugin) {
      this._type = type;
      this._plugin = plugin;
    }
    isEqual(selectionRange) {
      const { startColumn, startRow, endColumn, endRow, type } = this;
      const { startColumn: newStartColumn, startRow: newStartRow, endColumn: newEndColumn, endRow: newEndRow } = selectionRange;
      if (startColumn === newStartColumn && startRow === newStartRow && endColumn === newEndColumn && endRow === newEndRow) {
        return true;
      }
      return false;
    }
    isInclude(selectionRange) {
      const { startColumn, startRow, endColumn, endRow, type } = this;
      const { startColumn: newStartColumn, startRow: newStartRow, endColumn: newEndColumn, endRow: newEndRow } = selectionRange;
      if (!(newEndColumn < startColumn || newStartColumn > endColumn || newStartRow > endRow || newEndRow < startRow)) {
        return true;
      }
      return false;
    }
    get startColumn() {
      return this._startColumn;
    }
    get startRow() {
      return this._startRow;
    }
    get endColumn() {
      return this._endColumn;
    }
    get endRow() {
      return this._endRow;
    }
    get startX() {
      return this._startX;
    }
    get startY() {
      return this._startY;
    }
    get endX() {
      return this._endX;
    }
    get endY() {
      return this._endY;
    }
    get type() {
      return this._type;
    }
    get currentCell() {
      return this._currentCell;
    }
    highlightToSelection() {
      return makeCellToSelection(this._currentCell);
    }
    getValue() {
      return {
        selection: {
          startColumn: this._startColumn,
          startRow: this._startRow,
          endColumn: this._endColumn,
          endRow: this._endRow,
          startX: this._startX,
          startY: this._startY,
          endX: this._endX,
          endY: this._endY
        },
        cell: this._currentCell
      };
    }
    setValue(newSelectionRange, currentCell) {
      const {
        startColumn,
        startRow,
        endColumn,
        endRow,
        startX,
        startY,
        endX,
        endY
      } = newSelectionRange;
      this._startColumn = startColumn;
      this._startRow = startRow;
      this._endColumn = endColumn;
      this._endRow = endRow;
      this._startX = startX;
      this._startY = startY;
      this._endX = endX;
      this._endY = endY;
      this.setTypeByData();
      this.setCurrentCell(currentCell);
    }
    setCurrentCell(currentCell) {
      if (currentCell) {
        this._currentCell = currentCell;
      }
    }
    clearCurrentCell() {
      this._currentCell = null;
    }
    /**
     * Determine the type type based on the data
     */
    setTypeByData() {
      const rowCount = this._plugin.getWorkbook().getActiveSheet().getConfig().rowCount;
      const columnCount = this._plugin.getWorkbook().getActiveSheet().getConfig().columnCount;
      if (this._startRow === 0 && this._endRow === rowCount - 1) {
        return this._type = 2 /* COLUMN */;
      }
      if (this._startColumn === 0 && this._endColumn === columnCount - 1) {
        return this._type = 1 /* ROW */;
      }
      return this._type = 0 /* NORMAL */;
    }
  };

  // ../../packages/base-sheets/src/Controller/Selection/DragLineController.ts
  var DEFAULT_DRAG_LINE_CONFIG = {
    strokeColor: "rgb(1,136,251)",
    strokeWidth: 1,
    fillStrokeWidth: 5
  };
  var DragLineController = class {
    _dragLineControlMain;
    _dragLineControlContent;
    _dragLine;
    _manager;
    _moveObserver;
    _upObserver;
    _state;
    _direction;
    _end;
    // 
    _start;
    _dragUp;
    constructor(manager) {
      this._manager = manager;
    }
    getDragLine() {
      return this._dragLine;
    }
    create(option) {
      const { direction, end, dragUp, start } = option;
      this._direction = direction;
      this._end = end;
      this._start = start;
      this._dragUp = dragUp;
      const skeleton = this._manager.getSheetView().getSpreadsheetColumnTitle().getSkeleton();
      if (direction) {
        const width = skeleton?.rowTitleWidth;
        const contentWidth = skeleton?.columnTotalWidth;
        this._dragLineControlMain = new Rect("__SpreadsheetDragLineMain__" /* lineMain */, {
          width,
          height: 5,
          top: this._end - 5,
          fill: DEFAULT_DRAG_LINE_CONFIG.strokeColor
        });
        this._dragLineControlContent = new Rect("__SpreadsheetDragLineContent__" /* lineContent */, {
          width: contentWidth,
          height: 1,
          top: this._end - 1,
          left: width,
          fill: DEFAULT_DRAG_LINE_CONFIG.strokeColor
        });
      } else {
        const height = skeleton?.columnTitleHeight;
        const contentHeight = skeleton?.rowTotalHeight;
        this._dragLineControlMain = new Rect("__SpreadsheetDragLineMain__" /* lineMain */, {
          width: DEFAULT_DRAG_LINE_CONFIG.fillStrokeWidth,
          height,
          left: this._end - 5,
          fill: DEFAULT_DRAG_LINE_CONFIG.strokeColor
        });
        this._dragLineControlContent = new Rect("__SpreadsheetDragLineContent__" /* lineContent */, {
          width: DEFAULT_DRAG_LINE_CONFIG.strokeWidth,
          height: contentHeight,
          top: height,
          left: this._end - 1,
          fill: DEFAULT_DRAG_LINE_CONFIG.strokeColor
        });
      }
      this._dragLine = new Group("__SpreadsheetDragLine__" /* line */, this._dragLineControlMain, this._dragLineControlContent);
      this._dragLine.hide();
      this._dragLine.evented = false;
      const scene = this._manager.getScene();
      scene.addObject(this._dragLine, 3);
    }
    dragDown(e4) {
      const scene = this._manager.getScene();
      scene.disableEvent();
      this._state = {
        distance: this._direction ? e4.clientY : e4.clientX
      };
      this._dragLine.show();
      this._moveObserver = scene.onPointerMoveObserver.add((e5) => {
        this.dragMoving(e5);
      });
      this._upObserver = scene.onPointerUpObserver.add((e5) => {
        this.dragUp(e5);
        scene.onPointerMoveObserver.remove(this._moveObserver);
        scene.onPointerUpObserver.remove(this._upObserver);
        scene.enableEvent();
      });
    }
    dragMoving(e4) {
      if (this._direction) {
        this._dragLine.cursor = "row-resize" /* ROW_RESIZE */;
        if (e4.clientY < this._state.distance && this._state.distance - e4.clientY >= this._end - this._start - 5) {
          return;
        }
        this._dragLine.transformByState({
          top: e4.clientY - this._state.distance
        });
      } else {
        this._dragLine.cursor = "col-resize" /* COLUMN_RESIZE */;
        if (e4.clientX < this._state.distance && this._state.distance - e4.clientX >= this._end - this._start - 5) {
          return;
        }
        this._dragLine.transformByState({
          left: e4.clientX - this._state.distance
        });
      }
    }
    dragUp(e4) {
      let distance;
      if (this._direction) {
        distance = e4.clientY - this._state.distance;
        if (e4.clientY < this._state.distance && this._state.distance - e4.clientY >= this._end - this._start - 5) {
          distance = null;
        }
      } else {
        distance = e4.clientX - this._state.distance;
        if (e4.clientX < this._state.distance && this._state.distance - e4.clientX >= this._end - this._start - 5) {
          distance = null;
        }
      }
      this._dragUp(distance, e4);
      this._dragLine.dispose();
    }
  };

  // ../../packages/base-sheets/src/Controller/Selection/ColumnTitleController.ts
  var ColumnTitleController = class {
    _manager;
    _leftTopWidth;
    _startOffsetX = 0;
    _startOffsetY = 0;
    _index = 0;
    _currentWidth = 0;
    _highlightItem;
    _content;
    _Item;
    constructor(manager) {
      this._manager = manager;
      this._leftTopWidth = this._manager.getSheetView().getSpreadsheetLeftTopPlaceholder().getState().width;
      this._content = new Rect("HighLightContent", {
        width: 0,
        height: this._manager.getSheetView().getSpreadsheetSkeleton().columnTitleHeight,
        left: 0,
        fill: "rgb(220,220,220,0.5)"
      });
      this._Item = new Rect("HighLightItem", {
        width: 5,
        height: this._manager.getSheetView().getSpreadsheetSkeleton().columnTitleHeight,
        left: 0,
        fill: "rgb(220,220,220,0.5)"
      });
      this._highlightItem = new Group("HighLightColumnTitle", this._content, this._Item);
      this._highlightItem.hide();
      const scene = this._manager.getScene();
      scene.addObject(this._highlightItem, 3);
      this._initialize();
    }
    // 
    _initialize() {
      this._highlightItem.onPointerEnterObserver.add((evt) => {
        this._highlightItem.show();
      });
      this._highlightItem.onPointerMoveObserver.add((evt) => {
        this._highlightItem.show();
      });
      this._highlightItem.onPointerLeaveObserver.add((evt) => {
        this._highlightItem.hide();
      });
      this._Item.onPointerEnterObserver.add((evt) => {
        this._Item.cursor = "col-resize" /* COLUMN_RESIZE */;
      });
      this._Item.onPointerLeaveObserver.add((evt) => {
        this._Item.resetCursor();
      });
      this._Item.onPointerDownObserver.add((evt) => {
        this.pointerDown(evt);
      });
    }
    pointerDown(e4) {
      const main = this._manager.getMainComponent();
      const { offsetX: evtOffsetX, offsetY: evtOffsetY } = e4;
      this._startOffsetX = evtOffsetX;
      this._startOffsetY = evtOffsetY;
      const scrollXY = main.getAncestorScrollXY(this._startOffsetX, this._startOffsetY);
      const contentRef = this._manager.getPlugin().getSheetContainerControl().getContentRef();
      const clientX = e4.clientX + scrollXY.x - this._leftTopWidth - contentRef.current.getBoundingClientRect().left;
      const columnWidthAccumulation = main.getSkeleton()?.columnWidthAccumulation ?? [];
      for (let i4 = 0; i4 < columnWidthAccumulation?.length; i4++) {
        if (columnWidthAccumulation[i4] >= clientX) {
          this._index = i4;
          break;
        }
      }
      this._currentWidth = columnWidthAccumulation[0];
      if (this._index) {
        this._currentWidth = columnWidthAccumulation[this._index] - columnWidthAccumulation[this._index - 1];
      }
      if (columnWidthAccumulation[this._index] - clientX <= 5) {
        const end = columnWidthAccumulation[this._index] + this._leftTopWidth;
        const start = (this._index ? columnWidthAccumulation[this._index - 1] : 0) + this._leftTopWidth;
        this._manager.getDragLineControl().create({
          direction: 0 /* VERTICAL */,
          end,
          start,
          dragUp: (width, e5) => {
            this.setColumnWidth(width);
            this.highlightColumnTitle(e5);
          }
        });
        this._manager.getDragLineControl().dragDown(e4);
      }
      this.highlightColumn();
    }
    setColumnWidth(width) {
      const plugin = this._manager.getPlugin();
      const sheet = plugin.getContext().getWorkBook().getActiveSheet();
      if (width === null) {
        sheet.setColumnWidth(this._index, 1, 5);
      } else {
        sheet.setColumnWidth(this._index, 1, width + this._currentWidth);
      }
      this.highlightColumn();
    }
    highlightColumn() {
      this._manager.clearSelectionControls();
      const sheet = this._manager.getPlugin().getWorkbook().getActiveSheet();
      this._manager.addControlToCurrentByRangeData(
        {
          startRow: 0,
          startColumn: this._index,
          endColumn: this._index,
          endRow: sheet.getRowCount() - 1
        },
        {
          row: 0,
          column: this._index
        }
      );
    }
    highlightColumnTitle(e4) {
      const main = this._manager.getMainComponent();
      const { offsetX: evtOffsetX, offsetY: evtOffsetY } = e4;
      this._startOffsetX = evtOffsetX;
      this._startOffsetY = evtOffsetY;
      const scrollXY = main.getAncestorScrollXY(this._startOffsetX, this._startOffsetY);
      const contentRef = this._manager.getPlugin().getSheetContainerControl().getContentRef();
      const clientX = e4.clientX + scrollXY.x - this._leftTopWidth - contentRef.current.getBoundingClientRect().left;
      const columnWidthAccumulation = main.getSkeleton()?.columnWidthAccumulation ?? [];
      for (let i4 = 0; i4 < columnWidthAccumulation?.length; i4++) {
        if (columnWidthAccumulation[i4] >= clientX) {
          this._index = i4;
          break;
        }
      }
      this._currentWidth = columnWidthAccumulation[0];
      let left = this._leftTopWidth;
      if (this._index) {
        this._currentWidth = columnWidthAccumulation[this._index] - columnWidthAccumulation[this._index - 1];
        left = this._leftTopWidth + columnWidthAccumulation[this._index - 1];
      }
      this._content.transformByState({
        width: this._currentWidth - 5
      });
      this._Item.transformByState({
        left: this._currentWidth - 5
      });
      this._highlightItem.transformByState({
        width: this._currentWidth,
        left
      });
      this._highlightItem.show();
    }
  };

  // ../../packages/base-sheets/src/Controller/Selection/RowTitleController.ts
  var RowTitleController = class {
    _manager;
    _leftTopHeight;
    _startOffsetX = 0;
    _startOffsetY = 0;
    _index = 0;
    _currentHeight = 0;
    _highlightItem;
    _content;
    _Item;
    constructor(manager) {
      this._manager = manager;
      this._leftTopHeight = this._manager.getSheetView().getSpreadsheetLeftTopPlaceholder().getState().height;
      const width = this._manager.getSheetView().getSpreadsheetSkeleton().rowTitleWidth;
      this._content = new Rect("RowTitleContent", {
        width,
        height: 0,
        top: 0,
        fill: "rgb(220,220,220,0.5)"
      });
      this._Item = new Rect("RowTitleItem", {
        width,
        height: 5,
        top: 0,
        fill: "rgb(220,220,220,0.5)"
      });
      this._highlightItem = new Group("RowTitleGroup", this._content, this._Item);
      this._highlightItem.hide();
      const scene = this._manager.getScene();
      scene.addObject(this._highlightItem, 3);
      this._initialize();
    }
    // 
    _initialize() {
      this._highlightItem.onPointerEnterObserver.add((evt) => {
        this._highlightItem.show();
      });
      this._highlightItem.onPointerMoveObserver.add((evt) => {
        this._highlightItem.show();
      });
      this._highlightItem.onPointerLeaveObserver.add((evt) => {
        this._highlightItem.hide();
      });
      this._Item.onPointerEnterObserver.add((evt) => {
        this._Item.cursor = "row-resize" /* ROW_RESIZE */;
      });
      this._Item.onPointerLeaveObserver.add((evt) => {
        this._Item.resetCursor();
      });
      this._Item.onPointerDownObserver.add((evt) => {
        this.pointerDown(evt);
      });
    }
    pointerDown(e4) {
      const main = this._manager.getMainComponent();
      const { offsetX: evtOffsetX, offsetY: evtOffsetY } = e4;
      this._startOffsetX = evtOffsetX;
      this._startOffsetY = evtOffsetY;
      const scrollXY = main.getAncestorScrollXY(this._startOffsetX, this._startOffsetY);
      const contentRef = this._manager.getPlugin().getSheetContainerControl().getContentRef();
      const clientY = e4.clientY + scrollXY.y - this._leftTopHeight - contentRef.current.getBoundingClientRect().top;
      const rowHeightAccumulation = main.getSkeleton()?.rowHeightAccumulation ?? [];
      for (let i4 = 0; i4 < rowHeightAccumulation?.length; i4++) {
        if (rowHeightAccumulation[i4] >= clientY) {
          this._index = i4;
          break;
        }
      }
      this._currentHeight = rowHeightAccumulation[0];
      if (this._index) {
        this._currentHeight = rowHeightAccumulation[this._index] - rowHeightAccumulation[this._index - 1];
      }
      if (rowHeightAccumulation[this._index] - clientY <= 5) {
        const end = rowHeightAccumulation[this._index] + this._leftTopHeight;
        const start = (this._index ? rowHeightAccumulation[this._index - 1] : 0) + this._leftTopHeight;
        this._manager.getDragLineControl().create({
          direction: 1 /* HORIZONTAL */,
          end,
          start,
          dragUp: this.setRowHeight.bind(this)
        });
        this._manager.getDragLineControl().dragDown(e4);
      }
      this.highlightRow();
    }
    setRowHeight(height) {
      const plugin = this._manager.getPlugin();
      const sheet = plugin.getContext().getWorkBook().getActiveSheet();
      if (height === null) {
        sheet.setRowHeights(this._index, 1, 5);
      } else {
        sheet.setRowHeights(this._index, 1, height + this._currentHeight);
      }
      this.highlightRow();
    }
    highlightRow() {
      this._manager.clearSelectionControls();
      const sheet = this._manager.getPlugin().getWorkbook().getActiveSheet();
      this._manager.addControlToCurrentByRangeData(
        {
          startRow: this._index,
          startColumn: 0,
          endColumn: sheet.getColumnCount() - 1,
          endRow: this._index
        },
        {
          row: this._index,
          column: 0
        }
      );
    }
    highlightRowTitle(e4) {
      const main = this._manager.getMainComponent();
      const { offsetX: evtOffsetX, offsetY: evtOffsetY } = e4;
      this._startOffsetX = evtOffsetX;
      this._startOffsetY = evtOffsetY;
      const scrollXY = main.getAncestorScrollXY(this._startOffsetX, this._startOffsetY);
      const contentRef = this._manager.getPlugin().getSheetContainerControl().getContentRef();
      const clientY = e4.clientY + scrollXY.y - this._leftTopHeight - contentRef.current.getBoundingClientRect().top;
      const rowHeightAccumulation = main.getSkeleton()?.rowHeightAccumulation ?? [];
      for (let i4 = 0; i4 < rowHeightAccumulation?.length; i4++) {
        if (rowHeightAccumulation[i4] >= clientY) {
          this._index = i4;
          break;
        }
      }
      this._currentHeight = rowHeightAccumulation[0];
      let top = this._leftTopHeight;
      if (this._index) {
        this._currentHeight = rowHeightAccumulation[this._index] - rowHeightAccumulation[this._index - 1];
        top = this._leftTopHeight + rowHeightAccumulation[this._index - 1];
      }
      this._content.transformByState({
        height: this._currentHeight - 5
      });
      this._Item.transformByState({
        top: this._currentHeight - 5
      });
      this._highlightItem.transformByState({
        height: this._currentHeight,
        top
      });
      this._highlightItem.show();
    }
  };

  // ../../packages/base-sheets/src/Controller/Selection/SelectionManager.ts
  var SelectionManager2 = class {
    constructor(_sheetView) {
      this._sheetView = _sheetView;
      this._plugin = this._sheetView.getPlugin();
      this._initialize();
      this._initializeObserver();
    }
    _mainComponent;
    _rowComponent;
    _columnComponent;
    _leftTopComponent;
    _moveObserver;
    _upObserver;
    _selectionControls = [];
    // sheetID:Controls
    _selectionModels = /* @__PURE__ */ new Map();
    // sheetID:Models
    _plugin;
    _startSelectionRange;
    _startOffsetX = 0;
    _startOffsetY = 0;
    _worksheet;
    _columnTitleControl;
    _rowTitleControl;
    _dragLineControl;
    hasSelection = false;
    getSheetView() {
      return this._sheetView;
    }
    getScene() {
      return this._sheetView.getScene();
    }
    getContext() {
      return this._sheetView.getContext();
    }
    getMainComponent() {
      return this._mainComponent;
    }
    updateToSheet(worksheet) {
      this._worksheet = worksheet;
      const worksheetId = this.getWorksheetId();
      if (worksheetId) {
        const models = this._selectionModels.get(worksheetId);
        if (!models) {
          this._selectionModels.set(worksheetId, []);
        }
      }
    }
    getCurrentControls() {
      return this._selectionControls;
    }
    getCurrentControl() {
      const controls = this.getCurrentControls();
      if (controls && controls.length > 0) {
        for (const control of controls) {
          const currentCell = control.model.currentCell;
          if (currentCell) {
            return control;
          }
        }
      }
    }
    getCurrentModels() {
      const worksheetId = this.getWorksheetId();
      if (!worksheetId) {
        return;
      }
      const models = this._selectionModels.get(worksheetId);
      if (!models) {
        this._selectionModels.set(worksheetId, []);
      }
      return this._selectionModels.get(worksheetId);
    }
    getCurrentCellModel() {
      const models = this.getCurrentModels();
      if (models && models.length > 0) {
        for (const model of models) {
          const currentCell = model.currentCell;
          if (currentCell) {
            return currentCell;
          }
        }
      }
    }
    getCurrentModel() {
      const models = this.getCurrentModels();
      if (models && models.length > 0) {
        for (const model of models) {
          const currentCell = model.currentCell;
          if (currentCell) {
            return model;
          }
        }
      }
    }
    getCurrentModelsValue() {
      const models = this.getCurrentModels();
      if (!models) {
        return [];
      }
      const selectionModelsValue = [];
      for (let model of models) {
        selectionModelsValue.push(model.getValue());
      }
      return selectionModelsValue;
    }
    /**
     * Renders all controls of the currently active sheet
     * @returns
     */
    renderCurrentControls(command = true, models) {
      const worksheetId = this.getWorksheetId();
      if (worksheetId) {
        if (this._selectionControls) {
          for (let control of this._selectionControls) {
            control.dispose();
          }
        }
        const selectionModels = models || this._selectionModels.get(worksheetId);
        this._selectionControls = [];
        selectionModels?.forEach((model) => {
          const curCellRange = model.currentCell;
          const main = this._mainComponent;
          const control = SelectionControl3.create(this, this._selectionControls.length);
          let cellInfo = null;
          if (curCellRange) {
            cellInfo = main.getCellByIndex(curCellRange.row, curCellRange.column);
          }
          const { startRow, startColumn, endRow, endColumn } = model;
          const startCell = main.getNoMergeCellPositionByIndex(startRow, startColumn);
          const endCell = main.getNoMergeCellPositionByIndex(endRow, endColumn);
          control.update(
            {
              startColumn,
              startRow,
              endColumn,
              endRow,
              startY: startCell?.startY || 0,
              endY: endCell?.endY || 0,
              startX: startCell?.startX || 0,
              endX: endCell?.endX || 0
            },
            cellInfo
          );
          this._selectionControls.push(control);
        });
        command && this.setSelectionModel();
      }
    }
    getPlugin() {
      return this._plugin;
    }
    getWorksheetId() {
      return this._worksheet?.getSheetId();
    }
    /**
     * add a selection
     * @param selectionRange
     * @param curCellRange
     * @returns
     */
    addControlToCurrentByRangeData(selectionRange, curCellRange) {
      const currentControls = this.getCurrentControls();
      if (!currentControls) {
        return;
      }
      const main = this._mainComponent;
      const control = SelectionControl3.create(this, currentControls.length);
      let cellInfo = null;
      if (curCellRange) {
        cellInfo = main.getCellByIndex(curCellRange.row, curCellRange.column);
      }
      const { startRow, startColumn, endRow, endColumn } = selectionRange;
      const startCell = main.getNoMergeCellPositionByIndex(startRow, startColumn);
      const endCell = main.getNoMergeCellPositionByIndex(endRow, endColumn);
      control.update(
        {
          startColumn,
          startRow,
          endColumn,
          endRow,
          startY: startCell?.startY || 0,
          endY: endCell?.endY || 0,
          startX: startCell?.startX || 0,
          endX: endCell?.endX || 0
        },
        cellInfo
      );
      currentControls.push(control);
      this.setSelectionModel();
    }
    clearSelectionControls() {
      let curControls = this.getCurrentControls();
      if (curControls.length > 0) {
        for (let control of curControls) {
          control.dispose();
        }
        curControls.length = 0;
      }
    }
    /**
     * update all current controls data in model
     */
    setSelectionModel(models) {
      if (!this._worksheet)
        return;
      if (!models) {
        models = this._selectionControls.map((control) => control.model.getValue());
      }
      const workbook = this._worksheet.getContext().getWorkBook();
      const commandManager = workbook.getCommandManager();
      let action = {
        sheetId: this._worksheet.getSheetId(),
        actionName: SetSelectionValueAction.NAME,
        selections: models
      };
      action = ActionOperation.make(action).removeUndo().getAction();
      const command = new Command(
        {
          WorkBookUnit: workbook
        },
        action
      );
      commandManager.invoke(command);
    }
    /**
     * update current control in model
     */
    updateSelectionModel(selection, cell, index) {
      const worksheetId = this.getWorksheetId();
      if (!this._worksheet || !worksheetId)
        return;
      const selectionModels = this._selectionModels.get(worksheetId);
      const selectionModelsValue = [];
      selectionModels?.forEach((model, i4) => {
        if (i4 === index) {
          selectionModelsValue.push({ selection, cell });
        } else {
          selectionModelsValue.push(model.getValue());
        }
      });
      const workbook = this._worksheet.getContext().getWorkBook();
      const commandManager = workbook.getCommandManager();
      let action = {
        sheetId: this._worksheet.getSheetId(),
        actionName: "SetSelectionValueAction" /* SET_SELECTION_VALUE_ACTION */,
        selections: selectionModelsValue
      };
      action = ActionOperation.make(action).removeUndo().getAction();
      const command = new Command(
        {
          WorkBookUnit: workbook
        },
        action
      );
      commandManager.invoke(command);
    }
    setModels(selections) {
      const worksheetId = this.getWorksheetId();
      if (!worksheetId) {
        return;
      }
      const models = selections.map(({ selection, cell }) => {
        const model = new SelectionModel2(0 /* NORMAL */, this._plugin);
        model.setValue(selection, cell);
        return model;
      });
      this._selectionModels.set(worksheetId, models);
    }
    // recreateControlsByRangeData() { }
    /**
     * Move the selection according to different directions, usually used for the shortcut key operation of    
     * @param direction
     * @returns
     */
    move(direction) {
      const currentCell = this.getCurrentCellModel();
      if (!currentCell)
        return;
      let { row, column } = currentCell;
      const rowCount = this._worksheet?.getRowCount() || 1e3;
      const columnCount = this._worksheet?.getColumnCount() || 50;
      switch (direction) {
        case 2 /* TOP */:
          row--;
          if (row < 0) {
            row = 0;
          }
          break;
        case 3 /* BOTTOM */:
          row++;
          if (row > rowCount) {
            row = rowCount;
          }
          break;
        case 0 /* LEFT */:
          column--;
          if (column < 0) {
            column = 0;
          }
          break;
        case 1 /* RIGHT */:
          column++;
          if (column > columnCount) {
            column = columnCount;
          }
          break;
        default:
          break;
      }
      let rangeData = {
        startRow: row,
        endRow: row,
        startColumn: column,
        endColumn: column
      };
      let currentCellData = {
        row,
        column
      };
      this.clearSelectionControls();
      this.addControlToCurrentByRangeData(rangeData, currentCellData);
    }
    _initialize() {
      this._mainComponent = this._sheetView.getSpreadsheet();
      this._rowComponent = this._sheetView.getSpreadsheetRowTitle();
      this._columnComponent = this._sheetView.getSpreadsheetColumnTitle();
      this._leftTopComponent = this._sheetView.getSpreadsheetLeftTopPlaceholder();
      this._mainEventInitial();
      this._rowEventInitial();
      this._columnEventInitial();
      this._leftTopEventInitial();
      this._worksheet = this.getContext().getWorkBook().getActiveSheet();
      this._initModels();
      this._dragLineControl = new DragLineController(this);
      this._columnTitleControl = new ColumnTitleController(this);
      this._rowTitleControl = new RowTitleController(this);
    }
    _mainEventInitial() {
      const main = this._mainComponent;
      main.onPointerDownObserver.add((evt) => {
        const { offsetX: evtOffsetX, offsetY: evtOffsetY } = evt;
        this._startOffsetX = evtOffsetX;
        this._startOffsetY = evtOffsetY;
        const scrollXY = main.getAncestorScrollXY(this._startOffsetX, this._startOffsetY);
        const cellInfo = main.calculateCellIndexByPosition(evtOffsetX, evtOffsetY, scrollXY);
        const actualSelection = makeCellToSelection(cellInfo);
        if (!actualSelection || !this._worksheet) {
          return false;
        }
        const { startRow, startColumn, endColumn, endRow, startY, endY, startX, endX } = actualSelection;
        const startSelectionRange = {
          startColumn,
          startRow,
          endColumn,
          endRow,
          startY,
          endY,
          startX,
          endX
        };
        this._startSelectionRange = startSelectionRange;
        let selectionControl = this.getCurrentControl();
        let curControls = this.getCurrentControls();
        if (!curControls) {
          return false;
        }
        for (let control of curControls) {
          if (evt.button === 2 && control.model.isInclude(startSelectionRange)) {
            selectionControl = control;
            return;
          }
          if (control.model.isEqual(startSelectionRange)) {
            selectionControl = control;
            break;
          }
          if (!evt.shiftKey) {
            control.clearHighlight();
          }
        }
        if (curControls.length > 0 && !evt.ctrlKey && !evt.shiftKey) {
          for (let control of curControls) {
            control.dispose();
          }
          curControls.length = 0;
        }
        const currentCell = selectionControl && selectionControl.model.currentCell;
        if (selectionControl && evt.shiftKey && currentCell) {
          const { row, column } = currentCell;
          const startCell = main.getNoMergeCellPositionByIndex(row, column);
          const endCell = main.getNoMergeCellPositionByIndex(endRow, endColumn);
          const newSelectionRange = {
            startColumn: column,
            startRow: row,
            endColumn: startSelectionRange.startColumn,
            endRow: startSelectionRange.startRow,
            startY: startCell?.startY || 0,
            endY: endCell?.endY || 0,
            startX: startCell?.startX || 0,
            endX: endCell?.endX || 0
          };
          selectionControl.update(newSelectionRange, currentCell);
        } else {
          selectionControl = SelectionControl3.create(this, curControls.length);
          selectionControl.update(startSelectionRange, cellInfo);
          curControls.push(selectionControl);
        }
        this.hasSelection = true;
        const scene = this.getScene();
        scene.disableEvent();
        const scrollTimer = ScrollTimer.create(this.getScene());
        scrollTimer.startScroll(evtOffsetX, evtOffsetY);
        this.setSelectionModel();
        this._plugin.getObserver("onChangeSelectionObserver")?.notifyObservers(selectionControl);
        this._moveObserver = scene.onPointerMoveObserver.add((moveEvt) => {
          this.moving(moveEvt, selectionControl);
          const { offsetX: moveOffsetX, offsetY: moveOffsetY } = moveEvt;
          scrollTimer.scrolling(moveOffsetX, moveOffsetY, () => {
            this.moving(moveEvt, selectionControl);
          });
        });
        this._upObserver = scene.onPointerUpObserver.add((upEvt) => {
          this.up();
          scene.onPointerMoveObserver.remove(this._moveObserver);
          scene.onPointerUpObserver.remove(this._upObserver);
          scene.enableEvent();
          scrollTimer.stopScroll();
        });
      });
    }
    /**
     * When mousedown and mouseup need to go to the coordination and undo stack, when mousemove does not need to go to the coordination and undo stack
     * @param moveEvt
     * @param selectionControl
     * @returns
     */
    moving(moveEvt, selectionControl) {
      const main = this._mainComponent;
      const { offsetX: moveOffsetX, offsetY: moveOffsetY, clientX, clientY } = moveEvt;
      const { startRow, startColumn, endRow, endColumn } = this._startSelectionRange;
      const scrollXY = main.getAncestorScrollXY(this._startOffsetX, this._startOffsetY);
      const moveCellInfo = main.calculateCellIndexByPosition(moveOffsetX, moveOffsetY, scrollXY);
      const moveActualSelection = makeCellToSelection(moveCellInfo);
      if (!moveActualSelection) {
        return false;
      }
      const { startRow: moveStartRow, startColumn: moveStartColumn, endColumn: moveEndColumn, endRow: moveEndRow } = moveActualSelection;
      const newStartRow = Math.min(moveStartRow, startRow);
      const newStartColumn = Math.min(moveStartColumn, startColumn);
      const newEndRow = Math.max(moveEndRow, endRow);
      const newEndColumn = Math.max(moveEndColumn, endColumn);
      const newBounding = main.getSelectionBounding(newStartRow, newStartColumn, newEndRow, newEndColumn);
      if (!newBounding) {
        return false;
      }
      const { startRow: finalStartRow, startColumn: finalStartColumn, endRow: finalEndRow, endColumn: finalEndColumn } = newBounding;
      const startCell = main.getNoMergeCellPositionByIndex(finalStartRow, finalStartColumn);
      const endCell = main.getNoMergeCellPositionByIndex(finalEndRow, finalEndColumn);
      const newSelectionRange = {
        startColumn: finalStartColumn,
        startRow: finalStartRow,
        endColumn: finalEndColumn,
        endRow: finalEndRow,
        startY: startCell?.startY || 0,
        endY: endCell?.endY || 0,
        startX: startCell?.startX || 0,
        endX: endCell?.endX || 0
      };
      const {
        startRow: oldStartRow,
        endRow: oldEndRow,
        startColumn: oldStartColumn,
        endColumn: oldEndColumn
      } = selectionControl?.model || { startRow: -1, endRow: -1, startColumn: -1, endColumn: -1 };
      if (oldStartColumn !== finalStartColumn || oldStartRow !== finalStartRow || oldEndColumn !== finalEndColumn || oldEndRow !== finalEndRow) {
        selectionControl && selectionControl.update(newSelectionRange);
        this.setSelectionModel();
        selectionControl && this._plugin.getObserver("onChangeSelectionObserver")?.notifyObservers(selectionControl);
      }
    }
    /**
     * pointer up event
     * @param moveEvt
     * @param selectionControl
     * @returns
     */
    up() {
      this.setSelectionModel();
    }
    _rowEventInitial() {
      const row = this._rowComponent;
      row.onPointerEnterObserver.add((evt) => {
      });
    }
    _columnEventInitial() {
      const column = this._columnComponent;
      column.onPointerEnterObserver.add((evt) => {
      });
    }
    _leftTopEventInitial() {
      const leftTop = this._leftTopComponent;
      leftTop.onPointerDownObserver.add((evt) => {
      });
    }
    /**
     * Initialize selection model based on user configuration
     * @param selections
     */
    _initModels() {
      const selections = this._plugin.getConfig().selections;
      Object.keys(selections).forEach((worksheetId) => {
        const selectionsList = selections[worksheetId];
        const currentModels = [];
        selectionsList.forEach((selectionConfig) => {
          const { startColumn, startRow, endColumn, endRow } = selectionConfig.selection;
          const cell = selectionConfig.cell;
          const model = new SelectionModel2(0 /* NORMAL */, this._plugin);
          const cellInfo = cell ? {
            row: cell.row,
            column: cell.column,
            isMerged: false,
            isMergedMainCell: false,
            startY: 0,
            endY: 0,
            startX: 0,
            endX: 0,
            mergeInfo: {
              startColumn,
              startRow,
              endColumn,
              endRow,
              startY: 0,
              endY: 0,
              startX: 0,
              endX: 0
            }
          } : null;
          model.setValue(
            {
              startColumn,
              startRow,
              endColumn,
              endRow,
              startY: 0,
              endY: 0,
              startX: 0,
              endX: 0
            },
            cellInfo
          );
          currentModels.push(model);
        });
        this._selectionModels.set(worksheetId, currentModels);
      });
    }
    /**
     * Initialize selection based on user configuration
     * @param selections
     */
    _initControls() {
      const selections = this._plugin.getConfig().selections;
      Object.keys(selections).forEach((worksheetId) => {
        const selectionsList = selections[worksheetId];
        const currentControls = [];
        selectionsList.forEach((selectionConfig) => {
          const selectionRange = selectionConfig.selection;
          const curCellRange = selectionConfig.cell;
          const main = this._mainComponent;
          const control = SelectionControl3.create(this, currentControls.length);
          let cellInfo = null;
          if (curCellRange) {
            cellInfo = main.getCellByIndex(curCellRange.row, curCellRange.column);
          }
          const { startRow: finalStartRow, startColumn: finalStartColumn, endRow: finalEndRow, endColumn: finalEndColumn } = selectionRange;
          const startCell = main.getNoMergeCellPositionByIndex(finalStartRow, finalStartColumn);
          const endCell = main.getNoMergeCellPositionByIndex(finalEndRow, finalEndColumn);
          control.model.setValue(
            {
              startColumn: finalStartColumn,
              startRow: finalStartRow,
              endColumn: finalEndColumn,
              endRow: finalEndRow,
              startY: startCell?.startY || 0,
              endY: endCell?.endY || 0,
              startX: startCell?.startX || 0,
              endX: endCell?.endX || 0
            },
            cellInfo
          );
          currentControls.push(control);
        });
      });
    }
    /**
     * Initialize the observer
     */
    _initializeObserver() {
      const context = this._plugin.getContext();
      context.getContextObserver("onAfterChangeActiveSheetObservable").add(() => {
        this.renderCurrentControls();
      });
      this._worksheet?.getContext().getContextObserver("onSheetRenderDidMountObservable").add(() => {
        this.renderCurrentControls();
      });
    }
    /**
     * Get all range data of the current selection
     * @returns
     */
    getActiveRangeListData() {
      const models = this.getCurrentModels();
      if (models && models.length > 0) {
        const selections = models?.map((model) => ({
          startRow: model.startRow,
          startColumn: model.startColumn,
          endRow: model.endRow,
          endColumn: model.endColumn
        }));
        return selections;
      }
    }
    /**
     * Returns the list of active ranges in the active sheet or null if there are no active ranges.
     * If there is a single range selected, this behaves as a getActiveRange() call.
     *
     * @returns
     */
    getActiveRangeList() {
      const rangeListData = this.getActiveRangeListData();
      return rangeListData && this._worksheet?.getRangeList(rangeListData);
    }
    /**
     * Get the range of the currently active cell
     * @returns
     */
    getActiveRangeData() {
      const models = this.getCurrentModels();
      if (models && models.length > 0) {
        for (const model of models) {
          if (model.currentCell) {
            return {
              startRow: model.startRow,
              startColumn: model.startColumn,
              endRow: model.endRow,
              endColumn: model.endColumn
            };
          }
        }
      }
    }
    /**
     * Returns the selected range in the active sheet, or null if there is no active range. If multiple ranges are selected this method returns only the last selected range.
     * @returns
     */
    getActiveRange() {
      const rangeData = this.getActiveRangeData();
      return rangeData && this._worksheet?.getRange(rangeData);
    }
    /**
     * get active selection control
     * @returns
     */
    getCurrentCellData() {
      const models = this.getCurrentModels();
      if (models && models.length > 0) {
        for (const model of models) {
          const currentCell = model.currentCell;
          if (currentCell) {
            return {
              startRow: currentCell.row,
              startColumn: currentCell.column,
              endRow: currentCell.row,
              endColumn: currentCell.column
            };
          }
        }
      }
    }
    /**
     * get active selection control
     * @returns
     */
    getCurrentCell() {
      const rangeData = this.getCurrentCellData();
      return rangeData && this._worksheet?.getRange(rangeData);
    }
    getDragLineControl() {
      return this._dragLineControl;
    }
  };

  // ../../packages/base-sheets/src/View/Render/Views/SheetView.ts
  var SheetView = class extends BaseView {
    viewKey = "sheetView" /* SHEET_VIEW */;
    _selectionManager;
    _spreadsheetSkeleton;
    _spreadsheet;
    _spreadsheetRowTitle;
    _spreadsheetColumnTitle;
    _spreadsheetLeftTopPlaceholder;
    _initialize() {
      const scene = this.getScene();
      const context = this.getContext();
      const workbook = context.getWorkBook();
      let worksheet = workbook.getActiveSheet();
      if (!worksheet) {
        worksheet = workbook.getSheets()[0];
      }
      const spreadsheetSkeleton = this._buildSkeleton(worksheet);
      const { rowTotalHeight, columnTotalWidth, rowTitleWidth, columnTitleHeight } = spreadsheetSkeleton;
      const spreadsheet = new Spreadsheet("__SpreadsheetRender__" /* MAIN */, spreadsheetSkeleton);
      const spreadsheetRowTitle = new SpreadsheetRowTitle("__SpreadsheetRowTitle__" /* ROW */, spreadsheetSkeleton);
      const spreadsheetColumnTitle = new SpreadsheetColumnTitle("__SpreadsheetColumnTitle__" /* COLUMN */, spreadsheetSkeleton);
      const SpreadsheetLeftTopPlaceholder = new Rect("__SpreadsheetLeftTopPlaceholder__" /* LEFT_TOP */, {
        zIndex: 2,
        left: -1,
        top: -1,
        width: rowTitleWidth,
        height: columnTitleHeight,
        fill: getColor([248, 249, 250]),
        stroke: getColor([217, 217, 217]),
        strokeWidth: 1
      });
      this._spreadsheetSkeleton = spreadsheetSkeleton;
      this._spreadsheet = spreadsheet;
      this._spreadsheetRowTitle = spreadsheetRowTitle;
      this._spreadsheetColumnTitle = spreadsheetColumnTitle;
      this._spreadsheetLeftTopPlaceholder = SpreadsheetLeftTopPlaceholder;
      scene.addObjects([spreadsheet], 0);
      scene.addObjects([spreadsheetRowTitle, spreadsheetColumnTitle, SpreadsheetLeftTopPlaceholder], 2);
      scene.transformByState({
        width: this._columnWidthByTitle(worksheet),
        height: this._rowHeightByTitle(worksheet) + rowTotalHeight
        // width: this._columnWidthByTitle(worksheet) + columnTotalWidth + 100,
        // height: this._rowHeightByTitle(worksheet) + rowTotalHeight + 200,
      });
      this._updateViewport(rowTitleWidth, columnTitleHeight);
      this._selectionManager = new SelectionManager2(this);
    }
    getSelectionManager() {
      return this._selectionManager;
    }
    getSelectionControls() {
      return this._selectionManager.getCurrentControls();
    }
    getSpreadsheetSkeleton() {
      return this._spreadsheetSkeleton;
    }
    getSpreadsheet() {
      return this._spreadsheet;
    }
    getSpreadsheetRowTitle() {
      return this._spreadsheetRowTitle;
    }
    getSpreadsheetColumnTitle() {
      return this._spreadsheetColumnTitle;
    }
    getSpreadsheetLeftTopPlaceholder() {
      return this._spreadsheetLeftTopPlaceholder;
    }
    updateToSheet(worksheet) {
      const scene = this.getScene();
      const spreadsheetSkeleton = this._buildSkeleton(worksheet);
      const { rowTotalHeight, columnTotalWidth, rowTitleWidth, columnTitleHeight } = spreadsheetSkeleton;
      this._spreadsheetSkeleton = spreadsheetSkeleton;
      this._spreadsheet.updateSkeleton(spreadsheetSkeleton);
      this._spreadsheetRowTitle.updateSkeleton(spreadsheetSkeleton);
      this._spreadsheetColumnTitle.updateSkeleton(spreadsheetSkeleton);
      this._spreadsheetLeftTopPlaceholder.transformByState({
        width: rowTitleWidth,
        height: columnTitleHeight
      });
      scene.transformByState({
        width: this._columnWidthByTitle(worksheet),
        height: this._rowHeightByTitle(worksheet) + rowTotalHeight
        // width: this._columnWidthByTitle(worksheet) + columnTotalWidth + 100,
        // height: this._rowHeightByTitle(worksheet) + rowTotalHeight + 200,
      });
      this._updateViewport(rowTitleWidth, columnTitleHeight);
      this._selectionManager.updateToSheet(worksheet);
    }
    _updateViewport(rowTitleWidth, columnTitleHeight) {
      const scene = this.getScene();
      const rowTitleWidthScale = rowTitleWidth * scene.scaleX;
      const columnTitleHeightScale = columnTitleHeight * scene.scaleY;
      const viewMain = scene.getViewport("viewMain" /* VIEW_MAIN */);
      const viewTop = scene.getViewport("viewTop" /* VIEW_TOP */);
      const viewLeft = scene.getViewport("viewLeft" /* VIEW_LEFT */);
      const viewLeftTop = scene.getViewport("viewLeftTop" /* VIEW_LEFT_TOP */);
      viewMain?.resize({
        left: rowTitleWidthScale,
        top: columnTitleHeightScale
      });
      viewTop?.resize({
        left: rowTitleWidthScale,
        height: columnTitleHeightScale
      });
      viewLeft?.resize({
        top: columnTitleHeightScale,
        width: rowTitleWidthScale
      });
      viewLeftTop?.resize({
        width: rowTitleWidthScale,
        height: columnTitleHeightScale
      });
    }
    _buildSkeleton(worksheet) {
      const context = this.getContext();
      const workbook = context.getWorkBook();
      const config = worksheet.getConfig();
      const spreadsheetSkeleton = SpreadsheetSkeleton.create(config, worksheet.getCellMatrix(), workbook.getStyles(), context);
      return spreadsheetSkeleton;
    }
    _rowHeightByTitle(worksheet) {
      const config = worksheet?.getConfig();
      const columnTitle = config?.columnTitle.height || 0;
      return columnTitle;
    }
    _columnWidthByTitle(worksheet) {
      const config = worksheet?.getConfig();
      const rowTitle = config?.rowTitle.width || 0;
      return rowTitle;
    }
  };
  var SheetViewFactory = class {
    /**
     * Generate SheetView Instance
     * @param scene
     * @param plugin
     * @returns
     */
    create(scene, plugin) {
      return new SheetView().initialize(scene, plugin);
    }
  };
  CanvasViewRegistry.add(new SheetViewFactory());

  // ../../packages/base-sheets/src/View/Render/Views/OtherViewTest.ts
  var richTextTest = {
    id: "d",
    drawings: {
      shapeTest1: {
        objectId: "shapeTest1",
        objectProperties: {
          title: "test shape",
          description: "test shape",
          size: {
            width: 100,
            height: 400
          },
          positionH: {
            relativeFrom: 1 /* COLUMN */,
            posOffset: 100
          },
          positionV: {
            relativeFrom: 6 /* PARAGRAPH */,
            posOffset: 160
          },
          angle: 0,
          imageProperties: {
            contentUrl: "https://cnbabylon.com/assets/img/agents.png"
          }
        },
        layoutType: 3 /* WRAP_SQUARE */,
        behindDoc: 0 /* FALSE */,
        wrapText: 0 /* BOTH_SIDES */
      }
    },
    lists: {
      unorderedTest: {
        listId: "unorderedTest",
        nestingLevel: [
          {
            bulletAlignment: 1 /* START */,
            glyphFormat: " %0",
            textStyle: {
              fs: 12
            },
            startNumber: 0,
            glyphSymbol: "\u25CF",
            hanging: 21,
            indentStart: 21
          },
          {
            bulletAlignment: 1 /* START */,
            glyphFormat: " %1",
            textStyle: {
              fs: 12
            },
            startNumber: 0,
            glyphSymbol: "\u25A0",
            hanging: 21,
            indentStart: 42
          },
          {
            bulletAlignment: 1 /* START */,
            glyphFormat: " %1",
            textStyle: {
              fs: 12
            },
            startNumber: 0,
            glyphSymbol: "\u25C6",
            hanging: 21,
            indentStart: 63
          }
        ]
      },
      testBullet: {
        listId: "testBullet",
        nestingLevel: [
          {
            bulletAlignment: 1 /* START */,
            glyphFormat: " %1.",
            textStyle: {
              fs: 12
            },
            startNumber: 0,
            glyphType: 7 /* ROMAN */,
            hanging: 21,
            indentStart: 21
          },
          {
            bulletAlignment: 1 /* START */,
            glyphFormat: " %1.%2)",
            textStyle: {
              fs: 12
            },
            startNumber: 0,
            glyphType: 7 /* ROMAN */,
            hanging: 21,
            indentStart: 42
          },
          {
            bulletAlignment: 1 /* START */,
            glyphFormat: " %1.%2.%3.",
            textStyle: {
              fs: 12
            },
            startNumber: 0,
            glyphType: 7 /* ROMAN */,
            hanging: 21,
            indentStart: 63
          }
        ]
      }
    },
    body: {
      blockElements: {
        oneParagraph: {
          blockId: "oneParagraph",
          st: 0,
          ed: 15,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            bullet: {
              listId: "testBullet",
              nestingLevel: 0,
              textStyle: {
                fs: 20
              }
            },
            elements: {
              oneElement: {
                eId: "oneElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u5728\u201C\u7B2C1\u9898\u201D\u5DE5\u4F5C\u8868\u4E2D\u5B8C\u6210\u4EE5\u4E0B\u64CD\u4F5C",
                  ts: {
                    fs: 12,
                    bg: {
                      rgb: "rgb(200,0,90)"
                    },
                    cl: {
                      rgb: "rgb(255,130,0)"
                    }
                  }
                }
              },
              smallSub: {
                eId: "smallSub",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u4E0A\u6807",
                  ts: {
                    fs: 14,
                    bg: {
                      rgb: "rgb(2,128,2)"
                    },
                    cl: {
                      rgb: "rgb(0,1,55)"
                    },
                    va: 2 /* SUPERSCRIPT */
                  }
                }
              },
              twoElement: {
                eId: "twoElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u65E5\u671F\u5217\u5355\u5143\u683C\u6570\u636E\u9A8C\u8BC1\uFF0C\u9650\u5236\u53EA\u80FD\u8F93\u5165\u65E5\u671F\uFF08\u4ECB\u4E8E1949\u5E741\u67081\u65E5\u81F32099\u5E741\u67081\u65E5\uFF09",
                  ts: {
                    fs: 14,
                    bg: {
                      rgb: "rgb(90,128,255)"
                    },
                    cl: {
                      rgb: "rgb(0,1,255)"
                    }
                  }
                }
              }
            },
            elementOrder: [
              {
                elementId: "oneElement",
                paragraphElementType: 0 /* TEXT_RUN */
              },
              {
                elementId: "shapeTest1",
                paragraphElementType: 7 /* DRAWING */
              },
              {
                elementId: "smallSub",
                paragraphElementType: 0 /* TEXT_RUN */
              },
              {
                elementId: "twoElement",
                paragraphElementType: 0 /* TEXT_RUN */
              }
            ]
          }
        },
        twoParagraph: {
          blockId: "twoParagraph",
          st: 0,
          ed: 15,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            bullet: {
              listId: "testBullet",
              nestingLevel: 1,
              textStyle: {
                fs: 20
              }
            },
            elements: {
              oneElement: {
                eId: "oneElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u7EC6\u5316\u57CB\u70B9\u4E0A\u62A5\u94FE\u8DEF\u548C\u6307\u6807\u65B9\u6848\u68B3\u7406"
                }
              },
              twoElement: {
                eId: "twoElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u76EE\u524D\u901A\u8FC7\u6BCF\u65E5\u5B9A\u65F6\u4EFB\u52A1\u53D1\u9001\u62A5\u544A"
                }
              }
            },
            elementOrder: [
              {
                elementId: "oneElement",
                paragraphElementType: 0 /* TEXT_RUN */
              },
              {
                elementId: "twoElement",
                paragraphElementType: 0 /* TEXT_RUN */
              }
            ]
          }
        },
        threeParagraph: {
          blockId: "threeParagraph",
          st: 0,
          ed: 15,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            bullet: {
              listId: "testBullet",
              nestingLevel: 0,
              textStyle: {
                fs: 20
              }
            },
            elements: {
              oneElement: {
                eId: "oneElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u81EA2018\u5E74\u9996\u5C4A\u8FDB\u535A\u4F1A\u4E3E\u529E\u4EE5\u6765\uFF0C\u8FDB\u535A\u4F1A\u5DF2\u7ECF\u6210\u4E3A\u5168\u7403\u65B0\u54C1\u7684\u9996\u53D1\u5730\u3001\u524D\u6CBF\u6280\u672F\u7684\u9996\u9009\u5730\u3001\u521B\u65B0\u670D\u52A1\u7684\u9996\u63A8\u5730\u3002"
                }
              },
              twoElement: {
                eId: "twoElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u4E2D\u56FD\u8FD9\u5341\u5E74\u201D\u5BF9\u5916\u5F00\u653E\u6210\u5C31\u5C55\u6E56\u5317\u5C55\u533A\u4E3B\u8981\u4EE5\u56FE\u6587\u3001\u56FE\u8868\u3001\u6570\u636E\u3001\u89C6\u9891\u3001\u4F01\u4E1A\u5C55\u54C1\u3001\u5B9E\u7269\u6A21\u578B\u3001\u5149\u7535\u79D1\u6280\u7B49\u4F53\u73B0\u6E56\u5317\u5341\u5E74\u5F00\u653E\u6210\u5C31\u3001\u91CD\u5927\u5F00\u653E\u5E73\u53F0\u53CA\u4EA7\u4E1A\u3002\u6E56\u5317\u7701\u5171\u8BA117\u5BB6\u4F01\u4E1A\u3001\u673A\u6784\u7684\u5C55\u54C1\u5C06\u5728\u8FD9\u4E00\u5C55\u533A\u5C55\u793A"
                }
              }
            },
            elementOrder: [
              {
                elementId: "oneElement",
                paragraphElementType: 0 /* TEXT_RUN */
              },
              {
                elementId: "twoElement",
                paragraphElementType: 0 /* TEXT_RUN */
              }
            ]
          }
        },
        fourParagraph: {
          blockId: "fourParagraph",
          st: 0,
          ed: 15,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            bullet: {
              listId: "testBullet",
              nestingLevel: 1,
              textStyle: {
                fs: 20
              }
            },
            elements: {
              oneElement: {
                eId: "oneElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u56FD\u5BB6\u4E3B\u5E2D\u4E60\u8FD1\u5E73\u4EE5\u89C6\u9891\u65B9\u5F0F\u51FA\u5E2D\u5728\u4E0A\u6D77\u4E3E\u884C\u7684\u7B2C\u4E94\u5C4A\u4E2D\u56FD\u56FD\u9645\u8FDB\u53E3\u535A\u89C8\u4F1A\u5F00\u5E55\u5F0F\u5E76\u53D1\u8868\u9898\u4E3A\u300A\u5171\u521B\u5F00\u653E\u7E41\u8363\u7684\u7F8E\u597D\u672A\u6765\u300B\u7684\u81F4\u8F9E"
                }
              },
              twoElement: {
                eId: "twoElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u4E2D\u56FD\u5C06\u63A8\u52A8\u5404\u56FD\u5404\u65B9\u5171\u4EAB\u6DF1\u5316\u56FD\u9645\u5408\u4F5C\u673A\u9047\uFF0C\u5168\u9762\u6DF1\u5165\u53C2\u4E0E\u4E16\u754C\u8D38\u6613\u7EC4\u7EC7\u6539\u9769\u8C08\u5224"
                }
              }
            },
            elementOrder: [
              {
                elementId: "oneElement",
                paragraphElementType: 0 /* TEXT_RUN */
              },
              {
                elementId: "twoElement",
                paragraphElementType: 0 /* TEXT_RUN */
              }
            ]
          }
        },
        fiveParagraph: {
          blockId: "fiveParagraph",
          st: 0,
          ed: 15,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            bullet: {
              listId: "testBullet",
              nestingLevel: 2,
              textStyle: {
                fs: 20
              }
            },
            elements: {
              oneElement: {
                eId: "oneElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u4E2D\u56FD\u7537\u6392\u4E24\u540D\u73B0\u5F79\u56FD\u624B\u5F6D\u4E16\u5764\u548C\u5F20\u79C9\u9F99\u5206\u522B\u6548\u529B\u7684\u4E09\u5F97\u5229\u592A\u9633\u9E1F\u548C\u4E1C\u4EAC\u5927\u718A\u672C\u8F6E\u906D\u9047\u3002"
                }
              },
              twoElement: {
                eId: "twoElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u53CC\u65B9\u7ECF\u8FC7\u6FC0\u6218\uFF0C\u4E3B\u573A\u4F5C\u6218\u7684\u536B\u5195\u51A0\u519B\u4E09\u5F97\u5229\u6280\u9AD8\u4E00\u7B793-2\u9006\u8F6C\u51FB\u8D25\u5BF9\u624B\uFF0C\u529B\u593A\u7B2C3\u573A\u80DC\u5229"
                }
              }
            },
            elementOrder: [
              {
                elementId: "oneElement",
                paragraphElementType: 0 /* TEXT_RUN */
              },
              {
                elementId: "twoElement",
                paragraphElementType: 0 /* TEXT_RUN */
              }
            ]
          }
        }
      },
      blockElementOrder: ["oneParagraph", "twoParagraph", "threeParagraph", "fourParagraph", "fiveParagraph"]
    },
    documentStyle: {
      pageSize: {
        width: Infinity,
        height: Infinity
      },
      marginTop: 0,
      marginBottom: 0,
      marginRight: 2,
      marginLeft: 2
    }
  };

  // ../../packages/base-sheets/src/View/Render/CanvasView.ts
  var CanvasView = class {
    // worksheet
    constructor(_engine, _plugin) {
      this._engine = _engine;
      this._plugin = _plugin;
      this._initialize();
    }
    _scene;
    _views = [];
    _initialize() {
      const engine = this._engine;
      const context = this._plugin.getContext();
      const workbook = this._plugin.getWorkbook();
      let worksheet = workbook.getActiveSheet();
      if (!worksheet) {
        worksheet = workbook.getSheets()[0];
      }
      const config = worksheet.getConfig();
      const rowTitle = config.rowTitle;
      const columnTitle = config.columnTitle;
      const scene = new Scene("mainScene" /* MAIN_SCENE */, engine, {
        width: 1200,
        height: 1e3
      });
      scene.openTransformer();
      this._scene = scene;
      const viewMain = new Viewport("viewMain" /* VIEW_MAIN */, scene, {
        left: rowTitle.width,
        top: columnTitle.height,
        bottom: 0,
        right: 0,
        isWheelPreventDefaultX: true
      });
      const viewTop = new Viewport("viewTop" /* VIEW_TOP */, scene, {
        left: rowTitle.width,
        top: 0,
        height: columnTitle.height,
        right: 0,
        isWheelPreventDefaultX: true
      });
      const viewLeft = new Viewport("viewLeft" /* VIEW_LEFT */, scene, {
        left: 0,
        top: columnTitle.height,
        bottom: 0,
        width: rowTitle.width,
        isWheelPreventDefaultX: true
      });
      const viewLeftTop = new Viewport("viewLeftTop" /* VIEW_LEFT_TOP */, scene, {
        left: 0,
        top: 0,
        width: rowTitle.width,
        height: columnTitle.height,
        isWheelPreventDefaultX: true
      });
      viewMain.onScrollAfterObserver.add((param) => {
        const { scrollX: scrollX2, scrollY: scrollY2, actualScrollX, actualScrollY } = param;
        viewTop.updateScroll({
          scrollX: scrollX2,
          actualScrollX
        }).makeDirty(true);
        viewLeft.updateScroll({
          scrollY: scrollY2,
          actualScrollY
        }).makeDirty(true);
      });
      context.getContextObserver("onZoomRatioSheetObservable").add((value) => {
        const plugin = this._plugin;
        this._scene.scale(value.zoomRatio, value.zoomRatio);
      });
      scene.addViewport(viewMain, viewLeft, viewTop, viewLeftTop).attachControl();
      scene.on("MouseWheel" /* wheel */, (evt, state) => {
        const e4 = evt;
        if (e4.ctrlKey) {
          const deltaFactor = Math.abs(e4.deltaX);
          let scrollNum = deltaFactor < 40 ? 0.2 : deltaFactor < 80 ? 0.4 : 0.2;
          scrollNum *= e4.deltaY > 0 ? -1 : 1;
          if (scene.scaleX < 1) {
            scrollNum /= 2;
          }
          if (scene.scaleX + scrollNum > 4) {
            scene.scale(4, 4);
          } else if (scene.scaleX + scrollNum < 0.1) {
            scene.scale(0.1, 0.1);
          } else {
            const sheet = context.getWorkBook().getActiveSheet();
            const value = e4.deltaY > 0 ? 0.1 : -0.1;
            sheet.setZoomRatio(sheet.getZoomRatio() + value);
            e4.preventDefault();
          }
        } else {
          viewMain.onMouseWheel(e4, state);
        }
      });
      const scrollbar = new ScrollBar(viewMain);
      scene.addLayer(Layer.create(scene, [], 0), Layer.create(scene, [], 2));
      this._viewLoader(scene, this._plugin);
      engine.runRenderLoop(() => {
        scene.render();
        const app = document.getElementById("app");
        if (app) {
          app.innerText = `fps:${Math.round(engine.getFps()).toString()}`;
        }
      });
    }
    getView(key) {
      for (let view of this._views) {
        if (view.viewKey === key) {
          return view;
        }
      }
    }
    getSheetView() {
      return this.getView("sheetView" /* SHEET_VIEW */);
    }
    updateToSheet(worksheet) {
      for (let view of this._views) {
        view.updateToSheet(worksheet);
      }
    }
    _viewLoader(scene, plugin) {
      CanvasViewRegistry.getData().forEach((viewFactory) => {
        this._views.push(viewFactory.create(scene, plugin));
      });
    }
  };

  // ../../packages/base-sheets/src/Controller/CellEditorController.ts
  var CellEditorController = class {
    _plugin;
    // current edit cell
    currentEditRangeData;
    constructor(plugin) {
      this._plugin = plugin;
    }
    setCurrentEditRangeData() {
      const currentCell = this._plugin.getSelectionManager().getCurrentCellModel();
      if (!currentCell)
        return;
      let row;
      let column;
      if (currentCell.isMerged) {
        const mergeInfo = currentCell.mergeInfo;
        row = mergeInfo.startRow;
        column = mergeInfo.startColumn;
      } else {
        row = currentCell.row;
        column = currentCell.column;
      }
      this.currentEditRangeData = {
        startRow: row,
        startColumn: column,
        endRow: row,
        endColumn: column
      };
    }
    getCurrentEditRangeData() {
      return this.currentEditRangeData;
    }
    setCurrentEditRangeValue(cell) {
      const { startRow, startColumn, endRow, endColumn } = this.currentEditRangeData;
      const range2 = this._plugin.getContext().getWorkBook().getActiveSheet().getRange(startRow, startColumn, endRow, endColumn);
      range2.setRangeData(cell);
    }
    getSelectionValue() {
      const range2 = this._plugin.getSelectionManager().getActiveRange();
      if (!range2)
        return "";
      const value = range2 && range2.getDisplayValue();
      if (typeof value === "string") {
        return value;
      }
      if (typeof value === "object" && value !== null) {
        return handleJsonToDom(value);
      }
      return "";
    }
    getSelectionStyle() {
      return this._plugin.getSelectionManager().getActiveRange()?.getTextStyle();
    }
    setSelectionValue(value) {
      const range2 = this._plugin.getSelectionManager().getActiveRange();
      if (!range2)
        return;
      if (typeof value === "string") {
        range2.setValue(value);
      }
      if (typeof value === "object") {
        range2.setRangeData({ p: value });
      }
    }
    handleBackSpace() {
    }
    handleDirection(direction) {
    }
  };

  // ../../packages/base-sheets/src/Controller/CountBarController.ts
  var CountBarController = class {
    _plugin;
    _getCoreObserver(type) {
      return this._plugin.getGlobalContext().getObserverManager().requiredObserver(type, "core");
    }
    constructor(plugin) {
      this._plugin = plugin;
    }
    getPlugin() {
      return this._plugin;
    }
    listenEventManager() {
      this._getCoreObserver("onUIChangeObservable").add(({ name, value }) => {
        switch (name) {
          case "changeZoom": {
            const workbook = this._plugin.getContext().getWorkBook();
            if (workbook) {
              workbook.getActiveSheet().setZoomRatio(value);
            }
            break;
          }
        }
      });
    }
  };

  // ../../packages/base-sheets/src/Controller/RightMenuController.ts
  var RightMenuController = class {
    _plugin;
    constructor(plugin) {
      this._plugin = plugin;
    }
    listenEventManager() {
      this._plugin.getContext().getUniver().getGlobalContext().getObserverManager().requiredObserver("onUIChangeObservable", "core").add((msg) => {
        switch (msg.name) {
          case "insertRow":
            this.insertRow();
            break;
          case "insertColumn":
            this.insertColumn();
            break;
          case "deleteRow":
            this.deleteRow();
            break;
          case "deleteColumn":
            this.deleteColumn();
            break;
          case "moveTop":
            this.deleteCellTop();
            break;
          case "moveLeft":
            this.deleteCellLeft();
            break;
          case "clearContent":
            this.clearContent();
            break;
        }
      });
    }
    _getSelections() {
      const controls = this._plugin?.getSelectionManager().getCurrentControls();
      const selections = controls?.map((control) => {
        const model = control.model;
        return {
          startRow: model.startRow,
          startColumn: model.startColumn,
          endRow: model.endRow,
          endColumn: model.endColumn
        };
      });
      return selections;
    }
    insertRow = () => {
      const selections = this._getSelections();
      if (selections?.length === 1) {
        const sheet = this._plugin.getContext().getWorkBook().getActiveSheet();
        sheet?.insertRowBefore(selections[0].startRow, selections[0].endRow - selections[0].startRow + 1);
      }
    };
    deleteRow = () => {
      const selections = this._getSelections();
      if (selections?.length === 1) {
        const sheet = this._plugin.getContext().getWorkBook().getActiveSheet();
        sheet?.deleteRows(selections[0].startRow, selections[0].endRow - selections[0].startRow + 1);
      }
    };
    insertColumn = () => {
      const selections = this._getSelections();
      if (selections?.length === 1) {
        const sheet = this._plugin.getContext().getWorkBook().getActiveSheet();
        sheet.insertColumnBefore(selections[0].startColumn, selections[0].endColumn - selections[0].startColumn + 1);
      }
    };
    deleteColumn = () => {
      const selections = this._getSelections();
      if (selections?.length === 1) {
        const sheet = this._plugin.getContext().getWorkBook().getActiveSheet();
        sheet.deleteColumns(selections[0].startColumn, selections[0].endColumn - selections[0].startColumn + 1);
      }
    };
    clearContent = () => {
      const selections = this._getSelections();
      if (selections?.length === 1) {
        const sheet = this._plugin.getContext().getWorkBook().getActiveSheet();
        sheet.getRange(selections[0]).clear();
      }
    };
    deleteCellLeft = () => {
      const selections = this._getSelections();
      if (selections?.length === 1) {
        const sheet = this._plugin.getContext().getWorkBook().getActiveSheet();
        sheet.getRange(selections[0]).deleteCells(0);
      }
    };
    deleteCellTop = () => {
      const selections = this._getSelections();
      if (selections?.length === 1) {
        const sheet = this._plugin.getContext().getWorkBook().getActiveSheet();
        sheet.getRange(selections[0]).deleteCells(1);
      }
    };
    setColumnWidth(e4) {
      if (e4.key !== "Enter") {
        return;
      }
      const width = e4.target.value;
      const selections = this._getSelections();
      if (selections?.length === 1) {
        const sheet = this._plugin.getContext().getWorkBook().getActiveSheet();
        sheet.setColumnWidth(selections[0].startColumn, selections[0].endColumn - selections[0].startColumn + 1, Number(width));
      }
    }
    setRowHeight(e4) {
      if (e4.key !== "Enter") {
        return;
      }
      const height = e4.target.value;
      const selections = this._getSelections();
      if (selections?.length === 1) {
        const sheet = this._plugin.getContext().getWorkBook().getActiveSheet();
        sheet.setRowHeights(selections[0].startRow, selections[0].endRow - selections[0].startRow + 1, Number(height));
      }
    }
  };

  // ../../packages/base-sheets/src/Controller/SheetBarController.ts
  var SheetBarControl = class {
    _plugin;
    _getCoreObserver(type) {
      return this._plugin.getGlobalContext().getObserverManager().requiredObserver(type, "core");
    }
    constructor(plugin) {
      this._plugin = plugin;
    }
    listenEventManager() {
      this._getCoreObserver("onUIChangeObservable").add(({ name, value }) => {
        switch (name) {
          case "deleteSheet": {
            const workbook = this._plugin.getContext().getWorkBook();
            if (workbook) {
              workbook.removeSheetBySheetId(value);
            }
            break;
          }
          case "copySheet": {
            const workbook = this._plugin.getContext().getWorkBook();
            const activeSheet = workbook.getActiveSheet();
            const copySheet = activeSheet.copy(NameGen.getSheetName());
            if (workbook) {
              workbook.insertSheet(workbook.getActiveSheetIndex() + 1, copySheet.getConfig());
            }
            break;
          }
          case "renameSheet": {
            const { sheetId, sheetName } = value;
            const workbook = this._plugin.getContext().getUniver().getCurrentUniverSheetInstance().getWorkBook();
            const worksheet = workbook.getSheetBySheetId(sheetId);
            if (worksheet && sheetName !== worksheet.getName()) {
              worksheet.setName(sheetName);
            }
            break;
          }
          case "addSheet": {
            const workbook = this._plugin.getContext().getWorkBook();
            workbook.insertSheet();
            const size = workbook.getSheetSize();
            const sheets = workbook.getSheets();
            const lastSheet = sheets[size - 1];
            if (lastSheet) {
              lastSheet.activate();
            }
            break;
          }
          case "unHideSheet": {
            const workbook = this._plugin.getContext().getWorkBook();
            const worksheet = workbook.getSheetBySheetId(value);
            if (worksheet) {
              worksheet.showSheet();
            }
            break;
          }
          case "hideSheet": {
            const workbook = this._plugin.getContext().getWorkBook();
            const worksheet = workbook.getSheetBySheetId(value);
            if (worksheet) {
              worksheet.hideSheet();
            }
            break;
          }
          case "changeSheetColor": {
            const { color, sheetId } = value;
            const workbook = this._plugin.getContext().getWorkBook();
            const worksheet = workbook.getSheetBySheetId(sheetId);
            if (worksheet) {
              worksheet.setTabColor(color);
            }
            break;
          }
        }
      });
    }
  };

  // ../../packages/base-sheets/src/Controller/SheetContainerController.ts
  var SheetContainerController = class {
    _plugin;
    constructor(plugin) {
      this._plugin = plugin;
      this._initialize();
    }
    _initialize() {
      CommandManager.getCommandObservers().add(({ actions }) => {
        const plugin = this._plugin;
        if (!plugin)
          return;
        if (!actions || actions.length === 0)
          return;
        const action = actions[0];
        const currentUnitId = plugin.context.getWorkBook().getUnitId();
        const actionUnitId = action.getWorkBook().getUnitId();
        if (currentUnitId !== actionUnitId)
          return;
        const worksheet = action.getWorkBook().getActiveSheet();
        if (worksheet) {
          try {
            const canvasView = plugin.getCanvasView();
            if (canvasView) {
              canvasView.updateToSheet(worksheet);
              plugin.getMainComponent().makeDirty(true);
              plugin.getSelectionManager().renderCurrentControls(false);
            }
          } catch (error2) {
            console.info(error2);
          }
        }
      });
    }
  };

  // ../../packages/base-sheets/src/Controller/ToolbarController.ts
  var ToolbarController = class {
    _plugin;
    constructor(plugin) {
      this._plugin = plugin;
      this._initialize();
    }
    listenEventManager() {
      this._plugin.getContext().getUniver().getGlobalContext().getObserverManager().requiredObserver("onUIChangeObservable", "core").add((msg) => {
        switch (msg.name) {
          case "undo":
            this.setUndo();
            break;
          case "redo":
            this.setRedo();
            break;
        }
      });
      this._plugin.getContext().getUniver().getGlobalContext().getObserverManager().requiredObserver("onUIChangeObservable", "core").add((msg) => {
        switch (msg.name) {
          case "fontSize":
            this.setFontSize(msg.value);
            break;
          case "textRotation":
            this.setTextRotation(msg.value);
            break;
          case "wrapStrategy":
            this.setWrapStrategy(msg.value);
            break;
          case "verticalAlignment":
            this.setVerticalAlignment(msg.value);
            break;
          case "horizontalAlignment":
            this.setHorizontalAlignment(msg.value);
            break;
        }
      });
      this._plugin.getContext().getUniver().getGlobalContext().getObserverManager().requiredObserver("onUIChangeObservable", "core").add((msg) => {
        switch (msg.name) {
          case "borderInfo":
            this.setBorder(msg.value);
            break;
        }
      });
      this._plugin.getContext().getUniver().getGlobalContext().getObserverManager().requiredObserver("onUIChangeObservable", "core").add((msg) => {
        switch (msg.name) {
          case "fontFamily":
            this.setFontFamily(msg.value);
            break;
          case "fontColor":
            this.setFontColor(msg.value);
            break;
          case "background":
            this.setBackground(msg.value);
            break;
          case "merge":
            this.setMerge(msg.value);
            break;
        }
      });
      this._plugin.getContext().getUniver().getGlobalContext().getObserverManager().requiredObserver("onUIChangeObservable", "core").add((msg) => {
        switch (msg.name) {
          case "fontWeight":
            this.setFontWeight(msg.value);
            break;
          case "fontStyle":
            this.setFontStyle(msg.value);
            break;
          case "strikeThrough":
            this.setStrikeThrough(msg.value);
            break;
          case "underLine":
            this.setUnderline(msg.value);
            break;
        }
      });
    }
    _initialize() {
    }
    setRedo() {
      this._plugin.getContext().getCommandManager().redo();
    }
    setUndo() {
      this._plugin.getContext().getCommandManager().undo();
    }
    setFontColor(value) {
      this._plugin.getSelectionManager().getActiveRangeList()?.setFontColor(value);
    }
    setBackground(value) {
      this._plugin.getSelectionManager().getActiveRangeList()?.setBackground(value);
    }
    setFontSize(value) {
      this._plugin.getSelectionManager().getActiveRangeList()?.setFontSize(value);
    }
    setFontFamily(value) {
      this._plugin.getSelectionManager().getActiveRangeList()?.setFontFamily(value);
    }
    setFontWeight(value) {
      this._plugin.getSelectionManager().getActiveRangeList()?.setFontWeight(value);
    }
    setFontStyle(value) {
      this._plugin.getSelectionManager().getActiveRangeList()?.setFontStyle(value);
    }
    setStrikeThrough(value) {
      this._plugin.getSelectionManager().getActiveRangeList()?.setStrikeThrough(value);
    }
    setUnderline(value) {
      this._plugin.getSelectionManager().getActiveRangeList()?.setUnderline(value);
    }
    setMerge(value) {
      const currentRange = this._plugin.getSelectionManager().getActiveRange();
      switch (value) {
        case "all":
          currentRange?.merge();
          break;
        case "vertical":
          currentRange?.mergeVertically();
          break;
        case "horizontal":
          currentRange?.mergeAcross();
          break;
        case "cancel":
          currentRange?.breakApart();
          break;
        default:
          break;
      }
    }
    setHorizontalAlignment(value) {
      this._plugin.getSelectionManager().getActiveRangeList()?.setHorizontalAlignment(value);
    }
    setVerticalAlignment(value) {
      this._plugin.getSelectionManager().getActiveRangeList()?.setVerticalAlignment(value);
    }
    setWrapStrategy(value) {
      this._plugin.getSelectionManager().getActiveRangeList()?.setWrapStrategy(value);
    }
    setTextRotation(value) {
      if (value === "v") {
        this._plugin.getSelectionManager().getActiveRangeList()?.setVerticalText(1);
      } else {
        this._plugin.getSelectionManager().getActiveRangeList()?.setTextRotation(value);
      }
    }
    setBorder(info) {
      const controls = this._plugin.getSelectionManager().getCurrentControls();
      if (controls && controls.length > 0) {
        controls?.forEach((control) => {
          const model = control.model;
          const range2 = {
            startRow: model.startRow,
            startColumn: model.startColumn,
            endRow: model.endRow,
            endColumn: model.endColumn
          };
          this._plugin.getContext().getWorkBook().getActiveSheet().getRange(range2).setBorderByType(info.type, info.color, info.style);
        });
      }
    }
  };

  // ../../packages/base-sheets/src/Controller/FormulaBarController.ts
  var FormulaBarController = class {
    _plugin;
    constructor(plugin) {
      this._plugin = plugin;
    }
    // private _initialize() {
    //     this._plugin.getObserver('onChangeSelectionObserver')?.add((selectionControl: SelectionControl) => {
    //         const currentCell = selectionControl.model.currentCell;
    //         if (currentCell) {
    //             let currentRangeData;
    //             if (currentCell.isMerged) {
    //                 const mergeInfo = currentCell.mergeInfo;
    //                 currentRangeData = {
    //                     startRow: mergeInfo.startRow,
    //                     endRow: mergeInfo.endRow,
    //                     startColumn: mergeInfo.startColumn,
    //                     endColumn: mergeInfo.endColumn,
    //                 };
    //             } else {
    //                 const { row, column } = currentCell;
    //                 currentRangeData = {
    //                     startRow: row,
    //                     endRow: row,
    //                     startColumn: column,
    //                     endColumn: column,
    //                 };
    //             }
    //             const cellData = this._plugin.getWorkbook().getActiveSheet().getRange(currentRangeData).getObjectValue({ isIncludeStyle: true });
    //             if (cellData) {
    //                 let cellValue = String(cellData.m || cellData.v || '');
    //                 // If the cell has a formula, it needs to be intercepted
    //                 const cell = this._cellInputExtensionManager.handle({
    //                     row: currentRangeData.startRow,
    //                     column: currentRangeData.startColumn,
    //                     value: cellValue,
    //                 });
    //                 if (cell) {
    //                     cellValue = cell.value;
    //                 }
    //                 this._formulaBar.setFormulaContent(cellValue);
    //             }
    //             // empty cell
    //             else {
    //                 this._formulaBar.setFormulaContent('');
    //             }
    //         }
    //     });
    // }
  };

  // ../../packages/base-sheets/src/Basics/Register/NamedRangeActionExtension.ts
  var NamedRangeActionExtension = class extends BaseActionExtension {
    execute() {
      const actionDataList = this.actionDataList;
      actionDataList.forEach((actionData) => {
        if (actionData.operation != null && !ActionOperation.hasExtension(actionData)) {
          return false;
        }
        if (actionData.actionName === "InsertRowAction" /* INSERT_ROW_ACTION */) {
          const { sheetId, rowCount, rowIndex } = actionData;
          const namedRanges = Tools.deepClone(this._plugin.getWorkbook().getConfig().namedRanges);
          for (let i4 = 0; i4 < namedRanges.length; i4++) {
            const namedRangeData = namedRanges[i4].range.rangeData;
            if (rowIndex > namedRangeData.endRow) {
              continue;
            } else if (rowIndex >= namedRangeData.startRow && rowIndex <= namedRangeData.endRow) {
              namedRangeData.endRow += rowCount;
            } else {
              namedRangeData.startRow += rowCount;
              namedRangeData.endRow += rowCount;
            }
            const actionData2 = {
              actionName: "SetNamedRangeAction" /* SET_NAMED_RANGE_ACTION */,
              namedRange: namedRanges[i4],
              sheetId
            };
            this.push(actionData2);
          }
        }
      });
    }
  };
  var NamedRangeActionExtensionFactory = class extends BaseActionExtensionFactory2 {
    get zIndex() {
      return 3;
    }
    create(actionDataList) {
      return new NamedRangeActionExtension(actionDataList, this._plugin);
    }
  };

  // ../../packages/base-sheets/src/SheetPlugin.ts
  var SheetPlugin = class extends Plugin {
    _config;
    _canvasEngine;
    _canvasView;
    _rightMenuControl;
    _toolbarControl;
    _infoBarControl;
    _formulaBarController;
    _sheetBarControl;
    _cellEditorController;
    _countBarController;
    _sheetContainerController;
    _namedRangeActionExtensionFactory;
    // private _component: BaseComponentPlugin;
    constructor(config) {
      super("spreadsheet" /* SPREADSHEET */);
      this._config = Object.assign(DEFAULT_SPREADSHEET_PLUGIN_DATA, config);
    }
    initialize(context) {
      this.context = context;
      install(this);
      this.initConfig();
      this.initController();
      this.initCanvasView();
      this.registerExtension();
    }
    getConfig() {
      return this._config;
    }
    initConfig() {
      const config = this._config;
      if (!config.selections) {
        const worksheetId = this.getContext().getWorkBook().getActiveSheet().getSheetId();
        config.selections = {
          [worksheetId]: [
            {
              selection: DEFAULT_SELECTION
            }
          ]
        };
      }
    }
    initController() {
      this._sheetContainerController = new SheetContainerController(this);
      this._cellEditorController = new CellEditorController(this);
      this._formulaBarController = new FormulaBarController(this);
      this._sheetBarControl = new SheetBarControl(this);
      this._toolbarControl = new ToolbarController(this);
      this._rightMenuControl = new RightMenuController(this);
      this._countBarController = new CountBarController(this);
    }
    initCanvasView() {
      const engine = this.getContext().getUniver().getGlobalContext().getPluginManager().getPluginByName("renderEngine" /* BASE_RENDER */)?.getEngine();
      this._canvasEngine = engine;
      if (this._canvasView == null) {
        this._canvasView = new CanvasView(engine, this);
      }
    }
    onMounted(ctx) {
      this.initialize(ctx);
    }
    onDestroy() {
      super.onDestroy();
      uninstall(this);
      const actionRegister = this.context.getCommandManager().getActionExtensionManager().getRegister();
      actionRegister.delete(this._namedRangeActionExtensionFactory);
    }
    registerExtension() {
      const actionRegister = this.context.getCommandManager().getActionExtensionManager().getRegister();
      this._namedRangeActionExtensionFactory = new NamedRangeActionExtensionFactory(this);
      actionRegister.add(this._namedRangeActionExtensionFactory);
    }
    listenEventManager() {
      this._countBarController.listenEventManager();
      this._sheetBarControl.listenEventManager();
      this._toolbarControl.listenEventManager();
      this._rightMenuControl.listenEventManager();
    }
    getCanvasEngine() {
      return this._canvasEngine;
    }
    getCanvasView() {
      return this._canvasView;
    }
    getMainScene() {
      return this._canvasEngine.getScene("mainScene" /* MAIN_SCENE */);
    }
    getSheetView() {
      return this.getCanvasView().getSheetView();
    }
    getSelectionManager() {
      return this.getSheetView()?.getSelectionManager();
    }
    getCurrentControls() {
      return this.getSelectionManager()?.getCurrentControls();
    }
    getSelectionShape() {
      return this._canvasEngine;
    }
    getMainComponent() {
      return this.getSheetView().getSpreadsheet();
    }
    getLeftTopComponent() {
      return this.getSheetView().getSpreadsheetLeftTopPlaceholder();
    }
    getRowComponent() {
      return this.getSheetView().getSpreadsheetRowTitle();
    }
    getColumnComponent() {
      return this.getSheetView().getSpreadsheetColumnTitle();
    }
    getSpreadsheetSkeleton() {
      return this.getSheetView().getSpreadsheetSkeleton();
    }
    getWorkbook() {
      return this.context.getWorkBook();
    }
    getRightMenuControl() {
      return this._rightMenuControl;
    }
    getToolbarControl() {
      return this._toolbarControl;
    }
    getInfoBarControl() {
      return this._infoBarControl;
    }
    getSheetBarControl() {
      return this._sheetBarControl;
    }
    getCellEditorController() {
      return this._cellEditorController;
    }
    getFormulaBarController() {
      return this._formulaBarController;
    }
    getSheetContainerControl() {
      return this._sheetContainerController;
    }
    getCountBarController() {
      return this._countBarController;
    }
  };

  // ../../packages/ui-plugin-sheets/src/Basics/Const/PLUGIN_NAME.ts
  var SHEET_UI_PLUGIN_NAME = "SheetUI";

  // ../../packages/ui-plugin-sheets/src/Basics/Const/DefaultUniverSheetConfig.ts
  var DefaultRightMenuConfig = {
    InsertRow: true,
    InsertColumn: true,
    AddRowTop: false,
    AddRowBottom: false,
    AddColumnLeft: false,
    AddColumnRight: false,
    DeleteRow: true,
    DeleteColumn: true,
    HideRow: false,
    ShowRow: false,
    RowHeight: false,
    HideColumn: false,
    ShowColumn: false,
    ColumnWidth: false,
    DeleteCell: true,
    ClearContent: true,
    Matrix: false
  };
  var DefaultToolbarConfig = {
    undo: true,
    redo: true,
    // Undo redo
    paintFormat: true,
    // Format brush
    currencyFormat: true,
    // currency format
    percentageFormat: true,
    // Percentage format
    numberDecrease: true,
    // 'Decrease the number of decimal places'
    numberIncrease: true,
    // 'Increase the number of decimal places
    moreFormats: true,
    // 'More Formats'
    font: true,
    // 'font'
    fontSize: true,
    // 'Font size'
    bold: true,
    // 'Bold (Ctrl+B)'
    italic: true,
    // 'Italic (Ctrl+I)'
    strikethrough: true,
    // 'Strikethrough (Alt+Shift+5)'
    underline: true,
    // 'Underline (Alt+Shift+6)'
    textColor: true,
    // 'Text color'
    fillColor: true,
    // 'Cell color'
    border: true,
    // 'border'
    horizontalAlignMode: true,
    // 'Horizontal alignment'
    verticalAlignMode: true,
    // 'Vertical alignment'
    textWrapMode: true,
    // 'Wrap mode'
    textRotateMode: true,
    // 'Text Rotation Mode'
    mergeCell: true
  };
  var DefaultSheetContainerConfig = {
    outerLeft: false,
    outerRight: false,
    header: true,
    footer: true,
    innerLeft: false,
    innerRight: false,
    frozenHeaderLT: false,
    frozenHeaderRT: false,
    frozenHeaderLM: false,
    frozenContent: false,
    infoBar: true,
    toolbar: true,
    formulaBar: true,
    rightMenu: true,
    countBar: true,
    sheetBar: true
  };
  var DefaultSheetUiConfig = {
    layout: {
      sheetContainerConfig: DefaultSheetContainerConfig,
      rightMenuConfig: DefaultRightMenuConfig,
      toolbarConfig: DefaultToolbarConfig
    }
  };

  // ../../packages/ui-plugin-sheets/src/Locale/zh.ts
  var zh_default2 = {
    spreadsheetLabel: "\u63D2\u4EF6",
    spreadsheetRightLabel: "\u66F4\u591A Sheets",
    spreadsheet: {
      one: "\u4E00",
      two: "\u4E8C",
      three: "\u4E09"
    },
    // toolbar.undo
    toolbar: {
      undo: "\u64A4\u9500",
      redo: "\u91CD\u505A",
      paintFormat: "\u683C\u5F0F\u5237",
      currencyFormat: "\u8D27\u5E01\u683C\u5F0F",
      percentageFormat: "\u767E\u5206\u6BD4\u683C\u5F0F",
      numberDecrease: "\u51CF\u5C11\u5C0F\u6570\u4F4D\u6570",
      numberIncrease: "\u589E\u52A0\u5C0F\u6570\u4F4D\u6570",
      moreFormats: "\u66F4\u591A\u683C\u5F0F",
      font: "\u5B57\u4F53",
      fontSize: "\u5B57\u53F7\u5927\u5C0F",
      bold: "\u7C97\u4F53 (Ctrl+B)",
      italic: "\u659C\u4F53 (Ctrl+I)",
      strikethrough: "\u5220\u9664\u7EBF (Alt+Shift+5)",
      underline: "\u4E0B\u5212\u7EBF",
      textColor: {
        main: "\u6587\u672C\u989C\u8272",
        right: "\u989C\u8272\u9009\u62E9"
      },
      resetColor: "\u91CD\u7F6E\u989C\u8272",
      customColor: "\u81EA\u5B9A\u4E49",
      alternatingColors: "\u4EA4\u66FF\u989C\u8272",
      confirmColor: "\u786E\u5B9A\u989C\u8272",
      cancelColor: "\u53D6\u6D88",
      collapse: "\u6536\u8D77",
      fillColor: {
        main: "\u5355\u5143\u683C\u989C\u8272",
        right: "\u989C\u8272\u9009\u62E9"
      },
      border: {
        main: "\u8FB9\u6846",
        right: "\u8FB9\u6846\u7C7B\u578B"
      },
      mergeCell: {
        main: "\u5408\u5E76\u5355\u5143\u683C",
        right: "\u9009\u62E9\u5408\u5E76\u7C7B\u578B"
      },
      horizontalAlignMode: {
        main: "\u6C34\u5E73\u5BF9\u9F50",
        right: "\u5BF9\u9F50\u65B9\u5F0F"
      },
      verticalAlignMode: {
        main: "\u5782\u76F4\u5BF9\u9F50",
        right: "\u5BF9\u9F50\u65B9\u5F0F"
      },
      textWrapMode: {
        main: "\u6587\u672C\u6362\u884C",
        right: "\u6362\u884C\u65B9\u5F0F"
      },
      textRotateMode: {
        main: "\u6587\u672C\u65CB\u8F6C",
        right: "\u65CB\u8F6C\u65B9\u5F0F"
      },
      freezeTopRow: "\u51BB\u7ED3\u9996\u884C",
      sortAndFilter: "\u6392\u5E8F\u548C\u7B5B\u9009",
      findAndReplace: "\u67E5\u627E\u66FF\u6362",
      sum: "\u6C42\u548C",
      autoSum: "\u81EA\u52A8\u6C42\u548C",
      moreFunction: "\u66F4\u591A\u51FD\u6570",
      conditionalalFormat: "\u6761\u4EF6\u683C\u5F0F",
      comment: "\u6279\u6CE8",
      pivotTable: "\u6570\u636E\u900F\u89C6\u8868",
      chart: "\u56FE\u8868",
      screenshot: "\u622A\u56FE",
      splitColumn: "\u5206\u5217",
      insertImage: "\u63D2\u5165\u56FE\u7247",
      insertLink: "\u63D2\u5165\u94FE\u63A5",
      dataValidation: "\u6570\u636E\u9A8C\u8BC1",
      protection: "\u4FDD\u62A4\u5DE5\u4F5C\u8868\u5185\u5BB9",
      clearText: "\u6E05\u9664\u989C\u8272\u9009\u62E9",
      noColorSelectedText: "\u6CA1\u6709\u989C\u8272\u88AB\u9009\u62E9",
      toolMore: "\u66F4\u591A",
      toolLess: "\u5C11\u4E8E",
      toolClose: "\u6536\u8D77",
      toolMoreTip: "\u66F4\u591A\u529F\u80FD",
      moreOptions: "\u66F4\u591A\u9009\u9879",
      cellFormat: "\u8BBE\u7F6E\u5355\u5143\u683C\u683C\u5F0F",
      print: "\u6253\u5370",
      borderMethod: {
        top: "\u4E0A\u6846\u7EBF",
        bottom: "\u4E0B\u6846\u7EBF",
        left: "\u5DE6\u6846\u7EBF",
        right: "\u53F3\u6846\u7EBF"
      },
      more: "\u66F4\u591A"
    },
    defaultFmt: {
      Automatic: {
        text: "\u81EA\u52A8",
        value: "General",
        example: ""
      },
      Number: {
        text: "\u6570\u5B57",
        value: "##0.00",
        example: "1000.12"
      },
      Percent: {
        text: "\u767E\u5206\u6BD4",
        value: "#0.00%",
        example: "12.21%"
      },
      PlainText: {
        text: "\u7EAF\u6587\u672C",
        value: "@",
        example: ""
      },
      Scientific: {
        text: "\u79D1\u5B66\u8BA1\u6570",
        value: "0.00E+00",
        example: "1.01E+5"
      },
      Accounting: {
        text: "\u4F1A\u8BA1",
        value: "\xA5(0.00)",
        example: "\xA5(1200.09)"
      },
      Thousand: {
        text: "\u4E07\u5143",
        value: "w",
        example: "1\u4EBF2000\u4E072500"
      },
      Currency: {
        text: "\u8D27\u5E01",
        value: "\xA50.00",
        example: "\xA51200.09"
      },
      Digit: {
        text: "\u4E07\u51432\u4F4D\u5C0F\u6570",
        value: "w0.00",
        example: "2\u4E072500.55"
      },
      Date: {
        text: "\u65E5\u671F",
        value: "yyyy-MM-dd",
        example: "2017-11-29"
      },
      Time: { text: "\u65F6\u95F4", value: "hh:mm AM/PM", example: "3:00 PM" },
      Time24H: { text: "\u65F6\u95F424H", value: "hh:mm", example: "15:00" },
      DateTime: { text: "\u65E5\u671F\u65F6\u95F4", value: "yyyy-MM-dd hh:mm AM/PM", example: "2017-11-29 3:00 PM" },
      DateTime24H: { text: "\u65E5\u671F\u65F6\u95F424H", value: "yyyy-MM-dd hh:mm", example: "2017-11-29 15:00" },
      CustomFormats: { text: "\u81EA\u5B9A\u4E49\u683C\u5F0F", value: "fmtOtherSelf", example: "" }
    },
    format: {
      moreCurrency: "\u66F4\u591A\u8D27\u5E01\u683C\u5F0F",
      moreDateTime: "\u66F4\u591A\u65E5\u671F\u4E0E\u65F6\u95F4\u683C\u5F0F",
      moreNumber: "\u66F4\u591A\u6570\u5B57\u683C\u5F0F",
      titleCurrency: "\u8D27\u5E01\u683C\u5F0F",
      decimalPlaces: "\u5C0F\u6570\u4F4D\u6570",
      titleDateTime: "\u65E5\u671F\u4E0E\u65F6\u95F4\u683C\u5F0F",
      titleNumber: "\u6570\u5B57\u683C\u5F0F"
    },
    fontFamily: {
      TimesNewRoman: "Times New Roman",
      Arial: "Arial",
      Tahoma: "Tahoma",
      Verdana: "Verdana",
      MicrosoftAccorblack: "\u5FAE\u8F6F\u96C5\u9ED1",
      SimSun: "\u5B8B\u4F53",
      SimHei: "\u9ED1\u4F53",
      Kaiti: "\u6977\u4F53",
      FangSong: "\u4EFF\u5B8B",
      NSimSun: "\u65B0\u5B8B\u4F53",
      STXinwei: "\u534E\u6587\u65B0\u9B4F",
      STXingkai: "\u534E\u6587\u884C\u6977",
      STLiti: "\u534E\u6587\u96B6\u4E66",
      HanaleiFill: "HanaleiFill",
      Anton: "Anton",
      Pacifico: "Pacifico"
    },
    print: {
      normalBtn: "\u5E38\u89C4\u89C6\u56FE",
      layoutBtn: "\u9875\u9762\u5E03\u5C40",
      pageBtn: "\u5206\u9875\u9884\u89C8",
      menuItemPrint: "\u6253\u5370(Ctrl+P)",
      menuItemAreas: "\u6253\u5370\u533A\u57DF",
      menuItemRows: "\u6253\u5370\u6807\u9898\u884C",
      menuItemColumns: "\u6253\u5370\u6807\u9898\u5217"
    },
    align: {
      left: "\u5DE6\u5BF9\u9F50",
      center: "\u4E2D\u95F4\u5BF9\u9F50",
      right: "\u53F3\u5BF9\u9F50",
      top: "\u9876\u90E8\u5BF9\u9F50",
      middle: "\u5C45\u4E2D\u5BF9\u9F50",
      bottom: "\u5E95\u90E8\u5BF9\u9F50"
    },
    button: {
      confirm: "\u786E\u5B9A",
      cancel: "\u53D6\u6D88",
      close: "\u5173\u95ED",
      update: "Update",
      delete: "Delete",
      insert: "\u65B0\u5EFA",
      prevPage: "\u4E0A\u4E00\u9875",
      nextPage: "\u4E0B\u4E00\u9875",
      total: "\u603B\u5171\uFF1A"
    },
    punctuation: {
      tab: "Tab \u952E",
      semicolon: "\u5206\u53F7",
      comma: "\u9017\u53F7",
      space: "\u7A7A\u683C"
    },
    colorPicker: {
      collapse: "\u6536\u8D77",
      customColor: "\u81EA\u5B9A\u4E49",
      change: "\u5207\u6362",
      confirmColor: "\u786E\u5B9A",
      cancelColor: "\u53D6\u6D88"
    },
    borderLine: {
      borderTop: "\u4E0A\u6846\u7EBF",
      borderBottom: "\u4E0B\u6846\u7EBF",
      borderLeft: "\u5DE6\u6846\u7EBF",
      borderRight: "\u53F3\u6846\u7EBF",
      borderNone: "\u65E0",
      borderAll: "\u6240\u6709",
      borderOutside: "\u5916\u4FA7",
      borderInside: "\u5185\u4FA7",
      borderHorizontal: "\u5185\u4FA7\u6A2A\u7EBF",
      borderVertical: "\u5185\u4FA7\u7AD6\u7EBF",
      borderColor: "\u8FB9\u6846\u989C\u8272",
      borderSize: "\u8FB9\u6846\u7C97\u7EC6"
    },
    merge: {
      all: "\u5168\u90E8\u5408\u5E76",
      vertical: "\u5782\u76F4\u5408\u5E76",
      horizontal: "\u6C34\u5E73\u5408\u5E76",
      cancel: "\u53D6\u6D88\u5408\u5E76",
      overlappingError: "\u4E0D\u80FD\u5408\u5E76\u91CD\u53E0\u533A\u57DF",
      partiallyError: "\u65E0\u6CD5\u5BF9\u90E8\u5206\u5408\u5E76\u5355\u5143\u683C\u6267\u884C\u6B64\u64CD\u4F5C"
    },
    textWrap: {
      overflow: "\u6EA2\u51FA",
      wrap: "\u81EA\u52A8\u6362\u884C",
      clip: "\u622A\u65AD"
    },
    textRotate: {
      none: "\u65E0\u65CB\u8F6C",
      angleUp: "\u5411\u4E0A\u503E\u659C",
      angleDown: "\u5411\u4E0B\u503E\u659C",
      vertical: "\u7AD6\u6392\u6587\u5B57",
      rotationUp: "\u5411\u4E0A90\xB0",
      rotationDown: "\u5411\u4E0B90\xB0"
    },
    sheetConfig: {
      delete: "\u5220\u9664",
      copy: "\u590D\u5236",
      rename: "\u91CD\u547D\u540D",
      changeColor: "\u66F4\u6539\u989C\u8272",
      hide: "\u9690\u85CF",
      unhide: "\u53D6\u6D88\u9690\u85CF",
      moveLeft: "\u5411\u5DE6\u79FB",
      moveRight: "\u5411\u53F3\u79FB",
      resetColor: "\u91CD\u7F6E\u989C\u8272",
      cancelText: "\u53D6\u6D88",
      chooseText: "\u786E\u5B9A\u989C\u8272",
      tipNameRepeat: "\u6807\u7B7E\u9875\u7684\u540D\u79F0\u4E0D\u80FD\u91CD\u590D\uFF01\u8BF7\u91CD\u65B0\u4FEE\u6539",
      noMoreSheet: "\u5DE5\u4F5C\u8584\u5185\u81F3\u5C11\u542B\u6709\u4E00\u5F20\u53EF\u89C6\u5DE5\u4F5C\u8868\u3002\u82E5\u9700\u5220\u9664\u9009\u5B9A\u7684\u5DE5\u4F5C\u8868\uFF0C\u8BF7\u5148\u63D2\u5165\u4E00\u5F20\u65B0\u5DE5\u4F5C\u8868\u6216\u663E\u793A\u4E00\u5F20\u9690\u85CF\u7684\u5DE5\u4F5C\u8868\u3002",
      confirmDelete: "\u662F\u5426\u5220\u9664",
      redoDelete: "\u53EF\u4EE5\u901A\u8FC7Ctrl+Z\u64A4\u9500\u5220\u9664",
      noHide: "\u4E0D\u80FD\u9690\u85CF, \u81F3\u5C11\u4FDD\u7559\u4E00\u4E2Asheet\u6807\u7B7E",
      chartEditNoOpt: "\u56FE\u8868\u7F16\u8F91\u6A21\u5F0F\u4E0B\u4E0D\u5141\u8BB8\u8BE5\u64CD\u4F5C\uFF01",
      sheetNameSpecCharError: "\u540D\u79F0\u4E0D\u80FD\u8D85\u8FC731\u4E2A\u5B57\u7B26\uFF0C\u9996\u5C3E\u4E0D\u80FD\u662F' \u4E14\u540D\u79F0\u4E0D\u80FD\u5305\u542B:\r\n[ ] : \\ ? * /",
      sheetNameCannotIsEmptyError: "\u540D\u79F0\u4E0D\u80FD\u4E3A\u7A7A!"
    },
    rightClick: {
      copy: "\u590D\u5236",
      copyAs: "\u590D\u5236\u4E3A",
      cut: "\u526A\u5207",
      paste: "\u7C98\u8D34",
      insert: "\u63D2\u5165",
      delete: "\u5220\u9664",
      insertRow: "\u63D2\u5165\u884C",
      insertColumn: "\u63D2\u5165\u5217",
      deleteCell: "\u5220\u9664\u5355\u5143\u683C",
      deleteSelected: "\u5220\u9664\u9009\u4E2D",
      hide: "\u9690\u85CF",
      hideSelected: "\u9690\u85CF\u9009\u4E2D",
      showHide: "\u663E\u793A\u9690\u85CF",
      toTopAdd: "\u5411\u4E0A\u589E\u52A0",
      toBottomAdd: "\u5411\u4E0B\u589E\u52A0",
      toLeftAdd: "\u5411\u5DE6\u589E\u52A0",
      toRightAdd: "\u5411\u53F3\u589E\u52A0",
      deleteSelectedRow: "\u5220\u9664\u9009\u4E2D\u884C",
      deleteSelectedColumn: "\u5220\u9664\u9009\u4E2D\u5217",
      hideSelectedRow: "\u9690\u85CF\u9009\u4E2D\u884C",
      showHideRow: "\u663E\u793A\u9690\u85CF\u884C",
      rowHeight: "\u884C\u9AD8",
      hideSelectedColumn: "\u9690\u85CF\u9009\u4E2D\u5217",
      showHideColumn: "\u663E\u793A\u9690\u85CF\u5217",
      columnWidth: "\u5217\u5BBD",
      to: "\u5411",
      left: "\u5DE6",
      right: "\u53F3",
      top: "\u4E0A",
      bottom: "\u4E0B",
      moveLeft: "\u5DE6\u79FB",
      moveUp: "\u4E0A\u79FB",
      add: "\u589E\u52A0",
      row: "\u884C",
      column: "\u5217",
      width: "\u5BBD",
      height: "\u9AD8",
      number: "\u6570\u5B57",
      confirm: "\u786E\u8BA4",
      orderAZ: "A-Z\u987A\u5E8F\u6392\u5217",
      orderZA: "Z-A\u964D\u5E8F\u6392\u5217",
      clearContent: "\u6E05\u9664\u5185\u5BB9",
      matrix: "\u77E9\u9635\u64CD\u4F5C\u9009\u533A",
      sortSelection: "\u6392\u5E8F\u9009\u533A",
      filterSelection: "\u7B5B\u9009\u9009\u533A",
      chartGeneration: "\u56FE\u8868\u751F\u6210",
      firstLineTitle: "\u9996\u884C\u4E3A\u6807\u9898",
      untitled: "\u65E0\u6807\u9898",
      array1: "\u4E00\u7EF4\u6570\u7EC4",
      array2: "\u4E8C\u7EF4\u6570\u7EC4",
      array3: "\u591A\u7EF4\u6570\u7EC4",
      diagonal: "\u5BF9\u89D2\u7EBF",
      antiDiagonal: "\u53CD\u5BF9\u89D2\u7EBF",
      diagonalOffset: "\u5BF9\u89D2\u504F\u79FB",
      offset: "\u504F\u79FB\u91CF",
      boolean: "\u5E03\u5C14\u503C",
      flip: "\u7FFB\u8F6C",
      upAndDown: "\u4E0A\u4E0B",
      leftAndRight: "\u5DE6\u53F3",
      clockwise: "\u987A\u65F6\u9488",
      counterclockwise: "\u9006\u65F6\u9488",
      transpose: "\u8F6C\u7F6E",
      matrixCalculation: "\u77E9\u9635\u8BA1\u7B97",
      plus: "\u52A0",
      minus: "\u51CF",
      multiply: "\u4E58",
      divided: "\u9664",
      power: "\u6B21\u65B9",
      root: "\u6B21\u65B9\u6839",
      log: "log",
      delete0: "\u5220\u9664\u4E24\u7AEF0\u503C",
      removeDuplicate: "\u5220\u9664\u91CD\u590D\u503C",
      byRow: "\u6309\u884C",
      byCol: "\u6309\u5217",
      generateNewMatrix: "\u751F\u6210\u65B0\u77E9\u9635"
    },
    info: {
      detailUpdate: "\u65B0\u6253\u5F00",
      detailSave: "\u5DF2\u6062\u590D\u672C\u5730\u7F13\u5B58",
      row: "\u884C",
      column: "\u5217",
      loading: "\u6E32\u67D3\u4E2D\xB7\xB7\xB7",
      copy: "\u526F\u672C",
      return: "\u8FD4\u56DE",
      rename: "\u91CD\u547D\u540D",
      tips: "\u91CD\u547D\u540D",
      noName: "\u65E0\u6807\u9898\u7684\u7535\u5B50\u8868\u683C",
      wait: "\u5F85\u66F4\u65B0",
      add: "\u6DFB\u52A0",
      addLast: "\u5728\u5E95\u90E8\u6DFB\u52A0",
      backTop: "\u56DE\u5230\u9876\u90E8",
      // eslint-disable-next-line no-template-curly-in-string
      pageInfo: "\u5171${total}\u6761\uFF0C${totalPage}\u9875\uFF0C\u5F53\u524D\u5DF2\u663E\u793A${currentPage}\u9875",
      nextPage: "\u4E0B\u4E00\u9875",
      tipInputNumber: "\u8BF7\u8F93\u5165\u6570\u5B57",
      tipInputNumberLimit: "\u589E\u52A0\u8303\u56F4\u9650\u5236\u57281-100",
      tipRowHeightLimit: "\u884C\u9AD8\u5FC5\u987B\u57280 ~ 545\u4E4B\u95F4",
      tipColumnWidthLimit: "\u5217\u5BBD\u5FC5\u987B\u57280 ~ 2038\u4E4B\u95F4",
      // eslint-disable-next-line no-template-curly-in-string
      pageInfoFull: "\u5171${total}\u6761\uFF0C${totalPage}\u9875\uFF0C\u5DF2\u663E\u793A\u5168\u90E8\u6570\u636E"
    }
  };

  // ../../packages/ui-plugin-sheets/src/Locale/en.ts
  var en_default2 = {
    spreadsheetLabel: "Spreadsheet",
    spreadsheetRightLabel: "more Sheets",
    spreadsheet: {
      one: "one",
      two: "two",
      three: "three"
    },
    toolbar: {
      undo: "Undo",
      redo: "Redo",
      paintFormat: "Paint format",
      currencyFormat: "Format as currency",
      percentageFormat: "Format as percent",
      numberDecrease: "Decrease decimal places",
      numberIncrease: "Increase decimal places",
      moreFormats: "More formats",
      font: "Font",
      fontSize: "Font size",
      bold: "Bold (Ctrl+B)",
      italic: "Italic (Ctrl+I)",
      strikethrough: "Strikethrough (Alt+Shift+5)",
      underline: "Underline",
      textColor: {
        main: "Text color",
        right: "Choose color"
      },
      resetColor: "Reset",
      customColor: "CUSTOM",
      alternatingColors: "Alternating colors",
      confirmColor: "OK",
      cancelColor: "Cancel",
      collapse: "Collapse",
      fillColor: {
        main: "Fill color",
        right: "Choose color"
      },
      border: {
        main: "Border",
        right: "Border style"
      },
      mergeCell: {
        main: "Merge cells",
        right: "Choose merge type"
      },
      horizontalAlignMode: {
        main: "Horizontal align",
        right: "Alignment"
      },
      verticalAlignMode: {
        main: "Vertical align",
        right: "Alignment"
      },
      textWrapMode: {
        main: "Text wrap",
        right: "Text wrap mode"
      },
      textRotateMode: {
        main: "Text rotate",
        right: "Text rotate mode"
      },
      freezeTopRow: "Freeze top row",
      sortAndFilter: "Sort and filter",
      findAndReplace: "Find and replace",
      sum: "SUM",
      autoSum: "Auto SUM",
      moreFunction: "More functions",
      conditionalFormat: "Conditional format",
      comment: "Comment",
      pivotTable: "Pivot Table",
      chart: "Chart",
      screenshot: "Screenshot",
      splitColumn: "Split text",
      insertImage: "Insert image",
      insertLink: "Insert link",
      dataValidation: "Data validation",
      protection: "Protect the sheet",
      clearText: "Clear color",
      noColorSelectedText: "No color is selected",
      toolMore: "More",
      toolLess: "Less",
      toolClose: "Close",
      toolMoreTip: "More features",
      moreOptions: "More options",
      cellFormat: "Cell format config",
      print: "Print",
      borderMethod: {
        top: "Upper frame line",
        bottom: "Lower frame line",
        left: "Left frame line",
        right: "Right frame line"
      },
      more: "More"
    },
    defaultFmt: {
      Automatic: {
        text: "Automatic",
        value: "General",
        example: ""
      },
      Number: {
        text: "Number",
        value: "##0.00",
        example: "1000.12"
      },
      Percent: {
        text: "Percent",
        value: "#0.00%",
        example: "12.21%"
      },
      PlainText: {
        text: "Plain text",
        value: "@",
        example: ""
      },
      Scientific: {
        text: "Scientific",
        value: "0.00E+00",
        example: "1.01E+5"
      },
      Accounting: {
        text: "Accounting",
        value: "\xA5(0.00)",
        example: "\xA5(1200.09)"
      },
      Thousand: {
        text: "Ten Thousand",
        value: "w",
        example: "1\u4EBF2000\u4E072500"
      },
      Currency: {
        text: "Currency",
        value: "\xA50.00",
        example: "\xA51200.09"
      },
      Digit: {
        text: "\u4E07\u51432\u4F4D\u5C0F\u6570",
        value: "w0.00",
        example: "2\u4E072500.55"
      },
      Date: {
        text: "Date",
        value: "yyyy-MM-dd",
        example: "2017-11-29"
      },
      Time: { text: "Time", value: "hh:mm AM/PM", example: "3:00 PM" },
      Time24H: { text: "Time 24H", value: "hh:mm", example: "15:00" },
      DateTime: { text: "Date time", value: "yyyy-MM-dd hh:mm AM/PM", example: "2017-11-29 3:00 PM" },
      DateTime24H: { text: "Date time 24H", value: "yyyy-MM-dd hh:mm", example: "2017-11-29 15:00" },
      CustomFormats: { text: "Custom Formats", value: "fmtOtherSelf", example: "" }
    },
    format: {
      moreCurrency: "More currency formats",
      moreDateTime: "More date and time formats",
      moreNumber: "More number formats",
      titleCurrency: "Currency formats",
      decimalPlaces: "Decimal places",
      titleDateTime: "Date and time formats",
      titleNumber: "Number formats"
    },
    fontFamily: {
      TimesNewRoman: "Times New Roman",
      Arial: "Arial",
      Tahoma: "Tahoma",
      Verdana: "Verdana",
      MicrosoftAccorblack: "Microsoft Accor black ",
      SimSun: "SimSun",
      SimHei: "SimHei",
      Kaiti: "Kaiti",
      FangSong: "FangSong",
      NSimSun: "NSimSun",
      STXinwei: "STXinwei",
      STXingkai: "STXingkai",
      STLiti: "STLiti",
      HanaleiFill: "HanaleiFill",
      Anton: "Anton",
      Pacifico: "Pacifico"
    },
    print: {
      normalBtn: "Normal",
      layoutBtn: "Page Layout",
      pageBtn: "Page\u2002break\u2002preview",
      menuItemPrint: "Print (Ctrl+P)",
      menuItemAreas: "Print areas",
      menuItemRows: "Print title rows",
      menuItemColumns: "Print title columns"
    },
    align: {
      left: "left",
      center: "center",
      right: "right",
      top: "top",
      middle: "middle",
      bottom: "bottom"
    },
    dateFmtList: [
      {
        name: "1930-08-05",
        value: "yyyy-MM-dd"
      },
      {
        name: "1930/8/5",
        value: "yyyy/MM/dd"
      },
      {
        name: "08-05",
        value: "MM-dd"
      },
      {
        name: "8-5",
        value: "M-d"
      },
      {
        name: "13:30:30",
        value: "h:mm:ss"
      },
      {
        name: "13:30",
        value: "h:mm"
      },
      {
        name: "PM 01:30",
        value: "AM/PM hh:mm"
      },
      {
        name: "PM 1:30",
        value: "AM/PM h:mm"
      },
      {
        name: "PM 1:30:30",
        value: "AM/PM h:mm:ss"
      },
      {
        name: "08-05 PM 01:30",
        value: "MM-dd AM/PM hh:mm"
      }
    ],
    numFmtList: [
      {
        name: "1235",
        value: "0"
      },
      {
        name: "1234.56",
        value: "0.00"
      },
      {
        name: "1,235",
        value: "#,##0"
      },
      {
        name: "1,234.56",
        value: "#,##0.00"
      },
      {
        name: "1,235",
        value: "#,##0_);(#,##0)"
      },
      {
        name: "1,235",
        value: "#,##0_);[Red](#,##0)"
      },
      {
        name: "1,234.56",
        value: "#,##0.00_);(#,##0.00)"
      },
      {
        name: "1,234.56",
        value: "#,##0.00_);[Red](#,##0.00)"
      },
      {
        name: "$1,235",
        value: "$#,##0_);($#,##0)"
      },
      {
        name: "$1,235",
        value: "$#,##0_);[Red]($#,##0)"
      },
      {
        name: "$1,234.56",
        value: "$#,##0.00_);($#,##0.00)"
      },
      {
        name: "$1,234.56",
        value: "$#,##0.00_);[Red]($#,##0.00)"
      },
      {
        name: "1234.56",
        value: "@"
      },
      {
        name: "123456%",
        value: "0%"
      },
      {
        name: "123456.00%",
        value: "0.00%"
      },
      {
        name: "1.23E+03",
        value: "0.00E+00"
      },
      {
        name: "1.2E+3",
        value: "##0.0E+0"
      },
      {
        name: "1234 5/9",
        value: "# ?/?"
      },
      {
        name: "1234 14/25",
        value: "# ??/??"
      },
      {
        name: "$ 1,235",
        value: '_($* #,##0_);_(...($* "-"_);_(@_)'
      },
      {
        name: "1,235",
        value: '_(* #,##0_);_(*..._(* "-"_);_(@_)'
      },
      {
        name: "$ 1,234.56",
        // "value": '_($* #,##0.00_)...* "-"??_);_(@_)'
        value: '_($* #,##0.00_);_(...($* "-"_);_(@_)'
      },
      {
        name: "1,234.56",
        value: '_(* #,##0.00_);...* "-"??_);_(@_)'
      }
    ],
    button: {
      confirm: "OK",
      cancel: "Cancel",
      close: "Close",
      update: "Update",
      delete: "Delete",
      insert: "Insert",
      prevPage: "Previous",
      nextPage: "Next",
      total: "total:"
    },
    punctuation: {
      tab: "Tab",
      semicolon: "semicolond",
      comma: "comma",
      space: "space"
    },
    colorPicker: {
      collapse: "Collapse",
      customColor: "CUSTOM",
      change: "Change",
      confirmColor: "OK",
      cancelColor: "Cancel"
    },
    borderLine: {
      borderTop: "borderTop",
      borderBottom: "borderBottom",
      borderLeft: "borderLeft",
      borderRight: "borderRight",
      borderNone: "borderNone",
      borderAll: "borderAll",
      borderOutside: "borderOutside",
      borderInside: "borderInside",
      borderHorizontal: "borderHorizontal",
      borderVertical: "borderVertical",
      borderColor: "borderColor",
      borderSize: "borderSize"
    },
    merge: {
      all: "Merge all",
      vertical: "Vertical merge",
      horizontal: "Horizontal merger",
      cancel: "Cancel merge",
      overlappingError: "Cannot merge overlapping areas",
      partiallyError: "Cannot perform this operation on partially merged cells"
    },
    textWrap: {
      overflow: "Overflow",
      wrap: "Wrap",
      clip: "Clip"
    },
    textRotate: {
      none: "None",
      angleUp: "Tilt Up",
      angleDown: "Tilt Down",
      vertical: "Stack Vertically",
      rotationUp: "Rotate Up",
      rotationDown: "Rotate Down"
    },
    sheetConfig: {
      delete: "Delete",
      copy: "Copy",
      rename: "Rename",
      changeColor: "Change color",
      hide: "Hide",
      unhide: "Unhide",
      moveLeft: "Move left",
      moveRight: "Move right",
      resetColor: "Reset color",
      cancelText: "Cancel",
      chooseText: "Confirm color",
      tipNameRepeat: "The name of the tab page cannot be repeated! Please revise",
      noMoreSheet: "The workbook contains at least one visual worksheet. To delete the selected worksheet, please insert a new worksheet or show a hidden worksheet.",
      confirmDelete: "Are you sure to delete",
      redoDelete: "Can be undo by Ctrl+Z",
      noHide: "Can't hide, at least keep one sheet tag",
      chartEditNoOpt: "This operation is not allowed in chart editing mode!",
      sheetNameSpecCharError: `The name cannot contain:[ ] :  ? * / ' "`,
      sheetNameCannotIsEmptyError: "Sheet name cannot be empty"
    },
    rightClick: {
      copy: "Copy",
      copyAs: "Copy as",
      cut: "Cut",
      paste: "Paste",
      insert: "Insert",
      insertRow: "InsertRow",
      insertColumn: "InsertColumn",
      delete: "Delete",
      deleteCell: "Delete cell",
      deleteSelected: "Delete selected ",
      hide: "Hide",
      hideSelected: "Hide selected ",
      showHide: "Show hidden ",
      toTopAdd: "Towards Top Add",
      toBottomAdd: "Towards Bottom Add",
      toLeftAdd: "Towards Left Add",
      toRightAdd: "Towards Right Add",
      deleteSelectedRow: "Delete selected row",
      deleteSelectedColumn: "Delete selected column",
      hideSelectedRow: "Hide selected row",
      showHideRow: "Show selected row",
      rowHeight: "Row height",
      hideSelectedColumn: "Hide selected column",
      showHideColumn: "Show hide column",
      columnWidth: "Column width",
      to: "Towards",
      left: "Left",
      right: "Right",
      top: "Top",
      bottom: "Bottom",
      moveLeft: "Move left",
      moveUp: "Move up",
      add: "Add",
      row: "Row",
      column: "Column",
      width: "Width",
      height: "Height",
      number: "Number",
      confirm: "Confirm",
      orderAZ: "A-Z order",
      orderZA: "Z-A order",
      clearContent: "Clear content",
      matrix: "Matrix operation",
      sortSelection: "Sort",
      filterSelection: "Filter",
      chartGeneration: "Create chart",
      firstLineTitle: "first line title",
      untitled: "untitled",
      array1: "One-dimensional array",
      array2: "Two-dimensional array",
      array3: "Multidimensional Arrays",
      diagonal: "Diagonal",
      antiDiagonal: "Anti-diagonal",
      diagonalOffset: "Diagonal offset",
      offset: "Offset",
      boolean: "Boolean",
      flip: "Flip",
      upAndDown: "Up and down",
      leftAndRight: "Left and right",
      clockwise: "Clockwise",
      counterclockwise: "Counterclockwise",
      transpose: "Transpose",
      matrixCalculation: "Matrix calculation",
      plus: "Plus",
      minus: "Minus",
      multiply: "Multiply",
      divided: "Divided",
      power: "Power",
      root: "Root",
      log: "Log",
      delete0: "Delete 0 values at both ends",
      removeDuplicate: "Remove duplicate values",
      byRow: "By row",
      byCol: "By column",
      generateNewMatrix: "Generate new matrix"
    },
    info: {
      detailUpdate: "New opened",
      detailSave: "Local cache restored",
      row: "",
      column: "",
      loading: "Loading...",
      copy: "Copy",
      return: "Exit",
      rename: "Rename",
      tips: "Rename",
      noName: "Untitled spreadsheet",
      wait: "waiting for update",
      add: "Add",
      addLast: "more rows at bottom",
      backTop: "Back to the top",
      // eslint-disable-next-line no-template-curly-in-string
      pageInfo: "Total ${total}\uFF0C${totalPage} page\uFF0Ccurrent ${currentPage}",
      nextPage: "Next",
      tipInputNumber: "Please enter the number",
      tipInputNumberLimit: "The increase range is limited to 1-100",
      tipRowHeightLimit: "Row height must be between 0 ~ 545",
      tipColumnWidthLimit: "The column width must be between 0 ~ 2038",
      // eslint-disable-next-line no-template-curly-in-string
      pageInfoFull: "Total ${total}\uFF0C${totalPage} page\uFF0CAll data displayed"
    }
  };

  // ../../packages/ui-plugin-sheets/src/Basics/Observer.ts
  function installObserver(plugin) {
    plugin.pushToObserve("onRichTextKeyDownObservable");
    plugin.pushToObserve("onRichTextKeyUpObservable");
    plugin.pushToObserve("onUIDidMount");
  }

  // ../../packages/base-ui/src/Basics/Register/CellEditRegister/CellEditExtensionFactory.ts
  var BaseCellEditExtension = class {
    constructor(_cell, _value) {
      this._cell = _cell;
      this._value = _value;
    }
    getCell() {
      return this._cell;
    }
    /**
     * Modify the value
     */
    // setValue(value: string) { }
    /**
     * Execute the core logic after the check is successful
     */
    // execute() { }
  };
  var BaseCellEditExtensionFactory = class {
    // constructor(protected _plugin: T) { }
    get zIndex() {
      return 0;
    }
    /**
     * Generate Cell Extension
     * @param value
     * @returns
     */
    create(cell, value) {
      return new BaseCellEditExtension(cell, value);
    }
    /**
     * Check if this cell needs to be intercepted currently
     * @param row
     * @param column
     * @param value
     * @returns
     */
    check(cell) {
      return false;
    }
  };

  // ../../packages/base-ui/src/Basics/Register/CellEditRegister/RegistryFactory.ts
  var Registry3 = class {
    _data = [];
    static create() {
      return new Registry3();
    }
    add(dataInstance) {
      this._data.push(dataInstance);
    }
    delete(dataInstance) {
      const index = this._data.indexOf(dataInstance);
      this._data.splice(index, 1);
    }
    getData() {
      return this._data;
    }
  };
  var REGISTRY_CELL_EDIT_FACTORY = Registry3.create();

  // ../../packages/base-ui/src/Basics/Register/CellEditRegister/CellEditExtensionRegister.ts
  var CellEditExtensionRegister = class {
    _cellEditExtensionFactoryList = [];
    get cellEditExtensionFactoryList() {
      return this._cellEditExtensionFactoryList;
    }
    initialize() {
      this._initExtensions();
    }
    add(...extensionFactoryList) {
      this._cellEditExtensionFactoryList.push(...extensionFactoryList);
      this._cellEditExtensionFactoryList.sort(sortRules);
    }
    delete(extensionFactory) {
      const index = this._cellEditExtensionFactoryList.indexOf(extensionFactory);
      this._cellEditExtensionFactoryList.splice(index, 1);
    }
    _initExtensions() {
      this._cellEditExtensionFactoryList.push(...REGISTRY_CELL_EDIT_FACTORY.getData().sort(sortRules));
    }
  };

  // ../../packages/base-ui/src/Basics/Register/CellEditRegister/CellEditExtensionManager.ts
  var _CellEditExtensionManager = class {
    _cellEditExtensionFactoryList;
    static create() {
      if (!this.register) {
        this.register = new CellEditExtensionRegister();
        this.register.initialize();
      }
      return this.register;
    }
    /**
     * inject cell position
     * @param row
     * @param column
     * @param value
     */
    handle(cell) {
      const cellEditExtensionFactoryList = _CellEditExtensionManager?.register?.cellEditExtensionFactoryList;
      if (!cellEditExtensionFactoryList)
        return;
      this._cellEditExtensionFactoryList = cellEditExtensionFactoryList;
      const extension = this._checkExtension(cell);
      if (extension) {
        extension.execute();
        return extension.getCell();
      }
    }
    /**
     * Execute when the action is matched
     * @param command
     * @returns
     */
    _checkExtension(cell) {
      let extension = false;
      if (!this._cellEditExtensionFactoryList)
        return false;
      for (let index = 0; index < this._cellEditExtensionFactoryList.length; index++) {
        const extensionFactory = this._cellEditExtensionFactoryList[index];
        extension = extensionFactory.check(cell);
        if (extension !== false) {
          break;
        }
      }
      return extension;
    }
  };
  var CellEditExtensionManager = _CellEditExtensionManager;
  __publicField(CellEditExtensionManager, "register");

  // ../../packages/base-ui/src/Basics/Register/CellInputRegister/CellInputExtensionFactory.ts
  var BaseCellInputExtension = class {
    constructor(_cell, _value) {
      this._cell = _cell;
      this._value = _value;
    }
    getCell() {
      return this._cell;
    }
    /**
     * Modify the value
     */
    setValue(value) {
    }
    /**
     * Execute the core logic after the check is successful
     */
    execute() {
    }
  };
  var BaseCellInputExtensionFactory = class {
    constructor(_plugin) {
      this._plugin = _plugin;
    }
    get zIndex() {
      return 0;
    }
    /**
     * Generate FormulaBar Extension
     * @param value
     * @returns
     */
    create(cell, value) {
      return new BaseCellInputExtension(cell, value);
    }
    /**
     * Check if this cell needs to be intercepted currently
     * @param row
     * @param column
     * @param value
     * @returns
     */
    check(cell) {
      return false;
    }
  };

  // ../../packages/base-ui/src/Basics/Register/CellInputRegister/RegistryFactory.ts
  var Registry4 = class {
    _data = [];
    add(dataInstance) {
      this._data.push(dataInstance);
    }
    delete(dataInstance) {
      const index = this._data.indexOf(dataInstance);
      this._data.splice(index, 1);
    }
    getData() {
      return this._data;
    }
    static create() {
      return new Registry4();
    }
  };
  var REGISTRY_CELL_INPUT_FACTORY = Registry4.create();

  // ../../packages/base-ui/src/Basics/Register/CellInputRegister/CellInputExtensionRegister.ts
  var CellInputExtensionRegister = class {
    _cellInputExtensionFactoryList = [];
    get cellInputExtensionFactoryList() {
      return this._cellInputExtensionFactoryList;
    }
    initialize() {
      this._initExtensions();
    }
    add(...extensionFactoryList) {
      this._cellInputExtensionFactoryList.push(...extensionFactoryList);
      this._cellInputExtensionFactoryList.sort(sortRules);
    }
    delete(extensionFactory) {
      const index = this._cellInputExtensionFactoryList.indexOf(extensionFactory);
      this._cellInputExtensionFactoryList.splice(index, 1);
    }
    _initExtensions() {
      this._cellInputExtensionFactoryList.push(...REGISTRY_CELL_INPUT_FACTORY.getData().sort(sortRules));
    }
  };

  // ../../packages/base-ui/src/Basics/Register/CellInputRegister/CellInputExtensionManager.ts
  var _CellInputExtensionManager = class {
    _cellInputExtensionFactoryList;
    /**
     * inject cell position
     * @param row
     * @param column
     * @param value
     */
    handle(cell) {
      const cellInputExtensionFactoryList = _CellInputExtensionManager?.register?.cellInputExtensionFactoryList;
      if (!cellInputExtensionFactoryList)
        return;
      this._cellInputExtensionFactoryList = cellInputExtensionFactoryList;
      const extension = this._checkExtension(cell);
      if (extension) {
        extension.execute();
        return extension.getCell();
      }
    }
    /**
     * Execute when the action is matched
     * @param command
     * @returns
     */
    _checkExtension(cell) {
      let extension = false;
      if (!this._cellInputExtensionFactoryList)
        return false;
      for (let index = 0; index < this._cellInputExtensionFactoryList.length; index++) {
        const extensionFactory = this._cellInputExtensionFactoryList[index];
        extension = extensionFactory.check(cell);
        if (extension !== false) {
          break;
        }
      }
      return extension;
    }
    static create() {
      if (!this.register) {
        this.register = new CellInputExtensionRegister();
        this.register.initialize();
      }
      return this.register;
    }
  };
  var CellInputExtensionManager = _CellInputExtensionManager;
  __publicField(CellInputExtensionManager, "register");

  // ../../packages/base-ui/src/Basics/Register/Clipboard/ClipboardExtensionRegister.ts
  var ClipboardExtensionRegister = class {
    _clipboardExtensionFactoryList = [];
    get clipboardExtensionFactoryList() {
      return this._clipboardExtensionFactoryList;
    }
    add(...extensionFactoryList) {
      this._clipboardExtensionFactoryList.push(...extensionFactoryList);
      this._clipboardExtensionFactoryList.sort(sortRules);
    }
    delete(extensionFactory) {
      const index = this._clipboardExtensionFactoryList.indexOf(extensionFactory);
      this._clipboardExtensionFactoryList.splice(index, 1);
    }
  };

  // ../../packages/base-ui/src/Basics/Shared/Clipboard.ts
  var _Clipboard = class {
    static async writeText(text, e4) {
      if (_Clipboard.clipboard) {
        return _Clipboard.clipboard.writeText(text).then(
          () => true,
          (err) => console.dir(err)
        );
      }
      e4?.clipboardData?.setData("text/html", text);
    }
    static async write(data, e4) {
      if (_Clipboard.clipboard) {
        const blob = new Blob([data.data], { type: data.type ?? "text/html" });
        const clipboardData = [new ClipboardItem({ "text/html": blob })];
        return _Clipboard.clipboard.write(clipboardData).then(
          () => true,
          () => false
        );
      }
      e4?.clipboardData?.setData(data.type ?? "text/html", data.data);
    }
    static async readText() {
      if (_Clipboard.clipboard) {
        return _Clipboard.clipboard.readText().then(
          (text) => text,
          () => null
        );
      }
      if (!_Clipboard.textArea)
        return null;
      return new Promise((resolve, reject) => {
        resolve(_Clipboard.textArea.value);
      }).then((text) => text).then(() => null);
    }
    static async read(e4) {
      if (_Clipboard.clipboard) {
        const clipboardItems = await _Clipboard.clipboard.read();
        const Promises = [];
        for (const clipboardItem of clipboardItems) {
          for (const type of clipboardItem.types) {
            const blob = await clipboardItem.getType(type);
            const reader = new FileReader();
            if (type === "image/png") {
              reader.readAsDataURL(blob);
            } else {
              reader.readAsText(blob);
            }
            const promise = new Promise((resolve, reject) => {
              reader.onload = (e5) => {
                const item = { type, result: reader.result };
                resolve(item);
              };
            }).then(
              (res) => res,
              () => null
            );
            Promises.push(promise);
          }
        }
        return Promise.all(Promises);
      }
      const result = [];
      const clipboardData = e4?.clipboardData;
      const types = clipboardData?.types;
      if (!types)
        return null;
      for (let i4 = 0; i4 < types.length; i4++) {
        result.push({
          type: types[i4],
          result: clipboardData.getData(types[i4])
        });
      }
      return result;
    }
  };
  var Clipboard = _Clipboard;
  __publicField(Clipboard, "clipboard", window.navigator.clipboard);
  __publicField(Clipboard, "textArea");

  // ../../packages/base-ui/src/Basics/Register/Clipboard/ClipboardExtensionManager.ts
  var ClipboardExtensionManager = class {
    _clipboardExtensionFactoryList;
    // mounted on the instance
    _register;
    constructor() {
      this._register = new ClipboardExtensionRegister();
    }
    getRegister() {
      return this._register;
    }
    /**
     * inject all actions
     * @param command
     */
    handle(data) {
      const clipboardExtensionFactoryList = this._register?.clipboardExtensionFactoryList;
      if (!clipboardExtensionFactoryList)
        return;
      this._clipboardExtensionFactoryList = clipboardExtensionFactoryList;
      const extension = this._checkExtension(data);
      if (extension) {
        extension.execute();
      }
    }
    pasteResolver(evt) {
      return new Promise((resolve, reject) => {
        Clipboard.read(evt).then((file) => {
          if (!file)
            return [];
          const HtmlIndex = file.findIndex((item, index) => item && item.type === "text/html");
          const PlainIndex = file.findIndex((item, index) => item && item.type === "text/plain");
          const data = {};
          if (HtmlIndex > -1) {
            const html = file[HtmlIndex]?.result;
            data.html = html;
          }
          if (PlainIndex > -1) {
            const plain = file[PlainIndex]?.result;
            data.plain = plain;
          }
          resolve(data);
        });
      });
    }
    /**
     * Execute when the action is matched
     * @param command
     * @returns
     */
    _checkExtension(data) {
      if (!this._clipboardExtensionFactoryList)
        return false;
      let extension = false;
      for (let index = 0; index < this._clipboardExtensionFactoryList.length; index++) {
        const extensionFactory = this._clipboardExtensionFactoryList[index];
        extension = extensionFactory.check(data);
        if (extension !== false) {
          break;
        }
      }
      return extension;
    }
  };

  // ../../packages/base-ui/src/Basics/Register/DragAndDrop/DragAndDropExtensionRegister.ts
  var DragAndDropExtensionRegister = class {
    _DragAndDropExtensionFactoryList = [];
    get DragAndDropExtensionFactoryList() {
      return this._DragAndDropExtensionFactoryList;
    }
    add(...extensionFactoryList) {
      this._DragAndDropExtensionFactoryList.push(...extensionFactoryList);
      this._DragAndDropExtensionFactoryList.sort(sortRules);
    }
    delete(extensionFactory) {
      const index = this._DragAndDropExtensionFactoryList.indexOf(extensionFactory);
      this._DragAndDropExtensionFactoryList.splice(index, 1);
    }
  };

  // ../../packages/base-ui/src/Basics/Register/DragAndDrop/DragAndDropExtensionManager.ts
  var DragAndDropExtensionManager = class {
    _DragAndDropExtensionFactoryList;
    // mounted on the instance
    _register;
    constructor() {
      this._register = new DragAndDropExtensionRegister();
    }
    getRegister() {
      return this._register;
    }
    /**
     * inject all actions
     * @param command
     */
    handle(data) {
      const DragAndDropExtensionFactoryList = this._register?.DragAndDropExtensionFactoryList;
      if (!DragAndDropExtensionFactoryList)
        return;
      this._DragAndDropExtensionFactoryList = DragAndDropExtensionFactoryList;
      this._checkExtension(data);
    }
    /**
     * Execute when the action is matched
     * @param command
     * @returns
     */
    _checkExtension(data) {
      if (!this._DragAndDropExtensionFactoryList)
        return false;
      this._DragAndDropExtensionFactoryList.forEach((extensionFactory) => {
        const extension = extensionFactory.check(data);
        if (extension !== false) {
          extension.execute();
        }
      });
    }
    dragResolver(evt) {
      return new Promise((resolve, reject) => {
        if (!evt.dataTransfer)
          return;
        const dataList = [];
        if (evt.dataTransfer.items) {
          [...evt.dataTransfer.items].forEach((item, i4) => {
            if (item.kind === "file") {
              const file = item.getAsFile();
              if (file) {
                dataList.push({
                  kind: item.kind,
                  type: item.type,
                  file
                });
              }
            }
          });
        } else {
          [...evt.dataTransfer.files].forEach((file, i4) => {
            if (file) {
              dataList.push({
                kind: "file",
                type: file.type,
                file
              });
            }
          });
        }
        resolve(dataList);
      });
    }
  };

  // ../../node_modules/.pnpm/preact@10.12.1/node_modules/preact/dist/preact.module.js
  var n;
  var l;
  var u;
  var i;
  var t;
  var r;
  var o;
  var f;
  var e;
  var c = {};
  var s = [];
  var a = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
  function h(n3, l4) {
    for (var u4 in l4)
      n3[u4] = l4[u4];
    return n3;
  }
  function v(n3) {
    var l4 = n3.parentNode;
    l4 && l4.removeChild(n3);
  }
  function y(l4, u4, i4) {
    var t4, r4, o4, f4 = {};
    for (o4 in u4)
      "key" == o4 ? t4 = u4[o4] : "ref" == o4 ? r4 = u4[o4] : f4[o4] = u4[o4];
    if (arguments.length > 2 && (f4.children = arguments.length > 3 ? n.call(arguments, 2) : i4), "function" == typeof l4 && null != l4.defaultProps)
      for (o4 in l4.defaultProps)
        void 0 === f4[o4] && (f4[o4] = l4.defaultProps[o4]);
    return p(l4, f4, t4, r4, null);
  }
  function p(n3, i4, t4, r4, o4) {
    var f4 = { type: n3, props: i4, key: t4, ref: r4, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: null == o4 ? ++u : o4 };
    return null == o4 && null != l.vnode && l.vnode(f4), f4;
  }
  function d() {
    return { current: null };
  }
  function _(n3) {
    return n3.children;
  }
  function k(n3, l4, u4, i4, t4) {
    var r4;
    for (r4 in u4)
      "children" === r4 || "key" === r4 || r4 in l4 || g(n3, r4, null, u4[r4], i4);
    for (r4 in l4)
      t4 && "function" != typeof l4[r4] || "children" === r4 || "key" === r4 || "value" === r4 || "checked" === r4 || u4[r4] === l4[r4] || g(n3, r4, l4[r4], u4[r4], i4);
  }
  function b(n3, l4, u4) {
    "-" === l4[0] ? n3.setProperty(l4, null == u4 ? "" : u4) : n3[l4] = null == u4 ? "" : "number" != typeof u4 || a.test(l4) ? u4 : u4 + "px";
  }
  function g(n3, l4, u4, i4, t4) {
    var r4;
    n:
      if ("style" === l4)
        if ("string" == typeof u4)
          n3.style.cssText = u4;
        else {
          if ("string" == typeof i4 && (n3.style.cssText = i4 = ""), i4)
            for (l4 in i4)
              u4 && l4 in u4 || b(n3.style, l4, "");
          if (u4)
            for (l4 in u4)
              i4 && u4[l4] === i4[l4] || b(n3.style, l4, u4[l4]);
        }
      else if ("o" === l4[0] && "n" === l4[1])
        r4 = l4 !== (l4 = l4.replace(/Capture$/, "")), l4 = l4.toLowerCase() in n3 ? l4.toLowerCase().slice(2) : l4.slice(2), n3.l || (n3.l = {}), n3.l[l4 + r4] = u4, u4 ? i4 || n3.addEventListener(l4, r4 ? w : m, r4) : n3.removeEventListener(l4, r4 ? w : m, r4);
      else if ("dangerouslySetInnerHTML" !== l4) {
        if (t4)
          l4 = l4.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
        else if ("width" !== l4 && "height" !== l4 && "href" !== l4 && "list" !== l4 && "form" !== l4 && "tabIndex" !== l4 && "download" !== l4 && l4 in n3)
          try {
            n3[l4] = null == u4 ? "" : u4;
            break n;
          } catch (n4) {
          }
        "function" == typeof u4 || (null == u4 || false === u4 && -1 == l4.indexOf("-") ? n3.removeAttribute(l4) : n3.setAttribute(l4, u4));
      }
  }
  function m(n3) {
    t = true;
    try {
      return this.l[n3.type + false](l.event ? l.event(n3) : n3);
    } finally {
      t = false;
    }
  }
  function w(n3) {
    t = true;
    try {
      return this.l[n3.type + true](l.event ? l.event(n3) : n3);
    } finally {
      t = false;
    }
  }
  function x(n3, l4) {
    this.props = n3, this.context = l4;
  }
  function A(n3, l4) {
    if (null == l4)
      return n3.__ ? A(n3.__, n3.__.__k.indexOf(n3) + 1) : null;
    for (var u4; l4 < n3.__k.length; l4++)
      if (null != (u4 = n3.__k[l4]) && null != u4.__e)
        return u4.__e;
    return "function" == typeof n3.type ? A(n3) : null;
  }
  function P(n3) {
    var l4, u4;
    if (null != (n3 = n3.__) && null != n3.__c) {
      for (n3.__e = n3.__c.base = null, l4 = 0; l4 < n3.__k.length; l4++)
        if (null != (u4 = n3.__k[l4]) && null != u4.__e) {
          n3.__e = n3.__c.base = u4.__e;
          break;
        }
      return P(n3);
    }
  }
  function C(n3) {
    t ? setTimeout(n3) : f(n3);
  }
  function T(n3) {
    (!n3.__d && (n3.__d = true) && r.push(n3) && !$.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || C)($);
  }
  function $() {
    var n3, l4, u4, i4, t4, o4, f4, e4;
    for (r.sort(function(n4, l5) {
      return n4.__v.__b - l5.__v.__b;
    }); n3 = r.shift(); )
      n3.__d && (l4 = r.length, i4 = void 0, t4 = void 0, f4 = (o4 = (u4 = n3).__v).__e, (e4 = u4.__P) && (i4 = [], (t4 = h({}, o4)).__v = o4.__v + 1, M(e4, o4, t4, u4.__n, void 0 !== e4.ownerSVGElement, null != o4.__h ? [f4] : null, i4, null == f4 ? A(o4) : f4, o4.__h), N(i4, o4), o4.__e != f4 && P(o4)), r.length > l4 && r.sort(function(n4, l5) {
        return n4.__v.__b - l5.__v.__b;
      }));
    $.__r = 0;
  }
  function H(n3, l4, u4, i4, t4, r4, o4, f4, e4, a4) {
    var h4, v4, y4, d4, k5, b4, g5, m4 = i4 && i4.__k || s, w4 = m4.length;
    for (u4.__k = [], h4 = 0; h4 < l4.length; h4++)
      if (null != (d4 = u4.__k[h4] = null == (d4 = l4[h4]) || "boolean" == typeof d4 ? null : "string" == typeof d4 || "number" == typeof d4 || "bigint" == typeof d4 ? p(null, d4, null, null, d4) : Array.isArray(d4) ? p(_, { children: d4 }, null, null, null) : d4.__b > 0 ? p(d4.type, d4.props, d4.key, d4.ref ? d4.ref : null, d4.__v) : d4)) {
        if (d4.__ = u4, d4.__b = u4.__b + 1, null === (y4 = m4[h4]) || y4 && d4.key == y4.key && d4.type === y4.type)
          m4[h4] = void 0;
        else
          for (v4 = 0; v4 < w4; v4++) {
            if ((y4 = m4[v4]) && d4.key == y4.key && d4.type === y4.type) {
              m4[v4] = void 0;
              break;
            }
            y4 = null;
          }
        M(n3, d4, y4 = y4 || c, t4, r4, o4, f4, e4, a4), k5 = d4.__e, (v4 = d4.ref) && y4.ref != v4 && (g5 || (g5 = []), y4.ref && g5.push(y4.ref, null, d4), g5.push(v4, d4.__c || k5, d4)), null != k5 ? (null == b4 && (b4 = k5), "function" == typeof d4.type && d4.__k === y4.__k ? d4.__d = e4 = I(d4, e4, n3) : e4 = z(n3, d4, y4, m4, k5, e4), "function" == typeof u4.type && (u4.__d = e4)) : e4 && y4.__e == e4 && e4.parentNode != n3 && (e4 = A(y4));
      }
    for (u4.__e = b4, h4 = w4; h4--; )
      null != m4[h4] && ("function" == typeof u4.type && null != m4[h4].__e && m4[h4].__e == u4.__d && (u4.__d = L(i4).nextSibling), q(m4[h4], m4[h4]));
    if (g5)
      for (h4 = 0; h4 < g5.length; h4++)
        S(g5[h4], g5[++h4], g5[++h4]);
  }
  function I(n3, l4, u4) {
    for (var i4, t4 = n3.__k, r4 = 0; t4 && r4 < t4.length; r4++)
      (i4 = t4[r4]) && (i4.__ = n3, l4 = "function" == typeof i4.type ? I(i4, l4, u4) : z(u4, i4, i4, t4, i4.__e, l4));
    return l4;
  }
  function j(n3, l4) {
    return l4 = l4 || [], null == n3 || "boolean" == typeof n3 || (Array.isArray(n3) ? n3.some(function(n4) {
      j(n4, l4);
    }) : l4.push(n3)), l4;
  }
  function z(n3, l4, u4, i4, t4, r4) {
    var o4, f4, e4;
    if (void 0 !== l4.__d)
      o4 = l4.__d, l4.__d = void 0;
    else if (null == u4 || t4 != r4 || null == t4.parentNode)
      n:
        if (null == r4 || r4.parentNode !== n3)
          n3.appendChild(t4), o4 = null;
        else {
          for (f4 = r4, e4 = 0; (f4 = f4.nextSibling) && e4 < i4.length; e4 += 1)
            if (f4 == t4)
              break n;
          n3.insertBefore(t4, r4), o4 = r4;
        }
    return void 0 !== o4 ? o4 : t4.nextSibling;
  }
  function L(n3) {
    var l4, u4, i4;
    if (null == n3.type || "string" == typeof n3.type)
      return n3.__e;
    if (n3.__k) {
      for (l4 = n3.__k.length - 1; l4 >= 0; l4--)
        if ((u4 = n3.__k[l4]) && (i4 = L(u4)))
          return i4;
    }
    return null;
  }
  function M(n3, u4, i4, t4, r4, o4, f4, e4, c4) {
    var s4, a4, v4, y4, p4, d4, k5, b4, g5, m4, w4, A3, P4, C3, T5, $3 = u4.type;
    if (void 0 !== u4.constructor)
      return null;
    null != i4.__h && (c4 = i4.__h, e4 = u4.__e = i4.__e, u4.__h = null, o4 = [e4]), (s4 = l.__b) && s4(u4);
    try {
      n:
        if ("function" == typeof $3) {
          if (b4 = u4.props, g5 = (s4 = $3.contextType) && t4[s4.__c], m4 = s4 ? g5 ? g5.props.value : s4.__ : t4, i4.__c ? k5 = (a4 = u4.__c = i4.__c).__ = a4.__E : ("prototype" in $3 && $3.prototype.render ? u4.__c = a4 = new $3(b4, m4) : (u4.__c = a4 = new x(b4, m4), a4.constructor = $3, a4.render = B), g5 && g5.sub(a4), a4.props = b4, a4.state || (a4.state = {}), a4.context = m4, a4.__n = t4, v4 = a4.__d = true, a4.__h = [], a4._sb = []), null == a4.__s && (a4.__s = a4.state), null != $3.getDerivedStateFromProps && (a4.__s == a4.state && (a4.__s = h({}, a4.__s)), h(a4.__s, $3.getDerivedStateFromProps(b4, a4.__s))), y4 = a4.props, p4 = a4.state, a4.__v = u4, v4)
            null == $3.getDerivedStateFromProps && null != a4.componentWillMount && a4.componentWillMount(), null != a4.componentDidMount && a4.__h.push(a4.componentDidMount);
          else {
            if (null == $3.getDerivedStateFromProps && b4 !== y4 && null != a4.componentWillReceiveProps && a4.componentWillReceiveProps(b4, m4), !a4.__e && null != a4.shouldComponentUpdate && false === a4.shouldComponentUpdate(b4, a4.__s, m4) || u4.__v === i4.__v) {
              for (u4.__v !== i4.__v && (a4.props = b4, a4.state = a4.__s, a4.__d = false), u4.__e = i4.__e, u4.__k = i4.__k, u4.__k.forEach(function(n4) {
                n4 && (n4.__ = u4);
              }), w4 = 0; w4 < a4._sb.length; w4++)
                a4.__h.push(a4._sb[w4]);
              a4._sb = [], a4.__h.length && f4.push(a4);
              break n;
            }
            null != a4.componentWillUpdate && a4.componentWillUpdate(b4, a4.__s, m4), null != a4.componentDidUpdate && a4.__h.push(function() {
              a4.componentDidUpdate(y4, p4, d4);
            });
          }
          if (a4.context = m4, a4.props = b4, a4.__P = n3, A3 = l.__r, P4 = 0, "prototype" in $3 && $3.prototype.render) {
            for (a4.state = a4.__s, a4.__d = false, A3 && A3(u4), s4 = a4.render(a4.props, a4.state, a4.context), C3 = 0; C3 < a4._sb.length; C3++)
              a4.__h.push(a4._sb[C3]);
            a4._sb = [];
          } else
            do {
              a4.__d = false, A3 && A3(u4), s4 = a4.render(a4.props, a4.state, a4.context), a4.state = a4.__s;
            } while (a4.__d && ++P4 < 25);
          a4.state = a4.__s, null != a4.getChildContext && (t4 = h(h({}, t4), a4.getChildContext())), v4 || null == a4.getSnapshotBeforeUpdate || (d4 = a4.getSnapshotBeforeUpdate(y4, p4)), T5 = null != s4 && s4.type === _ && null == s4.key ? s4.props.children : s4, H(n3, Array.isArray(T5) ? T5 : [T5], u4, i4, t4, r4, o4, f4, e4, c4), a4.base = u4.__e, u4.__h = null, a4.__h.length && f4.push(a4), k5 && (a4.__E = a4.__ = null), a4.__e = false;
        } else
          null == o4 && u4.__v === i4.__v ? (u4.__k = i4.__k, u4.__e = i4.__e) : u4.__e = O(i4.__e, u4, i4, t4, r4, o4, f4, c4);
      (s4 = l.diffed) && s4(u4);
    } catch (n4) {
      u4.__v = null, (c4 || null != o4) && (u4.__e = e4, u4.__h = !!c4, o4[o4.indexOf(e4)] = null), l.__e(n4, u4, i4);
    }
  }
  function N(n3, u4) {
    l.__c && l.__c(u4, n3), n3.some(function(u5) {
      try {
        n3 = u5.__h, u5.__h = [], n3.some(function(n4) {
          n4.call(u5);
        });
      } catch (n4) {
        l.__e(n4, u5.__v);
      }
    });
  }
  function O(l4, u4, i4, t4, r4, o4, f4, e4) {
    var s4, a4, h4, y4 = i4.props, p4 = u4.props, d4 = u4.type, _4 = 0;
    if ("svg" === d4 && (r4 = true), null != o4) {
      for (; _4 < o4.length; _4++)
        if ((s4 = o4[_4]) && "setAttribute" in s4 == !!d4 && (d4 ? s4.localName === d4 : 3 === s4.nodeType)) {
          l4 = s4, o4[_4] = null;
          break;
        }
    }
    if (null == l4) {
      if (null === d4)
        return document.createTextNode(p4);
      l4 = r4 ? document.createElementNS("http://www.w3.org/2000/svg", d4) : document.createElement(d4, p4.is && p4), o4 = null, e4 = false;
    }
    if (null === d4)
      y4 === p4 || e4 && l4.data === p4 || (l4.data = p4);
    else {
      if (o4 = o4 && n.call(l4.childNodes), a4 = (y4 = i4.props || c).dangerouslySetInnerHTML, h4 = p4.dangerouslySetInnerHTML, !e4) {
        if (null != o4)
          for (y4 = {}, _4 = 0; _4 < l4.attributes.length; _4++)
            y4[l4.attributes[_4].name] = l4.attributes[_4].value;
        (h4 || a4) && (h4 && (a4 && h4.__html == a4.__html || h4.__html === l4.innerHTML) || (l4.innerHTML = h4 && h4.__html || ""));
      }
      if (k(l4, p4, y4, r4, e4), h4)
        u4.__k = [];
      else if (_4 = u4.props.children, H(l4, Array.isArray(_4) ? _4 : [_4], u4, i4, t4, r4 && "foreignObject" !== d4, o4, f4, o4 ? o4[0] : i4.__k && A(i4, 0), e4), null != o4)
        for (_4 = o4.length; _4--; )
          null != o4[_4] && v(o4[_4]);
      e4 || ("value" in p4 && void 0 !== (_4 = p4.value) && (_4 !== l4.value || "progress" === d4 && !_4 || "option" === d4 && _4 !== y4.value) && g(l4, "value", _4, y4.value, false), "checked" in p4 && void 0 !== (_4 = p4.checked) && _4 !== l4.checked && g(l4, "checked", _4, y4.checked, false));
    }
    return l4;
  }
  function S(n3, u4, i4) {
    try {
      "function" == typeof n3 ? n3(u4) : n3.current = u4;
    } catch (n4) {
      l.__e(n4, i4);
    }
  }
  function q(n3, u4, i4) {
    var t4, r4;
    if (l.unmount && l.unmount(n3), (t4 = n3.ref) && (t4.current && t4.current !== n3.__e || S(t4, null, u4)), null != (t4 = n3.__c)) {
      if (t4.componentWillUnmount)
        try {
          t4.componentWillUnmount();
        } catch (n4) {
          l.__e(n4, u4);
        }
      t4.base = t4.__P = null, n3.__c = void 0;
    }
    if (t4 = n3.__k)
      for (r4 = 0; r4 < t4.length; r4++)
        t4[r4] && q(t4[r4], u4, i4 || "function" != typeof n3.type);
    i4 || null == n3.__e || v(n3.__e), n3.__ = n3.__e = n3.__d = void 0;
  }
  function B(n3, l4, u4) {
    return this.constructor(n3, u4);
  }
  function D(u4, i4, t4) {
    var r4, o4, f4;
    l.__ && l.__(u4, i4), o4 = (r4 = "function" == typeof t4) ? null : t4 && t4.__k || i4.__k, f4 = [], M(i4, u4 = (!r4 && t4 || i4).__k = y(_, null, [u4]), o4 || c, c, void 0 !== i4.ownerSVGElement, !r4 && t4 ? [t4] : o4 ? null : i4.firstChild ? n.call(i4.childNodes) : null, f4, !r4 && t4 ? t4 : o4 ? o4.__e : i4.firstChild, r4), N(f4, u4);
  }
  function G(n3, l4) {
    var u4 = { __c: l4 = "__cC" + e++, __: n3, Consumer: function(n4, l5) {
      return n4.children(l5);
    }, Provider: function(n4) {
      var u5, i4;
      return this.getChildContext || (u5 = [], (i4 = {})[l4] = this, this.getChildContext = function() {
        return i4;
      }, this.shouldComponentUpdate = function(n5) {
        this.props.value !== n5.value && u5.some(function(n6) {
          n6.__e = true, T(n6);
        });
      }, this.sub = function(n5) {
        u5.push(n5);
        var l5 = n5.componentWillUnmount;
        n5.componentWillUnmount = function() {
          u5.splice(u5.indexOf(n5), 1), l5 && l5.call(n5);
        };
      }), n4.children;
    } };
    return u4.Provider.__ = u4.Consumer.contextType = u4;
  }
  n = s.slice, l = { __e: function(n3, l4, u4, i4) {
    for (var t4, r4, o4; l4 = l4.__; )
      if ((t4 = l4.__c) && !t4.__)
        try {
          if ((r4 = t4.constructor) && null != r4.getDerivedStateFromError && (t4.setState(r4.getDerivedStateFromError(n3)), o4 = t4.__d), null != t4.componentDidCatch && (t4.componentDidCatch(n3, i4 || {}), o4 = t4.__d), o4)
            return t4.__E = t4;
        } catch (l5) {
          n3 = l5;
        }
    throw n3;
  } }, u = 0, i = function(n3) {
    return null != n3 && void 0 === n3.constructor;
  }, t = false, x.prototype.setState = function(n3, l4) {
    var u4;
    u4 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = h({}, this.state), "function" == typeof n3 && (n3 = n3(h({}, u4), this.props)), n3 && h(u4, n3), null != n3 && this.__v && (l4 && this._sb.push(l4), T(this));
  }, x.prototype.forceUpdate = function(n3) {
    this.__v && (this.__e = true, n3 && this.__h.push(n3), T(this));
  }, x.prototype.render = _, r = [], f = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, $.__r = 0, e = 0;

  // ../../packages/base-ui/src/Common/AppContext.tsx
  var AppContext = G({});

  // ../../packages/base-ui/src/Common/KeyboardManager.ts
  var KeyboardManager = class {
    constructor(_plugin) {
      this._plugin = _plugin;
      this._observerManager = this._plugin.getContext().getObserverManager();
      this._installObserver();
    }
    _observerManager;
    /**
     * init keyboard listener
     *
     * add to docs/slides/
     */
    handleKeyboardAction(element) {
      const keyboardDownEvent = (evt) => {
        this._observerManager.requiredObserver("onKeyDownObservable", "core")?.notifyObservers(evt);
      };
      const keyboardUpEvent = (evt) => {
        this._observerManager.requiredObserver("onKeyUpObservable", "core")?.notifyObservers(evt);
      };
      const keyboardCopyEvent = (evt) => {
        this._observerManager.requiredObserver("onKeyCopyObservable", "core")?.notifyObservers(evt);
      };
      const keyboardPasteEvent = (evt) => {
        this._observerManager.requiredObserver("onKeyPasteObservable", "core")?.notifyObservers(evt);
      };
      const keyboardCutEvent = (evt) => {
        this._observerManager.requiredObserver("onKeyCutObservable", "core")?.notifyObservers(evt);
      };
      const keyboardCompositionStartEvent = (evt) => {
        this._observerManager.requiredObserver("onKeyCompositionStartObservable", "core")?.notifyObservers(evt);
      };
      const keyboardCompositionUpdateEvent = (evt) => {
        this._observerManager.requiredObserver("onKeyCompositionUpdateObservable", "core")?.notifyObservers(evt);
      };
      const keyboardCompositionEndEvent = (evt) => {
        this._observerManager.requiredObserver("onKeyCompositionEndObservable", "core")?.notifyObservers(evt);
      };
      element.addEventListener("keydown", keyboardDownEvent);
      element.addEventListener("keyup", keyboardUpEvent);
      element.addEventListener("copy", keyboardCopyEvent);
      element.addEventListener("paste", keyboardPasteEvent);
      element.addEventListener("cut", keyboardCutEvent);
      element.addEventListener("compositionstart", keyboardCompositionStartEvent);
      element.addEventListener("compositionupdate", keyboardCompositionUpdateEvent);
      element.addEventListener("compositionend", keyboardCompositionEndEvent);
    }
    _installObserver() {
      this._observerManager.addObserver("onKeyDownObservable", "core", new Observable());
      this._observerManager.addObserver("onKeyUpObservable", "core", new Observable());
      this._observerManager.addObserver("onKeyCopyObservable", "core", new Observable());
      this._observerManager.addObserver("onKeyPasteObservable", "core", new Observable());
      this._observerManager.addObserver("onKeyCutObservable", "core", new Observable());
      this._observerManager.addObserver("onKeyCompositionStartObservable", "core", new Observable());
      this._observerManager.addObserver("onKeyCompositionUpdateObservable", "core", new Observable());
      this._observerManager.addObserver("onKeyCompositionEndObservable", "core", new Observable());
    }
  };

  // ../../packages/base-ui/src/Common/DragManager.ts
  var DragManager = class {
    constructor(_plugin) {
      this._plugin = _plugin;
      this._observerManager = this._plugin.getContext().getObserverManager();
      this._installObserver();
    }
    _observerManager;
    /**
     * init Drag listener
     *
     * add to docs/slides/
     */
    handleDragAction(element) {
      const DropEvent = (evt) => {
        evt.preventDefault();
        this._observerManager.requiredObserver("onDropObservable", "core")?.notifyObservers(evt);
      };
      const DragOverEvent = (evt) => {
        evt.preventDefault();
      };
      element.addEventListener("drop", DropEvent);
      element.addEventListener("dragover", DragOverEvent);
    }
    _installObserver() {
      this._observerManager.addObserver("onDropObservable", "core", new Observable());
    }
  };

  // ../../packages/base-ui/src/Common/EventManager.ts
  var EventManager = class {
    constructor(_plugin) {
      this._plugin = _plugin;
      this._observerManager = this._plugin.getContext().getObserverManager();
      this._installObserver();
    }
    _observerManager;
    _installObserver() {
      this._observerManager.addObserver("onUIChangeObservable", "core", new Observable());
      this._observerManager.addObserver("onAfterChangeUILocaleObservable", "core", new Observable());
      this._observerManager.addObserver("onViewComponentFocusChange", "core", new Observable());
      this._observerManager.addObserver("onAddSheet", "core", new Observable());
      this._observerManager.addObserver("onDeleteSheet", "core", new Observable());
      this._observerManager.addObserver("onHideSheet", "core", new Observable());
      this._observerManager.addObserver("onUnHideSheet", "core", new Observable());
      this._observerManager.addObserver("onToLeftSheet", "core", new Observable());
      this._observerManager.addObserver("onToRightSheet", "core", new Observable());
      this._observerManager.addObserver("onCopySheet", "core", new Observable());
      this._observerManager.addObserver("onRemoveSheet", "core", new Observable());
      this._observerManager.addObserver("onSheetColor", "core", new Observable());
    }
  };

  // ../../node_modules/.pnpm/preact@10.12.1/node_modules/preact/hooks/dist/hooks.module.js
  var t2;
  var r2;
  var u2;
  var i2;
  var o2 = 0;
  var f2 = [];
  var c2 = [];
  var e2 = l.__b;
  var a2 = l.__r;
  var v2 = l.diffed;
  var l2 = l.__c;
  var m2 = l.unmount;
  function d2(t4, u4) {
    l.__h && l.__h(r2, t4, o2 || u4), o2 = 0;
    var i4 = r2.__H || (r2.__H = { __: [], __h: [] });
    return t4 >= i4.__.length && i4.__.push({ __V: c2 }), i4.__[t4];
  }
  function _2(n3) {
    return o2 = 5, F(function() {
      return { current: n3 };
    }, []);
  }
  function F(n3, r4) {
    var u4 = d2(t2++, 7);
    return z2(u4.__H, r4) ? (u4.__V = n3(), u4.i = r4, u4.__h = n3, u4.__V) : u4.__;
  }
  function b2() {
    for (var t4; t4 = f2.shift(); )
      if (t4.__P && t4.__H)
        try {
          t4.__H.__h.forEach(k2), t4.__H.__h.forEach(w2), t4.__H.__h = [];
        } catch (r4) {
          t4.__H.__h = [], l.__e(r4, t4.__v);
        }
  }
  l.__b = function(n3) {
    r2 = null, e2 && e2(n3);
  }, l.__r = function(n3) {
    a2 && a2(n3), t2 = 0;
    var i4 = (r2 = n3.__c).__H;
    i4 && (u2 === r2 ? (i4.__h = [], r2.__h = [], i4.__.forEach(function(n4) {
      n4.__N && (n4.__ = n4.__N), n4.__V = c2, n4.__N = n4.i = void 0;
    })) : (i4.__h.forEach(k2), i4.__h.forEach(w2), i4.__h = [])), u2 = r2;
  }, l.diffed = function(t4) {
    v2 && v2(t4);
    var o4 = t4.__c;
    o4 && o4.__H && (o4.__H.__h.length && (1 !== f2.push(o4) && i2 === l.requestAnimationFrame || ((i2 = l.requestAnimationFrame) || j2)(b2)), o4.__H.__.forEach(function(n3) {
      n3.i && (n3.__H = n3.i), n3.__V !== c2 && (n3.__ = n3.__V), n3.i = void 0, n3.__V = c2;
    })), u2 = r2 = null;
  }, l.__c = function(t4, r4) {
    r4.some(function(t5) {
      try {
        t5.__h.forEach(k2), t5.__h = t5.__h.filter(function(n3) {
          return !n3.__ || w2(n3);
        });
      } catch (u4) {
        r4.some(function(n3) {
          n3.__h && (n3.__h = []);
        }), r4 = [], l.__e(u4, t5.__v);
      }
    }), l2 && l2(t4, r4);
  }, l.unmount = function(t4) {
    m2 && m2(t4);
    var r4, u4 = t4.__c;
    u4 && u4.__H && (u4.__H.__.forEach(function(n3) {
      try {
        k2(n3);
      } catch (n4) {
        r4 = n4;
      }
    }), u4.__H = void 0, r4 && l.__e(r4, u4.__v));
  };
  var g2 = "function" == typeof requestAnimationFrame;
  function j2(n3) {
    var t4, r4 = function() {
      clearTimeout(u4), g2 && cancelAnimationFrame(t4), setTimeout(n3);
    }, u4 = setTimeout(r4, 100);
    g2 && (t4 = requestAnimationFrame(r4));
  }
  function k2(n3) {
    var t4 = r2, u4 = n3.__c;
    "function" == typeof u4 && (n3.__c = void 0, u4()), r2 = t4;
  }
  function w2(n3) {
    var t4 = r2;
    n3.__c = n3.__(), r2 = t4;
  }
  function z2(n3, t4) {
    return !n3 || n3.length !== t4.length || t4.some(function(t5, r4) {
      return t5 !== n3[r4];
    });
  }

  // ../../node_modules/.pnpm/preact@10.12.1/node_modules/preact/compat/dist/compat.module.js
  function g3(n3, t4) {
    for (var e4 in t4)
      n3[e4] = t4[e4];
    return n3;
  }
  function C2(n3, t4) {
    for (var e4 in n3)
      if ("__source" !== e4 && !(e4 in t4))
        return true;
    for (var r4 in t4)
      if ("__source" !== r4 && n3[r4] !== t4[r4])
        return true;
    return false;
  }
  function w3(n3) {
    this.props = n3;
  }
  (w3.prototype = new x()).isPureReactComponent = true, w3.prototype.shouldComponentUpdate = function(n3, t4) {
    return C2(this.props, n3) || C2(this.state, t4);
  };
  var x3 = l.__b;
  l.__b = function(n3) {
    n3.type && n3.type.__f && n3.ref && (n3.props.ref = n3.ref, n3.ref = null), x3 && x3(n3);
  };
  var N2 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
  function k3(n3) {
    function t4(t5) {
      var e4 = g3({}, t5);
      return delete e4.ref, n3(e4, t5.ref || null);
    }
    return t4.$$typeof = N2, t4.render = t4, t4.prototype.isReactComponent = t4.__f = true, t4.displayName = "ForwardRef(" + (n3.displayName || n3.name) + ")", t4;
  }
  var T3 = l.__e;
  l.__e = function(n3, t4, e4, r4) {
    if (n3.then) {
      for (var u4, o4 = t4; o4 = o4.__; )
        if ((u4 = o4.__c) && u4.__c)
          return null == t4.__e && (t4.__e = e4.__e, t4.__k = e4.__k), u4.__c(n3, t4);
    }
    T3(n3, t4, e4, r4);
  };
  var I2 = l.unmount;
  function L2(n3, t4, e4) {
    return n3 && (n3.__c && n3.__c.__H && (n3.__c.__H.__.forEach(function(n4) {
      "function" == typeof n4.__c && n4.__c();
    }), n3.__c.__H = null), null != (n3 = g3({}, n3)).__c && (n3.__c.__P === e4 && (n3.__c.__P = t4), n3.__c = null), n3.__k = n3.__k && n3.__k.map(function(n4) {
      return L2(n4, t4, e4);
    })), n3;
  }
  function U(n3, t4, e4) {
    return n3 && (n3.__v = null, n3.__k = n3.__k && n3.__k.map(function(n4) {
      return U(n4, t4, e4);
    }), n3.__c && n3.__c.__P === t4 && (n3.__e && e4.insertBefore(n3.__e, n3.__d), n3.__c.__e = true, n3.__c.__P = e4)), n3;
  }
  function D2() {
    this.__u = 0, this.t = null, this.__b = null;
  }
  function F3(n3) {
    var t4 = n3.__.__c;
    return t4 && t4.__a && t4.__a(n3);
  }
  function V2() {
    this.u = null, this.o = null;
  }
  l.unmount = function(n3) {
    var t4 = n3.__c;
    t4 && t4.__R && t4.__R(), t4 && true === n3.__h && (n3.type = null), I2 && I2(n3);
  }, (D2.prototype = new x()).__c = function(n3, t4) {
    var e4 = t4.__c, r4 = this;
    null == r4.t && (r4.t = []), r4.t.push(e4);
    var u4 = F3(r4.__v), o4 = false, i4 = function() {
      o4 || (o4 = true, e4.__R = null, u4 ? u4(l4) : l4());
    };
    e4.__R = i4;
    var l4 = function() {
      if (!--r4.__u) {
        if (r4.state.__a) {
          var n4 = r4.state.__a;
          r4.__v.__k[0] = U(n4, n4.__c.__P, n4.__c.__O);
        }
        var t5;
        for (r4.setState({ __a: r4.__b = null }); t5 = r4.t.pop(); )
          t5.forceUpdate();
      }
    }, c4 = true === t4.__h;
    r4.__u++ || c4 || r4.setState({ __a: r4.__b = r4.__v.__k[0] }), n3.then(i4, i4);
  }, D2.prototype.componentWillUnmount = function() {
    this.t = [];
  }, D2.prototype.render = function(n3, e4) {
    if (this.__b) {
      if (this.__v.__k) {
        var r4 = document.createElement("div"), o4 = this.__v.__k[0].__c;
        this.__v.__k[0] = L2(this.__b, r4, o4.__O = o4.__P);
      }
      this.__b = null;
    }
    var i4 = e4.__a && y(_, null, n3.fallback);
    return i4 && (i4.__h = null), [y(_, null, e4.__a ? null : n3.children), i4];
  };
  var W = function(n3, t4, e4) {
    if (++e4[1] === e4[0] && n3.o.delete(t4), n3.props.revealOrder && ("t" !== n3.props.revealOrder[0] || !n3.o.size))
      for (e4 = n3.u; e4; ) {
        for (; e4.length > 3; )
          e4.pop()();
        if (e4[1] < e4[0])
          break;
        n3.u = e4 = e4[2];
      }
  };
  (V2.prototype = new x()).__a = function(n3) {
    var t4 = this, e4 = F3(t4.__v), r4 = t4.o.get(n3);
    return r4[0]++, function(u4) {
      var o4 = function() {
        t4.props.revealOrder ? (r4.push(u4), W(t4, n3, r4)) : u4();
      };
      e4 ? e4(o4) : o4();
    };
  }, V2.prototype.render = function(n3) {
    this.u = null, this.o = /* @__PURE__ */ new Map();
    var t4 = j(n3.children);
    n3.revealOrder && "b" === n3.revealOrder[0] && t4.reverse();
    for (var e4 = t4.length; e4--; )
      this.o.set(t4[e4], this.u = [1, 0, this.u]);
    return n3.children;
  }, V2.prototype.componentDidUpdate = V2.prototype.componentDidMount = function() {
    var n3 = this;
    this.o.forEach(function(t4, e4) {
      W(n3, e4, t4);
    });
  };
  var z3 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103;
  var B2 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
  var H2 = "undefined" != typeof document;
  var Z = function(n3) {
    return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n3);
  };
  x.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t4) {
    Object.defineProperty(x.prototype, t4, { configurable: true, get: function() {
      return this["UNSAFE_" + t4];
    }, set: function(n3) {
      Object.defineProperty(this, t4, { configurable: true, writable: true, value: n3 });
    } });
  });
  var G2 = l.event;
  function J() {
  }
  function K() {
    return this.cancelBubble;
  }
  function Q() {
    return this.defaultPrevented;
  }
  l.event = function(n3) {
    return G2 && (n3 = G2(n3)), n3.persist = J, n3.isPropagationStopped = K, n3.isDefaultPrevented = Q, n3.nativeEvent = n3;
  };
  var X;
  var nn = { configurable: true, get: function() {
    return this.class;
  } };
  var tn = l.vnode;
  l.vnode = function(n3) {
    var t4 = n3.type, e4 = n3.props, u4 = e4;
    if ("string" == typeof t4) {
      var o4 = -1 === t4.indexOf("-");
      for (var i4 in u4 = {}, e4) {
        var l4 = e4[i4];
        H2 && "children" === i4 && "noscript" === t4 || "value" === i4 && "defaultValue" in e4 && null == l4 || ("defaultValue" === i4 && "value" in e4 && null == e4.value ? i4 = "value" : "download" === i4 && true === l4 ? l4 = "" : /ondoubleclick/i.test(i4) ? i4 = "ondblclick" : /^onchange(textarea|input)/i.test(i4 + t4) && !Z(e4.type) ? i4 = "oninput" : /^onfocus$/i.test(i4) ? i4 = "onfocusin" : /^onblur$/i.test(i4) ? i4 = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(i4) ? i4 = i4.toLowerCase() : o4 && B2.test(i4) ? i4 = i4.replace(/[A-Z0-9]/g, "-$&").toLowerCase() : null === l4 && (l4 = void 0), /^oninput$/i.test(i4) && (i4 = i4.toLowerCase(), u4[i4] && (i4 = "oninputCapture")), u4[i4] = l4);
      }
      "select" == t4 && u4.multiple && Array.isArray(u4.value) && (u4.value = j(e4.children).forEach(function(n4) {
        n4.props.selected = -1 != u4.value.indexOf(n4.props.value);
      })), "select" == t4 && null != u4.defaultValue && (u4.value = j(e4.children).forEach(function(n4) {
        n4.props.selected = u4.multiple ? -1 != u4.defaultValue.indexOf(n4.props.value) : u4.defaultValue == n4.props.value;
      })), n3.props = u4, e4.class != e4.className && (nn.enumerable = "className" in e4, null != e4.className && (u4.class = e4.className), Object.defineProperty(u4, "className", nn));
    }
    n3.$$typeof = z3, tn && tn(n3);
  };
  var en2 = l.__r;
  l.__r = function(n3) {
    en2 && en2(n3), X = n3.__c;
  };

  // ../../packages/base-ui/src/Framework/Preact.ts
  var Component = class extends x {
    constructor(props) {
      super(props);
      this.initialize(props);
    }
    getContext() {
      return this.context.context;
    }
    getLocale(name) {
      if (!name)
        return;
      return this.getContext().getLocale().get(name);
    }
    initialize(props) {
    }
  };
  __publicField(Component, "contextType", AppContext);

  // stylePlugin:D:\code\github\univer\packages\base-ui\src\Components\CanvasIcon\index.module.less
  var index_module_default = {};

  // ../../packages/base-ui/src/Components/CanvasIcon/CanvasIcon.tsx
  var CanvasIcon = class extends Component {
    canvasRef = d();
    componentDidMount() {
      this.drawLine();
    }
    drawLine() {
      const canvas = this.canvasRef;
      this.props.drawLine(canvas);
    }
    /**
     *
     * @param ctx   View DOM
     * @param type  BorderLine Type
     * @param hv
     * @param m_st  Start X
     * @param m_ed  Start Y
     * @param line_st   End X
     * @param line_ed   End Y
     */
    setLineDash(ctx, type, hv, m_st, m_ed, line_st, line_ed) {
      let borderType = {
        "0": "none",
        "1": "Thin",
        "2": "Hair",
        "3": "Dotted",
        "4": "Dashed",
        "5": "DashDot",
        "6": "DashDotDot",
        "7": "Double",
        "8": "Medium",
        "9": "MediumDashed",
        "10": "MediumDashDot",
        "11": "MediumDashDotDot",
        "12": "SlantedDashDot",
        "13": "Thick"
      };
      try {
        if (type === "Hair") {
          ctx.setLineDash([1, 2]);
        } else if (type.indexOf("DashDotDot") > -1) {
          ctx.setLineDash([2, 2, 5, 2, 2]);
        } else if (type.indexOf("DashDot") > -1) {
          ctx.setLineDash([2, 5, 2]);
        } else if (type.indexOf("Dotted") > -1) {
          ctx.setLineDash([2]);
        } else if (type.indexOf("Dashed") > -1) {
          ctx.setLineDash([3]);
        } else {
          ctx.setLineDash([0]);
        }
      } catch (e4) {
        console.log(e4);
      }
      ctx.beginPath();
      if (type.indexOf("Medium") > -1) {
        if (hv === "h") {
          ctx.moveTo(m_st, m_ed - 0.5);
          ctx.lineTo(line_st, line_ed - 0.5);
        } else {
          ctx.moveTo(m_st - 0.5, m_ed);
          ctx.lineTo(line_st - 0.5, line_ed);
        }
        ctx.lineWidth = 2;
      } else if (type === "Thick") {
        ctx.moveTo(m_st, m_ed);
        ctx.lineTo(line_st, line_ed);
        ctx.lineWidth = 3;
      } else {
        ctx.moveTo(m_st, m_ed);
        ctx.lineTo(line_st, line_ed);
        ctx.lineWidth = 1;
      }
    }
    render() {
      return <canvas ref={this.canvasRef} className={index_module_default.canvas} width={this.props.width} height={this.props.height} />;
    }
  };

  // ../../packages/base-ui/src/Components/CanvasIcon/BorderLine/BorderThin.tsx
  var BorderThin = class extends Component {
    ref = d();
    drawLine(ref) {
      const canvas = ref.current;
      let ctx = canvas.getContext("2d");
      this.ref.current.setLineDash(ctx, "Thin", "h", 0, 5, 100, 5);
      ctx.stroke();
      ctx.closePath();
    }
    render() {
      const { width = "100", height = "10" } = this.props;
      return <CanvasIcon ref={this.ref} width={width} height={height} drawLine={(dom) => this.drawLine(dom)} />;
    }
  };
  var BorderThin_default = BorderThin;

  // ../../packages/base-ui/src/Components/CanvasIcon/BorderLine/BorderHair.tsx
  var BorderHair = class extends Component {
    ref = d();
    drawLine(ref) {
      const canvas = ref.current;
      let ctx = canvas.getContext("2d");
      this.ref.current.setLineDash(ctx, "Hair", "h", 0, 5, 100, 5);
      ctx.stroke();
      ctx.closePath();
    }
    render() {
      const { width = "100", height = "10" } = this.props;
      return <CanvasIcon ref={this.ref} width={width} height={height} drawLine={(dom) => this.drawLine(dom)} />;
    }
  };
  var BorderHair_default = BorderHair;

  // ../../packages/base-ui/src/Components/CanvasIcon/BorderLine/BorderDotted.tsx
  var BorderDotted = class extends Component {
    ref = d();
    drawLine(ref) {
      const canvas = ref.current;
      let ctx = canvas.getContext("2d");
      this.ref.current.setLineDash(ctx, "Dotted", "h", 0, 5, 100, 5);
      ctx.stroke();
      ctx.closePath();
    }
    render() {
      const { width = "100", height = "10" } = this.props;
      return <CanvasIcon ref={this.ref} width={width} height={height} drawLine={(dom) => this.drawLine(dom)} />;
    }
  };
  var BorderDotted_default = BorderDotted;

  // ../../packages/base-ui/src/Components/CanvasIcon/BorderLine/BorderDashed.tsx
  var BorderDashed = class extends x {
    ref = d();
    drawLine(ref) {
      const canvas = ref.current;
      let ctx = canvas.getContext("2d");
      this.ref.current.setLineDash(ctx, "Dashed", "h", 0, 5, 100, 5);
      ctx.stroke();
      ctx.closePath();
    }
    render() {
      const { width = "100", height = "10" } = this.props;
      return <CanvasIcon ref={this.ref} width={width} height={height} drawLine={(dom) => this.drawLine(dom)} />;
    }
  };
  var BorderDashed_default = BorderDashed;

  // ../../packages/base-ui/src/Components/CanvasIcon/BorderLine/BorderDashDot.tsx
  var BorderDashDot = class extends Component {
    ref = d();
    drawLine(ref) {
      const canvas = ref.current;
      let ctx = canvas.getContext("2d");
      this.ref.current.setLineDash(ctx, "DashDot", "h", 0, 5, 100, 5);
      ctx.stroke();
      ctx.closePath();
    }
    render() {
      const { width = "100", height = "10" } = this.props;
      return <CanvasIcon ref={this.ref} width={width} height={height} drawLine={(dom) => this.drawLine(dom)} />;
    }
  };
  var BorderDashDot_default = BorderDashDot;

  // ../../packages/base-ui/src/Components/CanvasIcon/BorderLine/BorderDashDotDot.tsx
  var BorderDashDotDot = class extends Component {
    ref = d();
    drawLine(ref) {
      const canvas = ref.current;
      let ctx = canvas.getContext("2d");
      this.ref.current.setLineDash(ctx, "DashDotDot", "h", 0, 5, 100, 5);
      ctx.stroke();
      ctx.closePath();
    }
    render() {
      const { width = "100", height = "10" } = this.props;
      return <CanvasIcon ref={this.ref} width={width} height={height} drawLine={(dom) => this.drawLine(dom)} />;
    }
  };
  var BorderDashDotDot_default = BorderDashDotDot;

  // ../../packages/base-ui/src/Components/CanvasIcon/BorderLine/BorderMedium.tsx
  var BorderMedium = class extends Component {
    ref = d();
    drawLine(ref) {
      const canvas = ref.current;
      let ctx = canvas.getContext("2d");
      this.ref.current.setLineDash(ctx, "Medium", "h", 0, 5, 100, 5);
      ctx.stroke();
      ctx.closePath();
    }
    render() {
      const { width = "100", height = "10" } = this.props;
      return <CanvasIcon ref={this.ref} width={width} height={height} drawLine={(dom) => this.drawLine(dom)} />;
    }
  };
  var BorderMedium_default = BorderMedium;

  // ../../packages/base-ui/src/Components/CanvasIcon/BorderLine/BorderMediumDashed.tsx
  var BorderMediumDashed = class extends Component {
    ref = d();
    drawLine(ref) {
      const canvas = ref.current;
      let ctx = canvas.getContext("2d");
      this.ref.current.setLineDash(ctx, "MediumDashed", "h", 0, 5, 100, 5);
      ctx.stroke();
      ctx.closePath();
    }
    render() {
      const { width = "100", height = "10" } = this.props;
      return <CanvasIcon ref={this.ref} width={width} height={height} drawLine={(dom) => this.drawLine(dom)} />;
    }
  };
  var BorderMediumDashed_default = BorderMediumDashed;

  // ../../packages/base-ui/src/Components/CanvasIcon/BorderLine/BorderMediumDashDot.tsx
  var BorderMediumDashDot = class extends Component {
    ref = d();
    drawLine(ref) {
      const canvas = ref.current;
      let ctx = canvas.getContext("2d");
      this.ref.current.setLineDash(ctx, "MediumDashDot", "h", 0, 5, 100, 5);
      ctx.stroke();
      ctx.closePath();
    }
    render() {
      const { width = "100", height = "10" } = this.props;
      return <CanvasIcon ref={this.ref} width={width} height={height} drawLine={(dom) => this.drawLine(dom)} />;
    }
  };
  var BorderMediumDashDot_default = BorderMediumDashDot;

  // ../../packages/base-ui/src/Components/CanvasIcon/BorderLine/BorderMediumDashDotDot.tsx
  var BorderMediumDashDotDot = class extends Component {
    ref = d();
    drawLine(ref) {
      const canvas = ref.current;
      let ctx = canvas.getContext("2d");
      this.ref.current.setLineDash(ctx, "MediumDashDotDot", "h", 0, 5, 100, 5);
      ctx.stroke();
      ctx.closePath();
    }
    render() {
      const { width = "100", height = "10" } = this.props;
      return <CanvasIcon ref={this.ref} width={width} height={height} drawLine={(dom) => this.drawLine(dom)} />;
    }
  };
  var BorderMediumDashDotDot_default = BorderMediumDashDotDot;

  // ../../packages/base-ui/src/Components/CanvasIcon/BorderLine/BorderThick.tsx
  var BorderThick = class extends Component {
    ref = d();
    drawLine(ref) {
      const canvas = ref.current;
      let ctx = canvas.getContext("2d");
      this.ref.current.setLineDash(ctx, "Thick", "h", 0, 5, 100, 5);
      ctx.stroke();
      ctx.closePath();
    }
    render() {
      const { width = "100", height = "10" } = this.props;
      return <CanvasIcon ref={this.ref} width={width} height={height} drawLine={(dom) => this.drawLine(dom)} />;
    }
  };
  var BorderThick_default = BorderThick;

  // ../../packages/base-ui/src/Components/Icon/index.tsx
  var Icon_exports = {};
  __export(Icon_exports, {
    BackIcon: () => BackIcon,
    BoldIcon: () => BoldIcon,
    BottomBorderIcon: () => BottomBorderIcon,
    BottomVerticalIcon: () => BottomVerticalIcon,
    BrIcon: () => BrIcon,
    Cell: () => Cell_default,
    CenterAlignIcon: () => CenterAlignIcon,
    CenterVerticalIcon: () => CenterVerticalIcon,
    CloseIcon: () => CloseIcon,
    CorrectIcon: () => CorrectIcon,
    CutIcon: () => CutIcon,
    Data: () => Data_default,
    DeleteIcon: () => DeleteIcon,
    DeleteLineIcon: () => DeleteLineIcon,
    FillColorIcon: () => FillColorIcon,
    Font: () => Font_default,
    Format: () => Format_default,
    FormatIcon: () => FormatIcon,
    ForwardIcon: () => ForwardIcon,
    FullBorderIcon: () => FullBorderIcon,
    HideIcon: () => HideIcon,
    InnerBorderIcon: () => InnerBorderIcon,
    Insert: () => Insert_default,
    ItalicIcon: () => ItalicIcon,
    LeftAlignIcon: () => LeftAlignIcon,
    LeftBorderIcon: () => LeftBorderIcon,
    LoadingIcon: () => LoadingIcon,
    LogoIcon: () => LogoIcon,
    LtIcon: () => LtIcon,
    Math: () => Math_default,
    MenuIcon: () => MenuIcon,
    MergeIcon: () => MergeIcon,
    NextIcon: () => NextIcon,
    NoneBorderIcon: () => NoneBorderIcon,
    Other: () => Other_default,
    OuterBorderIcon: () => OuterBorderIcon,
    OverflowIcon: () => OverflowIcon,
    RightAlignIcon: () => RightAlignIcon,
    RightBorderIcon: () => RightBorderIcon,
    RightIcon: () => RightIcon,
    Sheet: () => Sheet_default,
    StripingBorderIcon: () => StripingBorderIcon,
    Text: () => Text_default,
    TextColorIcon: () => TextColorIcon,
    TextRotateAngleDownIcon: () => TextRotateAngleDownIcon,
    TextRotateAngleUpIcon: () => TextRotateAngleUpIcon,
    TextRotateIcon: () => TextRotateIcon,
    TextRotateRotationDownIcon: () => TextRotateRotationDownIcon,
    TextRotateRotationUpIcon: () => TextRotateRotationUpIcon,
    TextRotateVerticalIcon: () => TextRotateVerticalIcon,
    TopBorderIcon: () => TopBorderIcon,
    TopVerticalIcon: () => TopVerticalIcon,
    UnderLineIcon: () => UnderLineIcon,
    VerticalBorderIcon: () => VerticalBorderIcon,
    View: () => View_default
  });

  // ../../packages/base-ui/src/Utils/util.ts
  function isElement(element) {
    return element instanceof Element || element instanceof HTMLDocument;
  }
  var isDOM = typeof HTMLElement === "object" ? function(obj) {
    return obj instanceof HTMLElement;
  } : function(obj) {
    return obj && typeof obj === "object" && obj.nodeType === 1 && typeof obj.nodeName === "string";
  };
  function $$(selector, context) {
    context = context || document;
    let elements = context.querySelectorAll(selector);
    return elements.length === 1 ? Array.prototype.slice.call(elements)[0] : Array.prototype.slice.call(elements);
  }
  function randomId(prefix) {
    prefix = prefix ? `${prefix}-` : "";
    return prefix + Math.random().toString(36).replace(/[^a-z]+/g, "").substr(2, 10);
  }
  function getFirstChildren(obj) {
    let objChild = [];
    let objs = obj.getElementsByTagName("*");
    for (let i4 = 0, j3 = objs.length; i4 < j3; ++i4) {
      if (objs[i4].nodeType !== 1) {
        continue;
      }
      let temp = objs[i4].parentNode;
      if (temp && temp.nodeType === 1) {
        if (temp === obj) {
          objChild[objChild.length] = objs[i4];
        }
      } else if (temp && temp.parentNode === obj) {
        objChild[objChild.length] = objs[i4];
      }
    }
    return objChild;
  }
  function joinClassNames(...args) {
    if (!args.length)
      return;
    let result = "";
    args.forEach((item) => {
      if (item instanceof Object) {
        for (let k5 in item) {
          if (item[k5]) {
            result += ` ${k5}`;
          }
        }
      } else {
        result += item ? ` ${item}` : "";
      }
    });
    return result;
  }
  var getNodeindex = (elm) => [...elm.parentNode.children].indexOf(elm);
  function debounce(fn, time) {
    let timer = null;
    return function(...arg) {
      clearTimeout(timer);
      timer = setTimeout(() => {
        fn(...arg);
      }, time);
    };
  }
  function selectTextContent(ele) {
    if (window.getSelection) {
      let range2 = document.createRange();
      let content = ele.firstChild;
      if (content) {
        range2.setStart(content, 0);
        range2.setEnd(content, content.length);
        if (range2.startContainer && isInPage(range2.startContainer)) {
          window.getSelection()?.removeAllRanges();
          window.getSelection()?.addRange(range2);
        }
      }
    }
  }
  function selectTextContentCross(sEle, eEle) {
    if (window.getSelection) {
      let range2 = document.createRange();
      let sContent = sEle.firstChild;
      let eContent = eEle.firstChild;
      if (sContent && eContent) {
        range2.setStart(sContent, 0);
        range2.setEnd(eContent, eContent.length);
        if (range2.startContainer && isInPage(range2.startContainer)) {
          window.getSelection()?.removeAllRanges();
          window.getSelection()?.addRange(range2);
        }
      }
    }
  }
  function isInPage(node) {
    return node === document.body ? false : document.body.contains(node);
  }
  function textTrim(x4) {
    if (x4.length === 0) {
      return x4;
    }
    return x4.replace(/^\s+|\s+$/gm, "");
  }
  function getRefElement(ref) {
    if (isDOM(ref.current)) {
      return ref.current;
    }
    let refCurrent = ref.current;
    if (refCurrent) {
      return refCurrent?.base;
    }
    return ref.base;
  }
  function xssDeal(str) {
    if (typeof str !== "string")
      return str;
    return str.replace(/<script>/g, "&lt;script&gt;").replace(/<\/script>/, "&lt;/script&gt;");
  }
  function setLastCaretPosition(dom) {
    const range2 = window.getSelection();
    range2 && range2.selectAllChildren(dom);
    range2 && range2.collapseToEnd();
  }
  function findLocale(obj, fn) {
    for (let k5 in obj) {
      if (k5.endsWith("Locale") && typeof obj[k5] === "string") {
        const index = k5.indexOf("Locale");
        obj[k5.slice(0, index)] = fn(obj[k5]);
      }
    }
    return obj;
  }

  // stylePlugin:D:\code\github\univer\packages\base-ui\src\Components\Icon\Style\index.module.less
  var index_module_default2 = {
    "icon": "univer-icon",
    "iconIcon": "univer-icon-icon",
    "iconSpin": "univer-icon-spin",
    "loadingCircle": "univer-loadingCircle"
  };

  // ../../packages/base-ui/src/Components/Icon/AddIcon.tsx
  var Icon = (props) => {
    const { spin, rotate, children, name, style, className } = props;
    let svgStyle;
    if (style) {
      svgStyle = style;
      svgStyle.transform = rotate ? `rotate(${rotate}deg)` : "";
    } else {
      svgStyle = rotate ? { transform: `rotate(${rotate}deg)` } : {};
    }
    const classes = joinClassNames(
      index_module_default2.icon,
      {
        [`${index_module_default2.icon}-${name}`]: name,
        [`${index_module_default2.icon}-spin`]: spin || name === "loading"
      },
      className
    );
    return <span role="img" className={classes} style={{ ...svgStyle }}>{children}</span>;
  };

  // ../../packages/base-ui/src/Components/Icon/Loading/index.tsx
  var LoadingIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="loading" style={props.style}><svg viewBox="0 0 1024 1024" width="1em" height="1em" fill="currentColor"><path d="M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 0 0-94.3-139.9 437.71 437.71 0 0 0-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" /></svg></Icon>;

  // ../../packages/base-ui/src/Components/Icon/Logo/index.tsx
  var LogoIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="logo" style={props.style}><svg class="icon" viewBox="0 0 4864 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="8477" fill="currentColor">
    <path
      d="M1023.168 131.36c0 234.4-190.016 424.416-424.416 424.416 0-234.4 190.016-424.416 424.416-424.416zM131.36 1023.168c0-234.4 190.016-424.416 424.416-424.416 0 234.4-190.016 424.416-424.416 424.416zM929.696 929.696c-182.784 0-330.944-148.16-330.944-330.944 182.752 0 330.944 148.16 330.944 330.944z"
      fill="#2D7FF9"
      p-id="8478"
    />
    <path d="M494.848 0H0v494.848h494.848z" fill="#2D7FF9" opacity=".503" p-id="8479" />
    <path d="M558.016 81.376H81.376v476.64h476.64z" fill="#2D7FF9" opacity=".551" p-id="8480" />
    <path d="M558.304 164.416H164.384v393.92h393.92z" fill="#2D7FF9" opacity=".805" p-id="8481" />
    <path
      d="M1678.08 736v-64h-247.04V279.04H1356.8V736h321.28z m177.568 8.96c40.96 0 75.52-17.28 103.68-51.84V736h72.96V405.12h-72.96v202.24c-6.4 23.68-17.28 42.24-32 56.32-14.72 13.44-30.08 20.48-46.08 20.48-25.6 0-43.52-6.4-55.04-18.56-11.52-12.8-16.64-32-16.64-58.88v-201.6h-72.96v206.08c0 88.96 39.68 133.76 119.04 133.76z m407.936 0c42.88 0 77.44-10.88 103.04-32 26.24-21.76 43.52-55.04 51.2-99.84h-72.32c-5.76 48-32.64 72.32-81.28 72.32-28.16 0-49.28-10.24-63.36-30.08-15.36-20.48-22.4-49.28-22.4-85.76 0-35.84 7.68-64 23.04-83.84 15.36-20.48 36.48-30.08 63.36-30.08 21.76 0 39.68 5.12 53.12 15.36 12.8 10.24 21.76 25.6 26.24 46.72h72.32c-6.4-41.6-23.04-72.32-49.28-92.8-25.6-19.2-59.52-28.8-102.4-28.8-51.84 0-92.16 17.28-120.96 51.84-26.88 31.36-40.32 72.32-40.32 122.24 0 51.2 13.44 92.8 40.96 124.8 28.16 33.28 67.84 49.92 119.04 49.92z m292.128-8.96v-115.84l33.28-31.36 115.84 147.2h93.44l-159.36-193.92 146.56-136.96h-94.08l-135.68 131.2V270.08h-72.96V736h72.96z m404.096 126.72l179.2-457.6h-79.36l-83.84 235.52-87.68-235.52h-79.36l131.2 323.2-58.24 134.4h78.08z m357.408-117.76c99.2 0 149.12-35.2 149.12-105.6 0-29.44-13.44-53.12-39.68-69.76-17.92-12.16-46.08-22.4-83.2-31.36-33.28-8.32-55.04-14.72-65.92-19.2-17.92-7.68-26.24-17.28-26.24-27.52 0-12.8 5.12-21.76 16.64-27.52 9.6-5.76 24.32-8.32 43.52-8.32 22.4 0 39.04 3.2 49.92 10.24 10.24 6.4 17.92 18.56 23.04 35.2h71.04c-7.68-70.4-55.68-104.96-142.72-104.96-40.96 0-73.6 8.32-98.56 26.24-25.6 16.64-37.76 40.32-37.76 71.04 0 28.8 12.8 51.2 38.4 67.2 16 10.24 43.52 19.84 82.56 28.8 33.28 7.68 55.04 13.44 65.28 18.56 19.2 8.96 28.8 21.12 28.8 36.48 0 26.88-25.6 40.96-76.8 40.96-24.32 0-41.6-4.48-52.48-12.16-10.88-8.96-18.56-23.68-22.4-44.8h-71.04c7.04 77.44 56.32 116.48 148.48 116.48z m286.976-8.96v-184.96c0-28.16 6.4-50.56 19.84-68.48 12.8-17.92 30.72-26.88 53.76-26.88 24.96 0 43.52 7.68 56.32 23.68 10.88 14.72 16.64 36.48 16.64 64.64v192h72.96v-204.8c0-44.16-9.6-77.44-28.16-99.84-19.84-23.68-49.92-35.2-90.24-35.2-21.12 0-39.68 3.84-55.68 12.16-17.92 8.96-33.28 22.4-45.44 40.96v-179.2h-72.96V736h72.96z m447.648 8.96c44.16 0 80.64-12.8 110.08-37.76 23.04-20.48 38.4-46.72 46.08-77.44h-72.96c-8.96 18.56-18.56 32-29.44 40.32-14.08 10.24-32 15.36-54.4 15.36-26.24 0-46.72-8.32-60.8-24.32-14.08-16-22.4-39.68-24.96-70.4h247.68c0-59.52-13.44-106.24-39.68-139.52-28.8-37.12-70.4-55.04-124.8-55.04-49.28 0-88.32 16.64-116.48 50.56-29.44 33.28-43.52 74.24-43.52 123.52 0 55.04 15.36 97.92 46.08 129.28 28.8 30.08 67.84 45.44 117.12 45.44z m85.12-209.28h-170.24c4.48-26.24 13.44-46.08 26.88-59.52 14.08-14.08 32.64-20.48 56.96-20.48 51.2 0 80 26.24 86.4 80z m285.088 209.28c44.16 0 80.64-12.8 110.08-37.76 23.04-20.48 38.4-46.72 46.08-77.44h-72.96c-8.96 18.56-18.56 32-29.44 40.32-14.08 10.24-32 15.36-54.4 15.36-26.24 0-46.72-8.32-60.8-24.32-14.08-16-22.4-39.68-24.96-70.4h247.68c0-59.52-13.44-106.24-39.68-139.52-28.8-37.12-70.4-55.04-124.8-55.04-49.28 0-88.32 16.64-116.48 50.56-29.44 33.28-43.52 74.24-43.52 123.52 0 55.04 15.36 97.92 46.08 129.28 28.8 30.08 67.84 45.44 117.12 45.44z m85.12-209.28h-170.24c4.48-26.24 13.44-46.08 26.88-59.52 14.08-14.08 32.64-20.48 56.96-20.48 51.2 0 80 26.24 86.4 80z m310.016 200.32v-60.16h-43.52c-7.68 0-12.8-1.92-16.64-5.76-3.84-4.48-5.12-10.24-5.12-17.92v-186.88h73.6v-60.16h-73.6V298.24l-72.96 30.08v76.8h-59.52v60.16h59.52v186.88c0 26.88 6.4 46.72 19.2 60.8 13.44 15.36 34.56 23.04 63.36 23.04h55.68z"
      fill="#7C838C"
      p-id="8482"
    />
  </svg></Icon>;

  // ../../packages/base-ui/src/Components/Icon/Math/index.tsx
  var AddNumIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6466" width="1em" height="1em" fill="currentColor">
    <path d="M533.333333 789.333333m-42.666666 0a42.666667 42.666667 0 1 0 85.333333 0 42.666667 42.666667 0 1 0-85.333333 0Z" p-id="6467" />
    <path
      d="M682.666667 554.666667a85.333333 85.333333 0 0 0-85.333334 85.333333v85.333333a85.333333 85.333333 0 1 0 170.666667 0V640a85.333333 85.333333 0 0 0-85.333333-85.333333z m0 42.666666a42.666667 42.666667 0 0 1 42.666666 42.666667v85.333333a42.666667 42.666667 0 1 1-85.333333 0V640a42.666667 42.666667 0 0 1 42.666667-42.666667z"
      p-id="6468"
    />
    <path
      d="M367.829333 799.701333l90.538667-90.538666L367.786667 618.666667l-30.165334 30.165333 37.76 37.802667H256v42.666666h121.898667l-40.234667 40.234667 30.165333 30.165333z"
      p-id="6469"
    />
    <path
      d="M490.666667 213.333333a85.333333 85.333333 0 0 0-85.333334 85.333334v85.333333a85.333333 85.333333 0 1 0 170.666667 0V298.666667a85.333333 85.333333 0 0 0-85.333333-85.333334z m0 42.666667a42.666667 42.666667 0 0 1 42.666666 42.666667v85.333333a42.666667 42.666667 0 1 1-85.333333 0V298.666667a42.666667 42.666667 0 0 1 42.666667-42.666667zM682.666667 213.333333a85.333333 85.333333 0 0 0-85.333334 85.333334v85.333333a85.333333 85.333333 0 1 0 170.666667 0V298.666667a85.333333 85.333333 0 0 0-85.333333-85.333334z m0 42.666667a42.666667 42.666667 0 0 1 42.666666 42.666667v85.333333a42.666667 42.666667 0 0 1-85.333333 0V298.666667a42.666667 42.666667 0 0 1 42.666667-42.666667z"
      p-id="6470"
    />
    <path d="M341.333333 448m-42.666666 0a42.666667 42.666667 0 1 0 85.333333 0 42.666667 42.666667 0 1 0-85.333333 0Z" p-id="6471" />
  </svg></Icon>;
  var ReduceNumIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6336" width="1em" height="1em" fill="currentColor">
    <path d="M533.333333 448m-42.666666 0a42.666667 42.666667 0 1 0 85.333333 0 42.666667 42.666667 0 1 0-85.333333 0Z" p-id="6337" />
    <path d="M341.333333 789.333333m-42.666666 0a42.666667 42.666667 0 1 0 85.333333 0 42.666667 42.666667 0 1 0-85.333333 0Z" p-id="6338" />
    <path
      d="M346.496 394.368L256 303.786667 346.496 213.333333l30.165333 30.165334-37.717333 37.802666h119.424v42.666667H336.469333l40.192 40.234667-30.165333 30.165333z"
      p-id="6339"
    />
    <path
      d="M682.666667 213.333333a85.333333 85.333333 0 0 0-85.333334 85.333334v85.333333a85.333333 85.333333 0 1 0 170.666667 0V298.666667a85.333333 85.333333 0 0 0-85.333333-85.333334z m0 42.666667a42.666667 42.666667 0 0 1 42.666666 42.666667v85.333333a42.666667 42.666667 0 0 1-85.333333 0V298.666667a42.666667 42.666667 0 0 1 42.666667-42.666667zM490.666667 554.666667a85.333333 85.333333 0 0 0-85.333334 85.333333v85.333333a85.333333 85.333333 0 1 0 170.666667 0v-85.333333a85.333333 85.333333 0 0 0-85.333333-85.333333z m0 42.666666a42.666667 42.666667 0 0 1 42.666666 42.666667v85.333333a42.666667 42.666667 0 0 1-85.333333 0v-85.333333a42.666667 42.666667 0 0 1 42.666667-42.666667zM682.666667 554.666667a85.333333 85.333333 0 0 0-85.333334 85.333333v85.333333a85.333333 85.333333 0 1 0 170.666667 0v-85.333333a85.333333 85.333333 0 0 0-85.333333-85.333333z m0 42.666666a42.666667 42.666667 0 0 1 42.666666 42.666667v85.333333a42.666667 42.666667 0 0 1-85.333333 0v-85.333333a42.666667 42.666667 0 0 1 42.666667-42.666667z"
      p-id="6340"
    />
  </svg></Icon>;
  var PercentIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6209" width="1em" height="1em" fill="currentColor"><path
    d="M653.525333 213.333333l36.949334 21.333334-320 554.24-36.949334-21.333334L653.525333 213.333333zM682.666667 469.333333c71.68 0 128 67.626667 128 149.333334S754.346667 768 682.666667 768s-128-67.626667-128-149.333333 56.32-149.333333 128-149.333334z m0 42.666667c-46.165333 0-85.333333 46.976-85.333334 106.666667s39.168 106.666667 85.333334 106.666666c46.165333 0 85.333333-46.976 85.333333-106.666666s-39.168-106.666667-85.333333-106.666667zM341.333333 234.666667c71.68 0 128 67.626667 128 149.333333s-56.32 149.333333-128 149.333333S213.333333 465.706667 213.333333 384s56.32-149.333333 128-149.333333z m0 42.666666C295.168 277.333333 256 324.309333 256 384s39.168 106.666667 85.333333 106.666667c46.165333 0 85.333333-46.976 85.333334-106.666667s-39.168-106.666667-85.333334-106.666667z"
    p-id="6210"
  /></svg></Icon>;
  var MoneyIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6082" width="1em" height="1em" fill="currentColor"><path
    d="M658.816 256l34.986667 24.490667-124.629334 177.92h119.04v42.666666h-149.333333v85.333334h149.333333v42.666666h-149.333333v128h-42.666667v-128h-149.333333v-42.666666h149.333333v-85.333334h-149.333333v-42.666666h119.04L341.333333 280.490667 376.32 256l141.226667 201.728L658.816 256z"
    p-id="6083"
  /></svg></Icon>;
  var FxIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5446" width="1em" height="1em" fill="currentColor"><path
    d="M771.072 391.253333a6.698667 6.698667 0 0 0-0.512-9.514666 6.997333 6.997333 0 0 0-4.48-1.749334h-61.354667c-1.962667 0-3.84 0.853333-5.12 2.346667l-103.893333 122.709333a6.698667 6.698667 0 0 1-11.392-1.621333l-53.674667-119.381333a6.656 6.656 0 0 0-6.144-4.010667H381.866667l0.853333-3.968 6.741333-35.712c8.874667-46.933333 32.085333-68.864 72.533334-68.864 15.658667 0 29.994667 1.450667 41.258666 4.010667l11.861334-56.490667a197.888 197.888 0 0 0-46.464-5.12c-87.296 0-132.224 37.418667-148.650667 124.458667l-7.978667 41.813333H229.632a6.698667 6.698667 0 0 0-6.613333 5.376l-9.130667 43.818667a6.826667 6.826667 0 0 0 6.570667 8.106666h79.786666l-75.264 363.52a6.826667 6.826667 0 0 0 6.570667 8.234667H287.573333c3.242667 0 5.973333-2.346667 6.570667-5.418667l75.861333-366.165333h114.773334l57.685333 117.546667a6.570667 6.570667 0 0 1-1.024 7.381333l-152.746667 171.690667a6.826667 6.826667 0 0 0 5.12 11.264h61.44c2.005333 0 3.882667-0.853333 5.162667-2.389334l104.576-123.989333a6.826667 6.826667 0 0 1 11.392 1.493333l55.594667 120.661334a6.741333 6.741333 0 0 0 6.186666 3.968h54.613334a6.784 6.784 0 0 0 6.101333-9.770667L618.325333 567.466667a6.698667 6.698667 0 0 1 1.066667-7.466667l151.722667-168.661333-0.042667-0.042667z"
    p-id="5447"
  /></svg></Icon>;
  var AddIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5318" width="1em" height="1em" fill="currentColor">
    <path d="M213.333333 469.333333h597.333334v85.333334H213.333333z" p-id="5319" />
    <path d="M554.666667 213.333333v597.333334h-85.333334V213.333333z" p-id="5320" />
  </svg></Icon>;
  var ReduceIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5318" width="1em" height="1em" fill="currentColor"><path d="M213.333333 469.333333h597.333334v85.333334H213.333333z" p-id="5319" /></svg></Icon>;
  var Math_default = {
    AddNumIcon,
    ReduceNumIcon,
    PercentIcon,
    MoneyIcon,
    FxIcon,
    AddIcon,
    ReduceIcon
  };

  // ../../packages/base-ui/src/Components/Icon/Font/index.tsx
  var BoldIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5565" width="1em" height="1em" fill="currentColor"><path
    d="M298.666667 213.333333h224a174.208 174.208 0 0 1 141.952 275.242667A174.208 174.208 0 0 1 572.458667 810.666667H298.666667V213.333333z m273.792 348.458667l-174.250667-0.042667v149.333334h174.250667a74.666667 74.666667 0 0 0 6.101333-149.077334l-6.101333-0.213333zM398.208 312.874667v149.333333h124.458667a74.666667 74.666667 0 0 0 6.144-149.077333l-6.144-0.256H398.208z"
    p-id="5566"
  /></svg></Icon>;
  var ItalicIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5692" width="1em" height="1em" fill="currentColor">
    <path d="M469.333333 256h170.666667v42.666667h-170.666667z" p-id="5693" />
    <path d="M573.738667 284.586667l-81.493334 462.208-41.984-7.381334 81.493334-462.208z" p-id="5694" />
    <path d="M384 725.333333h170.666667v42.666667H384z" p-id="5695" />
  </svg></Icon>;
  var DeleteLineIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5311" width="1em" height="1em" fill="currentColor">
    <path d="M298.666667 256h426.666666v42.666667H298.666667z" p-id="5312" />
    <path
      d="M533.290667 554.666667l0.042666 192h-42.666666l-0.042667-192h42.666667z m0.042666-277.333334l-0.042666 234.666667h-42.666667l0.042667-234.666667h42.666666zM320 256v85.333333h-42.666667V256zM746.666667 256v85.333333h-42.666667V256z"
      p-id="5313"
    />
    <path d="M256 469.333333h512v42.666667H256zM426.666667 725.333333h170.666666v42.666667h-170.666666z" p-id="5314" />
  </svg></Icon>;
  var UnderLineIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5318" width="1em" height="1em" fill="currentColor">
    <path
      d="M362.666667 256v298.666667a149.333333 149.333333 0 0 0 298.453333 8.192L661.333333 554.666667V256h42.666667v298.666667a192 192 0 0 1-383.786667 9.045333L320 554.666667V256h42.666667z"
      p-id="5319"
    />
    <path
      d="M256 768m21.333333 0l469.333334 0q21.333333 0 21.333333 21.333333l0 0q0 21.333333-21.333333 21.333334l-469.333334 0q-21.333333 0-21.333333-21.333334l0 0q0-21.333333 21.333333-21.333333Z"
      p-id="5320"
    />
    <path
      d="M256 256m21.333333 0l128 0q21.333333 0 21.333334 21.333333l0 0q0 21.333333-21.333334 21.333334l-128 0q-21.333333 0-21.333333-21.333334l0 0q0-21.333333 21.333333-21.333333Z"
      p-id="5321"
    />
    <path
      d="M597.333333 256m21.333334 0l128 0q21.333333 0 21.333333 21.333333l0 0q0 21.333333-21.333333 21.333334l-128 0q-21.333333 0-21.333334-21.333334l0 0q0-21.333333 21.333334-21.333333Z"
      p-id="5322"
    />
  </svg></Icon>;
  var TextColorIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5440" width="1em" height="1em" fill="currentColor"><path
    d="M549.546667 256l194.133333 533.333333h-45.354667l-77.653333-213.333333H421.632l-77.653333 213.333333H298.666667L492.757333 256h56.789334z m-28.416 46.634667L437.162667 533.333333h167.978666l-84.010666-230.698666z"
    p-id="5441"
  /></svg></Icon>;
  var Font_default = {
    BoldIcon,
    ItalicIcon,
    DeleteLineIcon,
    UnderLineIcon,
    TextColorIcon
  };

  // ../../packages/base-ui/src/Components/Icon/Cell/index.tsx
  var FillColorIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5567" width="1em" height="1em" fill="currentColor">
    <path
      d="M730.24 562.176l-253.44 253.44-217.173333-217.258667 253.44-253.44 217.173333 217.258667z m-72.405333-0.042667L512.981333 417.28l-180.992 180.992 144.810667 144.853333 181.034667-181.034666z"
      p-id="5568"
    />
    <path
      d="M520.533333 298.666667v230.4H469.333333V349.824H392.533333v179.626667H341.333333V298.666667zM699.733333 554.666667c48.768 0 88.32 37.802667 88.32 84.48 0 46.634667-39.552 84.48-88.32 84.48"
      p-id="5569"
    />
  </svg></Icon>;
  var FullBorderIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5695" width="1em" height="1em" fill="currentColor">
    <path
      d="M213.333333 810.666667V256h42.666667v554.666667zM725.333333 810.666667V256h42.666667v554.666667zM469.333333 810.666667V256h42.666667v554.666667z"
      p-id="5696"
    />
    <path
      d="M213.333333 256h554.666667v42.666667H213.333333zM213.333333 512h554.666667v42.666667H213.333333zM213.333333 768h554.666667v42.666667H213.333333z"
      p-id="5697"
    />
  </svg></Icon>;
  var TopBorderIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5823" width="1em" height="1em" fill="currentColor">
    <path d="M213.333333 256h554.666667v42.666667H213.333333z" p-id="5824" />
    <path
      d="M213.333333 426.666667h42.666667v42.666666H213.333333zM213.333333 597.333333h42.666667v42.666667H213.333333zM213.333333 341.333333h42.666667v42.666667H213.333333zM213.333333 512h42.666667v42.666667H213.333333zM213.333333 682.666667h42.666667v42.666666H213.333333zM469.333333 426.666667h42.666667v42.666666h-42.666667zM725.333333 426.666667h42.666667v42.666666h-42.666667zM725.333333 597.333333h42.666667v42.666667h-42.666667zM725.333333 341.333333h42.666667v42.666667h-42.666667zM725.333333 512h42.666667v42.666667h-42.666667zM725.333333 682.666667h42.666667v42.666666h-42.666667zM725.333333 768h42.666667v42.666667h-42.666667zM469.333333 597.333333h42.666667v42.666667h-42.666667zM469.333333 341.333333h42.666667v42.666667h-42.666667zM469.333333 512h42.666667v42.666667h-42.666667zM469.333333 682.666667h42.666667v42.666666h-42.666667zM213.333333 768h42.666667v42.666667H213.333333zM384 768h42.666667v42.666667H384zM554.666667 768h42.666666v42.666667h-42.666666zM298.666667 768h42.666666v42.666667H298.666667zM469.333333 768h42.666667v42.666667h-42.666667zM640 768h42.666667v42.666667h-42.666667zM384 512h42.666667v42.666667H384zM554.666667 512h42.666666v42.666667h-42.666666zM298.666667 512h42.666666v42.666667H298.666667z"
      p-id="5825"
    />
    <path d="M469.333333 512h42.666667v42.666667h-42.666667zM640 512h42.666667v42.666667h-42.666667z" p-id="5826" />
  </svg></Icon>;
  var BottomBorderIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5952" width="1em" height="1em" fill="currentColor">
    <path d="M768 810.666667H213.333333v-42.666667h554.666667z" p-id="5953" />
    <path
      d="M768 640h-42.666667v-42.666667h42.666667zM768 469.333333h-42.666667v-42.666666h42.666667zM768 725.333333h-42.666667v-42.666666h42.666667zM768 554.666667h-42.666667v-42.666667h42.666667zM768 384h-42.666667V341.333333h42.666667z"
      p-id="5954"
    />
    <path d="M512 640h-42.666667v-42.666667h42.666667z" p-id="5955" />
    <path
      d="M256 640H213.333333v-42.666667h42.666667zM256 469.333333H213.333333v-42.666666h42.666667zM256 725.333333H213.333333v-42.666666h42.666667zM256 554.666667H213.333333v-42.666667h42.666667zM256 384H213.333333V341.333333h42.666667zM256 298.666667H213.333333V256h42.666667z"
      p-id="5956"
    />
    <path
      d="M512 469.333333h-42.666667v-42.666666h42.666667zM512 725.333333h-42.666667v-42.666666h42.666667zM512 554.666667h-42.666667v-42.666667h42.666667zM512 384h-42.666667V341.333333h42.666667z"
      p-id="5957"
    />
    <path
      d="M768 298.666667h-42.666667V256h42.666667zM597.333333 298.666667h-42.666666V256h42.666666zM426.666667 298.666667H384V256h42.666667zM682.666667 298.666667h-42.666667V256h42.666667zM512 298.666667h-42.666667V256h42.666667zM341.333333 298.666667H298.666667V256h42.666666z"
      p-id="5958"
    />
    <path
      d="M597.333333 554.666667h-42.666666v-42.666667h42.666666zM426.666667 554.666667H384v-42.666667h42.666667zM682.666667 554.666667h-42.666667v-42.666667h42.666667zM512 554.666667h-42.666667v-42.666667h42.666667zM341.333333 554.666667H298.666667v-42.666667h42.666666z"
      p-id="5959"
    />
  </svg></Icon>;
  var LeftBorderIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6085" width="1em" height="1em" fill="currentColor">
    <path d="M213.333333 810.666667V256h42.666667v554.666667z" p-id="6086" />
    <path
      d="M384 810.666667v-42.666667h42.666667v42.666667zM554.666667 810.666667v-42.666667h42.666666v42.666667zM298.666667 810.666667v-42.666667h42.666666v42.666667zM469.333333 810.666667v-42.666667h42.666667v42.666667zM640 810.666667v-42.666667h42.666667v42.666667z"
      p-id="6087"
    />
    <path
      d="M384 554.666667v-42.666667h42.666667v42.666667zM554.666667 554.666667v-42.666667h42.666666v42.666667zM298.666667 554.666667v-42.666667h42.666666v42.666667zM469.333333 554.666667v-42.666667h42.666667v42.666667zM640 554.666667v-42.666667h42.666667v42.666667zM469.333333 640v-42.666667h42.666667v42.666667zM469.333333 469.333333v-42.666666h42.666667v42.666666zM469.333333 725.333333v-42.666666h42.666667v42.666666z"
      p-id="6088"
    />
    <path d="M469.333333 554.666667v-42.666667h42.666667v42.666667zM469.333333 384V341.333333h42.666667v42.666667z" p-id="6089" />
    <path
      d="M384 298.666667V256h42.666667v42.666667zM554.666667 298.666667V256h42.666666v42.666667zM298.666667 298.666667V256h42.666666v42.666667zM469.333333 298.666667V256h42.666667v42.666667zM640 298.666667V256h42.666667v42.666667zM725.333333 298.666667V256h42.666667v42.666667z"
      p-id="6090"
    />
    <path
      d="M725.333333 810.666667v-42.666667h42.666667v42.666667zM725.333333 640v-42.666667h42.666667v42.666667zM725.333333 469.333333v-42.666666h42.666667v42.666666zM725.333333 725.333333v-42.666666h42.666667v42.666666zM725.333333 554.666667v-42.666667h42.666667v42.666667zM725.333333 384V341.333333h42.666667v42.666667z"
      p-id="6091"
    />
  </svg></Icon>;
  var RightBorderIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6217" width="1em" height="1em" fill="currentColor">
    <path d="M768 256v554.666667h-42.666667V256z" p-id="6218" />
    <path
      d="M597.333333 256v42.666667h-42.666666V256zM426.666667 256v42.666667H384V256zM682.666667 256v42.666667h-42.666667V256zM512 256v42.666667h-42.666667V256zM341.333333 256v42.666667H298.666667V256z"
      p-id="6219"
    />
    <path d="M597.333333 512v42.666667h-42.666666v-42.666667z" p-id="6220" />
    <path
      d="M597.333333 768v42.666667h-42.666666v-42.666667zM426.666667 768v42.666667H384v-42.666667zM682.666667 768v42.666667h-42.666667v-42.666667zM512 768v42.666667h-42.666667v-42.666667zM341.333333 768v42.666667H298.666667v-42.666667zM256 768v42.666667H213.333333v-42.666667z"
      p-id="6221"
    />
    <path
      d="M426.666667 512v42.666667H384v-42.666667zM682.666667 512v42.666667h-42.666667v-42.666667zM512 512v42.666667h-42.666667v-42.666667zM341.333333 512v42.666667H298.666667v-42.666667z"
      p-id="6222"
    />
    <path
      d="M256 256v42.666667H213.333333V256zM256 426.666667v42.666666H213.333333v-42.666666zM256 597.333333v42.666667H213.333333v-42.666667zM256 341.333333v42.666667H213.333333V341.333333zM256 512v42.666667H213.333333v-42.666667zM256 682.666667v42.666666H213.333333v-42.666666z"
      p-id="6223"
    />
    <path
      d="M512 426.666667v42.666666h-42.666667v-42.666666zM512 597.333333v42.666667h-42.666667v-42.666667zM512 341.333333v42.666667h-42.666667V341.333333zM512 512v42.666667h-42.666667v-42.666667zM512 682.666667v42.666666h-42.666667v-42.666666z"
      p-id="6224"
    />
  </svg></Icon>;
  var NoneBorderIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6350" width="1em" height="1em" fill="currentColor">
    <path
      d="M384 810.666667v-42.666667h42.666667v42.666667zM554.666667 810.666667v-42.666667h42.666666v42.666667zM298.666667 810.666667v-42.666667h42.666666v42.666667zM469.333333 810.666667v-42.666667h42.666667v42.666667zM640 810.666667v-42.666667h42.666667v42.666667zM384 554.666667v-42.666667h42.666667v42.666667zM384 298.666667V256h42.666667v42.666667zM554.666667 298.666667V256h42.666666v42.666667zM298.666667 298.666667V256h42.666666v42.666667zM469.333333 298.666667V256h42.666667v42.666667zM640 298.666667V256h42.666667v42.666667zM725.333333 298.666667V256h42.666667v42.666667zM213.333333 298.666667V256h42.666667v42.666667zM554.666667 554.666667v-42.666667h42.666666v42.666667zM298.666667 554.666667v-42.666667h42.666666v42.666667zM469.333333 554.666667v-42.666667h42.666667v42.666667zM640 554.666667v-42.666667h42.666667v42.666667z"
      p-id="6351"
    />
    <path
      d="M725.333333 810.666667v-42.666667h42.666667v42.666667zM213.333333 810.666667v-42.666667h42.666667v42.666667zM725.333333 640v-42.666667h42.666667v42.666667zM213.333333 640v-42.666667h42.666667v42.666667zM725.333333 469.333333v-42.666666h42.666667v42.666666zM213.333333 469.333333v-42.666666h42.666667v42.666666zM725.333333 725.333333v-42.666666h42.666667v42.666666zM213.333333 725.333333v-42.666666h42.666667v42.666666zM725.333333 554.666667v-42.666667h42.666667v42.666667zM213.333333 554.666667v-42.666667h42.666667v42.666667zM725.333333 384V341.333333h42.666667v42.666667zM213.333333 384V341.333333h42.666667v42.666667z"
      p-id="6352"
    />
    <path
      d="M469.333333 640v-42.666667h42.666667v42.666667zM469.333333 469.333333v-42.666666h42.666667v42.666666zM469.333333 725.333333v-42.666666h42.666667v42.666666zM469.333333 554.666667v-42.666667h42.666667v42.666667zM469.333333 384V341.333333h42.666667v42.666667z"
      p-id="6353"
    />
  </svg></Icon>;
  var OuterBorderIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6479" width="1em" height="1em" fill="currentColor">
    <path d="M213.333333 810.666667V256h42.666667v554.666667zM725.333333 810.666667V256h42.666667v554.666667z" p-id="6480" />
    <path d="M213.333333 256h554.666667v42.666667H213.333333zM213.333333 768h554.666667v42.666667H213.333333z" p-id="6481" />
    <path
      d="M384 554.666667v-42.666667h42.666667v42.666667zM554.666667 554.666667v-42.666667h42.666666v42.666667zM298.666667 554.666667v-42.666667h42.666666v42.666667zM469.333333 554.666667v-42.666667h42.666667v42.666667zM640 554.666667v-42.666667h42.666667v42.666667zM469.333333 640v-42.666667h42.666667v42.666667zM469.333333 469.333333v-42.666666h42.666667v42.666666zM469.333333 725.333333v-42.666666h42.666667v42.666666z"
      p-id="6482"
    />
    <path d="M469.333333 554.666667v-42.666667h42.666667v42.666667zM469.333333 384V341.333333h42.666667v42.666667z" p-id="6483" />
  </svg></Icon>;
  var InnerBorderIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6609" width="1em" height="1em" fill="currentColor">
    <path d="M213.333333 512h554.666667v42.666667H213.333333z" p-id="6610" />
    <path d="M512 256v554.666667h-42.666667V256z" p-id="6611" />
    <path
      d="M213.333333 426.666667h42.666667v42.666666H213.333333zM213.333333 597.333333h42.666667v42.666667H213.333333zM213.333333 341.333333h42.666667v42.666667H213.333333zM213.333333 682.666667h42.666667v42.666666H213.333333zM725.333333 426.666667h42.666667v42.666666h-42.666667zM725.333333 597.333333h42.666667v42.666667h-42.666667zM725.333333 341.333333h42.666667v42.666667h-42.666667zM725.333333 682.666667h42.666667v42.666666h-42.666667zM725.333333 768h42.666667v42.666667h-42.666667zM725.333333 256h42.666667v42.666667h-42.666667zM213.333333 768h42.666667v42.666667H213.333333zM213.333333 256h42.666667v42.666667H213.333333zM384 768h42.666667v42.666667H384zM384 256h42.666667v42.666667H384zM554.666667 768h42.666666v42.666667h-42.666666zM554.666667 256h42.666666v42.666667h-42.666666zM298.666667 768h42.666666v42.666667H298.666667zM298.666667 256h42.666666v42.666667H298.666667zM640 768h42.666667v42.666667h-42.666667zM640 256h42.666667v42.666667h-42.666667z"
      p-id="6612"
    />
  </svg></Icon>;
  var StripingBorderIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6866" width="1em" height="1em" fill="currentColor">
    <path d="M213.333333 512h554.666667v42.666667H213.333333z" p-id="6867" />
    <path
      d="M213.333333 426.666667h42.666667v42.666666H213.333333zM213.333333 597.333333h42.666667v42.666667H213.333333zM213.333333 341.333333h42.666667v42.666667H213.333333zM213.333333 682.666667h42.666667v42.666666H213.333333zM725.333333 426.666667h42.666667v42.666666h-42.666667zM469.333333 426.666667h42.666667v42.666666h-42.666667zM725.333333 597.333333h42.666667v42.666667h-42.666667zM469.333333 597.333333h42.666667v42.666667h-42.666667zM725.333333 341.333333h42.666667v42.666667h-42.666667zM469.333333 341.333333h42.666667v42.666667h-42.666667zM725.333333 682.666667h42.666667v42.666666h-42.666667zM469.333333 682.666667h42.666667v42.666666h-42.666667zM725.333333 768h42.666667v42.666667h-42.666667zM725.333333 256h42.666667v42.666667h-42.666667zM213.333333 768h42.666667v42.666667H213.333333zM213.333333 256h42.666667v42.666667H213.333333zM384 768h42.666667v42.666667H384zM384 256h42.666667v42.666667H384zM554.666667 768h42.666666v42.666667h-42.666666zM554.666667 256h42.666666v42.666667h-42.666666zM298.666667 768h42.666666v42.666667H298.666667zM298.666667 256h42.666666v42.666667H298.666667zM469.333333 768h42.666667v42.666667h-42.666667zM469.333333 256h42.666667v42.666667h-42.666667zM640 768h42.666667v42.666667h-42.666667zM640 256h42.666667v42.666667h-42.666667z"
      p-id="6868"
    />
  </svg></Icon>;
  var VerticalBorderIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6994" width="1em" height="1em" fill="currentColor">
    <path
      d="M213.333333 426.666667h42.666667v42.666666H213.333333zM213.333333 597.333333h42.666667v42.666667H213.333333zM213.333333 341.333333h42.666667v42.666667H213.333333zM213.333333 682.666667h42.666667v42.666666H213.333333zM725.333333 426.666667h42.666667v42.666666h-42.666667zM725.333333 597.333333h42.666667v42.666667h-42.666667zM725.333333 341.333333h42.666667v42.666667h-42.666667zM725.333333 682.666667h42.666667v42.666666h-42.666667zM725.333333 768h42.666667v42.666667h-42.666667zM725.333333 256h42.666667v42.666667h-42.666667zM725.333333 512h42.666667v42.666667h-42.666667zM213.333333 768h42.666667v42.666667H213.333333zM213.333333 256h42.666667v42.666667H213.333333zM213.333333 512h42.666667v42.666667H213.333333zM384 768h42.666667v42.666667H384zM384 256h42.666667v42.666667H384zM384 512h42.666667v42.666667H384zM554.666667 768h42.666666v42.666667h-42.666666zM554.666667 256h42.666666v42.666667h-42.666666zM554.666667 512h42.666666v42.666667h-42.666666zM298.666667 768h42.666666v42.666667H298.666667zM298.666667 256h42.666666v42.666667H298.666667zM298.666667 512h42.666666v42.666667H298.666667zM469.333333 768h42.666667v42.666667h-42.666667zM469.333333 256h42.666667v42.666667h-42.666667zM469.333333 512h42.666667v42.666667h-42.666667zM640 768h42.666667v42.666667h-42.666667zM640 256h42.666667v42.666667h-42.666667zM640 512h42.666667v42.666667h-42.666667z"
      p-id="6995"
    />
    <path d="M512 256v554.666667h-42.666667V256z" p-id="6996" />
  </svg></Icon>;
  var MergeIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7122" width="1em" height="1em" fill="currentColor">
    <path d="M810.666667 213.333333v597.333334H213.333333V213.333333h597.333334z m-42.666667 42.666667H256v512h512V256z" p-id="7123" />
    <path
      d="M389.162667 426.666667l90.538666 90.496-90.538666 90.538666-30.165334-30.165333 37.802667-37.845333-119.466667 0.042666v-42.666666l121.856-0.042667-40.192-40.192 30.165334-30.165333zM645.162667 426.666667L554.666667 517.162667l90.496 90.538666 30.165333-30.165333-37.76-37.845333 119.466667 0.042666v-42.666666l-121.856-0.042667 40.149333-40.192-30.165333-30.165333z"
      p-id="7124"
    />
  </svg></Icon>;
  var Cell_default = {
    FillColorIcon,
    FullBorderIcon,
    TopBorderIcon,
    BottomBorderIcon,
    LeftBorderIcon,
    RightBorderIcon,
    NoneBorderIcon,
    OuterBorderIcon,
    InnerBorderIcon,
    StripingBorderIcon,
    VerticalBorderIcon,
    MergeIcon
  };

  // ../../packages/base-ui/src/Components/Icon/Text/index.tsx
  var LeftAlignIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7250" width="1em" height="1em" fill="currentColor"><path
    d="M234.666667 298.666667h554.666666a21.333333 21.333333 0 1 1 0 42.666666h-554.666666a21.333333 21.333333 0 1 1 0-42.666666z m0 128h341.333333a21.333333 21.333333 0 0 1 0 42.666666h-341.333333a21.333333 21.333333 0 0 1 0-42.666666z m0 128h554.666666a21.333333 21.333333 0 1 1 0 42.666666h-554.666666a21.333333 21.333333 0 0 1 0-42.666666z m0 128h341.333333a21.333333 21.333333 0 0 1 0 42.666666h-341.333333a21.333333 21.333333 0 0 1 0-42.666666z"
    p-id="7251"
  /></svg></Icon>;
  var CenterAlignIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7377" width="1em" height="1em" fill="currentColor"><path
    d="M234.666667 298.666667h554.666666a21.333333 21.333333 0 1 1 0 42.666666h-554.666666a21.333333 21.333333 0 1 1 0-42.666666zM341.333333 426.666667h341.333334a21.333333 21.333333 0 1 1 0 42.666666H341.333333a21.333333 21.333333 0 0 1 0-42.666666z m-106.666666 128h554.666666a21.333333 21.333333 0 1 1 0 42.666666h-554.666666a21.333333 21.333333 0 0 1 0-42.666666zM341.333333 682.666667h341.333334a21.333333 21.333333 0 1 1 0 42.666666H341.333333a21.333333 21.333333 0 0 1 0-42.666666z"
    p-id="7378"
  /></svg></Icon>;
  var RightAlignIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7504" width="1em" height="1em" fill="currentColor"><path
    d="M234.666667 298.666667h554.666666a21.333333 21.333333 0 1 1 0 42.666666h-554.666666a21.333333 21.333333 0 1 1 0-42.666666z m213.333333 128h341.333333a21.333333 21.333333 0 1 1 0 42.666666h-341.333333a21.333333 21.333333 0 0 1 0-42.666666z m-213.333333 128h554.666666a21.333333 21.333333 0 1 1 0 42.666666h-554.666666a21.333333 21.333333 0 0 1 0-42.666666z m213.333333 128h341.333333a21.333333 21.333333 0 1 1 0 42.666666h-341.333333a21.333333 21.333333 0 0 1 0-42.666666z"
    p-id="7505"
  /></svg></Icon>;
  var TopVerticalIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7631" width="1em" height="1em" fill="currentColor"><path
    d="M298.666667 384h426.666666v42.666667H298.666667zM416 527.829333l90.496-90.496 90.538667 90.496-30.165334 30.165334-37.802666-37.717334v290.090667h-42.666667v-292.565333l-40.234667 40.192-30.165333-30.165334z"
    p-id="7632"
  /></svg></Icon>;
  var CenterVerticalIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7758" width="1em" height="1em" fill="currentColor"><path
    d="M725.333333 533.333333H298.666667v-42.666666h426.666666zM426.666667 634.496l90.496-90.496 90.538666 90.496-30.165333 30.165333-39.936-39.850666v121.557333h-42.666667v-119.765333l-38.101333 38.058666-30.165333-30.165333zM426.666667 389.162667l90.496 90.538666 90.538666-90.538666-30.165333-30.165334-39.936 39.893334V277.333333h-42.666667v119.765334l-38.101333-38.101334-30.165333 30.165334z"
    p-id="7759"
  /></svg></Icon>;
  var BottomVerticalIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7885" width="1em" height="1em" fill="currentColor"><path
    d="M725.333333 725.333333H298.666667v-42.666666h426.666666zM608 581.504l-90.496 90.496-90.538667-90.496 30.165334-30.165333 37.802666 37.717333V298.965333h42.666667v292.565334l40.234667-40.192 30.165333 30.165333z"
    p-id="7886"
  /></svg></Icon>;
  var TextRotateIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="8217" width="1em" height="1em" fill="currentColor"><path
    d="M549.546667 213.333333l77.653333 213.333334h0.64l-0.042667 1.621333 53.76 147.712h-45.354666l-38.826667-106.666667h-152.405333l-38.826667 106.666667H360.789333l53.674667-147.498667 0.042667-1.834666h0.64l77.610666-213.333334h56.789334z m-28.416 46.634667L460.458667 426.666667h121.386666l-60.714666-166.698667zM709.162667 618.666667l90.538666 90.496-90.538666 90.538666-30.165334-30.165333 37.76-37.802667H256v-42.666666h463.232l-40.234667-40.234667 30.165334-30.165333z"
    p-id="8218"
  /></svg></Icon>;
  var TextRotateAngleUpIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4524" width="1em" height="1em" fill="currentColor"><path
    d="M290.944 289.365333l205.738667 95.914667 0.469333-0.426667 1.109333 1.152 142.506667 66.432-32.128 32.085334-102.826667-47.957334-107.818666 107.733334 48 102.912-32.085334 32.042666-66.346666-142.250666-1.28-1.28 0.469333-0.512-96-205.696 40.192-40.149334z m12.885333 53.034667l74.965334 160.810667 85.845333-85.845334L303.786667 342.4zM690.432 463.104h128v128h-42.666667v-53.418667l-325.845333 325.802667-30.165333-30.165333 327.552-327.552h-56.874667v-42.666667z"
    fill="#444D5A"
    p-id="4525"
  /></svg></Icon>;
  var TextRotateAngleDownIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4659" width="1em" height="1em" fill="currentColor"><path
    d="M755.968 312.277333l-95.914667 205.738667 0.426667 0.469333-1.152 1.109334-66.432 142.506666-32.085333-32.128 47.957333-102.826666-107.733333-107.818667-102.912 48-32.042667-32.085333 142.250667-66.346667 1.28-1.28 0.512 0.469333 205.696-96 40.149333 40.192z m-53.034667 12.885334l-160.810666 74.965333 85.845333 85.845333 74.965333-160.810666zM582.229333 711.765333v128h-128v-42.666666h53.418667l-325.802667-325.845334 30.165334-30.165333 327.552 327.552v-56.874667h42.666666z"
    fill="#444D5A"
    p-id="4660"
  /></svg></Icon>;
  var TextRotateVerticalIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4794" width="1em" height="1em" fill="currentColor"><path
    d="M636.757333 298.666667l77.653334 213.333333h0.64l-0.042667 1.621333 53.76 147.712h-45.354667l-38.826666-106.666666h-152.405334l-38.826666 106.666666H448l53.674667-147.498666 0.042666-1.834667h0.64l77.610667-213.333333h56.789333z m-28.416 46.634666L547.669333 512h121.386667l-60.714667-166.698667zM394.368 698.496L303.786667 789.034667 213.333333 698.453333l30.165334-30.165333 37.802666 37.76V245.333333h42.666667v463.232l40.234667-40.234666 30.165333 30.165333z"
    fill="#444D5A"
    p-id="4795"
  /></svg></Icon>;
  var TextRotateRotationUpIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4929" width="1em" height="1em" fill="currentColor"><path
    d="M192 495.786667l213.333333-77.653334v-0.64l1.621334 0.042667L554.666667 363.776v45.354667l-106.666667 38.826666v152.405334l106.666667 38.826666v45.354667l-147.498667-53.674667-1.834667-0.042666v-0.64l-213.333333-77.610667V495.786667z m46.634667 28.416L405.333333 584.874667v-121.386667l-166.698666 60.714667zM597.333333 336.170667l90.496-90.538667 90.538667 90.538667-30.165333 30.165333-37.802667-37.76V789.333333h-42.666667V326.101333l-40.234666 40.234667L597.333333 336.170667z"
    fill="#444D5A"
    p-id="4930"
  /></svg></Icon>;
  var TextRotateRotationDownIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5199" width="1em" height="1em" fill="currentColor"><path
    d="M789.333333 528.213333l-213.333333 77.653334v0.64l-1.621333-0.042667L426.666667 660.224v-45.354667l106.666666-38.826666V423.637333l-106.666666-38.826666V339.456l147.498666 53.674667 1.834667 0.042666v0.64l213.333333 77.610667v56.789333z m-46.634666-28.416L576 439.125333v121.386667l166.698667-60.714667zM384 687.829333l-90.496 90.538667-90.538667-90.538667 30.165334-30.165333 37.802666 37.76V234.666667h42.666667v463.232l40.234667-40.234667 30.165333 30.165333z"
    fill="#444D5A"
    p-id="5200"
  /></svg></Icon>;
  var BrIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="8736" width="1em" height="1em" fill="currentColor">
    <path
      d="M213.333333 213.333333h85.12v597.333334H213.333333V213.333333z m225.450667 477.44l25.557333-21.333333-72.362666-63.786667 72.362666-63.872-25.557333-21.248-93.610667 80.853334h4.266667-4.266667l93.610667 89.386666z"
      p-id="8737"
    />
    <path d="M768 213.333333h42.581333v597.333334H768z" p-id="8738" />
    <path
      d="M540.928 367.274667H391.978667v42.581333h148.949333c59.605333 0 106.410667 38.314667 106.410667 85.12s-46.805333 85.12-106.410667 85.12H391.978667v42.581333h148.949333c85.12 0 157.482667-55.338667 157.482667-127.701333s-72.362667-127.701333-157.44-127.701333z"
      p-id="8739"
    />
  </svg></Icon>;
  var OverflowIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="8608" width="1em" height="1em" fill="currentColor">
    <path
      d="M300.288 810.666667H213.333333V213.333333h86.954667v279.978667h441.898667l-91.306667-85.845333 26.624-26.112L810.666667 512l-133.162667 130.688-26.624-26.154667 91.306667-85.845333-441.898667-0.042667z"
      p-id="8609"
    />
    <path d="M530.688 213.333333h42.666667v242.688h-42.666667V213.333333z m0 354.688h42.666667V810.666667h-42.666667v-242.688z" p-id="8610" />
  </svg></Icon>;
  var CutIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="8865" width="1em" height="1em" fill="currentColor">
    <path d="M767.829333 213.333333h42.496v597.333334h-42.496z" p-id="8866" />
    <path d="M767.146667 553.216h-384v-42.496h384v42.496zM213.333333 213.333333h84.992v597.333334H213.333333V213.333333z" p-id="8867" />
  </svg></Icon>;
  var Text_default = {
    LeftAlignIcon,
    CenterAlignIcon,
    RightAlignIcon,
    TopVerticalIcon,
    CenterVerticalIcon,
    BottomVerticalIcon,
    TextRotateIcon,
    TextRotateAngleUpIcon,
    BrIcon,
    OverflowIcon,
    CutIcon
  };

  // ../../packages/base-ui/src/Components/Icon/Insert/index.tsx
  var PhotoIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="8090" width="1em" height="1em" fill="currentColor"><path
    d="M810.666667 213.333333v597.333334H213.333333V213.333333h597.333334z m-42.666667 263.381334l-233.984 190.890666-118.613333-98.218666L256 704.64V768h512v-291.285333zM768 256H256v392.704l159.146667-134.954667 119.04 98.602667L768 421.674667V256zM384 341.333333a42.666667 42.666667 0 1 1 0 85.333334 42.666667 42.666667 0 0 1 0-85.333334z"
    p-id="8091"
  /></svg></Icon>;
  var LinkIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7962" width="1em" height="1em" fill="currentColor">
    <path
      d="M771.584 251.733333c-49.066667-51.2-132.266667-51.2-181.333333 0l-74.666667 76.8c-8.533333 8.533333-8.533333 23.466667 0 32 8.533333 8.533333 21.333333 8.533333 29.866667 0l74.666666-76.8c34.133333-34.133333 87.466667-34.133333 121.6 0 34.133333 34.133333 34.133333 89.6 0 123.733334l-121.6 123.733333c-34.133333 34.133333-87.466667 34.133333-121.6 0-8.533333-8.533333-21.333333-8.533333-29.866666 0-8.533333 8.533333-8.533333 23.466667 0 32 49.066667 51.2 132.266667 51.2 181.333333 0l121.6-123.733333c51.2-53.333333 51.2-136.533333 0-187.733334z"
      p-id="7963"
    />
    <path
      d="M477.184 663.466667l-74.666667 76.8c-34.133333 34.133333-87.466667 34.133333-121.6 0-34.133333-34.133333-34.133333-89.6 0-123.733334l121.6-123.733333c34.133333-34.133333 87.466667-34.133333 121.6 0 8.533333 8.533333 21.333333 8.533333 29.866667 0 8.533333-8.533333 8.533333-23.466667 0-32-49.066667-51.2-132.266667-51.2-181.333333 0l-121.6 123.733333c-51.2 51.2-49.066667 134.4 0 185.6 49.066667 51.2 132.266667 51.2 181.333333 0l74.666667-76.8c8.533333-8.533333 8.533333-23.466667 0-32-8.533333-6.4-21.333333-6.4-29.866667 2.133334z"
      p-id="7964"
    />
  </svg></Icon>;
  var ChartIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7833" width="1em" height="1em" fill="currentColor">
    <path d="M256 213.333333H213.333333v597.333334h597.333334v-42.666667H256z" p-id="7834" />
    <path
      d="M490.666667 343.466667V554.666667h185.6c-19.2 72.533333-85.333333 128-164.266667 128-93.866667 0-170.666667-76.8-170.666667-170.666667 0-87.466667 66.133333-157.866667 149.333334-168.533333M512 298.666667c-117.333333 0-213.333333 96-213.333333 213.333333s96 213.333333 213.333333 213.333333 213.333333-96 213.333333-213.333333h-192V298.666667H512z"
      p-id="7835"
    />
    <path
      d="M618.666667 260.266667c83.2 14.933333 134.4 74.666667 147.2 166.4H618.666667V260.266667m-42.666667-46.933334v256H810.666667c0-149.333333-85.333333-256-234.666667-256z"
      p-id="7836"
    />
  </svg></Icon>;
  var Insert_default = {
    PhotoIcon,
    LinkIcon,
    ChartIcon
  };

  // ../../packages/base-ui/src/Components/Icon/Format/index.tsx
  var BackIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} className={props.className} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5692" width="1em" height="1em" fill="currentColor"><path
    d="M737.664 419.328H426.666667v42.666667h311.296l-84.48 84.437333a21.333333 21.333333 0 0 0 30.208 30.165333l120.746666-120.704a21.290667 21.290667 0 0 0 0-30.165333l-120.746666-120.661333a21.333333 21.333333 0 0 0-30.165334 30.165333l84.138667 84.096zM213.333333 632.661333a213.333333 213.333333 0 0 1 213.333334-213.333333v42.666667a170.666667 170.666667 0 0 0-170.666667 170.666666H213.333333z m0 0h42.666667v64a21.333333 21.333333 0 0 1-42.666667 0v-64z"
    p-id="5693"
  /></svg></Icon>;
  var ForwardIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} className={props.className} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5565" width="1em" height="1em" fill="currentColor"><path
    d="M287.018667 419.328h310.997333v42.666667H286.72l84.48 84.437333a21.333333 21.333333 0 1 1-30.208 30.165333l-120.746667-120.704a21.248 21.248 0 0 1 0-30.165333l120.746667-120.661333a21.333333 21.333333 0 0 1 30.165333 30.165333L287.018667 419.328z m524.330666 213.333333a213.333333 213.333333 0 0 0-213.333333-213.333333v42.666667a170.666667 170.666667 0 0 1 170.666667 170.666666h42.666666z m0 0h-42.666666v64a21.333333 21.333333 0 1 0 42.666666 0v-64z"
    p-id="5566"
  /></svg></Icon>;
  var FormatIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5955" width="1em" height="1em" fill="currentColor"><path
    d="M725.333333 213.333333v85.333334h85.333334v234.666666h-298.666667V597.333333h21.333333v213.333334h-85.333333v-213.333334h21.333333v-106.666666h298.666667V341.333333h-42.666667v85.333334H213.333333V213.333333h512z m-42.666666 42.666667H256v128h426.666667V256z"
    p-id="5956"
  /></svg></Icon>;
  var NextIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} className={props.className} name="nextIcon" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5311" width="1em" height="1em" fill="currentColor"><path d="M512 682.666667L170.666667 341.333333h682.666666z" p-id="5312" /></svg></Icon>;
  var RightIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} className={props.className} name="rightIcon" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5311" width="1em" height="1em" fill="currentColor"><path d="M682.666667 512l-341.333334 341.333333V170.666667z" p-id="5312" /></svg></Icon>;
  var CorrectIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} className={props.className} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5311" width="1em" height="1em" fill="currentColor">
    <path d="M268.032 523.434667l60.373333-60.330667 211.2 211.2-60.373333 60.330667z" p-id="5312" />
    <path d="M780.928 312.234667l60.373333 60.330666-331.904 331.861334-60.330666-60.330667z" p-id="5313" />
  </svg></Icon>;
  var LtIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} className={props.className} name="foward" style={props.style}><svg width="1em" height="1em" fill="currentColor" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1732">
    <path d="M224.45 538.68l575.11-346.21-0.05-68.75-575.03 345.61-0.03 69.35z" p-id="1733" />
    <path d="M224.45 538.68l575.08 356.96v-69.52L224.48 469.33l-0.03 69.35z" p-id="1734" />
  </svg></Icon>;
  var CloseIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} className={props.className} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5318" width="1em" height="1em" fill="currentColor">
    <path d="M330.965333 270.634667l422.4 422.4-60.330666 60.330666-422.4-422.4z" p-id="5319" />
    <path d="M753.365333 330.965333l-422.4 422.4-60.330666-60.330666 422.4-422.4z" p-id="5320" />
  </svg></Icon>;
  var MenuIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} className={props.className} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5446" width="1em" height="1em" fill="currentColor"><path
    d="M213.333333 469.333333h597.333334v85.333334H213.333333zM213.333333 213.333333h597.333334v85.333334H213.333333zM213.333333 725.333333h597.333334v85.333334H213.333333z"
    p-id="5447"
  /></svg></Icon>;
  var HideIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} className={props.className} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6513" width="1em" height="1em" fill="currentColor">
    <path
      d="M512 219.428571c161.645714 0 307.931429 97.499429 438.857143 292.571429-130.925714 195.072-277.211429 292.571429-438.857143 292.571429S204.068571 707.072 73.142857 512c130.925714-195.072 277.211429-292.571429 438.857143-292.571429z m0 73.142858c-124.123429 0-241.225143 65.462857-365.714286 219.428571 119.661714 147.968 231.424 213.577143 365.714286 219.428571 124.196571 0 241.298286-65.462857 365.714286-219.428571-119.588571-147.968-231.350857-213.577143-365.714286-219.428571z"
      p-id="6514"
    />
    <path d="M818.614857 146.285714l51.712 51.712L197.997714 870.4 146.285714 818.688z" p-id="6515" />
    <path
      d="M512 365.714286a146.285714 146.285714 0 1 1 0 292.571428 146.285714 146.285714 0 0 1 0-292.571428z m0 73.142857a73.142857 73.142857 0 1 0 0 146.285714 73.142857 73.142857 0 0 0 0-146.285714z"
      p-id="6516"
    />
  </svg></Icon>;
  var Format_default = {
    BackIcon,
    ForwardIcon,
    FormatIcon,
    NextIcon,
    RightIcon,
    CorrectIcon,
    LtIcon,
    CloseIcon,
    MenuIcon,
    HideIcon
  };

  // ../../packages/base-ui/src/Components/Icon/Data/index.tsx
  var PivotableIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7578" width="1em" height="1em" fill="currentColor"><path
    d="M256 362.666667v298.666666l256 149.333334 256-149.333334v-298.666666L512 213.333333 256 362.666667zM725.333333 640l-213.333333 128-213.333333-128V384l213.333333-128 213.333333 128v256z m-189.354666 40.021333a18.645333 18.645333 0 0 1-18.645334 18.645334 18.304 18.304 0 0 1-18.688-18.645334V535.466667l-130.645333-75.349334a18.645333 18.645333 0 0 1 4.565333-34.133333 18.304 18.304 0 0 1 14.08 2.005333l130.688 74.666667 129.578667-74.666667a18.304 18.304 0 0 1 25.386667 6.698667 18.645333 18.645333 0 0 1-6.784 25.386667l-129.536 74.666666v145.237334z"
    p-id="7579"
  /></svg></Icon>;
  var SumIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7451" width="1em" height="1em" fill="currentColor"><path
    d="M774.058667 213.333333v42.666667H310.784l236.288 256-236.330667 256h463.317334v42.666667H213.333333l275.669334-298.666667L213.333333 213.333333z"
    p-id="7452"
  /></svg></Icon>;
  var OrderIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6675" width="1em" height="1em" fill="currentColor"><path
    d="M704 256a21.333333 21.333333 0 0 1 21.333333 21.333333v469.333334a21.333333 21.333333 0 1 1-42.666666 0v-469.333334c0-11.776 9.472-21.333333 21.333333-21.333333zM512 384c11.776 0 21.333333 7.68 21.333333 17.194667v221.610666c0 9.514667-9.472 17.194667-21.333333 17.194667-11.776 0-21.333333-7.68-21.333333-17.194667V401.194667c0-4.565333 2.218667-8.96 6.186666-12.16A24.32 24.32 0 0 1 512 384zM320 256a21.333333 21.333333 0 0 1 21.333333 21.333333v469.333334a21.333333 21.333333 0 1 1-42.666666 0v-469.333334c0-11.776 9.472-21.333333 21.333333-21.333333z m283.562667 368.896a21.333333 21.333333 0 0 1 30.165333 30.165333l-106.666667 106.666667a21.333333 21.333333 0 0 1-30.165333 0l-106.666667-106.666667a21.333333 21.333333 0 0 1 30.165334-30.165333L512 716.501333l91.605333-91.562666z m0.298666-225.834667a21.333333 21.333333 0 0 0 30.165334-30.165333l-106.666667-106.666667a21.333333 21.333333 0 0 0-30.165333 0l-106.666667 106.666667a21.333333 21.333333 0 0 0 30.165333 30.165333l91.562667-91.562666 91.605333 91.562666z"
    p-id="6676"
  /></svg></Icon>;
  var OrderDESCIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6548" width="1em" height="1em" fill="currentColor"><path
    d="M430.848 666.197333H366.592V236.074667a6.656 6.656 0 0 0-6.741333-6.528h-47.36a6.656 6.656 0 0 0-6.741334 6.528v430.122666H241.493333c-5.674667 0-8.874667 6.314667-5.333333 10.538667l94.72 115.2a6.912 6.912 0 0 0 10.624 0l94.72-115.2c3.413333-4.224 0.298667-10.538667-5.376-10.538667zM582.442667 806.698667l20.992-61.098667h103.68l21.205333 61.098667h43.690667L672.64 533.333333h-34.688l-99.370667 273.365334h43.861334z m112.896-97.877334h-79.872l39.552-119.424h0.768l39.552 119.466667zM742.570667 486.698667v-39.168h-124.288l124.288-203.093334V213.333333h-169.685334v36.949334h119.04l-123.904 201.941333v34.474667z"
    p-id="6549"
  /></svg></Icon>;
  var OrderASCIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6294" width="1em" height="1em" fill="currentColor"><path
    d="M430.848 357.76H366.592v430.165333a6.656 6.656 0 0 1-6.741333 6.485334h-47.36a6.656 6.656 0 0 1-6.741334-6.485334V357.76H241.493333c-5.674667 0-8.874667-6.314667-5.333333-10.538667l94.72-115.2a6.912 6.912 0 0 1 10.624 0l94.72 115.2c3.413333 4.224 0.298667 10.538667-5.376 10.538667zM582.442667 486.698667l20.992-61.098667h103.68l21.205333 61.098667h43.690667L672.64 213.333333h-34.688l-99.370667 273.365334h43.861334z m112.896-97.877334h-79.872l39.552-119.424h0.768l39.552 119.466667zM742.570667 806.698667v-39.168h-124.288l124.288-203.093334V533.333333h-169.685334v36.949334h119.04l-123.904 201.941333v34.474667z"
    p-id="6295"
  /></svg></Icon>;
  var FilterIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6802" width="1em" height="1em" fill="currentColor"><path
    d="M736 213.333333H328.533333C288 213.333333 256 245.333333 256 285.866667c0 17.066667 6.4 34.133333 17.066667 46.933333 0 2.133333 2.133333 2.133333 2.133333 4.266667l160 160v168.533333c0 6.4 2.133333 10.666667 6.4 14.933333l145.066667 123.733334c4.266667 2.133333 8.533333 4.266667 12.8 4.266666 6.4 0 10.666667-2.133333 14.933333-6.4 4.266667-4.266667 4.266667-10.666667 4.266667-14.933333V503.466667l170.666666-166.4 2.133334-2.133334c10.666667-12.8 17.066667-29.866667 17.066666-46.933333 0-42.666667-32-74.666667-72.533333-74.666667z m23.466667 93.866667s-2.133333 2.133333 0 0l-172.8 172.8c-4.266667 4.266667-6.4 8.533333-6.4 14.933333v251.733334l-104.533334-87.466667V490.666667c0-6.4-2.133333-10.666667-6.4-14.933334l-162.133333-166.4-2.133333-2.133333c-6.4-6.4-8.533333-12.8-8.533334-21.333333 0-17.066667 14.933333-32 32-32h407.466667c17.066667 0 32 14.933333 32 32 0 8.533333-4.266667 14.933333-8.533333 21.333333z"
    p-id="6803"
  /></svg></Icon>;
  var FilterRankIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6929" width="1em" height="1em" fill="currentColor">
    <path
      d="M736 213.333333H328.533333C288 213.333333 256 245.333333 256 285.866667c0 17.066667 6.4 34.133333 17.066667 46.933333 0 2.133333 2.133333 2.133333 2.133333 4.266667l160 160v168.533333c0 6.4 2.133333 10.666667 6.4 14.933333l145.066667 123.733334c4.266667 2.133333 8.533333 4.266667 12.8 4.266666 6.4 0 10.666667-2.133333 14.933333-6.4 4.266667-4.266667 4.266667-10.666667 4.266667-14.933333V503.466667l170.666666-166.4 2.133334-2.133334c10.666667-12.8 17.066667-29.866667 17.066666-46.933333 0-42.666667-32-74.666667-72.533333-74.666667z m23.466667 93.866667s-2.133333 2.133333 0 0l-172.8 172.8c-4.266667 4.266667-6.4 8.533333-6.4 14.933333v251.733334l-104.533334-87.466667V490.666667c0-6.4-2.133333-10.666667-6.4-14.933334l-162.133333-166.4-2.133333-2.133333c-6.4-6.4-8.533333-12.8-8.533334-21.333333 0-17.066667 14.933333-32 32-32h407.466667c17.066667 0 32 14.933333 32 32 0 8.533333-4.266667 14.933333-8.533333 21.333333z"
      p-id="6930"
    />
    <path
      d="M688.213333 378.410667l-101.546666 101.589333c-4.266667 4.266667-6.4 8.533333-6.4 14.933333v251.733334l-104.533334-87.466667V490.666667c0-6.4-2.133333-10.666667-6.4-14.933334L403.626667 408.32l284.586666-29.909333z"
      p-id="6931"
    />
  </svg></Icon>;
  var CleanIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7193" width="1em" height="1em" fill="currentColor"><path
    d="M214.016 722.432h593.92v42.410667H214.016v-42.410667z m578.048-312.106667l-180.693333-181.077333A53.376 53.376 0 0 0 573.738667 213.333333a45.653333 45.653333 0 0 0-32.64 13.226667l-313.941334 314.965333c-18.56 18.602667-17.322667 50.261333 2.688 70.4l68.010667 68.096h298.24l198.698667-199.338666c18.56-18.602667 17.322667-50.261333-2.730667-70.357334z m-213.546667 227.242667H315.434667L259.84 581.888c-3.968-4.010667-4.053333-9.088-2.730667-10.453333L430.08 398.08l193.92 193.92-45.44 45.568z"
    p-id="7194"
  /></svg></Icon>;
  var CheckIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5912" width="1em" height="1em" fill="currentColor"><path
    d="M764.330667 592.170667l30.165333 30.165333L734.165333 682.666667l60.330667 60.330666-30.165333 30.165334-60.330667-60.330667-60.330667 60.330667-30.165333-30.165334L673.834667 682.666667l-60.330667-60.330667 30.165333-30.165333 60.330667 60.330666 60.330667-60.330666zM725.333333 512v42.666667H256v128h256v42.666666H213.333333v-213.333333h512z m47.829334-209.664l30.165333 30.165333L682.666667 453.12l-30.165334 30.165333-90.496-90.453333 30.165334-30.208 60.330666 60.330667 120.661334-120.661334zM725.333333 256v42.666667H256v128h256v42.666666H213.333333V256h512z"
    p-id="5913"
  /></svg></Icon>;
  var Data_default = {
    PivotableIcon,
    SumIcon,
    OrderIcon,
    OrderDESCIcon,
    OrderASCIcon,
    FilterIcon,
    FilterRankIcon,
    CleanIcon,
    CheckIcon
  };

  // ../../packages/base-ui/src/Components/Icon/Sheet/index.tsx
  var CommentIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7705" width="1em" height="1em" fill="currentColor">
    <path d="M352 490.666667a32 32 0 1 0 64 0 32 32 0 0 0-64 0z m128 0a32 32 0 1 0 64 0 32 32 0 0 0-64 0z m128 0a32 32 0 1 0 64 0 32 32 0 0 0-64 0z" p-id="7706" />
    <path
      d="M768 298.666667H256c-23.466667 0-42.666667 19.2-42.666667 42.666666v298.666667c0 23.466667 19.2 42.666667 42.666667 42.666667h106.666667v128l128-128H768c23.466667 0 42.666667-19.2 42.666667-42.666667V341.333333c0-23.466667-19.2-42.666667-42.666667-42.666666z m0 320c0 12.8-8.533333 21.333333-21.333333 21.333333H469.333333l-64 64V640h-128c-12.8 0-21.333333-8.533333-21.333333-21.333333v-256c0-12.8 8.533333-21.333333 21.333333-21.333334h469.333334c12.8 0 21.333333 8.533333 21.333333 21.333334v256z"
      p-id="7707"
    />
  </svg></Icon>;
  var FreezeIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5448" width="1em" height="1em">
    <path d="M256.426667 256.426667h255.317333v553.130666H256.426667z" fill="#B5B8BD" p-id="5449" />
    <path
      d="M809.557333 213.930667v595.626666H213.930667V213.930667h595.626666z m-42.538666 42.538666H256.426667v510.549334h510.549333V256.426667z"
      fill="#444D5A"
      p-id="5450"
    />
    <path d="M490.453333 256.426667h42.538667v510.592h-42.538667z" fill="#444D5A" p-id="5451" />
    <path d="M256.426667 532.992v-42.538667h510.592v42.538667z" fill="#444D5A" p-id="5452" />
    <path
      d="M256.384 226.261333l264.192 264.192-30.122667 30.08-264.192-264.192 30.122667-30.08z m-30.122667 317.184l30.122667-30.122666 264.192 264.192-30.122667 30.08-264.192-264.149334z"
      fill="#444D5A"
      p-id="5453"
    />
  </svg></Icon>;
  var conditionalFormatIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6039" width="1em" height="1em" fill="currentColor"><path
    d="M810.666667 213.333333v597.333334H213.333333V213.333333h597.333334z m-42.666667 320h-106.666667V768H768v-234.666667z m-405.376 0h-106.666667V768h106.666667v-234.666667z m256.042667 86.784L445.482667 768H618.666667v-147.882667z m0-162.346666l-213.376 179.968v108.885333l213.376-179.072v-109.781333z m0-163.669334l-213.333334 179.029334v108.885333l213.333334-179.072V294.101333zM768 256h-103.936l-2.730667 2.304V490.666667H768V256zM362.666667 256H256v234.666667h106.666667V256z m235.008 0H405.333333v161.408L597.674667 256z"
    p-id="6040"
  /></svg></Icon>;
  var DivideIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5501" width="1em" height="1em" fill="currentColor"><path
    d="M544.896 389.717333h110.762667v46.933334c6.698667 6.613333 15.658667 6.613333 22.357333 0l84.949333-55.125334c6.698667-4.437333 6.698667-13.226667 0-19.84l-84.906666-57.386666c-6.741333-6.613333-15.701333-6.613333-22.4 0v41.258666h-133.12l-89.429334 154.453334H343.722667v0.128h-22.698667c-11.178667 0-22.357333 11.050667-22.357333 22.058666 0 11.050667 11.178667 22.058667 22.357333 22.058667h134.101333l-0.085333-0.128h0.426667l89.386666-154.453333h0.042667z m133.12 198.954667a15.061333 15.061333 0 0 0-22.314667 0v43.690667h-66.133333l-67.029333-110.293334-22.357334 44.117334s62.592 103.68 67.072 110.293333h88.448V721.066667a15.061333 15.061333 0 0 0 22.314667 0l84.949333-55.168c6.698667-4.437333 6.698667-13.226667 0-19.84l-84.906666-57.386667h-0.042667z"
    p-id="5502"
  /></svg></Icon>;
  var ReplaceIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4859" width="1em" height="1em" fill="currentColor"><path
    d="M768 430.933333H280.405333l-4.394666-0.554666c-5.461333-0.853333-6.570667-1.749333-12.885334-6.528l-2.986666-5.376c-6.4-11.946667-5.376-13.738667 2.986666-28.885334L440.618667 213.333333l34.218666 34.048-136.362666 135.424H768v48.170667z m-7.594667 163.242667L585.472 768l-34.261333-34.048 136.362666-135.424H258.048v-48.170667h484.096c10.453333 0 19.882667 6.272 23.893333 15.872a25.6 25.6 0 0 1-5.632 27.989334z"
    p-id="4860"
  /></svg></Icon>;
  var SearchIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4732" width="1em" height="1em" fill="currentColor"><path
    d="M664.832 634.624l128.554667 128.597333a21.333333 21.333333 0 1 1-30.165334 30.165334l-128.597333-128.597334a256 256 0 1 1 30.165333-30.165333zM469.333333 682.666667a213.333333 213.333333 0 1 0 0-426.666667 213.333333 213.333333 0 0 0 0 426.666667z"
    p-id="4733"
  /></svg></Icon>;
  var LockIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4605" width="1em" height="1em" fill="currentColor"><path
    d="M810.666667 213.333333v597.333334H213.333333V213.333333h597.333334zM341.333333 383.872H256V768h85.333333V383.872z m426.666667 0H383.872V768H768V383.872z m-149.333333 21.461333a64 64 0 0 1 63.701333 57.856L682.666667 469.333333v64h42.666666v213.333334h-298.666666v-213.333334h42.666666V469.333333a64 64 0 0 1 57.856-63.701333L533.333333 405.333333h85.333334z m64 170.666667h-213.333334v128h213.333334v-128z m-106.666667 21.333333a21.333333 21.333333 0 0 1 21.333333 21.333334v42.666666a21.333333 21.333333 0 1 1-42.666666 0v-42.666666a21.333333 21.333333 0 0 1 21.333333-21.333334z m42.666667-149.333333h-85.333334a21.333333 21.333333 0 0 0-20.992 17.493333L512 469.333333v64h128V469.333333a21.333333 21.333333 0 0 0-13.909333-20.010666l-3.584-0.981334-3.84-0.341333zM768 256H383.872v85.290667L768 341.333333V256zM341.333333 256H256v85.333333l85.333333-0.042666V256z"
    p-id="4606"
  /></svg></Icon>;
  var LocationIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5579" width="1em" height="1em" fill="currentColor"><path
    d="M618.666667 723.584V661.333333a21.333333 21.333333 0 1 1 42.666666 0v62.250667a128.128 128.128 0 0 0 104.917334-104.917333H704a21.333333 21.333333 0 1 1 0-42.666667h62.250667a128.128 128.128 0 0 0-104.917334-104.874667V533.333333a21.333333 21.333333 0 1 1-42.666666 0v-62.208a128.085333 128.085333 0 0 0-104.874667 104.874667H576a21.333333 21.333333 0 0 1 0 42.666667h-62.208a128.128 128.128 0 0 0 104.874667 104.917333z m149.333333-296.96a213.12 213.12 0 0 0-42.666667-24.874667V277.333333a21.333333 21.333333 0 0 0-21.333333-21.333333h-426.666667a21.333333 21.333333 0 0 0-21.333333 21.333333v341.333334a21.333333 21.333333 0 0 0 21.333333 21.333333h153.6c2.986667 14.848 7.594667 29.098667 13.482667 42.666667H256a42.666667 42.666667 0 0 1-42.666667-42.666667V256a42.666667 42.666667 0 0 1 42.666667-42.666667h469.333333a42.666667 42.666667 0 0 1 42.666667 42.666667v170.666667zM640 768a170.666667 170.666667 0 1 1 0-341.333333 170.666667 170.666667 0 0 1 0 341.333333z"
    p-id="5580"
  /></svg></Icon>;
  var PageIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5318" width="1em" height="1em">
    <path d="M810.666667 213.333333v597.333334H213.333333V213.333333h597.333334z m-42.666667 42.666667H256v512h512V256z" p-id="5319" />
    <path d="M256 512h256v42.666667H256zM554.666667 256v298.666667h-42.666667V256z" p-id="5320" />
    <path d="M405.333333 256v298.666667h-42.666666V256z" p-id="5321" />
  </svg></Icon>;
  var RegularIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5447" width="1em" height="1em" fill="currentColor">
    <path d="M256 256h554.666667v42.666667H256z" p-id="5448" />
    <path
      d="M298.666667 256v554.666667H256V256zM810.666667 256v554.666667h-42.666667V256zM469.333333 256v554.666667h-42.666666V256zM640 256v554.666667h-42.666667V256z"
      p-id="5449"
    />
    <path d="M256 426.666667h554.666667v42.666666H256zM256 597.333333h554.666667v42.666667H256zM256 768h554.666667v42.666667H256z" p-id="5450" />
  </svg></Icon>;
  var LayoutIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5576" width="1em" height="1em" fill="currentColor"><path
    d="M810.666667 213.333333v42.666667h-170.709334L640 768h170.666667v42.666667h-213.333334V213.333333h213.333334z m-384 0l-0.042667 554.666667H426.666667v42.666667H213.333333v-42.666667h170.624L384 256H213.333333V213.333333h213.333334z m106.666666 512v85.333334h-42.666666v-85.333334h42.666666z m0-170.666666v85.333333h-42.666666v-85.333333h42.666666z m0-170.666667v85.333333h-42.666666V384h42.666666z m0-170.666667v85.333334h-42.666666V213.333333h42.666666z"
    p-id="5577"
  /></svg></Icon>;
  var TableIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6094" width="1em" height="1em" fill="currentColor"><path
    d="M913.988 173.68H110.05c-25.671 0-46.676 21.007-46.676 46.679v665.897c0 25.651 20.987 46.638 46.637 46.638H913.95c25.671 0 46.676-21.004 46.676-46.676V220.32c0-25.651-20.988-46.64-46.638-46.64zM339.796 896.142c0 12.016-9.34 21.353-21.305 21.353H104.864c-11.965 0-21.303-9.337-21.303-21.353V768.023c0-12.014 9.338-21.353 21.303-21.353h213.627c11.965 0 21.305 9.34 21.305 21.353v128.118z m0-224.995c0 12.015-9.34 21.353-21.305 21.353H104.864c-11.965 0-21.303-9.338-21.303-21.353V543.029c0-12.013 9.338-21.354 21.303-21.354h213.627c11.965 0 21.305 9.34 21.305 21.354v128.117z m0-223.432c0 12.016-9.34 21.353-21.305 21.353H104.864c-11.965 0-21.303-9.337-21.303-21.353V319.596c0-12.013 9.338-21.353 21.303-21.353h213.627c11.965 0 21.305 9.34 21.305 21.353v128.118zM639.269 896.14c0 12.016-9.34 21.353-21.306 21.353H404.337c-11.966 0-21.305-9.337-21.305-21.353V768.023c0-12.014 9.34-21.353 21.305-21.353h213.626c11.966 0 21.306 9.34 21.306 21.353v128.118z m0-224.995c0 12.015-9.34 21.353-21.306 21.353H404.337c-11.966 0-21.305-9.338-21.305-21.353V543.029c0-12.013 9.34-21.354 21.305-21.354h213.626c11.966 0 21.306 9.34 21.306 21.354v128.117z m0-223.432c0 12.016-9.34 21.353-21.306 21.353H404.337c-11.966 0-21.305-9.337-21.305-21.353V319.596c0-12.013 9.34-21.353 21.305-21.353h213.626c11.966 0 21.306 9.34 21.306 21.353v128.118zM941.864 896.14c0 12.016-9.34 21.353-21.304 21.353H706.933c-11.966 0-21.304-9.337-21.304-21.353V768.023c0-12.014 9.338-21.353 21.304-21.353h213.626c11.966 0 21.304 9.34 21.304 21.353v128.118z m0-224.995c0 12.015-9.34 21.353-21.304 21.353H706.933c-11.966 0-21.304-9.338-21.304-21.353V543.029c0-12.013 9.338-21.354 21.304-21.354h213.626c11.966 0 21.304 9.34 21.304 21.354v128.117z m0-223.432c0 12.016-9.34 21.353-21.304 21.353H706.933c-11.966 0-21.304-9.337-21.304-21.353V319.596c0-12.013 9.338-21.353 21.304-21.353h213.626c11.966 0 21.304 9.34 21.304 21.353v128.118z"
    p-id="6095"
  /></svg></Icon>;
  var Sheet_default = {
    CommentIcon,
    FreezeIcon,
    conditionalFormatIcon,
    DivideIcon,
    ReplaceIcon,
    SearchIcon,
    LockIcon,
    LocationIcon,
    PageIcon,
    RegularIcon,
    LayoutIcon,
    TableIcon
  };

  // ../../packages/base-ui/src/Components/Icon/View/index.tsx
  var PrintIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4476" width="1em" height="1em" fill="currentColor">
    <path
      d="M743.125333 341.333333c35.669333 0 64.384 28.885333 67.285334 65.024l0.256 6.101334V682.666667h-149.76v-42.666667H768V412.458667c0-14.592-9.514667-26.154667-21.333333-28.16L743.168 384H280.874667c-12.16 0-22.784 10.24-24.576 24.149333l-0.298667 4.266667V640h127.36v42.666667H213.333333V412.458667c0-36.906667 26.794667-67.712 61.653334-70.826667L280.874667 341.333333h462.250666z"
      p-id="4477"
    />
    <path
      d="M682.666667 213.333333H341.333333v170.666667h341.333334V213.333333z m-42.666667 42.666667v85.333333H384V256h256zM682.666667 554.666667v256H341.333333v-256h341.333334z m-42.666667 42.666666H384v170.666667h256v-170.666667z"
      p-id="4478"
    />
    <path d="M341.333333 426.666667h128v42.666666H341.333333z" p-id="4479" />
  </svg></Icon>;
  var ScreenshotIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5374" width="1em" height="1em" fill="currentColor"><path
    d="M590.848 567.04l-265.386667-306.645333a28.245333 28.245333 0 0 1 3.2-40.149334 29.141333 29.141333 0 0 1 40.789334 3.242667l267.946666 309.674667a124.885333 124.885333 0 0 1 144.213334 34.474666 125.141333 125.141333 0 0 1-16.042667 176.256 125.141333 125.141333 0 0 1-176.341333-14.805333 125.013333 125.013333 0 0 1 1.621333-162.048z m40.149333 18.133333c-18.602667 15.701333-29.312 38.826667-29.312 63.189334 0 45.909333 37.461333 83.157333 83.754667 83.157333a83.413333 83.413333 0 0 0 83.712-83.157333 83.413333 83.413333 0 0 0-83.712-83.114667c-15.189333 0-29.44 4.010667-41.685333 11.008a28.458667 28.458667 0 0 1-12.757334 8.96v-0.042667z m-150.698666-52.565333l-38.229334 44.16a29.653333 29.653333 0 0 1-0.768 0.810667 124.885333 124.885333 0 0 1-6.528 151.509333 125.141333 125.141333 0 0 1-176.341333 14.805333C205.226667 699.306667 198.101333 620.373333 242.346667 567.637333a124.928 124.928 0 0 1 156.416-28.544l38.528-44.501333c9.514667 17.237333 24.746667 30.634667 43.008 37.973333z m105.6-122.026667a85.632 85.632 0 0 0-43.818667-37.12l129.749333-150.016a29.141333 29.141333 0 0 1 40.789334-3.242666 28.245333 28.245333 0 0 1 3.2 40.149333l-129.92 150.186667z m-300.8 301.44c35.413333 29.738667 88.064 25.301333 117.546666-9.813333a83.413333 83.413333 0 0 0-10.666666-117.546667 83.456 83.456 0 0 0-117.589334 9.856 83.456 83.456 0 0 0 10.709334 117.504z"
    p-id="5375"
  /></svg></Icon>;
  var PrintAreaIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5706" width="1em" height="1em" fill="currentColor"><path
    d="M727.04 706.218667a11.946667 11.946667 0 0 1 8.704 3.754666 13.312 13.312 0 0 1 3.626667 9.130667V810.666667H583.253333v-91.52c0-3.413333 1.28-6.741333 3.626667-9.173334a11.946667 11.946667 0 0 1 8.661333-3.754666zM362.666667 725.333333v42.666667h-128v-42.666667h128z m128 0v42.666667h-42.666667v-42.666667h42.666667z m301.696-143.957333a18.773333 18.773333 0 0 1 18.304 19.2v117.205333c0 10.581333-8.277333 19.2-18.346667 19.2h-28.458667v-11.434666c-0.128-21.333333-16.554667-38.570667-36.778666-38.570667h-131.498667c-20.224 0-36.693333 17.237333-36.778667 38.570667v11.477333h-28.458666a18.858667 18.858667 0 0 1-18.346667-19.2v-117.248c0-10.581333 8.277333-19.2 18.346667-19.2zM256 533.333333v128H213.333333v-128h42.666667z m411.477333 85.845334H567.04a12.586667 12.586667 0 0 0-12.245333 12.8c0.042667 7.125333 5.546667 12.885333 12.245333 12.842666h100.394667a12.586667 12.586667 0 0 0 12.202666-12.8c0-7.082667-5.504-12.8-12.202666-12.8zM723.072 512a14.506667 14.506667 0 0 1 14.165333 14.805333v35.84H585.386667v-35.84a14.506667 14.506667 0 0 1 14.165333-14.805333zM768 362.666667v128h-42.666667v-128h42.666667z m-512-42.666667v128H213.333333v-128h42.666667zM768 213.333333v64h-42.666667V256h-64V213.333333H768zM362.666667 213.333333v42.666667H256v21.333333H213.333333V213.333333h149.333334z m213.333333 0v42.666667h-128V213.333333h128z"
    p-id="5707"
  /></svg></Icon>;
  var PrintTitleIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5833" width="1em" height="1em" fill="currentColor">
    <path
      d="M727.04 706.218667a11.946667 11.946667 0 0 1 8.704 3.754666 13.312 13.312 0 0 1 3.626667 9.130667V810.666667H583.253333v-91.52c0-3.413333 1.28-6.741333 3.626667-9.173334a11.946667 11.946667 0 0 1 8.661333-3.754666zM768 213.333333v277.333334h-42.666667V256H256v469.333333h234.666667v42.666667H213.333333V213.333333h554.666667z m24.362667 368.042667a18.773333 18.773333 0 0 1 18.304 19.2v117.205333c0 10.581333-8.277333 19.2-18.346667 19.2h-28.458667v-11.434666c-0.128-21.333333-16.554667-38.570667-36.778666-38.570667h-131.498667c-20.224 0-36.693333 17.237333-36.778667 38.570667v11.477333h-28.458666a18.858667 18.858667 0 0 1-18.346667-19.2v-117.248c0-10.581333 8.277333-19.2 18.346667-19.2z m-124.885334 37.802667H567.04a12.586667 12.586667 0 0 0-12.245333 12.8c0.042667 7.125333 5.546667 12.885333 12.245333 12.842666h100.394667a12.586667 12.586667 0 0 0 12.202666-12.8c0-7.082667-5.504-12.8-12.202666-12.8zM723.072 512a14.506667 14.506667 0 0 1 14.165333 14.805333v35.84H585.386667v-35.84a14.506667 14.506667 0 0 1 14.165333-14.805333z"
      p-id="5834"
    />
    <path d="M341.333333 341.333333h298.666667v42.666667H341.333333zM341.333333 426.666667h170.666667v42.666666H341.333333z" fill="#444D5A" p-id="5835" />
  </svg></Icon>;
  var ImageIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="foward" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5815" width="1em" height="1em" fill="currentColor"><path
    d="M810.666667 213.333333v597.333334H213.333333V213.333333h597.333334z m-42.666667 263.381334l-233.984 190.890666-118.613333-98.218666L256 704.64V768h512v-291.285333zM768 256H256v392.704l159.146667-134.954667 119.04 98.602667L768 421.674667V256zM384 341.333333a42.666667 42.666667 0 1 1 0 85.333334 42.666667 42.666667 0 0 1 0-85.333334z"
    fill="#444D5A"
    p-id="5816"
  /></svg></Icon>;
  var View_default = {
    PrintIcon,
    ScreenshotIcon,
    PrintAreaIcon,
    PrintTitleIcon,
    ImageIcon
  };

  // ../../packages/base-ui/src/Components/Icon/Delete/index.tsx
  var DeleteIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="logo" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1214" width="1em" height="1em">
    <path
      d="M840 288H688v-56c0-40-32-72-72-72h-208C368 160 336 192 336 232V288h-152c-12.8 0-24 11.2-24 24s11.2 24 24 24h656c12.8 0 24-11.2 24-24s-11.2-24-24-24zM384 288v-56c0-12.8 11.2-24 24-24h208c12.8 0 24 11.2 24 24V288H384zM758.4 384c-12.8 0-24 11.2-24 24v363.2c0 24-19.2 44.8-44.8 44.8H332.8c-24 0-44.8-19.2-44.8-44.8V408c0-12.8-11.2-24-24-24s-24 11.2-24 24v363.2c0 51.2 41.6 92.8 92.8 92.8h358.4c51.2 0 92.8-41.6 92.8-92.8V408c-1.6-12.8-12.8-24-25.6-24z"
      p-id="1215"
    />
    <path
      d="M444.8 744v-336c0-12.8-11.2-24-24-24s-24 11.2-24 24v336c0 12.8 11.2 24 24 24s24-11.2 24-24zM627.2 744v-336c0-12.8-11.2-24-24-24s-24 11.2-24 24v336c0 12.8 11.2 24 24 24s24-11.2 24-24z"
      p-id="1216"
    />
  </svg></Icon>;

  // ../../packages/base-ui/src/Components/Icon/Other/index.tsx
  var Close = (props) => <Icon spin={props.spin} rotate={props.rotate} name="logo" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4224" width="1em" height="1em" fill="currentColor">
    <path d="M119.808 180.053333l60.330667-60.245333 724.053333 724.053333-60.330667 60.330667z" p-id="4225" />
    <path d="M843.946667 119.808l60.245333 60.330667-724.053333 724.053333-60.330667-60.330667z" p-id="4226" />
  </svg></Icon>;
  var DropDownIcon = (props) => <Icon spin={props.spin} rotate={props.rotate} name="dropdown" style={props.style}><svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4519" width="1em" height="1em">
    <path d="M149.930667 444.330667l60.330666-60.330667 362.069334 362.069333L512 806.4z" fill="#B5B8BD" p-id="4520" />
    <path d="M813.738667 384l60.330666 60.330667L512 806.4l-60.330667-60.330667z" fill="#B5B8BD" p-id="4521" />
  </svg></Icon>;
  var Other_default = { Close, DropDownIcon };

  // ../../packages/base-ui/src/Common/ComponentManager.ts
  var ComponentManager = class {
    _componentList = /* @__PURE__ */ new Map();
    constructor() {
      const iconList = {
        ForwardIcon,
        BackIcon,
        BoldIcon,
        ItalicIcon,
        DeleteLineIcon,
        UnderLineIcon,
        TextColorIcon,
        FillColorIcon,
        MergeIcon,
        TopBorderIcon,
        BottomBorderIcon,
        LeftBorderIcon,
        RightBorderIcon,
        NoneBorderIcon,
        FullBorderIcon,
        OuterBorderIcon,
        InnerBorderIcon,
        StripingBorderIcon,
        VerticalBorderIcon,
        LeftAlignIcon,
        CenterAlignIcon,
        RightAlignIcon,
        TopVerticalIcon,
        CenterVerticalIcon,
        BottomVerticalIcon,
        OverflowIcon,
        BrIcon,
        CutIcon,
        TextRotateIcon,
        TextRotateAngleUpIcon,
        TextRotateAngleDownIcon,
        TextRotateVerticalIcon,
        TextRotateRotationUpIcon,
        TextRotateRotationDownIcon,
        BorderThin: BorderThin_default,
        BorderHair: BorderHair_default,
        BorderDotted: BorderDotted_default,
        BorderDashed: BorderDashed_default,
        BorderDashDot: BorderDashDot_default,
        BorderDashDotDot: BorderDashDotDot_default,
        BorderMedium: BorderMedium_default,
        BorderMediumDashed: BorderMediumDashed_default,
        BorderMediumDashDot: BorderMediumDashDot_default,
        BorderMediumDashDotDot: BorderMediumDashDotDot_default,
        BorderThick: BorderThick_default
      };
      for (let k5 in iconList) {
        this.register(k5, iconList[k5]);
      }
    }
    register(name, component) {
      this._componentList.set(name, component);
    }
    get(name) {
      return this._componentList.get(name);
    }
    delete(name) {
      this._componentList.delete(name);
    }
  };

  // ../../packages/base-ui/src/Common/RegisterManager.ts
  var RegisterManager = class {
    constructor(_plugin) {
      this._plugin = _plugin;
      this.initialize();
    }
    _clipboardExtensionManager;
    _dragAndDropExtensionManager;
    initialize() {
      this.setClipboardExtensionManager();
      this.setDragAndDropExtensionManager();
    }
    setClipboardExtensionManager() {
      this._clipboardExtensionManager = new ClipboardExtensionManager();
      const onKeyPasteObservable = this._plugin.getContext().getObserverManager().getObserver("onKeyPasteObservable", "core");
      if (onKeyPasteObservable && !onKeyPasteObservable.hasObservers()) {
        onKeyPasteObservable.add((evt) => {
          this._clipboardExtensionManager.pasteResolver(evt).then((data) => {
            this._clipboardExtensionManager.handle(data);
          });
        });
      }
    }
    setDragAndDropExtensionManager() {
      this._dragAndDropExtensionManager = new DragAndDropExtensionManager();
      const onDropObservable = this._plugin.getContext().getObserverManager().getObserver("onDropObservable", "core");
      if (onDropObservable && !onDropObservable.hasObservers()) {
        onDropObservable.add((evt) => {
          this._dragAndDropExtensionManager.dragResolver(evt).then((dataList) => {
            if (dataList.length === 0)
              return;
            this._dragAndDropExtensionManager.handle(dataList);
          });
        });
      }
    }
    /**
     * usage this._clipboardExtensionManager.handle(data);
     * @returns
     */
    getClipboardExtensionManager() {
      return this._clipboardExtensionManager;
    }
    getDragAndDropExtensionManager() {
      return this._dragAndDropExtensionManager;
    }
    onMounted() {
      this.initialize();
    }
    onDestroy() {
    }
  };

  // ../../packages/base-ui/src/Helpers/Cell.ts
  function handleDomToJson($dom) {
    let nodeList = $dom.childNodes;
    if (nodeList.length === 0) {
      return $dom.textContent;
    }
    if (nodeList[0].nodeName === "DIV") {
      nodeList = nodeList[0].childNodes;
    }
    if (nodeList.length === 1 && nodeList[0].nodeName === "#text") {
      return nodeList[0].textContent;
    }
    const elements = [];
    let ed = 0;
    for (let i4 = 0; i4 < nodeList.length; i4++) {
      let span = nodeList[`${i4}`];
      let str;
      if (span.nodeName === "#text") {
        str = span.textContent ?? "";
        span = span.parentElement;
      } else {
        str = span.innerText;
      }
      let textStyle = handleStringToStyle(span);
      let spanTexts = splitSpanText(str);
      spanTexts.forEach((item) => {
        ed = +item.length;
        let eId = Tools.generateRandomId(6);
        elements.push({
          eId,
          st: 0,
          ed: item.length - 1,
          et: 0,
          tr: {
            ct: item,
            ts: textStyle
          }
        });
      });
    }
    const blockId = Tools.generateRandomId(6);
    let p4 = {
      id: Tools.generateRandomId(6),
      body: {
        blockElements: [
          {
            blockId,
            st: 0,
            ed,
            blockType: 0,
            paragraph: {
              elements
            }
          },
          {
            blockId: "b",
            st: 0,
            ed: 0,
            blockType: 2 /* SECTION_BREAK */,
            sectionBreak: {
              columnProperties: [],
              columnSeparatorType: 1,
              sectionType: 0
            }
          }
        ]
      },
      documentStyle: {}
    };
    return p4;
  }
  function handleStringToStyle($dom) {
    const cssText = $dom.style.cssText;
    if (cssText == null || cssText.length === 0) {
      return {};
    }
    let cssTextArray = cssText.split(";");
    let styleList = {};
    cssTextArray.forEach((s4) => {
      s4 = s4.toLowerCase();
      let key = textTrim(s4.substr(0, s4.indexOf(":")));
      let value = textTrim(s4.substr(s4.indexOf(":") + 1));
      if (key === "font-weight") {
        if (value === "bold") {
          styleList.bl = 1;
        } else {
          styleList.bl = 0;
        }
      } else if (key === "font-style") {
        if (value === "italic") {
          styleList.it = 1;
        } else {
          styleList.it = 0;
        }
      } else if (key === "font-family") {
        styleList.ff = value;
      } else if (key === "font-size") {
        let fs = parseInt(value);
        if (cssText.indexOf("vertical-align") > -1 && (cssText.indexOf("sub") > -1 || cssText.indexOf("sup") > -1)) {
          fs *= 2;
        }
        if (value.indexOf("px") !== -1) {
          fs = pxToPt(parseInt(value));
        }
        styleList.fs = fs;
      } else if (key === "color") {
        styleList.cl = {
          rgb: value
        };
      } else if (key === "background" || key === "background-color") {
        styleList.bg = {
          rgb: value
        };
      } else if (key === "text-decoration-line") {
        if (value === "underline") {
          if (!styleList.ul) {
            styleList.ul = { s: 1 };
          }
          styleList.ul.s = 1;
        } else if (value === "line-through") {
          if (!styleList.st) {
            styleList.st = { s: 1 };
          }
          styleList.st.s = 1;
        } else if (value === "overline") {
          if (!styleList.ol) {
            styleList.ol = { s: 1 };
          }
          styleList.ol.s = 1;
        }
      } else if (key === "text-decoration-color") {
        if (styleList.hasOwnProperty("ul")) {
          if (!styleList.ul) {
            styleList.ul = { s: 1, cl: { rgb: value } };
          }
          styleList.ul.cl = {
            rgb: value
          };
        }
        if (styleList.hasOwnProperty("st")) {
          if (!styleList.st) {
            styleList.st = { s: 1, cl: { rgb: value } };
          }
          styleList.st.cl = {
            rgb: value
          };
        }
        if (styleList.hasOwnProperty("ol")) {
          if (!styleList.ol) {
            styleList.ol = { s: 1, cl: { rgb: value } };
          }
          styleList.ol.cl = {
            rgb: value
          };
        }
      } else if (key === "text-decoration-style") {
        if (styleList.hasOwnProperty("ul")) {
          if (!styleList.ul) {
            styleList.ul = { s: 1, t: Number(value) };
          }
          styleList.ul.t = Number(value);
        }
        if (styleList.hasOwnProperty("st")) {
          if (!styleList.st) {
            styleList.st = { s: 1, t: Number(value) };
          }
          styleList.st.t = Number(value);
        }
        if (styleList.hasOwnProperty("ol")) {
          if (!styleList.ol) {
            styleList.ol = { s: 1, t: Number(value) };
          }
          styleList.ol.t = Number(value);
        }
      } else if (key === "text-decoration" || key === "univer-strike") {
        styleList.st = {
          s: 1
        };
      }
      if (key === "univer-underline") {
        styleList.ul = {
          s: 1
        };
      }
      if (key === "vertical-align") {
        if (value === "sub") {
          styleList.va = 1;
        } else if (value === "super") {
          styleList.va = 2;
        } else if (value === "top") {
          styleList.vt = 1;
        } else if (value === "middle") {
          styleList.vt = 2;
        } else if (value === "bottom") {
          styleList.vt = 3;
        } else {
          styleList.va = 0;
        }
      }
      if (key === "transform") {
        const values = value.split(")");
        const index = values.findIndex((item) => item.includes("rotate"));
        if (index > -1) {
          const match = values[index].match(/\d+/g);
          let angle = 0;
          let ver = 0;
          if (match?.length) {
            angle = +match[0];
          }
          if ($dom.dataset.vertical) {
            ver = +$dom.dataset.vertical;
          }
          styleList.tr = {
            a: angle,
            v: ver
          };
        }
      }
      if (key === "text-align") {
        if (value === "left") {
          styleList.ht = 1;
        } else if (value === "center") {
          styleList.ht = 2;
        } else if (value === "right") {
          styleList.ht = 3;
        } else if (value === "justify") {
          styleList.ht = 4;
        } else {
          styleList.ht = 0;
        }
      }
      if (key === "overflow-wrap" || key === "overflowWrap") {
        if (value === "break-word") {
          styleList.tb = 3;
        }
      }
    });
    return styleList;
  }
  function splitSpanText(text) {
    if (text === "")
      return [text];
    const regex2 = /(?:(\n+.+)|(.+))/g;
    let arr = text.match(regex2);
    let arr1 = arr.map((item) => item.replace(/\n/g, "\r\n"));
    return arr1;
  }

  // stylePlugin:D:\code\github\univer\packages\base-ui\src\Components\Button\Style\index.module.less
  var index_module_default4 = {
    "btn": "univer-btn",
    "btnLg": "univer-btn-lg",
    "btnSm": "univer-btn-sm",
    "btnPrimary": "univer-btn-primary",
    "btnDanger": "univer-btn-danger",
    "btnText": "univer-btn-text",
    "btnActive": "univer-btn-active",
    "btnRound": "univer-btn-round",
    "btnCircle": "univer-btn-circle",
    "btnBlock": "univer-btn-block",
    "btnLoading": "univer-btn-loading"
  };

  // ../../packages/base-ui/src/Components/Button/Button.tsx
  var Button = class extends Component {
    constructor(props) {
      super();
      this.state = {
        isActive: props.active ?? false
      };
    }
    getSizeCls() {
      const { size } = this.props;
      let sizeCls = "";
      switch (size) {
        case "large":
          sizeCls = "lg";
          break;
        case "small":
          sizeCls = "sm";
          break;
        default:
          break;
      }
      return sizeCls;
    }
    getClass() {
      const { isActive } = this.state;
      const { type, shape, danger, block, loading, size, className, unActive } = this.props;
      return joinClassNames(
        index_module_default4.btn,
        {
          [`${index_module_default4.btn}-${type}`]: type,
          [`${index_module_default4.btn}-${shape}`]: shape,
          [`${index_module_default4.btn}-${this.getSizeCls()}`]: size,
          [`${index_module_default4.btn}-danger`]: !!danger,
          [`${index_module_default4.btn}-block`]: block,
          [`${index_module_default4.btn}-loading`]: loading,
          [`${index_module_default4.btn}-active`]: isActive
        },
        className
      );
    }
    handleClick = (e4) => {
      const { disabled, onClick, unActive } = this.props;
      if (disabled) {
        e4.preventDefault();
        return;
      }
      if (unActive) {
        onClick?.(e4);
        return;
      }
      this.setState(
        {
          isActive: !this.state.isActive
        },
        () => {
          if (onClick) {
            onClick.call(null, e4, this.state.isActive);
          }
        }
      );
    };
    componentWillReceiveProps(props) {
      this.setState({
        isActive: props.active
      });
    }
    render() {
      const { htmlType, disabled, style, loading, children } = this.props;
      return <button type={htmlType} onClick={this.handleClick} className={this.getClass()} disabled={disabled} style={style}>
        {loading ? <LoadingIcon /> : ""}
        {children}
      </button>;
    }
  };
  var Button_default = Button;

  // ../../node_modules/.pnpm/react-colorful@5.6.1_biqbaboplfbrettd7655fr4n2y/node_modules/react-colorful/dist/index.mjs
  var import_react = __toESM(require_react(), 1);
  function u3() {
    return (u3 = Object.assign || function(e4) {
      for (var r4 = 1; r4 < arguments.length; r4++) {
        var t4 = arguments[r4];
        for (var n3 in t4)
          Object.prototype.hasOwnProperty.call(t4, n3) && (e4[n3] = t4[n3]);
      }
      return e4;
    }).apply(this, arguments);
  }
  function c3(e4, r4) {
    if (null == e4)
      return {};
    var t4, n3, o4 = {}, a4 = Object.keys(e4);
    for (n3 = 0; n3 < a4.length; n3++)
      r4.indexOf(t4 = a4[n3]) >= 0 || (o4[t4] = e4[t4]);
    return o4;
  }
  function i3(e4) {
    var t4 = (0, import_react.useRef)(e4), n3 = (0, import_react.useRef)(function(e5) {
      t4.current && t4.current(e5);
    });
    return t4.current = e4, n3.current;
  }
  var s3 = function(e4, r4, t4) {
    return void 0 === r4 && (r4 = 0), void 0 === t4 && (t4 = 1), e4 > t4 ? t4 : e4 < r4 ? r4 : e4;
  };
  var f3 = function(e4) {
    return "touches" in e4;
  };
  var v3 = function(e4) {
    return e4 && e4.ownerDocument.defaultView || self;
  };
  var d3 = function(e4, r4, t4) {
    var n3 = e4.getBoundingClientRect(), o4 = f3(r4) ? function(e5, r5) {
      for (var t5 = 0; t5 < e5.length; t5++)
        if (e5[t5].identifier === r5)
          return e5[t5];
      return e5[0];
    }(r4.touches, t4) : r4;
    return { left: s3((o4.pageX - (n3.left + v3(e4).pageXOffset)) / n3.width), top: s3((o4.pageY - (n3.top + v3(e4).pageYOffset)) / n3.height) };
  };
  var h3 = function(e4) {
    !f3(e4) && e4.preventDefault();
  };
  var m3 = import_react.default.memo(function(o4) {
    var a4 = o4.onMove, l4 = o4.onKey, s4 = c3(o4, ["onMove", "onKey"]), m4 = (0, import_react.useRef)(null), g5 = i3(a4), p4 = i3(l4), b4 = (0, import_react.useRef)(null), _4 = (0, import_react.useRef)(false), x4 = (0, import_react.useMemo)(function() {
      var e4 = function(e5) {
        h3(e5), (f3(e5) ? e5.touches.length > 0 : e5.buttons > 0) && m4.current ? g5(d3(m4.current, e5, b4.current)) : t4(false);
      }, r4 = function() {
        return t4(false);
      };
      function t4(t5) {
        var n3 = _4.current, o5 = v3(m4.current), a5 = t5 ? o5.addEventListener : o5.removeEventListener;
        a5(n3 ? "touchmove" : "mousemove", e4), a5(n3 ? "touchend" : "mouseup", r4);
      }
      return [function(e5) {
        var r5 = e5.nativeEvent, n3 = m4.current;
        if (n3 && (h3(r5), !function(e6, r6) {
          return r6 && !f3(e6);
        }(r5, _4.current) && n3)) {
          if (f3(r5)) {
            _4.current = true;
            var o5 = r5.changedTouches || [];
            o5.length && (b4.current = o5[0].identifier);
          }
          n3.focus(), g5(d3(n3, r5, b4.current)), t4(true);
        }
      }, function(e5) {
        var r5 = e5.which || e5.keyCode;
        r5 < 37 || r5 > 40 || (e5.preventDefault(), p4({ left: 39 === r5 ? 0.05 : 37 === r5 ? -0.05 : 0, top: 40 === r5 ? 0.05 : 38 === r5 ? -0.05 : 0 }));
      }, t4];
    }, [p4, g5]), C3 = x4[0], E2 = x4[1], H3 = x4[2];
    return (0, import_react.useEffect)(function() {
      return H3;
    }, [H3]), import_react.default.createElement("div", u3({}, s4, { onTouchStart: C3, onMouseDown: C3, className: "react-colorful__interactive", ref: m4, onKeyDown: E2, tabIndex: 0, role: "slider" }));
  });
  var g4 = function(e4) {
    return e4.filter(Boolean).join(" ");
  };
  var p3 = function(r4) {
    var t4 = r4.color, n3 = r4.left, o4 = r4.top, a4 = void 0 === o4 ? 0.5 : o4, l4 = g4(["react-colorful__pointer", r4.className]);
    return import_react.default.createElement("div", { className: l4, style: { top: 100 * a4 + "%", left: 100 * n3 + "%" } }, import_react.default.createElement("div", { className: "react-colorful__pointer-fill", style: { backgroundColor: t4 } }));
  };
  var b3 = function(e4, r4, t4) {
    return void 0 === r4 && (r4 = 0), void 0 === t4 && (t4 = Math.pow(10, r4)), Math.round(t4 * e4) / t4;
  };
  var _3 = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
  var y3 = function(e4) {
    var r4 = e4.s, t4 = e4.v, n3 = e4.a, o4 = (200 - r4) * t4 / 100;
    return { h: b3(e4.h), s: b3(o4 > 0 && o4 < 200 ? r4 * t4 / 100 / (o4 <= 100 ? o4 : 200 - o4) * 100 : 0), l: b3(o4 / 2), a: b3(n3, 2) };
  };
  var q3 = function(e4) {
    var r4 = y3(e4);
    return "hsl(" + r4.h + ", " + r4.s + "%, " + r4.l + "%)";
  };
  var k4 = function(e4) {
    var r4 = y3(e4);
    return "hsla(" + r4.h + ", " + r4.s + "%, " + r4.l + "%, " + r4.a + ")";
  };
  var I3 = function(e4) {
    var r4 = e4.h, t4 = e4.s, n3 = e4.v, o4 = e4.a;
    r4 = r4 / 360 * 6, t4 /= 100, n3 /= 100;
    var a4 = Math.floor(r4), l4 = n3 * (1 - t4), u4 = n3 * (1 - (r4 - a4) * t4), c4 = n3 * (1 - (1 - r4 + a4) * t4), i4 = a4 % 6;
    return { r: b3(255 * [n3, u4, l4, l4, c4, n3][i4]), g: b3(255 * [c4, n3, n3, u4, l4, l4][i4]), b: b3(255 * [l4, l4, c4, n3, n3, u4][i4]), a: b3(o4, 2) };
  };
  var z4 = function(e4) {
    var r4 = /rgba?\(?\s*(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i.exec(e4);
    return r4 ? L3({ r: Number(r4[1]) / (r4[2] ? 100 / 255 : 1), g: Number(r4[3]) / (r4[4] ? 100 / 255 : 1), b: Number(r4[5]) / (r4[6] ? 100 / 255 : 1), a: void 0 === r4[7] ? 1 : Number(r4[7]) / (r4[8] ? 100 : 1) }) : { h: 0, s: 0, v: 0, a: 1 };
  };
  var L3 = function(e4) {
    var r4 = e4.r, t4 = e4.g, n3 = e4.b, o4 = e4.a, a4 = Math.max(r4, t4, n3), l4 = a4 - Math.min(r4, t4, n3), u4 = l4 ? a4 === r4 ? (t4 - n3) / l4 : a4 === t4 ? 2 + (n3 - r4) / l4 : 4 + (r4 - t4) / l4 : 0;
    return { h: b3(60 * (u4 < 0 ? u4 + 6 : u4)), s: b3(a4 ? l4 / a4 * 100 : 0), v: b3(a4 / 255 * 100), a: o4 };
  };
  var S2 = import_react.default.memo(function(r4) {
    var t4 = r4.hue, n3 = r4.onChange, o4 = g4(["react-colorful__hue", r4.className]);
    return import_react.default.createElement("div", { className: o4 }, import_react.default.createElement(m3, { onMove: function(e4) {
      n3({ h: 360 * e4.left });
    }, onKey: function(e4) {
      n3({ h: s3(t4 + 360 * e4.left, 0, 360) });
    }, "aria-label": "Hue", "aria-valuenow": b3(t4), "aria-valuemax": "360", "aria-valuemin": "0" }, import_react.default.createElement(p3, { className: "react-colorful__hue-pointer", left: t4 / 360, color: q3({ h: t4, s: 100, v: 100, a: 1 }) })));
  });
  var T4 = import_react.default.memo(function(r4) {
    var t4 = r4.hsva, n3 = r4.onChange, o4 = { backgroundColor: q3({ h: t4.h, s: 100, v: 100, a: 1 }) };
    return import_react.default.createElement("div", { className: "react-colorful__saturation", style: o4 }, import_react.default.createElement(m3, { onMove: function(e4) {
      n3({ s: 100 * e4.left, v: 100 - 100 * e4.top });
    }, onKey: function(e4) {
      n3({ s: s3(t4.s + 100 * e4.left, 0, 100), v: s3(t4.v - 100 * e4.top, 0, 100) });
    }, "aria-label": "Color", "aria-valuetext": "Saturation " + b3(t4.s) + "%, Brightness " + b3(t4.v) + "%" }, import_react.default.createElement(p3, { className: "react-colorful__saturation-pointer", top: 1 - t4.v / 100, left: t4.s / 100, color: q3(t4) })));
  });
  var F4 = function(e4, r4) {
    if (e4 === r4)
      return true;
    for (var t4 in e4)
      if (e4[t4] !== r4[t4])
        return false;
    return true;
  };
  var P2 = function(e4, r4) {
    return e4.replace(/\s/g, "") === r4.replace(/\s/g, "");
  };
  function Y(e4, t4, l4) {
    var u4 = i3(l4), c4 = (0, import_react.useState)(function() {
      return e4.toHsva(t4);
    }), s4 = c4[0], f4 = c4[1], v4 = (0, import_react.useRef)({ color: t4, hsva: s4 });
    (0, import_react.useEffect)(function() {
      if (!e4.equal(t4, v4.current.color)) {
        var r4 = e4.toHsva(t4);
        v4.current = { hsva: r4, color: t4 }, f4(r4);
      }
    }, [t4, e4]), (0, import_react.useEffect)(function() {
      var r4;
      F4(s4, v4.current.hsva) || e4.equal(r4 = e4.fromHsva(s4), v4.current.color) || (v4.current = { hsva: s4, color: r4 }, u4(r4));
    }, [s4, e4, u4]);
    var d4 = (0, import_react.useCallback)(function(e5) {
      f4(function(r4) {
        return Object.assign({}, r4, e5);
      });
    }, []);
    return [s4, d4];
  }
  var R;
  var V3 = "undefined" != typeof window ? import_react.useLayoutEffect : import_react.useEffect;
  var $2 = function() {
    return R || ("undefined" != typeof __webpack_nonce__ ? __webpack_nonce__ : void 0);
  };
  var J2 = /* @__PURE__ */ new Map();
  var Q2 = function(e4) {
    V3(function() {
      var r4 = e4.current ? e4.current.ownerDocument : document;
      if (void 0 !== r4 && !J2.has(r4)) {
        var t4 = r4.createElement("style");
        t4.innerHTML = `.react-colorful{position:relative;display:flex;flex-direction:column;width:200px;height:200px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.react-colorful__saturation{position:relative;flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(0deg,#000,transparent),linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.react-colorful__alpha-gradient,.react-colorful__pointer-fill{content:"";position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;border-radius:inherit}.react-colorful__alpha-gradient,.react-colorful__saturation{box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}.react-colorful__alpha,.react-colorful__hue{position:relative;height:24px}.react-colorful__hue{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.react-colorful__last-control{border-radius:0 0 8px 8px}.react-colorful__interactive{position:absolute;left:0;top:0;right:0;bottom:0;border-radius:inherit;outline:none;touch-action:none}.react-colorful__pointer{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}.react-colorful__interactive:focus .react-colorful__pointer{transform:translate(-50%,-50%) scale(1.1)}.react-colorful__alpha,.react-colorful__alpha-pointer{background-color:#fff;background-image:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>')}.react-colorful__saturation-pointer{z-index:3}.react-colorful__hue-pointer{z-index:2}`, J2.set(r4, t4);
        var n3 = $2();
        n3 && t4.setAttribute("nonce", n3), r4.head.appendChild(t4);
      }
    }, []);
  };
  var ee = function(r4) {
    var t4 = r4.className, n3 = r4.hsva, o4 = r4.onChange, a4 = { backgroundImage: "linear-gradient(90deg, " + k4(Object.assign({}, n3, { a: 0 })) + ", " + k4(Object.assign({}, n3, { a: 1 })) + ")" }, l4 = g4(["react-colorful__alpha", t4]), u4 = b3(100 * n3.a);
    return import_react.default.createElement("div", { className: l4 }, import_react.default.createElement("div", { className: "react-colorful__alpha-gradient", style: a4 }), import_react.default.createElement(m3, { onMove: function(e4) {
      o4({ a: e4.left });
    }, onKey: function(e4) {
      o4({ a: s3(n3.a + e4.left) });
    }, "aria-label": "Alpha", "aria-valuetext": u4 + "%", "aria-valuenow": u4, "aria-valuemin": "0", "aria-valuemax": "100" }, import_react.default.createElement(p3, { className: "react-colorful__alpha-pointer", left: n3.a, color: k4(n3) })));
  };
  var re = function(t4) {
    var n3 = t4.className, o4 = t4.colorModel, a4 = t4.color, l4 = void 0 === a4 ? o4.defaultColor : a4, i4 = t4.onChange, s4 = c3(t4, ["className", "colorModel", "color", "onChange"]), f4 = (0, import_react.useRef)(null);
    Q2(f4);
    var v4 = Y(o4, l4, i4), d4 = v4[0], h4 = v4[1], m4 = g4(["react-colorful", n3]);
    return import_react.default.createElement("div", u3({}, s4, { ref: f4, className: m4 }), import_react.default.createElement(T4, { hsva: d4, onChange: h4 }), import_react.default.createElement(S2, { hue: d4.h, onChange: h4 }), import_react.default.createElement(ee, { hsva: d4, onChange: h4, className: "react-colorful__last-control" }));
  };
  var Ee = { defaultColor: "rgba(0, 0, 0, 1)", toHsva: z4, fromHsva: function(e4) {
    var r4 = I3(e4);
    return "rgba(" + r4.r + ", " + r4.g + ", " + r4.b + ", " + r4.a + ")";
  }, equal: P2 };
  var He = function(r4) {
    return import_react.default.createElement(re, u3({}, r4, { colorModel: Ee }));
  };
  var qe = /^#?([0-9A-F]{3,8})$/i;
  var ke = function(r4) {
    var t4 = r4.color, l4 = void 0 === t4 ? "" : t4, s4 = r4.onChange, f4 = r4.onBlur, v4 = r4.escape, d4 = r4.validate, h4 = r4.format, m4 = r4.process, g5 = c3(r4, ["color", "onChange", "onBlur", "escape", "validate", "format", "process"]), p4 = (0, import_react.useState)(function() {
      return v4(l4);
    }), b4 = p4[0], _4 = p4[1], x4 = i3(s4), C3 = i3(f4), E2 = (0, import_react.useCallback)(function(e4) {
      var r5 = v4(e4.target.value);
      _4(r5), d4(r5) && x4(m4 ? m4(r5) : r5);
    }, [v4, m4, d4, x4]), H3 = (0, import_react.useCallback)(function(e4) {
      d4(e4.target.value) || _4(v4(l4)), C3(e4);
    }, [l4, v4, d4, C3]);
    return (0, import_react.useEffect)(function() {
      _4(v4(l4));
    }, [l4, v4]), import_react.default.createElement("input", u3({}, g5, { value: h4 ? h4(b4) : b4, spellCheck: "false", onChange: E2, onBlur: H3 }));
  };
  var Ie = function(e4) {
    return "#" + e4;
  };
  var Oe = function(r4) {
    var t4 = r4.prefixed, n3 = r4.alpha, o4 = c3(r4, ["prefixed", "alpha"]), l4 = (0, import_react.useCallback)(function(e4) {
      return e4.replace(/([^0-9A-F]+)/gi, "").substring(0, n3 ? 8 : 6);
    }, [n3]), i4 = (0, import_react.useCallback)(function(e4) {
      return function(e5, r5) {
        var t5 = qe.exec(e5), n4 = t5 ? t5[1].length : 0;
        return 3 === n4 || 6 === n4 || !!r5 && 4 === n4 || !!r5 && 8 === n4;
      }(e4, n3);
    }, [n3]);
    return import_react.default.createElement(ke, u3({}, o4, { escape: l4, format: t4 ? Ie : void 0, process: Ie, validate: i4 }));
  };

  // stylePlugin:D:\code\github\univer\packages\base-ui\src\Components\Input\Style\index.module.less
  var index_module_default8 = {
    "input": "univer-input",
    "inputFocused": "univer-input-focused",
    "inputDisabled": "univer-input-disabled",
    "inputBorderless": "univer-input-borderless",
    "inputBorderlessFocused": "univer-input-borderless-focused"
  };

  // ../../packages/base-ui/src/Components/Input/input.tsx
  var Input = class extends Component {
    ref = d();
    initialize(props) {
      this.state = {
        value: props.value,
        focused: false
      };
    }
    setValue = (value, callback) => {
      this.setState(
        (prevState) => ({
          value
        }),
        callback
      );
    };
    handleChange = (e4) => {
      const { onChange } = this.props;
      if (!onChange)
        return;
      const target = e4.target;
      this.setValue(target.value);
      onChange(e4);
    };
    handlePressEnter = (e4) => {
      const { onPressEnter } = this.props;
      if (e4.key === "Enter") {
        onPressEnter?.(e4);
      }
    };
    onFocus = (e4) => {
      const { onFocus } = this.props;
      onFocus?.(e4);
    };
    onClick = (e4) => {
      const { onClick } = this.props;
      onClick?.(e4);
    };
    onBlur = (e4) => {
      const { onBlur } = this.props;
      onBlur?.(e4);
    };
    // get input value
    getValue = () => this.ref.current.value;
    componentWillMount() {
      if (this.props.value) {
        this.setValue(this.props.value);
      }
    }
    componentWillReceiveProps(nextProps) {
      if (nextProps.value && nextProps.value !== this.state.value) {
        this.setValue(nextProps.value);
      }
    }
    render(props, state) {
      const { id, disabled, type, placeholder, bordered = true, className = "", readonly } = props;
      const { value } = state;
      const classes = joinClassNames(
        index_module_default8.input,
        {
          [`${index_module_default8.input}-disable`]: disabled,
          [`${index_module_default8.input}-borderless`]: !bordered
        },
        className
      );
      return <input
        type={type}
        onBlur={this.onBlur}
        onFocus={this.onFocus}
        className={classes}
        placeholder={placeholder}
        disabled={disabled}
        ref={this.ref}
        onChange={this.handleChange}
        value={value}
        onClick={this.onClick}
        readonly={readonly}
        id={id}
        onKeyUp={this.handlePressEnter}
      />;
    }
  };

  // ../../packages/base-ui/src/Components/ColorPicker/RgbaColorInput/RgbaColorInput.tsx
  var RgbaColorInput = (props) => {
    let { color } = props;
    if (!color)
      return null;
    let rgba;
    if (color.indexOf("#") > -1) {
      color = Color2.hexToRgbString(color);
      if (!color)
        return null;
      rgba = color.replace("rgba(", "").replace(")", "").split(",");
    } else if (color.indexOf("rgba") > -1) {
      rgba = color.replace("rgba(", "").replace(")", "").split(",");
    } else {
      rgba = color.replace("rgb(", "").replace(")", "").split(",");
      rgba.push("1");
    }
    let inputRef = _2(null);
    const onChange = () => {
      props.onChange(inputRef.current.base.value);
    };
    return <Input ref={inputRef} type="text" value={`rgba(${rgba})`} onChange={onChange} />;
  };

  // stylePlugin:D:\code\github\univer\packages\base-ui\src\Components\ColorPicker\ColorPickerPanel\index.module.less
  var index_module_default9 = {
    "colorPickerPanel": "univer-color-picker-panel",
    "colorPickerPanelSetting": "univer-color-picker-panel-setting",
    "panelInput": "univer-panel-input",
    "panelColor": "univer-panel-color"
  };

  // ../../packages/base-ui/src/Components/ColorPicker/ColorPickerPanel/ColorPickerPanel.tsx
  var ColorPickerPanel = class extends Component {
    initialize(props) {
      this.state = {
        color: props.color || "#000"
      };
    }
    setColor(color) {
      this.setState({ color });
      this.props.onChange(color);
    }
    render() {
      return <div className={index_module_default9.colorPickerPanel} onClick={(e4) => e4.stopPropagation()}>
        <He className={index_module_default9.colorPicker} color={this.state.color} onChange={debounce(this.setColor.bind(this), 500)} />
        <div className={index_module_default9.colorPickerPanelSetting}>
          <div className={index_module_default9.panelInput}>{this.props.rgb ? <RgbaColorInput color={this.state.color} onChange={debounce(this.setColor.bind(this), 500)} /> : <Oe color={this.state.color} onChange={debounce(this.setColor.bind(this), 500)} />}</div>
          <div className={index_module_default9.panelColor}>
            <div style={{ background: this.state.color }} />
            <div style={{ background: this.props.color }} />
          </div>
        </div>
      </div>;
    }
  };

  // stylePlugin:D:\code\github\univer\packages\base-ui\src\Components\ColorPicker\index.module.less
  var index_module_default10 = {
    "colorPickerOuter": "univer-color-picker-outer",
    "colorPicker": "univer-color-picker",
    "picker": "univer-picker",
    "pickerSwatches": "univer-picker-swatches",
    "pickerSwatchesItem": "univer-picker-swatches-item",
    "pickerSwatch": "univer-picker-swatch",
    "pickerSwatchBtn": "univer-picker-swatch-btn",
    "colorfulWarp": "univer-colorful-warp",
    "colorBtn": "univer-color-btn",
    "colorPickerSlot": "univer-color-picker-slot"
  };

  // ../../packages/base-ui/src/Components/ColorPicker/ColorPicker.tsx
  var allColor = [
    ["#000", "#444", "#666", "#999", "#ccc", "#eee", "#f3f3f3", "#fff"],
    ["#f00", "#f90", "#ff0", "#0f0", "#0ff", "#00f", "#90f", "#f0f"],
    ["#f4cccc", "#fce5cd", "#fff2cc", "#d9ead3", "#d0e0e3", "#cfe2f3", "#d9d2e9", "#ead1dc"],
    ["#ea9999", "#f9cb9c", "#ffe599", "#b6d7a8", "#a2c4c9", "#9fc5e8", "#b4a7d6", "#d5a6bd"],
    ["#e06666", "#f6b26b", "#ffd966", "#93c47d", "#76a5af", "#6fa8dc", "#8e7cc3", "#c27ba0"],
    ["#c00", "#e69138", "#f1c232", "#6aa84f", "#45818e", "#3d85c6", "#674ea7", "#a64d79"],
    ["#900", "#b45f06", "#bf9000", "#38761d", "#134f5c", "#0b5394", "#351c75", "#741b47"],
    ["#600", "#783f04", "#7f6000", "#274e13", "#0c343d", "#073763", "#20124d", "#4c1130"]
  ];
  var ColorPicker = class extends Component {
    ulRef = d();
    initialize(props) {
      this.state = {
        presetColors: allColor,
        defaultColor: props.color || "#000",
        afterColor: props.color || "#000",
        rgb: true,
        setting: false,
        styles: {},
        currentLocale: "",
        root: null
      };
    }
    /**
     * Gets the selected color
     * @param {string} presetColor new color
     * @param {boolean} val true:Close color selector
     */
    onChange = (presetColor) => {
      this.props.onChange && this.props.onChange(presetColor);
      this.setState({
        afterColor: presetColor
      });
    };
    /**
     * confirm color
     *
     * @eventProperty
     */
    onClick = (color, e4) => {
      this.props.onClick && this.props.onClick(color, e4);
    };
    /**
     * cancel and close
     *
     * @eventProperty
     */
    onCancel = () => {
      this.props.onCancel && this.props.onCancel();
    };
    hideSelect = (e4) => {
      if (e4 && this.ulRef.current.contains(e4.target))
        return;
      this.setState((prevState) => ({ styles: { display: "none" } }));
      document.removeEventListener("click", this.hideSelect, true);
    };
    showSelect = (root) => {
      this.setState((prevState) => ({ styles: { display: "block" } }));
      document.addEventListener("click", this.hideSelect, true);
    };
    /**
     *
     * @param root Locate according to root
     * @param ele Element to locate
     * @returns
     */
    getOffset = (root, ele) => {
      const rootRect = root.getBoundingClientRect();
      const eleRect = this.ulRef.current.getBoundingClientRect();
      const w4 = document.documentElement.clientWidth || document.body.clientWidth;
      const h4 = document.documentElement.clientHeight || document.body.clientHeight;
      let left = 0;
      let top = 0;
      top = rootRect.top + eleRect.height > h4 ? rootRect.top - eleRect.height : rootRect.top + rootRect.height;
      left = rootRect.left + eleRect.width > w4 ? w4 - eleRect.width : rootRect.left;
      return { left, top };
    };
    /**
     * Custom switch
     * @param e
     */
    onSwitch = (e4) => {
      e4.stopImmediatePropagation();
      new Promise((resolve, reject) => {
        this.setState({ setting: !this.state.setting });
        resolve("end");
      }).then(() => {
        if (this.state.root) {
          const { top, left } = this.getOffset(this.state.root, this.ulRef.current);
          this.ulRef.current.style.left = `${left}px`;
          this.ulRef.current.style.top = `${top}px`;
        }
      });
    };
    componentDidMount() {
      this.props.getComponent?.(this);
    }
    render() {
      const obj = Object.assign(this.state.styles || {}, this.props.style);
      return <div className={`${index_module_default10.colorPickerOuter} ${this.props.className}`} ref={this.ulRef} style={{ ...obj }}><div
        className={index_module_default10.colorPicker}
        onClick={(e4) => {
        }}
      >
        <div className={index_module_default10.picker}>
          <div className={index_module_default10.pickerSwatches}>{this.state.presetColors.map((presetColor) => <div className={index_module_default10.pickerSwatchesItem}>{presetColor.map((item) => <span className={index_module_default10.pickerSwatch} style={{ background: item }}><Tooltip title={item} placement="top"><button
            key={item}
            className={index_module_default10.pickerSwatchBtn}
            style={{ background: item }}
            onClick={(e4) => {
              this.props.onClick && this.props.onClick(item, e4);
            }}
          /></Tooltip></span>)}</div>)}</div>
          <div><Button_default onClick={this.onSwitch}>{this.state.setting ? this.getLocale("colorPicker.collapse") : this.getLocale("colorPicker.customColor")}</Button_default></div>
        </div>
        {this.state.setting ? <div className={index_module_default10.colorfulWarp}>
          <ColorPickerPanel color={this.state.defaultColor} rgb={this.state.rgb} onChange={this.onChange.bind(this)} />
          <div>
            <Button_default
              type="primary"
              onClick={(e4) => {
                this.onClick?.(this.state.afterColor, e4);
              }}
            >{this.getLocale("colorPicker.confirmColor")}</Button_default>
            <Button_default
              danger
              onClick={(e4) => {
                this.onCancel();
              }}
            >{this.getLocale("colorPicker.cancelColor")}</Button_default>
            <Button_default
              onClick={(e4) => {
                e4.stopPropagation();
                this.setState({
                  rgb: !this.state.rgb
                });
              }}
            >{this.getLocale("colorPicker.change")}</Button_default>
          </div>
        </div> : null}
      </div></div>;
    }
  };

  // ../../packages/base-ui/src/Components/Container/Container.tsx
  var Container = k3((props, ref) => {
    const { children, style, className, onClick, onContextMenu } = props;
    return <div onContextMenu={onContextMenu} ref={ref} style={style} className={className} onClick={onClick}>{children}</div>;
  });

  // stylePlugin:D:\code\github\univer\packages\base-ui\src\Components\Layout\index.module.less
  var index_module_default13 = {
    "layoutWrapper": "univer-layout-wrapper",
    "layoutWrapperHasSider": "univer-layout-wrapper-has-sider",
    "headerWrapper": "univer-header-wrapper",
    "footerWrapper": "univer-footer-wrapper",
    "contentWrapper": "univer-content-wrapper",
    "siderWrapper": "univer-sider-wrapper"
  };

  // ../../packages/base-ui/src/Components/Layout/Layout.tsx
  var Layout = class extends Component {
    ref = d();
    state = {
      isAside: false
    };
    // If the first child element contains the `aside` component, the layout needs to be changed to horizontal arrangement
    componentDidMount() {
      if (this.ref.current) {
        let children = getFirstChildren(this.ref.current);
        const childrens = children instanceof Array ? children : [children];
        for (const ele of childrens) {
          if (ele.tagName === "ASIDE") {
            this.setState({
              isAside: true
            });
          }
        }
      }
    }
    render(props, state) {
      const { children, style, className = "" } = props;
      const { isAside } = state;
      return <section
        style={style}
        ref={this.ref}
        className={isAside ? `${index_module_default13.layoutWrapper} ${index_module_default13.layoutWrapperHasSider} ${className}` : `${index_module_default13.layoutWrapper} ${className}`}
      >{children}</section>;
    }
  };
  var Header = (props) => {
    const { children, style, className = "" } = props;
    return <header style={style} className={`${index_module_default13.headerWrapper} ${className}`}>{children}</header>;
  };
  var Footer = (props) => {
    const { children, style, className = "" } = props;
    return <footer style={style} className={`${index_module_default13.footerWrapper} ${className}`}>{children}</footer>;
  };
  var Content = k3((props, ref) => {
    const { children, style, className = "" } = props;
    return <main ref={ref} style={style} className={`${index_module_default13.contentWrapper} ${className}`}>{children}</main>;
  });
  var Sider = (props) => {
    const { children, style, className = "" } = props;
    return <aside style={style} className={`${index_module_default13.siderWrapper} ${className}`}>{children}</aside>;
  };

  // stylePlugin:D:\code\github\univer\packages\base-ui\src\Components\Menu\index.module.less
  var index_module_default14 = {
    "colsMenu": "univer-cols-menu",
    "colsMenuitem": "univer-cols-menuitem",
    "colsMenuitemLine": "univer-cols-menuitem-line",
    "colsMenuitemDisabled": "univer-cols-menuitem-disabled"
  };

  // ../../packages/base-ui/src/Components/Menu/Menu.tsx
  var Menu = class extends Component {
    _MenuRef = d();
    _refs = [];
    getMenuRef = () => this._MenuRef;
    handleClick = (e4, item, index) => {
      const { deep = 0 } = this.props;
      item.onClick?.call(null, e4, item.value, index, deep);
      this.props.onClick?.call(null, e4, item.value, index, deep);
      this.showMenu(false);
    };
    showMenu = (show) => {
      this.setState(
        (prevState) => ({ show }),
        () => {
          this.getStyle();
        }
      );
    };
    mouseEnter = (e4, index) => {
      const { menu = [] } = this.props;
      if (menu[index].children) {
        this._refs[index].showMenu(true);
      }
    };
    mouseLeave = (e4, index) => {
      const { menu = [] } = this.props;
      if (menu[index].children) {
        this._refs[index].showMenu(false);
      }
    };
    getStyle = () => {
      const current = this._MenuRef.current;
      if (!current)
        return;
      let style = {};
      const curPosition = current.getBoundingClientRect();
      let docPosition;
      const { dom, parent } = this.props;
      docPosition = {
        left: 0,
        right: document.documentElement.clientWidth,
        top: 0,
        bottom: document.documentElement.clientHeight
      };
      if (parent) {
        current.style.position = "fixed";
        let parPosition = current.parentElement?.getBoundingClientRect();
        if (!parPosition)
          return;
        if (parPosition.right + curPosition.width > docPosition.right) {
          style.left = `${parPosition.left - curPosition.width}px`;
          style.top = `${parPosition.top}px`;
        } else {
          style.left = `${parPosition.right}px`;
          style.top = `${parPosition.top}px`;
        }
        this.setState({
          posStyle: style
        });
      }
    };
    render() {
      const { className = "", style = "", menu, deep = 0 } = this.props;
      const { show, posStyle } = this.state;
      return <ul className={joinClassNames(index_module_default14.colsMenu, className)} style={{ ...style, ...posStyle, display: show ? "block" : "none" }} ref={this._MenuRef}>{menu?.map((item, index) => {
        if (item.show === false)
          return;
        return <>
          <li
            className={joinClassNames(index_module_default14.colsMenuitem, item.className ?? "", item.disabled ? index_module_default14.colsMenuitemDisabled : "")}
            style={item.style ?? ""}
            onClick={(e4) => this.handleClick(e4, item, index)}
            onMouseEnter={(e4) => {
              this.mouseEnter(e4, index);
            }}
            onMouseLeave={(e4) => {
              this.mouseLeave(e4, index);
            }}
          >
            {item.label}
            {item.children ? <Menu
              ref={(ele) => this._refs[index] = ele}
              menu={item.children}
              onClick={item.onClick}
              className={item.className}
              style={item.style}
              parent={this}
              deep={deep + 1}
            /> : <></>}
          </li>
          {item.border ? <div className={index_module_default14.colsMenuitemLine} /> : ""}
        </>;
      })}</ul>;
    }
    initialize() {
      this.state = {
        show: false,
        posStyle: {}
      };
    }
  };

  // stylePlugin:D:\code\github\univer\packages\base-ui\src\Components\Tooltip\index.module.less
  var index_module_default19 = {
    "tooltipGroup": "univer-tooltip-Group",
    "tooltipTitle": "univer-tooltip-title",
    "tooltipBody": "univer-tooltip-body",
    "tooltipSs": "univer-tooltip-ss",
    "top": "univer-top",
    "tooltipTriangle": "univer-tooltip-triangle",
    "right": "univer-right",
    "bottom": "univer-bottom",
    "left": "univer-left"
  };

  // ../../packages/base-ui/src/Components/Tooltip/Tooltip.tsx
  var placementClassNames = {
    top: index_module_default19.top,
    bottom: index_module_default19.bottom,
    left: index_module_default19.left,
    right: index_module_default19.right
  };
  var Tooltip = class extends Component {
    tooltip = d();
    initialize(props) {
      this.state = {
        placement: props.placement || "top",
        placementClassName: joinClassNames(index_module_default19.tooltipTitle, placementClassNames[props.placement || "top"]),
        top: "",
        left: "",
        show: false
      };
    }
    handleMouseOver() {
      if (this.tooltip && this.tooltip.current) {
        let tooltipInfo = this.tooltip.current.getBoundingClientRect();
        let top = tooltipInfo.height;
        let left = tooltipInfo.width;
        if (this.state.placement === "bottom") {
          this.setState({
            top: top + 10,
            left: left / 2,
            show: true
          });
        } else if (this.state.placement === "left") {
          this.setState({
            top: top / 2,
            left: left + 5,
            show: true
          });
        } else if (this.state.placement === "right") {
          this.setState({
            top: top / 2,
            left: -left - 10,
            show: true
          });
        } else {
          this.setState({
            top: -top - 20,
            left: left / 2,
            show: true
          });
        }
      }
    }
    handleMouseLeave() {
      this.setState({
        show: false
      });
    }
    render() {
      return <div ref={this.tooltip} className={index_module_default19.tooltipGroup} style={this.props.styles}>
        <div className={index_module_default19.tooltipBody} onMouseEnter={this.handleMouseOver.bind(this)} onMouseLeave={this.handleMouseLeave.bind(this)}>{this.props.children}</div>
        {this.props.title ? <span
          className={this.state.placementClassName}
          style={{
            top: `${this.state.top}px`,
            left: `${this.state.left}px`,
            display: `${this.state.show ? "block" : "none"}`
          }}
        >
          {this.props.title}
          <span className={index_module_default19.tooltipTriangle} />
        </span> : null}
      </div>;
    }
  };

  // stylePlugin:D:\code\github\univer\packages\base-ui\src\Components\Dropdown\index.module.less
  var index_module_default20 = {
    "dropdown": "univer-dropdown",
    "dropContent": "univer-drop-content",
    "dropIcon": "univer-drop-icon"
  };

  // ../../packages/base-ui/src/Components/Dropdown/Dropdown.tsx
  var Dropdown = class extends Component {
    MenuRef = d();
    DropRef = d();
    IconRef = d();
    handleClick = (e4) => {
      this.props.onClick?.();
      this.props.onMainClick?.();
      const { icon } = this.props;
      if (!icon) {
        this.MenuRef.current?.showMenu(true);
      }
    };
    handleSubClick = () => {
      this.MenuRef.current?.showMenu(true);
    };
    hideMenu = () => {
      this.MenuRef.current?.showMenu(false);
    };
    hideMenuClick = (e4) => {
      if (!this.DropRef.current || !this.DropRef.current?.contains(e4.target)) {
        this.hideMenu();
      }
    };
    componentDidMount() {
      const { placement } = this.props;
      let style = { position: "absolute" };
      if (!placement || placement === "Bottom") {
        style.left = 0;
        style.top = "100%";
      } else if (placement === "Top") {
        style.left = 0;
        style.top = "-100%";
      } else if (placement === "Left") {
        style.left = "-100%";
        style.top = 0;
      } else {
        style.left = "100%";
        style.top = 0;
      }
      this.setState({
        menuStyle: style
      });
      window.addEventListener("click", this.hideMenuClick, true);
    }
    componentWillUnmount() {
      window.removeEventListener("click", this.hideMenuClick, true);
    }
    render() {
      const { children, menu, showArrow, icon, tooltip } = this.props;
      const { menuStyle } = this.state;
      return <div className={index_module_default20.dropdown} ref={this.DropRef}>
        <Tooltip title={tooltip} placement="bottom"><div className={index_module_default20.dropContent} onClick={this.handleClick}>
          {children}
          {showArrow ? <Icon_exports.Format.NextIcon /> : ""}
        </div></Tooltip>
        {icon ? <div ref={this.IconRef} className={index_module_default20.dropIcon} onClick={this.handleSubClick}>{icon}</div> : ""}
        <Menu onClick={menu.onClick} ref={this.MenuRef} menu={menu.menu} className={menu.className} style={{ ...menu.style, ...menuStyle }} />
      </div>;
    }
    initialize() {
      this.state = {
        menuStyle: {}
      };
    }
  };

  // stylePlugin:D:\code\github\univer\packages\base-ui\src\Components\Slider\index.module.less
  var index_module_default23 = {
    "slider": "univer-slider",
    "srOnly": "univer-sr-only"
  };

  // ../../packages/base-ui/src/Components/Slider/Slider.tsx
  var Slider = class extends Component {
    idPrev;
    idNext;
    width;
    ref = d();
    initialize(props) {
      this.state = {
        valuePrev: 0,
        valueNext: 0
      };
    }
    onInput = (index, e4) => {
      const target = e4.target;
      const value = target.value;
      this.changeInputValue(index, value);
      this.props.onChange?.call(this, e4);
    };
    /**
     * 
     */
    onClick = (index, e4) => {
      const { min = 0, max = 100, step = 1 } = this.props;
      const target = e4.currentTarget;
      let track = e4.offsetX;
      const width = target.offsetWidth;
      if (track < 0 || track > width)
        return;
      let value = track / this.width * (max - min);
      if (value % step) {
        value += step - value % step;
      }
      this.changeInputValue(index, value);
      this.props.onClick?.call(this, e4, value);
    };
    /**
     *
     * @param index input index
     * @param value 
     * input
     */
    changeInputValue = (index, value) => {
      let parentNode = this.ref.current;
      let input = parentNode.getElementsByTagName("input")[index];
      let id = input.id;
      parentNode.style.setProperty(`--${id}`, value);
      if (!index) {
        this.setValue({ valuePrev: value });
      } else {
        this.setValue({ valueNext: value });
      }
    };
    setValue = (value, fn) => {
      this.setState(
        (prevState) => ({
          ...value
        }),
        fn
      );
    };
    componentWillMount() {
      this.idPrev = randomId("slider");
      this.idNext = randomId("slider");
    }
    componentDidMount() {
      const { min = 0, max = 100, range: range2 } = this.props;
      let diff = max - min;
      let slider = this.ref.current;
      this.width = slider.offsetWidth;
      slider.style.cssText += `--${this.idPrev}: ${this.state.valuePrev}; --${this.idNext}: ${this.state.valueNext}`;
      document.styleSheets[0].addRule(
        `.${index_module_default23.slider}::after`,
        `margin-left: calc((var(--${this.idNext}) - ${min})/${diff}*100%); width: calc((var(--${this.idPrev}) - var(--${this.idNext}))/${diff}*100%);`
      );
      document.styleSheets[0].insertRule(
        `.${index_module_default23.slider}::after {margin-left: calc((var(--${this.idNext}) - ${min})/${diff}*100%); width: calc((var(--${this.idPrev}) - var(--${this.idNext}))/${diff}*100%);}`,
        0
      );
      document.styleSheets[0].addRule(
        `.${index_module_default23.slider}::before`,
        `margin-left: calc((var(--${this.idPrev}) - ${min})/${diff}*100%);width: calc((var(--${this.idNext}) - var(--${this.idPrev}))/${diff}*100%);`
      );
      document.styleSheets[0].insertRule(
        `.${index_module_default23.slider}::before {margin-left: calc((var(--${this.idPrev}) - ${min})/${diff}*100%);width: calc((var(--${this.idNext}) - var(--${this.idPrev}))/${diff}*100%);}`,
        0
      );
      if (range2) {
        let { value } = this.props;
        value = value || [0, 0];
        this.setValue({
          valuePrev: value[0],
          valueNext: value[1]
        });
      } else {
        let { value } = this.props;
        value = value || 0;
        this.changeInputValue(0, value);
      }
    }
    render(props, state) {
      const { valuePrev, valueNext } = state;
      const { step = 1, min = 0, max = 100, range: range2 = false } = props;
      if (range2) {
        return <div className={index_module_default23.slider} role="group" aria-labelledby="multi-lbl" style={{ "--min": min, "--max": max }} ref={this.ref}>
          <label class="sr-only" for={this.idPrev} />
          <input id={this.idPrev} type="range" min={min} value={valuePrev} max={max} step={step} onInput={(e4) => this.onInput(0, e4)} />
          <label class="sr-only" for={this.idNext} />
          <input id={this.idNext} type="range" min={min} value={valueNext} max={max} step={step} onInput={(e4) => this.onInput(1, e4)} />
        </div>;
      }
      return <div className={index_module_default23.slider} role="group" aria-labelledby="multi-lbl" style={{ "--min": min, "--max": max }} ref={this.ref} onClick={(e4) => this.onClick(0, e4)}>
        <label class="sr-only" for={this.idPrev} />
        <input id={this.idPrev} type="range" min={min} value={valuePrev} max={max} step={step} onInput={(e4) => this.onInput(0, e4)} />
      </div>;
    }
  };

  // stylePlugin:D:\code\github\univer\packages\base-ui\src\Components\Item\index.module.less
  var index_module_default26 = {
    "selectItem": "univer-select-item",
    "selectItemSelected": "univer-select-item-selected",
    "selectItemContent": "univer-select-item-content",
    "selectItemSuffix": "univer-select-item-suffix",
    "selectDisabledItem": "univer-select-disabled-item"
  };

  // ../../packages/base-ui/src/Components/Item/Item.tsx
  var Item = class extends Component {
    // getLabelLocale(label: ComponentChildren) {
    //     if (typeof label === 'string') {
    //         return this.getLocale(label);
    //     }
    // }
    render() {
      const { selected, label, suffix, disabled } = this.props;
      return <div className={joinClassNames(index_module_default26.selectItem, disabled ? index_module_default26.selectDisabledItem : "")}>
        {selected ? <span className={index_module_default26.selectItemSelected}><Icon_exports.CorrectIcon /></span> : ""}
        {
          /* <span className={styles.selectItemContent}>{this.getLabelLocale(label)}</span> */
        }
        <span className={index_module_default26.selectItemContent}>{label}</span>
        {suffix ? <span className={index_module_default26.selectItemSuffix}>{suffix}</span> : ""}
      </div>;
    }
  };

  // stylePlugin:D:\code\github\univer\packages\base-ui\src\Components\Select\index.module.less
  var index_module_default27 = {
    "selectComponent": "univer-select-component",
    "selectButton": "univer-select-button",
    "selectSingle": "univer-select-single",
    "selectInput": "univer-select-input",
    "selectDouble": "univer-select-double",
    "dropdown": "univer-dropdown",
    "dropContent": "univer-drop-content",
    "selectLine": "univer-select-line",
    "dropIcon": "univer-drop-icon",
    "selectLabel": "univer-select-label"
  };

  // ../../packages/base-ui/src/Components/Select/Select.tsx
  var Select = class extends Component {
    ColorRef;
    onClick;
    onPressEnter;
    initialize() {
      const { children = [], hideSelectedIcon } = this.props;
      const list = this.resetMenu(children, hideSelectedIcon);
      this.state = {
        menu: list,
        color: this.props.defaultColor ?? "#000",
        content: "",
        value: ""
      };
    }
    getType(type) {
      switch (type) {
        case 0:
          return this.getSingle();
        case 1:
          return this.getInput();
        case 3:
          return this.getDouble();
        case 4:
          return this.getFix();
        case 5:
          return this.getDoubleFix();
      }
    }
    initData() {
      const { type, display, children = [], label } = this.props;
      if (type === 0 || type === 3) {
        if (!children.length)
          return;
        let index = children.findIndex((item2) => item2.selected);
        if (index < 0)
          index = 0;
        const list = this.handleSelected(index);
        const item = children[index];
        if (display === 1 /* SUFFIX */) {
          this.setState({
            content: item.suffix,
            menu: list
          });
        } else {
          this.setState({
            content: item.label,
            menu: list
          });
        }
        this.onClick = (...arg) => {
          const item2 = children[arg[2]];
          this.props.onClick?.(arg[1], arg[2], arg[3]);
          if (item2.unSelectable) {
            return;
          }
          const list2 = this.handleSelected(arg[2]);
          if (display === 1 /* SUFFIX */) {
            this.setState({
              content: children[arg[2]].suffix,
              menu: list2
            });
          } else {
            this.setState({
              content: children[arg[2]].label,
              menu: list2
            });
          }
        };
      } else if (type === 1) {
        if (!children.length)
          return;
        const getLabel = (label2) => {
          if (label2 !== null) {
            if (label2 === "")
              return;
            let index = children.findIndex((item) => label2 === item.label);
            let list = this.handleSelected(index < 0 ? null : index);
            this.setState({
              content: label2,
              menu: list
            });
          } else {
            let index = children.findIndex((item2) => item2.selected);
            if (index < 0)
              index = 0;
            let list = this.handleSelected(index);
            const item = children[index];
            this.setState({
              content: item.label,
              menu: list
            });
          }
        };
        getLabel(label);
        this.onClick = (...arg) => {
          this.props.onClick?.(arg[1], arg[2], arg[3]);
          const list = this.handleSelected(arg[2]);
          this.setState({
            content: children[arg[2]].label,
            menu: list
          });
        };
        this.onPressEnter = (e4) => {
          const value = e4.currentTarget.value;
          this.props.onPressEnter?.(value);
          getLabel(value);
        };
      } else if (type === 2) {
        const list = this.handleSelected(null);
        this.setState({
          menu: list
        });
        this.onClick = () => {
          const { color } = this.state;
          this.props.onClick?.(color);
        };
      } else if (type === 4 || type === 5) {
        if (!children.length)
          return;
        let index = children.findIndex((item2) => item2.selected);
        if (index < 0)
          index = 0;
        const item = children[index];
        const list = this.handleSelected(index);
        this.setState({
          menu: list,
          value: item.value
        });
        this.onClick = (...arg) => {
          if (arg.length) {
            this.props.onClick?.(arg[1], arg[2], arg[3]);
            const list2 = this.handleSelected(arg[2]);
            this.setState({
              menu: list2,
              value: children[arg[2]].value
            });
          } else {
            this.props.onClick?.(this.state.value);
          }
        };
      }
    }
    componentDidMount() {
      this.initData();
    }
    componentWillReceiveProps(nextProps) {
      this.props = Object.assign(this.props, nextProps);
      this.initData();
    }
    resetMenu(children, hideSelectedIcon) {
      const list = [];
      for (let i4 = 0; i4 < children.length; i4++) {
        let selected = false;
        if (!hideSelectedIcon) {
          selected = children[i4].selected ?? false;
        }
        list[i4] = { label: "" };
        list[i4].label = <Item disabled={children[i4].disabled} border={children[i4].border} selected={selected} label={children[i4].label} suffix={children[i4].suffix} />;
        list[i4].disabled = children[i4].disabled;
        list[i4].style = children[i4].style;
        list[i4].value = children[i4].value;
        list[i4].className = children[i4].className;
        list[i4].onClick = children[i4].onClick;
        list[i4].border = children[i4].border;
        if (children[i4].children) {
          list[i4].children = this.resetMenu(children[i4].children);
        }
      }
      return list;
    }
    // 
    handleSelected = (index) => {
      const { children = [], hideSelectedIcon } = this.props;
      if (children.length) {
        children.forEach((item) => {
          item.selected = false;
        });
        if (index !== null) {
          children[index].selected = true;
        }
      }
      const list = this.resetMenu(children, hideSelectedIcon);
      return list;
    };
    // 
    getSingle = () => {
      const { content, menu } = this.state;
      const { className = "", tooltip, onMainClick } = this.props;
      return <div className={`${index_module_default27.selectSingle} ${className}`}><Dropdown onMainClick={onMainClick} tooltip={tooltip} menu={{ menu, onClick: this.onClick }} showArrow><div>{content}</div></Dropdown></div>;
    };
    handlePressEnter = (e4, ref) => {
      this.onPressEnter(e4);
      ref.current?.hideMenu();
    };
    //Input
    getInput = () => {
      const { content, menu } = this.state;
      const { className = "", tooltip, onMainClick } = this.props;
      const ref = d();
      return <div className={`${index_module_default27.selectInput} ${className}`}><Dropdown onMainClick={onMainClick} ref={ref} tooltip={tooltip} menu={{ menu, onClick: this.onClick }} showArrow><Input onPressEnter={(e4) => this.handlePressEnter(e4, ref)} onBlur={this.onPressEnter} type="number" value={content} /></Dropdown></div>;
    };
    getDouble = () => {
      const { content, menu } = this.state;
      const { className = "", tooltip, onClick } = this.props;
      return <div className={`${index_module_default27.selectDouble} ${className}`}><Dropdown onClick={onClick} tooltip={tooltip} menu={{ menu, onClick: this.onClick }} icon={<Icon_exports.NextIcon />}><div className={index_module_default27.selectLabel}>{content}</div></Dropdown></div>;
    };
    getFix = () => {
      const { label, className = "", tooltip } = this.props;
      const { menu } = this.state;
      return <div className={`${index_module_default27.selectDouble} ${className}`}><Dropdown tooltip={tooltip} menu={{ menu, onClick: this.onClick }} showArrow><div className={index_module_default27.selectLabel}>{label}</div></Dropdown></div>;
    };
    getDoubleFix = () => {
      const { label, className = "", tooltip, onClick } = this.props;
      const { menu } = this.state;
      return <div className={`${index_module_default27.selectDouble} ${className}`}><Dropdown tooltip={tooltip} onClick={onClick} menu={{ menu, onClick: this.onClick }} icon={<Icon_exports.NextIcon />}><div className={index_module_default27.selectLabel}>{label}</div></Dropdown></div>;
    };
    render() {
      const { type = 0 } = this.props;
      return <div className={index_module_default27.selectComponent}>{this.getType(type)}</div>;
    }
  };

  // stylePlugin:D:\code\github\univer\packages\base-ui\src\Basics\CSS\Skin\default.module.less
  var default_module_default = {
    "successColor": "#52c41a",
    "warningColor": "#faad14",
    "errorColor": "#f5222d",
    "borderRadiusBase": "2px",
    "borderWidthBase": "1px",
    "borderStyleBase": "solid",
    "lineHeightBase": "1.5715",
    "fontWeight": "400",
    "fontSizeBase": "14px",
    "fontSizeLg": "16px",
    "fontSizeSm": "12px",
    "paddingBase": "1em",
    "marginBase": "1em",
    "gray1": "#ffffff",
    "gray2": "#fafafa",
    "gray3": "#f5f5f5",
    "gray4": "#f0f0f0",
    "gray5": "#d9d9d9",
    "gray6": "#bfbfbf",
    "gray7": "#8c8c8c",
    "gray8": "#595959",
    "gray9": "#434343",
    "gray10": "#262626",
    "gray11": "#1f1f1f",
    "gray12": "#141414",
    "gray13": "#000000",
    "gray14": "#efefef",
    "gray15": "#e0e0e0",
    "gray16": "#ececec",
    "gray17": "#cbcbcb",
    "primaryColor": "#0188fb",
    "primaryColorHover": "#5391ff",
    "linkColor": "#1890ff",
    "bg": "#fff",
    "bgHover": "#efefef",
    "fontSize": "14px",
    "headingColor": "#262626",
    "textColor": "#333",
    "textColorSecondary": "#8c8c8c",
    "disabledColor": "#bfbfbf",
    "disabledBg": "#f5f5f5",
    "borderColorBase": "#d9d9d9",
    "boxShadowBase": "0 3px 6px -4px rgba(0, 0, 0, 0.12), 0 6px 16px 0 rgba(0, 0, 0, 0.08), 0 9px 28px 8px rgba(0, 0, 0, 0.05)",
    "borderColorBaseHover": "#bfbfbf"
  };

  // ../../node_modules/.pnpm/css-vars-ponyfill@2.4.8/node_modules/css-vars-ponyfill/dist/css-vars-ponyfill.esm.js
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i4 = 1; i4 < arguments.length; i4++) {
        var source = arguments[i4];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function getUrls(urls) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var settings = {
      mimeType: options.mimeType || null,
      onBeforeSend: options.onBeforeSend || Function.prototype,
      onSuccess: options.onSuccess || Function.prototype,
      onError: options.onError || Function.prototype,
      onComplete: options.onComplete || Function.prototype
    };
    var urlArray = Array.isArray(urls) ? urls : [urls];
    var urlQueue = Array.apply(null, Array(urlArray.length)).map(function(x4) {
      return null;
    });
    function isValidCss(text) {
      var isString3 = typeof text === "string";
      var isHTML = isString3 && text.trim().charAt(0) === "<";
      return isString3 && !isHTML;
    }
    function onError2(xhr, urlIndex) {
      settings.onError(xhr, urlArray[urlIndex], urlIndex);
    }
    function onSuccess2(responseText, urlIndex) {
      var returnVal = settings.onSuccess(responseText, urlArray[urlIndex], urlIndex);
      responseText = returnVal === false ? "" : returnVal || responseText;
      urlQueue[urlIndex] = responseText;
      if (urlQueue.indexOf(null) === -1) {
        settings.onComplete(urlQueue);
      }
    }
    var parser = document.createElement("a");
    urlArray.forEach(function(url, i4) {
      parser.setAttribute("href", url);
      parser.href = String(parser.href);
      var isIElte9 = Boolean(document.all && !window.atob);
      var isIElte9CORS = isIElte9 && parser.host.split(":")[0] !== location.host.split(":")[0];
      if (isIElte9CORS) {
        var isSameProtocol = parser.protocol === location.protocol;
        if (isSameProtocol) {
          var xdr = new XDomainRequest();
          xdr.open("GET", url);
          xdr.timeout = 0;
          xdr.onprogress = Function.prototype;
          xdr.ontimeout = Function.prototype;
          xdr.onload = function() {
            var text = xdr.responseText;
            if (isValidCss(text)) {
              onSuccess2(text, i4);
            } else {
              onError2(xdr, i4);
            }
          };
          xdr.onerror = function(err) {
            onError2(xdr, i4);
          };
          setTimeout(function() {
            xdr.send();
          }, 0);
        } else {
          console.warn("Internet Explorer 9 Cross-Origin (CORS) requests must use the same protocol (".concat(url, ")"));
          onError2(null, i4);
        }
      } else {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", url);
        if (settings.mimeType && xhr.overrideMimeType) {
          xhr.overrideMimeType(settings.mimeType);
        }
        settings.onBeforeSend(xhr, url, i4);
        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
            var text = xhr.responseText;
            if (xhr.status < 400 && isValidCss(text)) {
              onSuccess2(text, i4);
            } else if (xhr.status === 0 && isValidCss(text)) {
              onSuccess2(text, i4);
            } else {
              onError2(xhr, i4);
            }
          }
        };
        xhr.send();
      }
    });
  }
  function getCssData(options) {
    var regex2 = {
      cssComments: /\/\*[\s\S]+?\*\//g,
      cssImports: /(?:@import\s*)(?:url\(\s*)?(?:['"])([^'"]*)(?:['"])(?:\s*\))?(?:[^;]*;)/g
    };
    var settings = {
      rootElement: options.rootElement || document,
      include: options.include || 'style,link[rel="stylesheet"]',
      exclude: options.exclude || null,
      filter: options.filter || null,
      skipDisabled: options.skipDisabled !== false,
      useCSSOM: options.useCSSOM || false,
      onBeforeSend: options.onBeforeSend || Function.prototype,
      onSuccess: options.onSuccess || Function.prototype,
      onError: options.onError || Function.prototype,
      onComplete: options.onComplete || Function.prototype
    };
    var sourceNodes = Array.apply(null, settings.rootElement.querySelectorAll(settings.include)).filter(function(node) {
      return !matchesSelector(node, settings.exclude);
    });
    var cssArray = Array.apply(null, Array(sourceNodes.length)).map(function(x4) {
      return null;
    });
    function handleComplete() {
      var isComplete = cssArray.indexOf(null) === -1;
      if (isComplete) {
        cssArray.reduce(function(skipIndices, value, i4) {
          if (value === "") {
            skipIndices.push(i4);
          }
          return skipIndices;
        }, []).reverse().forEach(function(skipIndex) {
          return [sourceNodes, cssArray].forEach(function(arr) {
            return arr.splice(skipIndex, 1);
          });
        });
        var cssText = cssArray.join("");
        settings.onComplete(cssText, cssArray, sourceNodes);
      }
    }
    function handleSuccess(cssText, cssIndex, node, sourceUrl) {
      var returnVal = settings.onSuccess(cssText, node, sourceUrl);
      cssText = returnVal !== void 0 && Boolean(returnVal) === false ? "" : returnVal || cssText;
      resolveImports(cssText, node, sourceUrl, function(resolvedCssText, errorData) {
        if (cssArray[cssIndex] === null) {
          errorData.forEach(function(data) {
            return settings.onError(data.xhr, node, data.url);
          });
          if (!settings.filter || settings.filter.test(resolvedCssText)) {
            cssArray[cssIndex] = resolvedCssText;
          } else {
            cssArray[cssIndex] = "";
          }
          handleComplete();
        }
      });
    }
    function parseImportData(cssText, baseUrl) {
      var ignoreRules = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      var importData = {};
      importData.rules = (cssText.replace(regex2.cssComments, "").match(regex2.cssImports) || []).filter(function(rule) {
        return ignoreRules.indexOf(rule) === -1;
      });
      importData.urls = importData.rules.map(function(rule) {
        return rule.replace(regex2.cssImports, "$1");
      });
      importData.absoluteUrls = importData.urls.map(function(url) {
        return getFullUrl$1(url, baseUrl);
      });
      importData.absoluteRules = importData.rules.map(function(rule, i4) {
        var oldUrl = importData.urls[i4];
        var newUrl = getFullUrl$1(importData.absoluteUrls[i4], baseUrl);
        return rule.replace(oldUrl, newUrl);
      });
      return importData;
    }
    function resolveImports(cssText, node, baseUrl, callbackFn) {
      var __errorData = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [];
      var __errorRules = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : [];
      var importData = parseImportData(cssText, baseUrl, __errorRules);
      if (importData.rules.length) {
        getUrls(importData.absoluteUrls, {
          onBeforeSend: function onBeforeSend2(xhr, url, urlIndex) {
            settings.onBeforeSend(xhr, node, url);
          },
          onSuccess: function onSuccess2(cssText2, url, urlIndex) {
            var returnVal = settings.onSuccess(cssText2, node, url);
            cssText2 = returnVal === false ? "" : returnVal || cssText2;
            var responseImportData = parseImportData(cssText2, url, __errorRules);
            responseImportData.rules.forEach(function(rule, i4) {
              cssText2 = cssText2.replace(rule, responseImportData.absoluteRules[i4]);
            });
            return cssText2;
          },
          onError: function onError2(xhr, url, urlIndex) {
            __errorData.push({
              xhr,
              url
            });
            __errorRules.push(importData.rules[urlIndex]);
            resolveImports(cssText, node, baseUrl, callbackFn, __errorData, __errorRules);
          },
          onComplete: function onComplete2(responseArray) {
            responseArray.forEach(function(importText, i4) {
              cssText = cssText.replace(importData.rules[i4], importText);
            });
            resolveImports(cssText, node, baseUrl, callbackFn, __errorData, __errorRules);
          }
        });
      } else {
        callbackFn(cssText, __errorData);
      }
    }
    if (sourceNodes.length) {
      sourceNodes.forEach(function(node, i4) {
        var linkHref = node.getAttribute("href");
        var linkRel = node.getAttribute("rel");
        var isLink = node.nodeName.toLowerCase() === "link" && linkHref && linkRel && linkRel.toLowerCase().indexOf("stylesheet") !== -1;
        var isSkip = settings.skipDisabled === false ? false : node.disabled;
        var isStyle = node.nodeName.toLowerCase() === "style";
        if (isLink && !isSkip) {
          var isURIScheme = linkHref.indexOf("data:text/css") !== -1;
          if (isURIScheme) {
            var cssText = decodeURIComponent(linkHref.substring(linkHref.indexOf(",") + 1));
            if (settings.useCSSOM) {
              cssText = Array.apply(null, node.sheet.cssRules).map(function(rule) {
                return rule.cssText;
              }).join("");
            }
            handleSuccess(cssText, i4, node, location.href);
          } else {
            getUrls(linkHref, {
              mimeType: "text/css",
              onBeforeSend: function onBeforeSend2(xhr, url, urlIndex) {
                settings.onBeforeSend(xhr, node, url);
              },
              onSuccess: function onSuccess2(cssText2, url, urlIndex) {
                var sourceUrl = getFullUrl$1(linkHref);
                handleSuccess(cssText2, i4, node, sourceUrl);
              },
              onError: function onError2(xhr, url, urlIndex) {
                cssArray[i4] = "";
                settings.onError(xhr, node, url);
                handleComplete();
              }
            });
          }
        } else if (isStyle && !isSkip) {
          var _cssText = node.textContent;
          if (settings.useCSSOM) {
            _cssText = Array.apply(null, node.sheet.cssRules).map(function(rule) {
              return rule.cssText;
            }).join("");
          }
          handleSuccess(_cssText, i4, node, location.href);
        } else {
          cssArray[i4] = "";
          handleComplete();
        }
      });
    } else {
      settings.onComplete("", []);
    }
  }
  function getFullUrl$1(url, base) {
    var d4 = document.implementation.createHTMLDocument("");
    var b4 = d4.createElement("base");
    var a4 = d4.createElement("a");
    d4.head.appendChild(b4);
    d4.body.appendChild(a4);
    b4.href = base || document.baseURI || (document.querySelector("base") || {}).href || location.href;
    a4.href = url;
    return a4.href;
  }
  function matchesSelector(elm, selector) {
    var matches = elm.matches || elm.matchesSelector || elm.webkitMatchesSelector || elm.mozMatchesSelector || elm.msMatchesSelector || elm.oMatchesSelector;
    return matches.call(elm, selector);
  }
  var balancedMatch = balanced;
  function balanced(a4, b4, str) {
    if (a4 instanceof RegExp)
      a4 = maybeMatch(a4, str);
    if (b4 instanceof RegExp)
      b4 = maybeMatch(b4, str);
    var r4 = range(a4, b4, str);
    return r4 && {
      start: r4[0],
      end: r4[1],
      pre: str.slice(0, r4[0]),
      body: str.slice(r4[0] + a4.length, r4[1]),
      post: str.slice(r4[1] + b4.length)
    };
  }
  function maybeMatch(reg, str) {
    var m4 = str.match(reg);
    return m4 ? m4[0] : null;
  }
  balanced.range = range;
  function range(a4, b4, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a4);
    var bi = str.indexOf(b4, ai + 1);
    var i4 = ai;
    if (ai >= 0 && bi > 0) {
      if (a4 === b4) {
        return [ai, bi];
      }
      begs = [];
      left = str.length;
      while (i4 >= 0 && !result) {
        if (i4 == ai) {
          begs.push(i4);
          ai = str.indexOf(a4, i4 + 1);
        } else if (begs.length == 1) {
          result = [begs.pop(), bi];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi;
          }
          bi = str.indexOf(b4, i4 + 1);
        }
        i4 = ai < bi && ai >= 0 ? ai : bi;
      }
      if (begs.length) {
        result = [left, right];
      }
    }
    return result;
  }
  function parseCss(css) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var defaults2 = {
      preserveStatic: true,
      removeComments: false
    };
    var settings = _extends({}, defaults2, options);
    var errors = [];
    function error2(msg) {
      throw new Error("CSS parse error: ".concat(msg));
    }
    function match(re2) {
      var m4 = re2.exec(css);
      if (m4) {
        css = css.slice(m4[0].length);
        return m4;
      }
    }
    function open() {
      return match(/^{\s*/);
    }
    function close() {
      return match(/^}/);
    }
    function whitespace() {
      match(/^\s*/);
    }
    function comment() {
      whitespace();
      if (css[0] !== "/" || css[1] !== "*") {
        return;
      }
      var i4 = 2;
      while (css[i4] && (css[i4] !== "*" || css[i4 + 1] !== "/")) {
        i4++;
      }
      if (!css[i4]) {
        return error2("end of comment is missing");
      }
      var str = css.slice(2, i4);
      css = css.slice(i4 + 2);
      return {
        type: "comment",
        comment: str
      };
    }
    function comments() {
      var cmnts = [];
      var c4;
      while (c4 = comment()) {
        cmnts.push(c4);
      }
      return settings.removeComments ? [] : cmnts;
    }
    function selector() {
      whitespace();
      while (css[0] === "}") {
        error2("extra closing bracket");
      }
      var m4 = match(/^(("(?:\\"|[^"])*"|'(?:\\'|[^'])*'|[^{])+)/);
      if (m4) {
        var _selector = m4[0].trim();
        var selectorItems;
        var hasComment = /\/\*/.test(_selector);
        if (hasComment) {
          _selector = _selector.replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, "");
        }
        var hasCommaInQuotes = /["']\w*,\w*["']/.test(_selector);
        if (hasCommaInQuotes) {
          _selector = _selector.replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, function(m5) {
            return m5.replace(/,/g, "\u200C");
          });
        }
        var hasMultipleSelectors = /,/.test(_selector);
        if (hasMultipleSelectors) {
          selectorItems = _selector.split(/\s*(?![^(]*\)),\s*/);
        } else {
          selectorItems = [_selector];
        }
        if (hasCommaInQuotes) {
          selectorItems = selectorItems.map(function(s4) {
            return s4.replace(/\u200C/g, ",");
          });
        }
        return selectorItems;
      }
    }
    function declaration() {
      if (css[0] === "@") {
        return at_rule();
      }
      match(/^([;\s]*)+/);
      var comment_regexp = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
      var prop = match(/^(\*?[-#/*\\\w.]+(\[[0-9a-z_-]+\])?)\s*/);
      if (!prop) {
        return;
      }
      prop = prop[0].trim();
      if (!match(/^:\s*/)) {
        return error2("property missing ':'");
      }
      var val = match(/^((?:\/\*.*?\*\/|'(?:\\'|.)*?'|"(?:\\"|.)*?"|\((\s*'(?:\\'|.)*?'|"(?:\\"|.)*?"|[^)]*?)\s*\)|[^};])+)/);
      var ret = {
        type: "declaration",
        property: prop.replace(comment_regexp, ""),
        value: val ? val[0].replace(comment_regexp, "").trim() : ""
      };
      match(/^[;\s]*/);
      return ret;
    }
    function declarations() {
      if (!open()) {
        return error2("missing '{'");
      }
      var d4;
      var decls = comments();
      while (d4 = declaration()) {
        decls.push(d4);
        decls = decls.concat(comments());
      }
      if (!close()) {
        return error2("missing '}'");
      }
      return decls;
    }
    function keyframe() {
      whitespace();
      var vals = [];
      var m4;
      while (m4 = match(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/)) {
        vals.push(m4[1]);
        match(/^,\s*/);
      }
      if (vals.length) {
        return {
          type: "keyframe",
          values: vals,
          declarations: declarations()
        };
      }
    }
    function at_keyframes() {
      var m4 = match(/^@([-\w]+)?keyframes\s*/);
      if (!m4) {
        return;
      }
      var vendor = m4[1];
      m4 = match(/^([-\w]+)\s*/);
      if (!m4) {
        return error2("@keyframes missing name");
      }
      var name = m4[1];
      if (!open()) {
        return error2("@keyframes missing '{'");
      }
      var frame;
      var frames = comments();
      while (frame = keyframe()) {
        frames.push(frame);
        frames = frames.concat(comments());
      }
      if (!close()) {
        return error2("@keyframes missing '}'");
      }
      return {
        type: "keyframes",
        name,
        vendor,
        keyframes: frames
      };
    }
    function at_page() {
      var m4 = match(/^@page */);
      if (m4) {
        var sel = selector() || [];
        return {
          type: "page",
          selectors: sel,
          declarations: declarations()
        };
      }
    }
    function at_page_margin_box() {
      var m4 = match(/@(top|bottom|left|right)-(left|center|right|top|middle|bottom)-?(corner)?\s*/);
      if (m4) {
        var name = "".concat(m4[1], "-").concat(m4[2]) + (m4[3] ? "-".concat(m4[3]) : "");
        return {
          type: "page-margin-box",
          name,
          declarations: declarations()
        };
      }
    }
    function at_fontface() {
      var m4 = match(/^@font-face\s*/);
      if (m4) {
        return {
          type: "font-face",
          declarations: declarations()
        };
      }
    }
    function at_supports() {
      var m4 = match(/^@supports *([^{]+)/);
      if (m4) {
        return {
          type: "supports",
          supports: m4[1].trim(),
          rules: rules()
        };
      }
    }
    function at_host() {
      var m4 = match(/^@host\s*/);
      if (m4) {
        return {
          type: "host",
          rules: rules()
        };
      }
    }
    function at_media() {
      var m4 = match(/^@media([^{]+)*/);
      if (m4) {
        return {
          type: "media",
          media: (m4[1] || "").trim(),
          rules: rules()
        };
      }
    }
    function at_custom_m() {
      var m4 = match(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);
      if (m4) {
        return {
          type: "custom-media",
          name: m4[1].trim(),
          media: m4[2].trim()
        };
      }
    }
    function at_document() {
      var m4 = match(/^@([-\w]+)?document *([^{]+)/);
      if (m4) {
        return {
          type: "document",
          document: m4[2].trim(),
          vendor: m4[1] ? m4[1].trim() : null,
          rules: rules()
        };
      }
    }
    function at_x() {
      var m4 = match(/^@(import|charset|namespace)\s*([^;]+);/);
      if (m4) {
        return {
          type: m4[1],
          name: m4[2].trim()
        };
      }
    }
    function at_rule() {
      whitespace();
      if (css[0] === "@") {
        var ret = at_x() || at_fontface() || at_media() || at_keyframes() || at_supports() || at_document() || at_custom_m() || at_host() || at_page() || at_page_margin_box();
        if (ret && !settings.preserveStatic) {
          var hasVarFunc = false;
          if (ret.declarations) {
            hasVarFunc = ret.declarations.some(function(decl) {
              return /var\(/.test(decl.value);
            });
          } else {
            var arr = ret.keyframes || ret.rules || [];
            hasVarFunc = arr.some(function(obj) {
              return (obj.declarations || []).some(function(decl) {
                return /var\(/.test(decl.value);
              });
            });
          }
          return hasVarFunc ? ret : {};
        }
        return ret;
      }
    }
    function rule() {
      if (!settings.preserveStatic) {
        var balancedMatch$1 = balancedMatch("{", "}", css);
        if (balancedMatch$1) {
          var hasVarDecl = /:(?:root|host)(?![.:#(])/.test(balancedMatch$1.pre) && /--\S*\s*:/.test(balancedMatch$1.body);
          var hasVarFunc = /var\(/.test(balancedMatch$1.body);
          if (!hasVarDecl && !hasVarFunc) {
            css = css.slice(balancedMatch$1.end + 1);
            return {};
          }
        }
      }
      var sel = selector() || [];
      var decls = settings.preserveStatic ? declarations() : declarations().filter(function(decl) {
        var hasVarDecl2 = sel.some(function(s4) {
          return /:(?:root|host)(?![.:#(])/.test(s4);
        }) && /^--\S/.test(decl.property);
        var hasVarFunc2 = /var\(/.test(decl.value);
        return hasVarDecl2 || hasVarFunc2;
      });
      if (!sel.length) {
        error2("selector missing");
      }
      return {
        type: "rule",
        selectors: sel,
        declarations: decls
      };
    }
    function rules(core) {
      if (!core && !open()) {
        return error2("missing '{'");
      }
      var node;
      var rules2 = comments();
      while (css.length && (core || css[0] !== "}") && (node = at_rule() || rule())) {
        if (node.type) {
          rules2.push(node);
        }
        rules2 = rules2.concat(comments());
      }
      if (!core && !close()) {
        return error2("missing '}'");
      }
      return rules2;
    }
    return {
      type: "stylesheet",
      stylesheet: {
        rules: rules(true),
        errors
      }
    };
  }
  function parseVars(cssData) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var defaults2 = {
      parseHost: false,
      store: {},
      onWarning: function onWarning2() {
      }
    };
    var settings = _extends({}, defaults2, options);
    var reVarDeclSelectors = new RegExp(":".concat(settings.parseHost ? "host" : "root", "$"));
    if (typeof cssData === "string") {
      cssData = parseCss(cssData, settings);
    }
    cssData.stylesheet.rules.forEach(function(rule) {
      if (rule.type !== "rule" || !rule.selectors.some(function(s4) {
        return reVarDeclSelectors.test(s4);
      })) {
        return;
      }
      rule.declarations.forEach(function(decl, i4) {
        var prop = decl.property;
        var value = decl.value;
        if (prop && prop.indexOf("--") === 0) {
          settings.store[prop] = value;
        }
      });
    });
    return settings.store;
  }
  function stringifyCss(tree) {
    var delim = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    var cb = arguments.length > 2 ? arguments[2] : void 0;
    var renderMethods = {
      charset: function charset(node) {
        return "@charset " + node.name + ";";
      },
      comment: function comment(node) {
        return node.comment.indexOf("__CSSVARSPONYFILL") === 0 ? "/*" + node.comment + "*/" : "";
      },
      "custom-media": function customMedia(node) {
        return "@custom-media " + node.name + " " + node.media + ";";
      },
      declaration: function declaration(node) {
        return node.property + ":" + node.value + ";";
      },
      document: function document2(node) {
        return "@" + (node.vendor || "") + "document " + node.document + "{" + visit(node.rules) + "}";
      },
      "font-face": function fontFace(node) {
        return "@font-face{" + visit(node.declarations) + "}";
      },
      host: function host(node) {
        return "@host{" + visit(node.rules) + "}";
      },
      import: function _import(node) {
        return "@import " + node.name + ";";
      },
      keyframe: function keyframe(node) {
        return node.values.join(",") + "{" + visit(node.declarations) + "}";
      },
      keyframes: function keyframes(node) {
        return "@" + (node.vendor || "") + "keyframes " + node.name + "{" + visit(node.keyframes) + "}";
      },
      media: function media(node) {
        return "@media " + node.media + "{" + visit(node.rules) + "}";
      },
      namespace: function namespace(node) {
        return "@namespace " + node.name + ";";
      },
      page: function page(node) {
        return "@page " + (node.selectors.length ? node.selectors.join(", ") : "") + "{" + visit(node.declarations) + "}";
      },
      "page-margin-box": function pageMarginBox(node) {
        return "@" + node.name + "{" + visit(node.declarations) + "}";
      },
      rule: function rule(node) {
        var decls = node.declarations;
        if (decls.length) {
          return node.selectors.join(",") + "{" + visit(decls) + "}";
        }
      },
      supports: function supports(node) {
        return "@supports " + node.supports + "{" + visit(node.rules) + "}";
      }
    };
    function visit(nodes) {
      var buf = "";
      for (var i4 = 0; i4 < nodes.length; i4++) {
        var n3 = nodes[i4];
        if (cb) {
          cb(n3);
        }
        var txt = renderMethods[n3.type](n3);
        if (txt) {
          buf += txt;
          if (txt.length && n3.selectors) {
            buf += delim;
          }
        }
      }
      return buf;
    }
    return visit(tree.stylesheet.rules);
  }
  function walkCss(node, fn) {
    node.rules.forEach(function(rule) {
      if (rule.rules) {
        walkCss(rule, fn);
        return;
      }
      if (rule.keyframes) {
        rule.keyframes.forEach(function(keyframe) {
          if (keyframe.type === "keyframe") {
            fn(keyframe.declarations, rule);
          }
        });
        return;
      }
      if (!rule.declarations) {
        return;
      }
      fn(rule.declarations, node);
    });
  }
  var VAR_PROP_IDENTIFIER = "--";
  var VAR_FUNC_IDENTIFIER = "var";
  function transformCss(cssData) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var defaults2 = {
      preserveStatic: true,
      preserveVars: false,
      variables: {},
      onWarning: function onWarning2() {
      }
    };
    var settings = _extends({}, defaults2, options);
    if (typeof cssData === "string") {
      cssData = parseCss(cssData, settings);
    }
    walkCss(cssData.stylesheet, function(declarations, node) {
      for (var i4 = 0; i4 < declarations.length; i4++) {
        var decl = declarations[i4];
        var type = decl.type;
        var prop = decl.property;
        var value = decl.value;
        if (type !== "declaration") {
          continue;
        }
        if (!settings.preserveVars && prop && prop.indexOf(VAR_PROP_IDENTIFIER) === 0) {
          declarations.splice(i4, 1);
          i4--;
          continue;
        }
        if (value.indexOf(VAR_FUNC_IDENTIFIER + "(") !== -1) {
          var resolvedValue = resolveValue(value, settings);
          if (resolvedValue !== decl.value) {
            resolvedValue = fixNestedCalc(resolvedValue);
            if (!settings.preserveVars) {
              decl.value = resolvedValue;
            } else {
              declarations.splice(i4, 0, {
                type,
                property: prop,
                value: resolvedValue
              });
              i4++;
            }
          }
        }
      }
    });
    return stringifyCss(cssData);
  }
  function fixNestedCalc(value) {
    var reCalcVal = /calc\(([^)]+)\)/g;
    (value.match(reCalcVal) || []).forEach(function(match) {
      var newVal = "calc".concat(match.split("calc").join(""));
      value = value.replace(match, newVal);
    });
    return value;
  }
  function resolveValue(value) {
    var settings = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var __recursiveFallback = arguments.length > 2 ? arguments[2] : void 0;
    if (value.indexOf("var(") === -1) {
      return value;
    }
    var valueData = balancedMatch("(", ")", value);
    function resolveFunc(value2) {
      var name = value2.split(",")[0].replace(/[\s\n\t]/g, "");
      var fallback = (value2.match(/(?:\s*,\s*){1}(.*)?/) || [])[1];
      var match = Object.prototype.hasOwnProperty.call(settings.variables, name) ? String(settings.variables[name]) : void 0;
      var replacement = match || (fallback ? String(fallback) : void 0);
      var unresolvedFallback = __recursiveFallback || value2;
      if (!match) {
        settings.onWarning('variable "'.concat(name, '" is undefined'));
      }
      if (replacement && replacement !== "undefined" && replacement.length > 0) {
        return resolveValue(replacement, settings, unresolvedFallback);
      } else {
        return "var(".concat(unresolvedFallback, ")");
      }
    }
    if (!valueData) {
      if (value.indexOf("var(") !== -1) {
        settings.onWarning('missing closing ")" in the value "'.concat(value, '"'));
      }
      return value;
    } else if (valueData.pre.slice(-3) === "var") {
      var isEmptyVarFunc = valueData.body.trim().length === 0;
      if (isEmptyVarFunc) {
        settings.onWarning("var() must contain a non-whitespace string");
        return value;
      } else {
        return valueData.pre.slice(0, -3) + resolveFunc(valueData.body) + resolveValue(valueData.post, settings);
      }
    } else {
      return valueData.pre + "(".concat(resolveValue(valueData.body, settings), ")") + resolveValue(valueData.post, settings);
    }
  }
  var isBrowser = typeof window !== "undefined";
  var isNativeSupport = isBrowser && window.CSS && window.CSS.supports && window.CSS.supports("(--a: 0)");
  var counters = {
    group: 0,
    job: 0
  };
  var defaults = {
    rootElement: isBrowser ? document : null,
    shadowDOM: false,
    include: "style,link[rel=stylesheet]",
    exclude: "",
    variables: {},
    onlyLegacy: true,
    preserveStatic: true,
    preserveVars: false,
    silent: false,
    updateDOM: true,
    updateURLs: true,
    watch: null,
    onBeforeSend: function onBeforeSend() {
    },
    onError: function onError() {
    },
    onWarning: function onWarning() {
    },
    onSuccess: function onSuccess() {
    },
    onComplete: function onComplete() {
    },
    onFinally: function onFinally() {
    }
  };
  var regex = {
    cssComments: /\/\*[\s\S]+?\*\//g,
    cssKeyframes: /@(?:-\w*-)?keyframes/,
    cssMediaQueries: /@media[^{]+\{([\s\S]+?})\s*}/g,
    cssUrls: /url\((?!['"]?(?:data|http|\/\/):)['"]?([^'")]*)['"]?\)/g,
    cssVarDeclRules: /(?::(?:root|host)(?![.:#(])[\s,]*[^{]*{\s*[^}]*})/g,
    cssVarDecls: /(?:[\s;]*)(-{2}\w[\w-]*)(?:\s*:\s*)([^;]*);/g,
    cssVarFunc: /var\(\s*--[\w-]/,
    cssVars: /(?:(?::(?:root|host)(?![.:#(])[\s,]*[^{]*{\s*[^;]*;*\s*)|(?:var\(\s*))(--[^:)]+)(?:\s*[:)])/
  };
  var variableStore = {
    dom: {},
    job: {},
    user: {}
  };
  var cssVarsIsRunning = false;
  var cssVarsObserver = null;
  var cssVarsSrcNodeCount = 0;
  var debounceTimer = null;
  var isShadowDOMReady = false;
  function cssVars() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var msgPrefix = "cssVars(): ";
    var settings = _extends({}, defaults, options);
    function handleError(message, sourceNode, xhr, url) {
      if (!settings.silent && window.console) {
        console.error("".concat(msgPrefix).concat(message, "\n"), sourceNode);
      }
      settings.onError(message, sourceNode, xhr, url);
    }
    function handleWarning(message) {
      if (!settings.silent && window.console) {
        console.warn("".concat(msgPrefix).concat(message));
      }
      settings.onWarning(message);
    }
    function handleFinally(hasChanged) {
      settings.onFinally(Boolean(hasChanged), isNativeSupport, getTimeStamp() - settings.__benchmark);
    }
    if (!isBrowser) {
      return;
    }
    if (settings.watch) {
      settings.watch = defaults.watch;
      addMutationObserver(settings);
      cssVars(settings);
      return;
    } else if (settings.watch === false && cssVarsObserver) {
      cssVarsObserver.disconnect();
      cssVarsObserver = null;
    }
    if (!settings.__benchmark) {
      if (cssVarsIsRunning === settings.rootElement) {
        cssVarsDebounced(options);
        return;
      }
      var srcNodes = [].slice.call(settings.rootElement.querySelectorAll('[data-cssvars]:not([data-cssvars="out"])'));
      settings.__benchmark = getTimeStamp();
      settings.exclude = [cssVarsObserver ? '[data-cssvars]:not([data-cssvars=""])' : '[data-cssvars="out"]', "link[disabled]:not([data-cssvars])", settings.exclude].filter(function(selector) {
        return selector;
      }).join(",");
      settings.variables = fixVarNames(settings.variables);
      srcNodes.forEach(function(srcNode) {
        var hasStyleCache = srcNode.nodeName.toLowerCase() === "style" && srcNode.__cssVars.text;
        var hasStyleChanged = hasStyleCache && srcNode.textContent !== srcNode.__cssVars.text;
        if (hasStyleCache && hasStyleChanged) {
          srcNode.sheet && (srcNode.sheet.disabled = false);
          srcNode.setAttribute("data-cssvars", "");
        }
      });
      if (!cssVarsObserver) {
        var outNodes = [].slice.call(settings.rootElement.querySelectorAll('[data-cssvars="out"]'));
        outNodes.forEach(function(outNode) {
          var dataGroup = outNode.getAttribute("data-cssvars-group");
          var srcNode = dataGroup ? settings.rootElement.querySelector('[data-cssvars="src"][data-cssvars-group="'.concat(dataGroup, '"]')) : null;
          if (!srcNode) {
            outNode.parentNode.removeChild(outNode);
          }
        });
        if (cssVarsSrcNodeCount && srcNodes.length < cssVarsSrcNodeCount) {
          cssVarsSrcNodeCount = srcNodes.length;
          variableStore.dom = {};
        }
      }
    }
    if (document.readyState !== "loading") {
      if (isNativeSupport && settings.onlyLegacy) {
        var hasVarChange = false;
        if (settings.updateDOM) {
          var targetElm = settings.rootElement.host || (settings.rootElement === document ? document.documentElement : settings.rootElement);
          Object.keys(settings.variables).forEach(function(key) {
            var varValue = settings.variables[key];
            hasVarChange = hasVarChange || varValue !== getComputedStyle(targetElm).getPropertyValue(key);
            targetElm.style.setProperty(key, varValue);
          });
        }
        handleFinally(hasVarChange);
      } else if (!isShadowDOMReady && (settings.shadowDOM || settings.rootElement.shadowRoot || settings.rootElement.host)) {
        getCssData({
          rootElement: defaults.rootElement,
          include: defaults.include,
          exclude: settings.exclude,
          skipDisabled: false,
          onSuccess: function onSuccess2(cssText, node, url) {
            var isUserDisabled = (node.sheet || {}).disabled && !node.__cssVars;
            if (isUserDisabled) {
              return false;
            }
            cssText = cssText.replace(regex.cssComments, "").replace(regex.cssMediaQueries, "");
            cssText = (cssText.match(regex.cssVarDeclRules) || []).join("");
            return cssText || false;
          },
          onComplete: function onComplete2(cssText, cssArray, nodeArray) {
            parseVars(cssText, {
              store: variableStore.dom,
              onWarning: handleWarning
            });
            isShadowDOMReady = true;
            cssVars(settings);
          }
        });
      } else {
        cssVarsIsRunning = settings.rootElement;
        getCssData({
          rootElement: settings.rootElement,
          include: settings.include,
          exclude: settings.exclude,
          skipDisabled: false,
          onBeforeSend: settings.onBeforeSend,
          onError: function onError2(xhr, node, url) {
            var responseUrl = xhr.responseURL || getFullUrl(url, location.href);
            var statusText = xhr.statusText ? "(".concat(xhr.statusText, ")") : "Unspecified Error" + (xhr.status === 0 ? " (possibly CORS related)" : "");
            var errorMsg = "CSS XHR Error: ".concat(responseUrl, " ").concat(xhr.status, " ").concat(statusText);
            handleError(errorMsg, node, xhr, responseUrl);
          },
          onSuccess: function onSuccess2(cssText, node, url) {
            var isUserDisabled = (node.sheet || {}).disabled && !node.__cssVars;
            if (isUserDisabled) {
              return false;
            }
            var isLink = node.nodeName.toLowerCase() === "link";
            var isStyleImport = node.nodeName.toLowerCase() === "style" && cssText !== node.textContent;
            var returnVal = settings.onSuccess(cssText, node, url);
            cssText = returnVal !== void 0 && Boolean(returnVal) === false ? "" : returnVal || cssText;
            if (settings.updateURLs && (isLink || isStyleImport)) {
              cssText = fixRelativeCssUrls(cssText, url);
            }
            return cssText;
          },
          onComplete: function onComplete2(cssText, cssArray) {
            var nodeArray = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
            var currentVars = _extends({}, variableStore.dom, variableStore.user);
            var hasVarChange2 = false;
            variableStore.job = {};
            nodeArray.forEach(function(node, i5) {
              var nodeCSS = cssArray[i5];
              node.__cssVars = node.__cssVars || {};
              node.__cssVars.text = nodeCSS;
              if (regex.cssVars.test(nodeCSS)) {
                try {
                  var cssTree = parseCss(nodeCSS, {
                    preserveStatic: settings.preserveStatic,
                    removeComments: true
                  });
                  parseVars(cssTree, {
                    parseHost: Boolean(settings.rootElement.host),
                    store: variableStore.dom,
                    onWarning: handleWarning
                  });
                  node.__cssVars.tree = cssTree;
                } catch (err) {
                  handleError(err.message, node);
                }
              }
            });
            _extends(variableStore.job, variableStore.dom);
            if (settings.updateDOM) {
              _extends(variableStore.user, settings.variables);
              _extends(variableStore.job, variableStore.user);
            } else {
              _extends(variableStore.job, variableStore.user, settings.variables);
              _extends(currentVars, settings.variables);
            }
            hasVarChange2 = counters.job > 0 && Boolean(Object.keys(variableStore.job).length > Object.keys(currentVars).length || Boolean(Object.keys(currentVars).length && Object.keys(variableStore.job).some(function(key) {
              return variableStore.job[key] !== currentVars[key];
            })));
            if (hasVarChange2) {
              resetCssNodes(settings.rootElement);
              cssVars(settings);
            } else {
              var outCssArray = [];
              var outNodeArray = [];
              var hasKeyframesWithVars = false;
              if (settings.updateDOM) {
                counters.job++;
              }
              nodeArray.forEach(function(node, i5) {
                var isSkip = !node.__cssVars.tree;
                if (node.__cssVars.tree) {
                  try {
                    transformCss(node.__cssVars.tree, _extends({}, settings, {
                      variables: variableStore.job,
                      onWarning: handleWarning
                    }));
                    var outCss = stringifyCss(node.__cssVars.tree);
                    if (settings.updateDOM) {
                      var nodeCSS = cssArray[i5];
                      var hasCSSVarFunc = regex.cssVarFunc.test(nodeCSS);
                      if (!node.getAttribute("data-cssvars")) {
                        node.setAttribute("data-cssvars", "src");
                      }
                      if (outCss.length && hasCSSVarFunc) {
                        var dataGroup = node.getAttribute("data-cssvars-group") || ++counters.group;
                        var outCssNoSpaces = outCss.replace(/\s/g, "");
                        var outNode = settings.rootElement.querySelector('[data-cssvars="out"][data-cssvars-group="'.concat(dataGroup, '"]')) || document.createElement("style");
                        hasKeyframesWithVars = hasKeyframesWithVars || regex.cssKeyframes.test(outCss);
                        if (settings.preserveStatic) {
                          node.sheet && (node.sheet.disabled = true);
                        }
                        if (!outNode.hasAttribute("data-cssvars")) {
                          outNode.setAttribute("data-cssvars", "out");
                        }
                        if (outCssNoSpaces === node.textContent.replace(/\s/g, "")) {
                          isSkip = true;
                          if (outNode && outNode.parentNode) {
                            node.removeAttribute("data-cssvars-group");
                            outNode.parentNode.removeChild(outNode);
                          }
                        } else if (outCssNoSpaces !== outNode.textContent.replace(/\s/g, "")) {
                          [node, outNode].forEach(function(n3) {
                            n3.setAttribute("data-cssvars-job", counters.job);
                            n3.setAttribute("data-cssvars-group", dataGroup);
                          });
                          outNode.textContent = outCss;
                          outCssArray.push(outCss);
                          outNodeArray.push(outNode);
                          if (!outNode.parentNode) {
                            node.parentNode.insertBefore(outNode, node.nextSibling);
                          }
                        }
                      }
                    } else {
                      if (node.textContent.replace(/\s/g, "") !== outCss) {
                        outCssArray.push(outCss);
                      }
                    }
                  } catch (err) {
                    handleError(err.message, node);
                  }
                }
                if (isSkip) {
                  node.setAttribute("data-cssvars", "skip");
                }
                if (!node.hasAttribute("data-cssvars-job")) {
                  node.setAttribute("data-cssvars-job", counters.job);
                }
              });
              cssVarsSrcNodeCount = settings.rootElement.querySelectorAll('[data-cssvars]:not([data-cssvars="out"])').length;
              if (settings.shadowDOM) {
                var elms = [].concat(settings.rootElement).concat([].slice.call(settings.rootElement.querySelectorAll("*")));
                for (var i4 = 0, elm; elm = elms[i4]; ++i4) {
                  if (elm.shadowRoot && elm.shadowRoot.querySelector("style")) {
                    var shadowSettings = _extends({}, settings, {
                      rootElement: elm.shadowRoot
                    });
                    cssVars(shadowSettings);
                  }
                }
              }
              if (settings.updateDOM && hasKeyframesWithVars) {
                fixKeyframes(settings.rootElement);
              }
              cssVarsIsRunning = false;
              settings.onComplete(outCssArray.join(""), outNodeArray, JSON.parse(JSON.stringify(variableStore.job)), getTimeStamp() - settings.__benchmark);
              handleFinally(outNodeArray.length);
            }
          }
        });
      }
    } else {
      document.addEventListener("DOMContentLoaded", function init(evt) {
        cssVars(options);
        document.removeEventListener("DOMContentLoaded", init);
      });
    }
  }
  cssVars.reset = function() {
    counters.job = 0;
    counters.group = 0;
    cssVarsIsRunning = false;
    if (cssVarsObserver) {
      cssVarsObserver.disconnect();
      cssVarsObserver = null;
    }
    cssVarsSrcNodeCount = 0;
    debounceTimer = null;
    isShadowDOMReady = false;
    for (var prop in variableStore) {
      variableStore[prop] = {};
    }
  };
  function addMutationObserver(settings) {
    function isDisabled(node) {
      var isDisabledAttr = isLink(node) && node.hasAttribute("disabled");
      var isDisabledSheet = (node.sheet || {}).disabled;
      return isDisabledAttr || isDisabledSheet;
    }
    function isLink(node) {
      var isStylesheet = node.nodeName.toLowerCase() === "link" && (node.getAttribute("rel") || "").indexOf("stylesheet") !== -1;
      return isStylesheet;
    }
    function isStyle(node) {
      return node.nodeName.toLowerCase() === "style";
    }
    function isValidAttributeMutation(mutation) {
      var isValid = false;
      if (mutation.type === "attributes" && isLink(mutation.target) && !isDisabled(mutation.target)) {
        var isEnabledMutation = mutation.attributeName === "disabled";
        var isHrefMutation = mutation.attributeName === "href";
        var isSkipNode = mutation.target.getAttribute("data-cssvars") === "skip";
        var isSrcNode = mutation.target.getAttribute("data-cssvars") === "src";
        if (isEnabledMutation) {
          isValid = !isSkipNode && !isSrcNode;
        } else if (isHrefMutation) {
          if (isSkipNode) {
            mutation.target.setAttribute("data-cssvars", "");
          } else if (isSrcNode) {
            resetCssNodes(settings.rootElement, true);
          }
          isValid = true;
        }
      }
      return isValid;
    }
    function isValidStyleTextMutation(mutation) {
      var isValid = false;
      if (mutation.type === "childList") {
        var isStyleElm = isStyle(mutation.target);
        var isOutNode = mutation.target.getAttribute("data-cssvars") === "out";
        isValid = isStyleElm && !isOutNode;
      }
      return isValid;
    }
    function isValidAddMutation(mutation) {
      var isValid = false;
      if (mutation.type === "childList") {
        isValid = [].slice.call(mutation.addedNodes).some(function(node) {
          var isElm = node.nodeType === 1;
          var hasAttr = isElm && node.hasAttribute("data-cssvars");
          var isStyleWithVars = isStyle(node) && regex.cssVars.test(node.textContent);
          var isValid2 = !hasAttr && (isLink(node) || isStyleWithVars);
          return isValid2 && !isDisabled(node);
        });
      }
      return isValid;
    }
    function isValidRemoveMutation(mutation) {
      var isValid = false;
      if (mutation.type === "childList") {
        isValid = [].slice.call(mutation.removedNodes).some(function(node) {
          var isElm = node.nodeType === 1;
          var isOutNode = isElm && node.getAttribute("data-cssvars") === "out";
          var isSrcNode = isElm && node.getAttribute("data-cssvars") === "src";
          var isValid2 = isSrcNode;
          if (isSrcNode || isOutNode) {
            var dataGroup = node.getAttribute("data-cssvars-group");
            var orphanNode = settings.rootElement.querySelector('[data-cssvars-group="'.concat(dataGroup, '"]'));
            if (isSrcNode) {
              resetCssNodes(settings.rootElement, true);
            }
            if (orphanNode) {
              orphanNode.parentNode.removeChild(orphanNode);
            }
          }
          return isValid2;
        });
      }
      return isValid;
    }
    if (!window.MutationObserver) {
      return;
    }
    if (cssVarsObserver) {
      cssVarsObserver.disconnect();
      cssVarsObserver = null;
    }
    cssVarsObserver = new MutationObserver(function(mutations) {
      var hasValidMutation = mutations.some(function(mutation) {
        return isValidAttributeMutation(mutation) || isValidStyleTextMutation(mutation) || isValidAddMutation(mutation) || isValidRemoveMutation(mutation);
      });
      if (hasValidMutation) {
        cssVars(settings);
      }
    });
    cssVarsObserver.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["disabled", "href"],
      childList: true,
      subtree: true
    });
  }
  function cssVarsDebounced(settings) {
    var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(function() {
      settings.__benchmark = null;
      cssVars(settings);
    }, delay);
  }
  function fixKeyframes(rootElement) {
    var animationNameProp = ["animation-name", "-moz-animation-name", "-webkit-animation-name"].filter(function(prop) {
      return getComputedStyle(document.body)[prop];
    })[0];
    if (animationNameProp) {
      var allNodes = [].slice.call(rootElement.querySelectorAll("*"));
      var keyframeNodes = [];
      var nameMarker = "__CSSVARSPONYFILL-KEYFRAMES__";
      for (var i4 = 0, len = allNodes.length; i4 < len; i4++) {
        var node = allNodes[i4];
        var animationName = getComputedStyle(node)[animationNameProp];
        if (animationName !== "none") {
          node.style[animationNameProp] += nameMarker;
          keyframeNodes.push(node);
        }
      }
      void document.body.offsetHeight;
      for (var _i = 0, _len = keyframeNodes.length; _i < _len; _i++) {
        var nodeStyle = keyframeNodes[_i].style;
        nodeStyle[animationNameProp] = nodeStyle[animationNameProp].replace(nameMarker, "");
      }
    }
  }
  function fixRelativeCssUrls(cssText, baseUrl) {
    var cssUrls = cssText.replace(regex.cssComments, "").match(regex.cssUrls) || [];
    cssUrls.forEach(function(cssUrl) {
      var oldUrl = cssUrl.replace(regex.cssUrls, "$1");
      var newUrl = getFullUrl(oldUrl, baseUrl);
      cssText = cssText.replace(cssUrl, cssUrl.replace(oldUrl, newUrl));
    });
    return cssText;
  }
  function fixVarNames() {
    var varObj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var reLeadingHyphens = /^-{2}/;
    return Object.keys(varObj).reduce(function(obj, value) {
      var key = reLeadingHyphens.test(value) ? value : "--".concat(value.replace(/^-+/, ""));
      obj[key] = varObj[value];
      return obj;
    }, {});
  }
  function getFullUrl(url) {
    var base = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : location.href;
    var d4 = document.implementation.createHTMLDocument("");
    var b4 = d4.createElement("base");
    var a4 = d4.createElement("a");
    d4.head.appendChild(b4);
    d4.body.appendChild(a4);
    b4.href = base;
    a4.href = url;
    return a4.href;
  }
  function getTimeStamp() {
    return isBrowser && (window.performance || {}).now ? window.performance.now() : (/* @__PURE__ */ new Date()).getTime();
  }
  function resetCssNodes(rootElement) {
    var resetDOMVariableStore = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var resetNodes = [].slice.call(rootElement.querySelectorAll('[data-cssvars="skip"],[data-cssvars="src"]'));
    resetNodes.forEach(function(node) {
      return node.setAttribute("data-cssvars", "");
    });
    if (resetDOMVariableStore) {
      variableStore.dom = {};
    }
  }

  // stylePlugin:D:\code\github\univer\packages\ui-plugin-sheets\src\View\SheetContainer\index.module.less
  var index_module_default28 = {
    "layoutContainer": "univer-layout-container",
    "contentContainerHorizontal": "univer-content-container-horizontal",
    "contentInnerLeftContainer": "univer-content-inner-left-container",
    "hoverCursor": "univer-hover-cursor",
    "contentInnerRightContainer": "univer-content-inner-right-container",
    "contentContainerVertical": "univer-content-container-vertical",
    "mainContent": "univer-main-content",
    "outerRightContainer": "univer-outer-right-container"
  };

  // stylePlugin:D:\code\github\univer\packages\ui-plugin-sheets\src\View\InfoBar\index.module.less
  var index_module_default29 = {
    "infoDetail": "univer-info-detail",
    "infoReturn": "univer-info-return",
    "univericon": "univer-univericon",
    "univericonLogo": "univer-univericon-logo",
    "sheetName": "univer-sheet-name",
    "infoDetailUpdate": "univer-info-detail-update",
    "infoDetailSave": "univer-info-detail-save"
  };

  // ../../packages/ui-plugin-sheets/src/View/InfoBar/InfoBar.tsx
  var InfoBar = class extends Component {
    initialize() {
      this.state = {
        infoList: null
      };
    }
    componentDidMount() {
      this.props.getComponent?.(this);
    }
    setInfoList(list) {
      this.setState({
        infoList: list
      });
    }
    render() {
      const { renameSheet } = this.props;
      if (!this.state.infoList)
        return;
      const { back, sheet, update: update2, save, rename } = this.state.infoList;
      return <Container className={index_module_default29.infoDetail}>
        {
          /* <div style={{ marginRight: '18px' }}>
              <Tooltip title={back.label} placement={'bottom'}>
                  <Button className={styles.infoReturn} type="text">
                      <DropDownIcon rotate={90} />
                  </Button>
              </Tooltip>
          </div> */
        }
        {
          /* <LogoIcon style={{ width: '152px', height: '32px' }} /> */
        }
        <div className={index_module_default29.sheetName}><Tooltip title={rename.label} placement="bottom"><Input bordered={false} value={sheet.label} onBlur={renameSheet} /></Tooltip></div>
        <div className={index_module_default29.infoDetailUpdate}>{update2.label}</div>
        <div className={index_module_default29.infoDetailSave}>{save.label}</div>
      </Container>;
    }
  };

  // stylePlugin:D:\code\github\univer\packages\ui-plugin-sheets\src\View\RightMenu\index.module.less
  var index_module_default30 = {
    "contextMenu": "univer-context-menu",
    "colsMenu": "univer-cols-menu",
    "colsMenuitem": "univer-cols-menuitem",
    "btn": "univer-btn",
    "rightMenuCenter": "univer-right-menu-center",
    "rightMenuItem": "univer-right-menu-item"
  };

  // ../../packages/ui-plugin-sheets/src/View/RightMenu/RightMenu.tsx
  var RightMenu = class extends Component {
    ulRef = d();
    root = d();
    initialize() {
      this.state = {
        visible: false,
        srcElement: null,
        eventType: null,
        children: [],
        replace: []
      };
    }
    // 
    resetMenuList(children, replace) {
      const componentManager = this.getContext().getPluginManager().getPluginByName(SHEET_UI_PLUGIN_NAME)?.getComponentManager();
      for (let i4 = 0; i4 < children.length; i4++) {
        const item = children[i4];
        if (item.customLabel) {
          const Label = componentManager?.get(item.customLabel.name);
          const props = item.customLabel.props ?? {};
          if (Label) {
            item.label = <Label {...props} />;
          }
        } else if (typeof item.label === "string") {
          item.label = this.getLocale(replace[i4].label);
        }
        if (item.children) {
          item.children = this.resetMenuList(item.children, replace[i4].children);
        }
      }
      return children;
    }
    setMenuList(children) {
      this.setState({
        children,
        replace: JSON.parse(JSON.stringify(children))
      });
    }
    // TODO:
    componentDidMount() {
      this.props.getComponent?.(this);
      document.addEventListener("click", this.handleClick);
    }
    componentWillUnmount() {
      document.removeEventListener("click", this.handleClick);
    }
    // 
    handleContextMenu = async (event, rect, down) => {
      event.preventDefault();
      this.setState({ visible: true, srcElement: event.target, eventType: event.type }, () => {
        new Promise((resolve, reject) => {
          this.ulRef.current.showMenu(true);
          resolve();
        }).then(() => {
          const clickX = !down ? event.clientX : rect.x;
          const clickY = !down ? event.clientY : rect.y;
          const screenW = window.innerWidth;
          const screenH = window.innerHeight;
          const rootW = this.ulRef.current.base.offsetWidth;
          const rootH = this.ulRef.current.base.offsetHeight;
          const right = screenW - clickX > rootW;
          const left = !right;
          const bottom = screenH - clickY > rootH;
          const top = !bottom;
          if (right) {
            this.root.current.style.left = `${clickX}px`;
          }
          if (left) {
            this.root.current.style.left = `${clickX - rootW}px`;
          }
          if (bottom) {
            this.root.current.style.top = `${clickY}px`;
          }
          if (top) {
            this.root.current.style.top = `${clickY - rootH}px`;
          }
        });
      });
    };
    // 
    handleClick = (e4) => {
      const { visible, eventType, srcElement } = this.state;
      if (!this.root.current)
        return;
      if (eventType === "click" && srcElement && srcElement.contains(e4.target)) {
        return;
      }
      if (this.root.current.contains(e4.target)) {
        return;
      }
      if (visible) {
        this.setState({ visible: false });
      }
    };
    // 
    showRightMenu(show) {
      this.ulRef.current.showMenu(show);
    }
    render() {
      if (!this.state.children.length) {
        return;
      }
      const wrapStyles = { ...this.props.style };
      const { visible } = this.state;
      return visible && <div
        ref={this.root}
        className={index_module_default30.contextMenu}
        style={wrapStyles}
        onContextMenu={(e4) => {
          e4.preventDefault();
        }}
      ><Menu ref={this.ulRef} menu={this.resetMenuList(this.state.children, this.state.replace)} onClick={this.handleClick} /></div>;
    }
  };

  // ../../packages/ui-plugin-sheets/src/View/RightMenu/RightMenuInput.tsx
  var RightMenuInput = class extends Component {
    handleClick(e4) {
      e4.stopPropagation();
    }
    handleKeyUp(e4) {
      const { onKeyUp } = this.props;
      onKeyUp?.(e4);
    }
    render() {
      const { prefix, suffix } = this.props;
      return <div>
        {this.getLocale(prefix)}
        <Input onPressEnter={this.handleKeyUp.bind(this)} type="number" placeholder="1" onClick={this.handleClick} />
        {this.getLocale(suffix)}
      </div>;
    }
  };

  // ../../packages/ui-plugin-sheets/src/View/RightMenu/RightMenuItem.tsx
  var RightMenuItem = class extends Component {
    render() {
      const { label } = this.props;
      return <div className={index_module_default30.rightMenuItem}>
        {this.getLocale(label)}
        <Icon_exports.Format.RightIcon />
      </div>;
    }
  };

  // stylePlugin:D:\code\github\univer\packages\ui-plugin-sheets\src\View\CountBar\index.module.less
  var index_module_default31 = {
    "countBar": "univer-count-bar",
    "btn": "univer-btn",
    "countZoom": "univer-count-zoom",
    "countSlider": "univer-count-slider",
    "countStatistic": "univer-count-statistic"
  };

  // ../../packages/ui-plugin-sheets/src/View/CountBar/CountBar.tsx
  var CountBar = class extends Component {
    max = 400;
    min = 0;
    ref = d();
    initialize(props) {
      this.state = {
        zoom: 100,
        content: ""
      };
    }
    setValue = (value, fn) => {
      this.setState(
        (prevState) => ({
          ...value
        }),
        fn
      );
    };
    setZoom(zoom) {
      if (zoom !== this.state.zoom) {
        this.setValue({
          zoom
        });
        this.ref.current.changeInputValue(0, zoom);
      }
    }
    onChange = (e4) => {
      let target = e4.target;
      if (this.props.onChange) {
        this.props.onChange(target.value);
      }
      this.setValue({ zoom: target.value });
      this.ref.current.changeInputValue(0, target.value);
    };
    handleClick = (e4, value) => {
      this.setValue({ zoom: value });
    };
    addZoom = () => {
      let number = Math.floor(this.state.zoom / 10);
      let value = (number + 1) * 10;
      if (value >= this.max)
        value = this.max;
      this.setValue({ zoom: value });
      if (this.props.onChange) {
        this.props.onChange(String(value));
      }
    };
    reduceZoom = () => {
      let number = Math.ceil(this.state.zoom / 10);
      let value = (number - 1) * 10;
      if (value <= this.min)
        value = this.min;
      this.setValue({ zoom: value });
      if (this.props.onChange) {
        this.props.onChange(String(value));
      }
      this.ref.current.changeInputValue(0, value);
    };
    componentDidMount() {
      this.getContext().getObserverManager().getObserver("onCountBarDidMountObservable", "spreadsheet" /* SPREADSHEET */)?.notifyObservers(this);
    }
    render(props, state) {
      const { zoom, content } = state;
      return <div className={index_module_default31.countBar}>
        <Button_default type="text" className={index_module_default31.countZoom}>{zoom}</Button_default>
        <Button_default type="text" onClick={this.addZoom}><Icon_exports.Math.AddIcon /></Button_default>
        <div className={index_module_default31.countSlider}><Slider ref={this.ref} onChange={this.onChange} value={zoom} min={this.min} max={this.max} onClick={this.handleClick} /></div>
        <Button_default type="text" onClick={this.reduceZoom}><Icon_exports.Math.ReduceIcon /></Button_default>
        {
          /* <Button type="text">
              <PageIcon />
          </Button> */
        }
        {
          /* <Button type="text">
              <LayoutIcon />
          </Button> */
        }
        <Button_default type="text"><Icon_exports.Sheet.RegularIcon /></Button_default>
        <span className={index_module_default31.countStatistic}>{content}</span>
      </div>;
    }
  };

  // stylePlugin:D:\code\github\univer\packages\ui-plugin-sheets\src\View\SheetBar\index.module.less
  var index_module_default32 = {
    "sheetBar": "univer-sheet-bar",
    "sheetBarOptions": "univer-sheet-bar-options",
    "sheetBarOptionsButton": "univer-sheet-bar-options-button",
    "sheetBarScrollButton": "univer-sheet_bar_scroll_button",
    "slideTabBar": "univer-slide-tab-bar",
    "slideTabActive": "univer-slide-tab-active",
    "slideTabItem": "univer-slide-tab-item",
    "slideTabDivider": "univer-slide-tab-divider",
    "slideTabContent": "univer-slide-tab-content",
    "slideTabTitle": "univer-slide-tab-title",
    "slideTabIcon": "univer-slide-tab-icon",
    "slideTabFooter": "univer-slide-tab-footer",
    "slideTabActiveBar": "univer-slide-tab-active-bar",
    "sheetUl": "univer-sheet-ul",
    "colsMenuitem": "univer-cols-menuitem",
    "selectColorPickerParent": "univer-select-color-picker-parent",
    "selectItemContent": "univer-select-item-content",
    "selectColorPicker": "univer-select-color-picker",
    "selectItem": "univer-select-item",
    "sheetBarMenu": "univer-sheet-bar-menu",
    "sheetBarMenuItem": "univer-sheet-bar-menu-item",
    "sheetBarMenuIcon": "univer-sheet-bar-menu-icon",
    "sheetBarMenuItemHide": "univer-sheet-bar-menu-item-hide"
  };

  // ../../packages/ui-plugin-sheets/src/View/SheetBar/SheetBarMenu.tsx
  var SheetBarMenu = class extends Component {
    initialize() {
      this.state = {
        show: false
      };
    }
    handleClick(e4, item) {
      e4.stopPropagation();
      const { onClick } = this.props;
      if (item.onClick) {
        item.onClick(e4);
      }
      onClick?.(e4);
      this.showMenu(false);
      window.removeEventListener("click", this.hideMenu, true);
    }
    hideMenu = () => {
      this.showMenu(false);
    };
    showMenu(show) {
      this.setState({ show }, () => {
        if (this.state.show)
          window.addEventListener("click", this.hideMenu, true);
      });
    }
    render() {
      const { menu, style } = this.props;
      const { show } = this.state;
      return <ul className={index_module_default32.sheetBarMenu} style={{ ...style, display: show ? "block" : " none" }}>{menu.map((item) => <li onClick={(e4) => this.handleClick(e4, item)} className={joinClassNames(index_module_default32.sheetBarMenuItem, item.hide ? index_module_default32.sheetBarMenuItemHide : "")}>
        <span className={index_module_default32.sheetBarMenuIcon}>
          {item.hide ? <Icon_exports.HideIcon /> : ""}
          {item.selected ? <Icon_exports.Data.CheckIcon /> : ""}
        </span>
        {item.label}
      </li>)}</ul>;
    }
  };

  // ../../packages/ui-plugin-sheets/src/Basics/SlideTabBar/SlideScrollbar.ts
  var SlideScrollbar = class {
    _slideTabBar;
    _scrollX;
    constructor(slideTabBar) {
      const primeval = slideTabBar.primeval();
      this._scrollX = primeval.scrollLeft;
      this._slideTabBar = slideTabBar;
    }
    scrollX(x4) {
      const primeval = this._slideTabBar.primeval();
      primeval.scrollLeft = x4;
      this._scrollX = primeval.scrollLeft;
    }
    scrollRight() {
      const primeval = this._slideTabBar.primeval();
      primeval.scrollLeft = primeval.scrollWidth;
      this._scrollX = primeval.scrollLeft;
    }
    getScrollX() {
      return this._scrollX;
    }
  };

  // ../../packages/ui-plugin-sheets/src/Basics/SlideTabBar/Animate.ts
  var Tween = {
    easeOutStrong(t4, b4, c4, d4) {
      return -c4 * ((t4 = t4 / d4 - 1) * t4 * t4 * t4 - 1) + b4;
    },
    backOut(t4, b4, c4, d4, s4) {
      if (typeof s4 === "undefined") {
        s4 = 0.7;
      }
      return c4 * ((t4 = t4 / d4 - 1) * t4 * ((s4 + 1) * t4 + s4) + 1) + b4;
    }
  };
  var CONFIG = {
    loop: false,
    begin: 0,
    end: 0,
    duration: 300,
    delay: 0,
    type: "easeOutStrong",
    receive(v4) {
    },
    success(v4) {
    },
    cancel(v4) {
    },
    complete(v4) {
    }
  };
  var Animate = class {
    static success(...animates) {
      let successNumber = 0;
      return new Promise((resolve) => {
        for (let i4 = 0; i4 < animates.length; i4++) {
          let animate = animates[i4];
          let config = animate._config;
          let success = config.success;
          let loop = config.loop;
          if (loop) {
            continue;
          }
          config.success = (v4) => {
            successNumber++;
            if (success) {
              success.call(animate, v4);
            }
            if (successNumber === animates.length) {
              resolve();
            }
          };
        }
      });
    }
    _config;
    _status;
    _start;
    _handle;
    _delayHandle;
    _fakeHandle() {
      let times = Date.now() - this._start;
      times = times >= this._config.duration ? this._config.duration : times;
      let val = Tween[this._config.type](times, this._config.begin, this._config.end - this._config.begin, this._config.duration, 0.7);
      let fix = val.toFixed(2);
      this._config.receive(fix);
      if (this._status === 1 /* Cancel */) {
        this._config.cancel(fix);
        this._config.complete(fix);
        return;
      }
      if (times === this._config.duration) {
        this._config.success(fix);
        this._config.complete(fix);
        return;
      }
      this._handle = requestAnimationFrame(() => {
        this._fakeHandle();
      });
    }
    constructor(config) {
      this._config = {
        ...CONFIG,
        ...config
      };
      if (this._config.loop) {
        this._config.complete = () => {
        };
        this._config.success = () => {
          this.request();
        };
      }
    }
    request() {
      if (this._config.delay === 0) {
        this._status = 0 /* Request */;
        this._start = Date.now();
        this._fakeHandle();
      } else {
        this._delayHandle && clearTimeout(this._delayHandle);
        this._delayHandle = setTimeout(() => {
          this._status = 0 /* Request */;
          this._start = Date.now();
          this._fakeHandle();
        }, this._config.delay);
      }
    }
    cancel() {
      this._status = 1 /* Cancel */;
      this._delayHandle && clearTimeout(this._delayHandle);
      cancelAnimationFrame(this._handle);
    }
  };

  // ../../packages/ui-plugin-sheets/src/Basics/SlideTabBar/SlideTabItem.ts
  var SlideTabItem = class {
    static midline(item) {
      return item.getBoundingRect().x + item.getBoundingRect().width / 2;
    }
    static make(nodeList, slideTabBar) {
      let result = [];
      nodeList.forEach((item) => result.push(new SlideTabItem(item, slideTabBar)));
      return result;
    }
    _slideTabItem;
    _animate;
    _midline;
    _translateX;
    _scrollbar;
    _slideTabBar;
    _editMode;
    _placeholder;
    constructor(slideTabItem, slideTabBar) {
      this._slideTabItem = slideTabItem;
      this._animate = null;
      this._translateX = 0;
      this._editMode = false;
      this._slideTabBar = slideTabBar;
      this._placeholder = null;
      this._scrollbar = slideTabBar.getScrollbar();
      this.update();
    }
    isEditMode() {
      return this._editMode;
    }
    classList() {
      return this._slideTabItem.classList;
    }
    primeval() {
      return this._slideTabItem;
    }
    translateX(x4) {
      this._translateX = x4;
      this._slideTabItem.style.transform = `translateX(${x4}px)`;
      return this.getTranslateXDirection();
    }
    editor(callback) {
      if (this._editMode === false) {
        let input = this.primeval().querySelector("span");
        let blurAction = (focusEvent) => {
          this._editMode = false;
          if (input) {
            input.removeAttribute("contentEditable");
            input.removeEventListener("blur", blurAction);
            input.removeEventListener("input", inputAction);
          }
          this._slideTabBar.updateItems();
          if (this._slideTabBar.getConfig().onChangeName) {
            this._slideTabBar.getConfig().onChangeName(focusEvent);
          }
          if (callback) {
            callback(focusEvent);
          }
        };
        let inputAction = () => {
          if (input) {
            const brs = input.querySelectorAll("br");
            if (brs.length > 0) {
              brs.forEach((br) => {
                if (input) {
                  input.removeChild(br);
                }
              });
              input.blur();
            }
          }
        };
        if (input) {
          input.setAttribute("contentEditable", "true");
          input.addEventListener("blur", blurAction);
          input.addEventListener("input", inputAction);
          this._editMode = true;
          SlideTabBar.keepLastIndex(input);
        }
      }
    }
    animate() {
      return {
        translateX: (x4) => {
          if (this._translateX !== x4) {
            if (this._animate) {
              this._animate.cancel();
              this._animate = null;
            }
            this._animate = new Animate({
              begin: this._translateX,
              end: x4,
              receive: (val) => {
                this._slideTabItem.style.transform = `translateX(${val}px)`;
              }
            });
            this._translateX = x4;
            this._animate.request();
          }
        },
        cancel: () => {
          if (this._animate) {
            this._animate.cancel();
            this._animate = null;
          }
        }
      };
    }
    after(other) {
      this._slideTabItem.after(other._slideTabItem || other);
    }
    update() {
      this._midline = SlideTabItem.midline(this);
    }
    disableFixed() {
      if (this._placeholder) {
        const primeval = this._slideTabBar.primeval();
        this._slideTabItem.style.removeProperty("position");
        this._slideTabItem.style.removeProperty("left");
        this._slideTabItem.style.removeProperty("top");
        this._slideTabItem.style.removeProperty("width");
        this._slideTabItem.style.removeProperty("height");
        this._slideTabItem.style.removeProperty("box-shadow");
        this._slideTabItem.style.removeProperty("background");
        this._placeholder.after(this._slideTabItem);
        primeval.removeChild(this._placeholder);
        this._placeholder = null;
      }
    }
    enableFixed() {
      const placeholder = document.createElement("div");
      const boundingRect = this.getBoundingRect();
      this._placeholder = placeholder;
      this._placeholder.style.width = `${boundingRect.width}px`;
      this._placeholder.style.height = `${boundingRect.height}px`;
      this._placeholder.style.flexShrink = "0";
      this._slideTabItem.style.left = `${boundingRect.x - this.getScrollbar().getScrollX()}px`;
      this._slideTabItem.style.top = `${boundingRect.y}px`;
      this._slideTabItem.style.width = `${boundingRect.width}px`;
      this._slideTabItem.style.height = `${boundingRect.height}px`;
      this._slideTabItem.style.background = getComputedStyle(this._slideTabItem).background;
      this._slideTabItem.style.boxShadow = "0px 0px 1px 1px rgba(82,82,82,0.1)";
      this._slideTabItem.style.position = "fixed";
      this._slideTabItem.after(placeholder);
      document.body.appendChild(this._slideTabItem);
    }
    addEventListener(type, action, options) {
      this._slideTabItem.addEventListener(type, action, options);
    }
    removeEventListener(type, action, options) {
      this._slideTabItem.removeEventListener(type, action, options);
    }
    getScrollbar() {
      return this._scrollbar;
    }
    getMidLine() {
      return this._midline;
    }
    getBoundingRect() {
      const boundingClientRect = this._slideTabItem.getBoundingClientRect();
      boundingClientRect.x += this._scrollbar.getScrollX();
      return boundingClientRect;
    }
    getWidth() {
      return this.getBoundingRect().width;
    }
    getTranslateXDirection() {
      const midline = SlideTabItem.midline(this);
      return midline > this._midline ? 1 : midline < this._midline ? -1 : 0;
    }
    equals(other) {
      return other && other._slideTabItem === this._slideTabItem;
    }
  };

  // ../../packages/ui-plugin-sheets/src/Basics/SlideTabBar/SlideTabBar.ts
  var SlideTabBar = class {
    static checkedSkipSlide(event) {
      let parent = event.target;
      while (parent != null && parent !== document.body) {
        if (parent.getAttribute("data-slide-skip")) {
          return true;
        }
        parent = parent.parentElement;
      }
      return false;
    }
    static keepLastIndex(inputHtml) {
      setTimeout(() => {
        const range2 = window.getSelection();
        if (range2) {
          range2.selectAllChildren(inputHtml);
          range2.collapseToEnd();
        }
      });
    }
    _activeTabItemIndex;
    _slideTabBar;
    _slideTabItems;
    _config;
    _downActionX;
    _moveActionX;
    _compareIndex;
    _activeTabItem;
    _moveAction;
    _upAction;
    _downAction;
    _wheelAction;
    _scrollIncremental;
    _compareDirection;
    _autoScrollTime;
    _slideScrollbar;
    _hasEditItem() {
      for (let index = 0; index < this._slideTabItems.length; index++) {
        const element = this._slideTabItems[index];
        if (element.isEditMode()) {
          return true;
        }
      }
      return false;
    }
    _autoScrollFrame() {
      if (this._activeTabItem) {
        this._compareDirection = this._activeTabItem.translateX(this._moveActionX);
        switch (this._compareDirection) {
          case 1: {
            this._slideScrollbar.scrollX(this._slideScrollbar.getScrollX() + this._scrollIncremental);
            this._compareRight();
            break;
          }
          case 0: {
            this._slideScrollbar.scrollX(this._slideScrollbar.getScrollX() + this._scrollIncremental);
            this._compareIndex = this._activeTabItemIndex;
            break;
          }
          case -1: {
            this._slideScrollbar.scrollX(this._slideScrollbar.getScrollX() + this._scrollIncremental);
            this._compareLeft();
            break;
          }
        }
      }
      this._autoScrollTime = requestAnimationFrame(() => {
        this._autoScrollFrame();
      });
    }
    _startAutoScroll() {
      if (this._autoScrollTime == null) {
        this._autoScrollFrame();
      }
    }
    _closeAutoScroll() {
      if (this._autoScrollTime) {
        cancelAnimationFrame(this._autoScrollTime);
      }
      this._autoScrollTime = null;
    }
    _scrollLeft(event) {
      const boundingRect = this.getBoundingRect();
      const boundingLine = 10;
      const x4 = event.pageX - boundingRect.x;
      if (x4 < boundingLine) {
        this._scrollIncremental = -Math.min(Math.abs(x4 - boundingLine) * 0.1, 50);
      }
    }
    _scrollRight(event) {
      const boundingRect = this.getBoundingRect();
      const boundingLine = 10;
      const x4 = event.pageX - boundingRect.x;
      if (x4 > boundingRect.width - boundingLine) {
        this._scrollIncremental = Math.min(Math.abs(x4 - (boundingRect.width - boundingLine)) * 0.1, 50);
      }
    }
    _sortedItems() {
      if (this._activeTabItem != null && this._activeTabItemIndex != null && this._compareIndex != null) {
        this._slideTabItems.splice(this._activeTabItemIndex, 1);
        this._slideTabItems.splice(this._compareIndex, 0, this._activeTabItem);
        if (this._config.slideTabBarItemAutoSort) {
          for (let i4 = 0; i4 < this._slideTabItems.length; i4++) {
            let item = this._slideTabItems[i4];
            let next = this._slideTabItems[i4 + 1];
            if (next) {
              item.after(next);
            }
          }
        }
      }
    }
    _compareLeft() {
      if (this._activeTabItem && this._activeTabItemIndex) {
        let splice = this._slideTabItems.findIndex((item) => item.equals(this._activeTabItem));
        let length = this._slideTabItems.length;
        let collect = [];
        for (let i4 = 0; i4 < splice; i4++) {
          if (i4 >= splice) {
            break;
          }
          collect.push(this._slideTabItems[i4]);
        }
        for (let i4 = splice + 1; i4 < length; i4++) {
          this._slideTabItems[i4].animate().translateX(0);
        }
        let notFound = true;
        for (let i4 = collect.length - 1; i4 >= 0; i4--) {
          let item = collect[i4];
          if (SlideTabItem.midline(this._activeTabItem) < item.getMidLine()) {
            item.animate().translateX(this._activeTabItem.getWidth());
            this._compareIndex = i4;
            notFound = false;
          } else {
            item.animate().translateX(0);
            if (notFound) {
              this._compareIndex = this._activeTabItemIndex;
            }
          }
        }
      }
    }
    _compareRight() {
      if (this._activeTabItem) {
        let splice = this._slideTabItems.findIndex((item) => item.equals(this._activeTabItem));
        let length = this._slideTabItems.length;
        let collect = [];
        for (let i4 = splice + 1; i4 < length; i4++) {
          collect.push(this._slideTabItems[i4]);
        }
        for (let i4 = 0; i4 < splice; i4++) {
          this._slideTabItems[i4].animate().translateX(0);
        }
        let notFound = true;
        for (let i4 = 0; i4 < collect.length; i4++) {
          let item = collect[i4];
          if (SlideTabItem.midline(this._activeTabItem) > item.getMidLine()) {
            item.animate().translateX(-this._activeTabItem.getWidth());
            this._compareIndex = splice + i4 + 1;
            notFound = false;
          } else {
            item.animate().translateX(0);
            if (notFound) {
              this._compareIndex = this._activeTabItemIndex;
            }
          }
        }
      }
    }
    _initialize() {
      document.addEventListener("mousemove", this._moveAction);
      document.addEventListener("mouseup", this._upAction);
      this._slideTabBar.addEventListener("wheel", this._wheelAction);
      this._slideTabItems.forEach((item) => {
        item.addEventListener("mousedown", this._downAction);
      });
    }
    constructor(config) {
      if (config.slideTabRoot == null) {
        throw new Error("not found slide-tab-bar root element");
      }
      const slideTabBar = config.slideTabRoot.querySelector(`.${config.slideTabBarClassName ?? "slide-tab-bar"}`);
      const slideTabItems = config.slideTabRoot.querySelectorAll(`.${config.slideTabBarItemClassName ?? "slide-tab-item"}`);
      if (slideTabBar == null) {
        throw new Error("not found slide-tab-bar");
      }
      this._config = config;
      this._activeTabItem = null;
      this._downActionX = 0;
      this._moveActionX = 0;
      this._compareDirection = 0;
      this._compareIndex = 0;
      this._activeTabItemIndex = 0;
      this._slideTabBar = slideTabBar;
      this._slideScrollbar = new SlideScrollbar(this);
      this._slideTabItems = SlideTabItem.make(slideTabItems, this);
      let lastPageX = 0;
      let lastPageY = 0;
      let lastTime = 0;
      this._downAction = (downEvent) => {
        if (downEvent.button === 2) {
          lastPageX = 0;
          lastTime = 0;
          lastPageY = 0;
          return;
        }
        const { pageX, pageY } = downEvent;
        const current = Date.now();
        const diffTime = current - lastTime <= 800;
        const diffPageX = pageX === lastPageX;
        const diffPageY = pageY === lastPageY;
        if (diffTime && diffPageX && diffPageY) {
          const slideItem = this._slideTabItems.find((item) => item.equals(new SlideTabItem(downEvent.currentTarget, this)));
          if (slideItem) {
            slideItem.editor();
          }
          lastTime = 0;
          lastPageX = 0;
          lastPageY = 0;
        } else {
          if (!this._hasEditItem()) {
            if (SlideTabBar.checkedSkipSlide(downEvent)) {
              lastPageX = 0;
              lastTime = 0;
              lastPageY = 0;
              return;
            }
            const slideItemIndex = this._slideTabItems.findIndex((item) => item.equals(new SlideTabItem(downEvent.currentTarget, this)));
            if (slideItemIndex > -1) {
              this._compareIndex = slideItemIndex;
              this._downActionX = downEvent.pageX;
              this._moveActionX = 0;
              this._scrollIncremental = 0;
              this._activeTabItem = this._slideTabItems[slideItemIndex];
              this._activeTabItemIndex = slideItemIndex;
              if (this._config.activeClassNameAutoController) {
                this._slideTabItems.forEach((item) => {
                  item.classList().remove(this._config.slideTabBarItemActiveClassName ?? "slide-tab-active");
                });
                this._activeTabItem.classList().add(this._config.slideTabBarItemActiveClassName ?? "slide-tab-active");
              }
              this._activeTabItem.enableFixed();
              this._startAutoScroll();
            } else {
              this.updateItems();
              this._activeTabItemIndex = 0;
              this._downActionX = 0;
              this._scrollIncremental = 0;
              this._compareIndex = 0;
              this._activeTabItem = null;
            }
          }
          lastPageX = pageX;
          lastPageY = pageY;
          lastTime = current;
        }
      };
      this._upAction = (upEvent) => {
        if (this._activeTabItem) {
          this._closeAutoScroll();
          this._activeTabItem.disableFixed();
          this._sortedItems();
          this.updateItems();
          if (this._config.onSlideEnd && this._activeTabItemIndex !== this._compareIndex) {
            this._config.onSlideEnd(upEvent);
          }
          let event = new MouseEvent("click", {
            view: window,
            bubbles: true,
            cancelable: true
          });
          this._activeTabItem.primeval().dispatchEvent(event);
          this._scrollIncremental = 0;
          this._activeTabItemIndex = 0;
          this._downActionX = 0;
          this._moveActionX = 0;
          this._compareIndex = 0;
          this._activeTabItem = null;
        }
      };
      this._moveAction = (moveEvent) => {
        if (this._activeTabItem) {
          this._moveActionX = moveEvent.pageX - this._downActionX;
          this._scrollIncremental = 0;
          this._scrollLeft(moveEvent);
          this._scrollRight(moveEvent);
        }
      };
      this._wheelAction = (wheelEvent) => {
        if (wheelEvent.deltaY > 0) {
          this._slideScrollbar.scrollX(this._slideScrollbar.getScrollX() + wheelEvent.deltaY);
        } else {
          this._slideScrollbar.scrollX(this._slideScrollbar.getScrollX() + wheelEvent.deltaY);
        }
      };
      this._initialize();
    }
    primeval() {
      return this._slideTabBar;
    }
    updateItems() {
      for (let i4 = 0; i4 < this._slideTabItems.length; i4++) {
        this._slideTabItems[i4].animate().cancel();
        this._slideTabItems[i4].translateX(0);
        this._slideTabItems[i4].update();
      }
    }
    getScrollbar() {
      return this._slideScrollbar;
    }
    getConfig() {
      return this._config;
    }
    getBoundingRect() {
      return this._slideTabBar.getBoundingClientRect();
    }
    getSlideTabItems() {
      return this._slideTabItems;
    }
    destroy() {
      document.removeEventListener("mousemove", this._moveAction);
      document.removeEventListener("mouseup", this._upAction);
      document.removeEventListener("wheel", this._wheelAction);
      this._slideTabItems.forEach((item) => {
        item.removeEventListener("mousedown", this._downAction);
      });
    }
  };

  // ../../packages/ui-plugin-sheets/src/View/SheetBar/SheetBar.tsx
  var SheetBar = class extends Component {
    ref = d();
    ulRef = d();
    sheetContainerRef = d();
    slideTabRoot = d();
    sheetContentRef = d();
    sheetBarContentRef = d();
    slideTabBar;
    // ,,
    time = 0;
    target = null;
    cloneTarget = null;
    startLeft;
    startClientX;
    _localeObserver;
    _renderKey = 1;
    initialize(props) {
      this.state = {
        sheetList: [],
        sheetUl: [],
        menuList: []
      };
    }
    resetLabel(list) {
      const componentManager = this.getContext().getPluginManager().getPluginByName(SHEET_UI_PLUGIN_NAME)?.getComponentManager();
      for (let i4 = 0; i4 < list.length; i4++) {
        const item = list[i4];
        if (item.customLabel) {
          const Label = componentManager?.get(item.customLabel.name);
          if (Label) {
            const props = item.customLabel.props ?? {};
            item.label = <Label {...props} />;
          }
        }
        if (item.children) {
          item.children = this.resetLabel(item.children);
        }
      }
      return list;
    }
    // setstate
    setValue = (value, fn) => {
      let { sheetList, menuList, sheetUl } = value;
      if (sheetList) {
        sheetList = this.resetLabel(sheetList);
      }
      if (menuList) {
        menuList = this.resetLabel(menuList);
      }
      if (sheetUl) {
        sheetUl = this.resetLabel(sheetUl);
      }
      this.setState((prevState) => ({ ...value }), fn);
    };
    // 
    scrollLeft = (e4) => {
      this.slideTabBar.getScrollbar().scrollX(this.slideTabBar.getScrollbar().getScrollX() - 50);
    };
    scrollRight = (e4) => {
      this.slideTabBar.getScrollbar().scrollX(this.slideTabBar.getScrollbar().getScrollX() + 50);
    };
    overGrid = () => {
    };
    // 
    contextMenu = (e4) => {
      e4.preventDefault();
      this.showUlList(e4);
    };
    // 
    showSelect = (e4, ref) => {
      e4.stopImmediatePropagation();
      const current = ref.current;
      if (current)
        current.showMenu(true);
      window.addEventListener("click", this.hideSelect);
    };
    // 
    hideSelect = (e4) => {
      const ulCurrent = this.ulRef.current;
      if (ulCurrent)
        ulCurrent.showMenu(false);
      window.removeEventListener("click", this.hideSelect);
    };
    // sheetullist
    showUlList = (e4) => {
      new Promise((resolve) => {
        const target = e4.currentTarget;
        const id = target.dataset.id;
        this.showSelect(e4, this.ulRef);
        resolve();
      }).then(() => {
        const currentTarget = e4.currentTarget.closest(`.${index_module_default32.slideTabItem}`);
        if (currentTarget) {
          const currentRect = currentTarget.getBoundingClientRect();
          const left = `${currentRect.left}px`;
          const bottom = `${currentRect.height}px`;
          const ul = this.ulRef.current.base;
          ul.style.left = left;
          ul.style.bottom = bottom;
          ul.style.top = "auto";
          ul.style.right = "auto";
        }
      });
    };
    // sheet
    reNameSheet = (id) => {
      const item = this.slideTabBar.getSlideTabItems().find((item2) => item2.primeval().dataset.id === id);
      if (item) {
        item.editor();
      }
    };
    changeEditable = (e4) => {
      const target = e4.target;
      let listener;
      target.contentEditable = "true";
      target.focus();
      target.addEventListener(
        "blur",
        listener = (event) => {
          this.props.changeSheetName?.(e4);
          target.contentEditable = "false";
          target.removeEventListener("blur", listener);
        }
      );
    };
    componentDidUpdate() {
      if (this.slideTabBar) {
        this.slideTabBar.destroy();
      }
      this.slideTabBar = new SlideTabBar({
        slideTabBarClassName: "univer-slide-tab-bar",
        slideTabBarItemActiveClassName: "univer-slide-tab-active",
        slideTabBarItemClassName: "univer-slide-tab-item",
        slideTabBarItemAutoSort: true,
        slideTabRoot: this.slideTabRoot.current,
        onChangeName: (event) => {
          this.props.changeSheetName?.(event);
        },
        onSlideEnd: (event) => {
          this.props.dragEnd?.(this.slideTabBar.getSlideTabItems().map((item) => item.primeval()));
        }
      });
    }
    componentDidMount() {
      this.props.getComponent?.(this);
    }
    render(props, state) {
      const { sheetList, menuList, sheetUl } = state;
      const { addSheet, selectSheet } = this.props;
      if (!sheetList.length)
        return;
      return <div className={index_module_default32.sheetBar} ref={this.slideTabRoot}>
        {
          /* user options button */
        }
        <div className={index_module_default32.sheetBarOptions}>
          <Button_default className={index_module_default32.sheetBarOptionsButton} onClick={addSheet} type="text"><Icon_exports.Math.AddIcon style={{ fontSize: "20px" }} /></Button_default>
          <Button_default className={index_module_default32.sheetBarOptionsButton} onClick={(e4) => this.ref.current.showMenu(true)} type="text">
            <Icon_exports.MenuIcon style={{ fontSize: "20px" }} />
            <SheetBarMenu onClick={selectSheet} menu={menuList} ref={this.ref} />
          </Button_default>
        </div>
        {
          /* user slide button */
        }
        <div className={index_module_default32.slideTabBar} ref={this.sheetContainerRef}>{sheetList.map((item) => <div
          onMouseDown={item.onDown}
          onClick={item.onClick}
          onContextMenu={this.contextMenu}
          data-id={item.sheetId}
          key={this._renderKey++}
          className={`${index_module_default32.slideTabItem} ${item.selected ? index_module_default32.slideTabActive : ""}`}
        >
          <div className={`${index_module_default32.slideTabContent}`}>
            <div className={`${index_module_default32.slideTabDivider}`} />
            <div className={`${index_module_default32.slideTabTitle}`}><span style={{ padding: "2px 5px 2px 5px" }}>{item.label}</span></div>
            <div className={`${index_module_default32.slideTabIcon}`} data-slide-skip="true" style={{ lineHeight: 1 }} data-id={item.sheetId} onClick={this.contextMenu}><Icon_exports.NextIcon /></div>
          </div>
          <div className={`${index_module_default32.slideTabFooter}`}><div className={`${index_module_default32.slideTabActiveBar}`} style={item.color ? { background: item.color } : {}} /></div>
        </div>)}</div>
        {
          /* mouse right button context menu */
        }
        <Menu className={index_module_default32.sheetUl} menu={sheetUl} ref={this.ulRef} />
        {
          /* prev next scroll button */
        }
        <div className={`${index_module_default32.sheetBarOptions} ${index_module_default32.sheetBarScrollButton}`}>
          <Button_default type="text" className={index_module_default32.sheetBarOptionsButton} onClick={this.scrollLeft}><Icon_exports.NextIcon rotate={90} style={{ padding: "5px" }} /></Button_default>
          <Button_default type="text" className={index_module_default32.sheetBarOptionsButton} onClick={this.scrollRight}><Icon_exports.NextIcon rotate={-90} style={{ padding: "5px" }} /></Button_default>
        </div>
      </div>;
    }
  };

  // stylePlugin:D:\code\github\univer\packages\ui-plugin-sheets\src\View\FormulaBar\index.module.less
  var index_module_default33 = {
    "formulaBox": "univer-formula-box",
    "selectButton": "univer-select-button",
    "tooltipGroup": "univer-tooltip-Group",
    "tooltipBody": "univer-tooltip-body",
    "formulaBar": "univer-formula-bar",
    "formulaIcon": "univer-formula-icon",
    "formulaGrey": "univer-formula-grey",
    "formulaBlack": "univer-formula-black",
    "formulaInput": "univer-formula-input",
    "formulaContent": "univer-formula-content"
  };

  // ../../packages/ui-plugin-sheets/src/View/FormulaBar/FormulaBar.tsx
  var FormulaBar = class extends Component {
    _render;
    // formulaContent = createRef<HTMLDivElement>();
    initialize(props) {
      this.state = {
        namedRanges: [
          {
            value: "1",
            label: "1"
          }
        ],
        spanClass: index_module_default33.formulaGrey,
        formulaContent: ""
      };
      this.onkeyUp = debounce(this.onkeyUp, 300);
    }
    onkeyUp = (value) => {
    };
    printChange = (e4) => {
      this.onkeyUp(e4.target);
    };
    setFormulaContent(value) {
      this.setState({
        formulaContent: value
      });
    }
    setNamedRanges(namedRanges) {
      this.setState({
        namedRanges
      });
    }
    componentDidMount() {
      this.props.getComponent?.(this);
    }
    render(props, state) {
      const { namedRanges } = state;
      return <div className={index_module_default33.formulaBox}>
        {
          /* <Select children={namedRanges} type={0}></Select> */
        }
        <div className={index_module_default33.formulaBar}>
          <div className={index_module_default33.formulaIcon}>
            <span className={state.spanClass}><Icon_exports.Format.CloseIcon /></span>
            <span className={state.spanClass}><Icon_exports.Format.CorrectIcon /></span>
            <span className={index_module_default33.formulaBlack}><Icon_exports.Math.FxIcon /></span>
          </div>
          <div className={index_module_default33.formulaInput}><div autoFocus contentEditable={true} className={index_module_default33.formulaContent} onKeyUp={(e4) => this.printChange(e4)}>{state.formulaContent}</div></div>
        </div>
      </div>;
    }
  };

  // stylePlugin:D:\code\github\univer\packages\ui-plugin-sheets\src\View\RichText\index.module.less
  var index_module_default34 = {
    "richTextEditorContainer": "univer-rich-text-editor-container",
    "richTextEditor": "univer-rich-text-editor",
    "formulaTextColor": "univer-formula-text-color",
    "formulaTextString": "univer-formula-text-string"
  };

  // ../../packages/ui-plugin-sheets/src/View/RichText/CellTextStyle.ts
  var CellTextStyle = class {
    inlineStyleAffectAttribute;
    inlineStyleAffectCssName;
    univerToCssName;
    editor;
    constructor(ele) {
      this.inlineStyleAffectAttribute = { bl: 1, it: 1, ff: 1, cl: 1, un: 1, fs: 1, fc: 1, bg: 1 };
      this.inlineStyleAffectCssName = { "font-weight": 1, "font-style": 1, "font-family": 1, "text-decoration": 1, "border-bottom": 1, "font-size": 1, color: 1, background: 1 };
      this.univerToCssName = {
        bl: "font-weight",
        it: "font-style",
        ff: "font-family",
        fs: "font-size",
        fc: "color",
        bg: "background",
        cl: "text-decoration",
        un: "border-bottom"
      };
      this.editor = ele;
    }
    // TODO:
    updateFormat(attr, foucsStatus) {
      if (attr in this.inlineStyleAffectAttribute) {
        let value = this.editor.textContent;
        if (value.substr(0, 1) !== "=") {
          this.updateInlineStringFormat(attr, foucsStatus);
        }
      }
    }
    updateInlineStringFormat(attr, value) {
      let w4 = window.getSelection();
      let range2;
      if (w4?.type === "None") {
      } else {
        range2 = w4?.getRangeAt(0);
      }
      if (!range2)
        return;
      let $textEditor = this.editor;
      let endContainer = range2.endContainer;
      let startContainer = range2.startContainer;
      let endOffset = range2.endOffset;
      let startOffset = range2.startOffset;
      if ($textEditor) {
        if (startContainer === endContainer) {
          let span = startContainer.parentNode;
          let spanIndex;
          let inherit = false;
          let content = span.innerHTML;
          let fullContent = $textEditor.innerHTML;
          if (fullContent.substr(0, 5) !== "<span") {
            inherit = true;
          }
          let left = "";
          let mid = "";
          let right = "";
          let s1 = 0;
          let s22 = startOffset;
          let s32 = endOffset;
          let s4 = content.length;
          left = content.substring(s1, s22);
          mid = content.substring(s22, s32);
          right = content.substring(s32, s4);
          let cont = "";
          if (left !== "") {
            let cssText = span.style.cssText;
            if (inherit) {
              let box = span.closest(`.${index_module_default34.richTextEditorContainer}`);
              if (box != null) {
                cssText = this.extendCssText(box.style.cssText, cssText);
              }
            }
            cont += `<span style='${cssText}'>${left}</span>`;
          }
          if (mid !== "") {
            let cssText = this.getCssText(span.style.cssText, attr, value);
            if (inherit) {
              let box = span.closest(`.${index_module_default34.richTextEditorContainer}`);
              if (box != null) {
                cssText = this.extendCssText(box.style.cssText, cssText);
              }
            }
            cont += `<span style='${cssText}'>${mid}</span>`;
          }
          if (right !== "") {
            let cssText = span.style.cssText;
            if (inherit) {
              let box = span.closest(`.${index_module_default34.richTextEditorContainer}`);
              if (box != null) {
                cssText = this.extendCssText(box.style.cssText, cssText);
              }
            }
            cont += `<span style='${cssText}'>${right}</span>`;
          }
          if (startContainer.parentNode.tagName === "SPAN") {
            spanIndex = $$("span", $textEditor).indexOf(span);
            let spanP = span.parentElement?.innerHTML;
            let spanText = span.outerHTML.replace("\\", "");
            const newS = spanP?.replace(spanText, cont);
            span.parentElement.innerHTML = newS;
          } else {
            spanIndex = 0;
            span.innerHTML = cont;
          }
          let seletedNodeIndex = 0;
          if (s1 === s22) {
            seletedNodeIndex = spanIndex;
          } else {
            seletedNodeIndex = spanIndex + 1;
          }
          selectTextContent($textEditor.querySelectorAll("span")[seletedNodeIndex]);
        } else if (startContainer.parentNode.tagName === "SPAN" && endContainer.parentNode.tagName === "SPAN") {
          let startSpan = startContainer.parentNode;
          let startSpanIndex;
          let endSpan = endContainer.parentNode;
          let endSpanIndex;
          startSpanIndex = $$("span", $textEditor).indexOf(startSpan);
          endSpanIndex = $$("span", $textEditor).indexOf(endSpan);
          let startContent = startSpan.innerHTML;
          let endContent = endSpan.innerHTML;
          let sleft = "";
          let sright = "";
          let eleft = "";
          let eright = "";
          let s1 = 0;
          let s22 = startOffset;
          let s32 = endOffset;
          let s4 = endContent.length;
          sleft = startContent.substring(s1, s22);
          sright = startContent.substring(s22, startContent.length);
          eleft = endContent.substring(0, s32);
          eright = endContent.substring(s32, s4);
          let spans = Array.prototype.slice.call($textEditor.querySelectorAll("span"));
          let replaceSpans = spans.slice(startSpanIndex, endSpanIndex + 1);
          let cont = "";
          for (let i4 = 0; i4 < startSpanIndex; i4++) {
            let span = spans[`${i4}`];
            let content = span.innerHTML;
            cont += `<span style='${span.style.cssText}'>${content}</span>`;
          }
          if (sleft !== "") {
            cont += `<span style='${startSpan.style.cssText}'>${sleft}</span>`;
          }
          if (sright !== "") {
            let cssText = this.getCssText(startSpan.style.cssText, attr, value);
            cont += `<span style='${cssText}'>${sright}</span>`;
          }
          if (startSpanIndex < endSpanIndex) {
            for (let i4 = startSpanIndex + 1; i4 < endSpanIndex; i4++) {
              let span = spans[`${i4}`];
              let content = span.innerHTML;
              let cssText = this.getCssText(span.style.cssText, attr, value);
              cont += `<span style='${cssText}'>${content}</span>`;
            }
          }
          if (eleft !== "") {
            let cssText = this.getCssText(endSpan.style.cssText, attr, value);
            cont += `<span style='${cssText}'>${eleft}</span>`;
          }
          if (eright !== "") {
            cont += `<span style='${endSpan.style.cssText}'>${eright}</span>`;
          }
          for (let i4 = endSpanIndex + 1; i4 < spans.length; i4++) {
            let span = spans[`${i4}`];
            let content = span.innerHTML;
            cont += `<span style='${span.style.cssText}'>${content}</span>`;
          }
          $textEditor.innerHTML = cont;
          let startSeletedNodeIndex;
          let endSeletedNodeIndex;
          if (s1 === s22) {
            startSeletedNodeIndex = startSpanIndex;
            endSeletedNodeIndex = endSpanIndex;
          } else {
            startSeletedNodeIndex = startSpanIndex + 1;
            endSeletedNodeIndex = endSpanIndex + 1;
          }
          spans = $textEditor.querySelectorAll("span");
          selectTextContentCross(spans[`${startSeletedNodeIndex}`], spans[`${endSeletedNodeIndex}`]);
        }
      }
    }
    extendCssText(origin, cover, isLimit = true) {
      let originArray = origin.split(";");
      let coverArray = cover.split(";");
      let newCss = "";
      let addKeyList = {};
      for (let i4 = 0; i4 < originArray.length; i4++) {
        let so = originArray[i4];
        let isAdd = true;
        so = so.toLowerCase();
        let okey = textTrim(so.substr(0, so.indexOf(":")));
        if (okey === "font-size") {
          continue;
        }
        let ovalue = textTrim(so.substr(so.indexOf(":") + 1));
        if (isLimit) {
          if (!(okey in this.inlineStyleAffectCssName)) {
            continue;
          }
        }
        for (let a4 = 0; a4 < coverArray.length; a4++) {
          let sc = coverArray[a4];
          sc = sc.toLowerCase();
          let ckey = textTrim(sc.substr(0, sc.indexOf(":")));
          let cvalue = textTrim(sc.substr(sc.indexOf(":") + 1));
          if (okey === ckey) {
            newCss += `${ckey}:${cvalue};`;
            isAdd = false;
            continue;
          }
        }
        if (isAdd) {
          newCss += `${okey}:${ovalue};`;
        }
        addKeyList[okey] = 1;
      }
      for (let a4 = 0; a4 < coverArray.length; a4++) {
        let sc = coverArray[a4];
        sc = sc.toLowerCase();
        let ckey = textTrim(sc.substr(0, sc.indexOf(":")));
        let cvalue = textTrim(sc.substr(sc.indexOf(":") + 1));
        if (isLimit) {
          if (!(ckey in this.inlineStyleAffectCssName)) {
            continue;
          }
        }
        if (!(ckey in addKeyList)) {
          newCss += `${ckey}:${cvalue};`;
        }
      }
      return newCss;
    }
    getCssText(cssText, attr, value) {
      let styleObj = {};
      styleObj[attr] = value;
      if (attr === "un") {
        let fontColor = this.getClassWithcss(cssText, "color");
        if (fontColor === "") {
          fontColor = "#000000";
        }
        let fs = this.getClassWithcss(cssText, "font-size");
        let fsNum = parseInt(fs);
        if (fs === "") {
          fsNum = 11;
        }
        styleObj._fontSize = fsNum;
        styleObj._color = fontColor;
      }
      let s4 = this.getFontStyleByCell(styleObj, void 0, void 0, false);
      let ukey = textTrim(s4 && s4.substr(0, s4.indexOf(":")));
      let uvalue = textTrim(s4 && s4.substr(s4.indexOf(":") + 1));
      uvalue = uvalue.substr(0, uvalue.length - 1);
      cssText = this.removeClassWidthCss(cssText, attr);
      cssText = this.upsetClassWithCss(cssText, ukey, uvalue);
      return cssText;
    }
    getClassWithcss(cssText, ukey) {
      let cssTextArray = cssText.split(";");
      if (ukey == null || ukey.length === 0) {
        return cssText;
      }
      if (cssText.indexOf(ukey) > -1) {
        for (let i4 = 0; i4 < cssTextArray.length; i4++) {
          let s4 = cssTextArray[i4];
          s4 = s4.toLowerCase();
          let key = textTrim(s4.substr(0, s4.indexOf(":")));
          let value = textTrim(s4.substr(s4.indexOf(":") + 1));
          if (key === ukey) {
            return value;
          }
        }
      }
      return "";
    }
    removeClassWidthCss(cssText, ukey) {
      let cssTextArray = cssText.split(";");
      let newCss = "";
      let oUkey = ukey;
      if (ukey == null || ukey.length === 0) {
        return cssText;
      }
      if (ukey in this.univerToCssName) {
        ukey = this.univerToCssName[ukey];
      }
      if (cssText.indexOf(ukey) > -1) {
        for (let i4 = 0; i4 < cssTextArray.length; i4++) {
          let s4 = cssTextArray[i4];
          s4 = s4.toLowerCase();
          let key = textTrim(s4.substr(0, s4.indexOf(":")));
          let value = textTrim(s4.substr(s4.indexOf(":") + 1));
          if (key === ukey || oUkey === "cl" && key === "lucky-strike" || oUkey === "un" && key === "lucky-underline") {
            continue;
          } else if (key.length > 0) {
            newCss += `${key}:${value};`;
          }
        }
      } else {
        newCss = cssText;
      }
      return newCss;
    }
    upsetClassWithCss(cssText, ukey, uvalue) {
      let cssTextArray = cssText.split(";");
      let newCss = "";
      if (ukey == null || ukey.length === 0) {
        return cssText;
      }
      if (cssText.indexOf(ukey) > -1) {
        for (let i4 = 0; i4 < cssTextArray.length; i4++) {
          let s4 = cssTextArray[i4];
          s4 = s4.toLowerCase();
          let key = textTrim(s4.substr(0, s4.indexOf(":")));
          let value = textTrim(s4.substr(s4.indexOf(":") + 1));
          if (key === ukey) {
            newCss += `${key}:${uvalue};`;
          } else if (key.length > 0) {
            newCss += `${key}:${value};`;
          }
        }
      } else if (ukey.length > 0) {
        cssText += `${ukey}:${uvalue};`;
        newCss = cssText;
      }
      return newCss;
    }
    getFontStyleByCell(cell, checksAF, checksCF, isCheck = true) {
      if (cell == null) {
        return "";
      }
      let style = "";
      for (let key in cell) {
        let value = cell[key];
        if (isCheck) {
          value = this.checkstatusByCell(cell, key);
        }
        if (key === "bl" && value !== "0") {
          style += "font-weight: bold;";
        }
        if (key === "it" && value !== "0") {
          style += "font-style:italic;";
        }
        if (key === "ff") {
          let f4 = value;
          style += `font-family: ${f4};`;
        }
        if (key === "fs" && value !== "10") {
          style += `font-size: ${value}pt;`;
        }
        if (key === "fc" && value !== "#000000" || checksAF != null || checksCF != null && checksCF.textColor != null) {
          if (checksCF != null && checksCF.textColor != null) {
            style += `color: ${checksCF.textColor};`;
          } else if (checksAF != null) {
            style += `color: ${checksAF[0]};`;
          } else {
            style += `color: ${value};`;
          }
        }
        if (key === "bg" && value !== "#ffffff" && value !== "#fff") {
          style += `background: ${value};`;
        }
        if (key === "cl" && value !== "0") {
          style += "text-decoration: line-through;";
        }
        if (key === "un" && (value === "1" || value === "3")) {
          let color = cell._color;
          if (color == null) {
            color = cell.fc;
          }
          let fs = cell._fontSize || 11;
          if (fs == null) {
            fs = cell.fs || 11;
          }
          style += `border-bottom: ${Math.floor(fs / 9)}px solid ${color};`;
        }
      }
      return style;
    }
    checkstatusByCell(cell, a4) {
      let foucsStatus;
      let tf = { bl: 1, it: 1, ff: 1, cl: 1, un: 1 };
      if (a4 in tf) {
        if (foucsStatus == null) {
          foucsStatus = "0";
        } else {
          foucsStatus = foucsStatus[a4];
          if (foucsStatus == null) {
            foucsStatus = "0";
          }
        }
      } else if (a4 === "fc") {
        if (foucsStatus == null) {
          foucsStatus = "#000000";
        } else {
          foucsStatus = foucsStatus[a4];
          if (foucsStatus == null) {
            foucsStatus = "#000000";
          }
          if (foucsStatus.indexOf("rgba") > -1) {
            foucsStatus = Color2.rgbColorToHexValue(foucsStatus);
          }
        }
      } else if (a4 === "bg") {
        if (foucsStatus == null) {
          foucsStatus = null;
        } else {
          foucsStatus = foucsStatus[a4];
          if (foucsStatus == null) {
            foucsStatus = null;
          } else if (foucsStatus.toString().indexOf("rgba") > -1) {
            foucsStatus = Color2.rgbColorToHexValue(foucsStatus);
          }
        }
      } else if (a4.substr(0, 2) === "bs") {
        if (foucsStatus == null) {
          foucsStatus = "none";
        } else {
          foucsStatus = foucsStatus[a4];
          if (foucsStatus == null) {
            foucsStatus = "none";
          }
        }
      } else if (a4.substr(0, 2) === "bc") {
        if (foucsStatus == null) {
          foucsStatus = "#000000";
        } else {
          foucsStatus = foucsStatus[a4];
          if (foucsStatus == null) {
            foucsStatus = "#000000";
          }
        }
      } else if (a4 === "ht") {
        if (foucsStatus == null) {
          foucsStatus = "1";
        } else {
          foucsStatus = foucsStatus[a4];
          if (foucsStatus == null) {
            foucsStatus = "1";
          }
        }
        if (["0", "1", "2"].indexOf(foucsStatus.toString()) === -1) {
          foucsStatus = "1";
        }
      } else if (a4 === "vt") {
        if (foucsStatus == null) {
          foucsStatus = "0";
        } else {
          foucsStatus = foucsStatus[a4];
          if (foucsStatus == null) {
            foucsStatus = "0";
          }
        }
        if (["0", "1", "2"].indexOf(foucsStatus.toString()) === -1) {
          foucsStatus = "0";
        }
      } else if (a4 === "ct") {
        if (foucsStatus == null) {
          foucsStatus = null;
        } else {
          foucsStatus = foucsStatus[a4];
          if (foucsStatus == null) {
            foucsStatus = null;
          }
        }
      } else if (a4 === "fs") {
        if (foucsStatus == null) {
          foucsStatus = "10";
        } else {
          foucsStatus = foucsStatus[a4];
          if (foucsStatus == null) {
            foucsStatus = "10";
          }
        }
      } else if (a4 === "tb") {
        if (foucsStatus == null) {
          foucsStatus = "0";
        } else {
          foucsStatus = foucsStatus[a4];
          if (foucsStatus == null) {
            foucsStatus = "0";
          }
        }
      } else if (a4 === "tr") {
        if (foucsStatus == null) {
          foucsStatus = "0";
        } else {
          foucsStatus = foucsStatus[a4];
          if (foucsStatus == null) {
            foucsStatus = "0";
          }
        }
      } else if (a4 === "rt") {
        if (foucsStatus == null) {
          foucsStatus = null;
        } else {
          foucsStatus = foucsStatus[a4];
          if (foucsStatus == null) {
            foucsStatus = null;
          }
        }
      }
      return foucsStatus;
    }
  };

  // ../../packages/ui-plugin-sheets/src/View/RichText/RichText.tsx
  var RichText2 = class extends Component {
    container = d();
    ref = d();
    cellTextStyle;
    hooks = /* @__PURE__ */ new Map();
    initialize(props) {
    }
    setValue(value) {
      if (this.ref.current) {
        this.ref.current.innerHTML = xssDeal(value);
      }
    }
    getValue() {
      return this.ref.current?.innerHTML || "";
    }
    show() {
      this.container.current.style.display = "block";
    }
    hide() {
      this.container.current.style.display = "none";
    }
    onKeyDown(event) {
      const onKeyDown = this.hooks.get("onKeyDown");
      onKeyDown && onKeyDown(event);
      if (event.key === "Enter") {
        event.preventDefault();
      }
    }
    onKeyUp(event) {
      const onKeyUp = this.hooks.get("onKeyUp");
      onKeyUp && onKeyUp(event);
      if (event.key === "Enter") {
        event.preventDefault();
      }
    }
    /**
     * init
     */
    componentWillMount() {
    }
    componentDidMount() {
      this.props.getComponent?.(this);
      this.cellTextStyle = new CellTextStyle(this.ref.current);
    }
    /**
     * destory
     */
    componentWillUnmount() {
    }
    render(props, state) {
      const { style, className = "", onClick, text } = props;
      return <div className={`${index_module_default34.richTextEditorContainer} ${className}`} style={style} ref={this.container}><div
        ref={this.ref}
        className={index_module_default34.richTextEditor}
        onClick={onClick}
        onKeyDown={this.onKeyDown.bind(this)}
        onKeyUp={this.onKeyUp.bind(this)}
        dangerouslySetInnerHTML={{ __html: text || "" }}
        contentEditable
      /></div>;
    }
  };

  // ../../packages/ui-plugin-sheets/src/View/Slot/Slot.tsx
  var Slot = class extends Component {
    refMap = /* @__PURE__ */ new Map();
    initialize() {
      this.state = {
        slotGroup: /* @__PURE__ */ new Map()
      };
    }
    componentDidMount() {
      this.props.getComponent?.(this);
    }
    setSlotGroup(group, cb) {
      this.setState(
        {
          slotGroup: group
        },
        cb
      );
    }
    getSlotGroup() {
      return this.refMap;
    }
    getRender(slotGroup) {
      const group = [];
      slotGroup.forEach((v4, k5) => {
        const Slot2 = slotGroup.get(k5)?.component;
        const props = slotGroup.get(k5)?.props;
        if (!Slot2)
          return;
        group.push(
          <Slot2
            ref={(ele) => {
              this.refMap.set(k5, ele);
            }}
            {...props}
          />
        );
      });
      return group;
    }
    render() {
      const { slotGroup } = this.state;
      return <div>{this.getRender(slotGroup)}</div>;
    }
  };

  // stylePlugin:D:\code\github\univer\packages\ui-plugin-sheets\src\View\Toolbar\index.module.less
  var index_module_default35 = {
    "toolbarWarp": "univer-toolbar-warp",
    "singleButton": "univer-single-button",
    "moreHide": "univer-more-hide",
    "moreShow": "univer-more-show",
    "toolbar": "univer-toolbar",
    "selectButton": "univer-select-button",
    "colsMenu": "univer-cols-menu",
    "selectLabelString": "univer-select-label-string",
    "dropContent": "univer-drop-content",
    "selectDoubleString": "univer-select-double-string",
    "selectColorPickerParent": "univer-select-color-picker-parent",
    "selectItemContent": "univer-select-item-content",
    "selectColorPicker": "univer-select-color-picker",
    "selectItem": "univer-select-item",
    "selectLineBoldParent": "univer-select-line-bold-parent",
    "selectSingle": "univer-select-single",
    "selectInput": "univer-select-input",
    "selectDouble": "univer-select-double",
    "univericonNextIcon": "univer-univericon-nextIcon",
    "textButton": "univer-text-button",
    "moreButton": "univer-more-button",
    "moreTool": "univer-more-tool",
    "tooltipTitle": "univer-tooltip-title",
    "bottom": "univer-bottom"
  };

  // ../../packages/ui-plugin-sheets/src/View/Toolbar/Toolbar.tsx
  var Toolbar = class extends Component {
    toolbarRef = d();
    moreBtnRef = d();
    moreToolRef = d();
    SelectRef = d();
    clientWidth = 0;
    /**
     * Gets the distance of each button from the parent element
     */
    debounceSetToolbarListWidth = debounce(() => {
      this.setToolbarListWidth();
    }, 50);
    initialize() {
      this.state = {
        // Button contains main button and drop down arrow, translation file contains main and right
        showMore: false,
        toolList: [],
        defaultToolList: [],
        moreToolList: [],
        toolbarListWidths: []
      };
    }
    /**
     * show more tool buttons
     *
     * TODO : more buttons
     */
    showMore = () => {
      let showMore = this.state.showMore;
      this.setState({ showMore: !showMore });
      if (!showMore) {
        document.addEventListener("click", this.hide, true);
      }
    };
    hide = (e4) => {
      if (this.moreToolRef.current.contains(e4.target))
        return;
      e4.stopImmediatePropagation();
      this.setState({ showMore: false });
      document.removeEventListener("click", this.hide, true);
    };
    setToolbarListWidth = () => {
      if (!this.clientWidth) {
        this.clientWidth = document.documentElement.clientWidth;
      }
      const list = this.toolbarRef.current.querySelectorAll(`.${index_module_default35.toolbarWarp} > div`);
      const moreButtonWidth = this.moreBtnRef.current.clientWidth;
      let width = 60 + moreButtonWidth;
      let index = null;
      const clientWidth = document.documentElement.clientWidth;
      if (clientWidth <= this.clientWidth) {
        this.clientWidth = clientWidth;
        for (let i4 = 0; i4 < list.length; i4++) {
          width += list[i4].clientWidth + 6;
          if (width > clientWidth) {
            index = i4;
            break;
          }
        }
        if (index !== null) {
          this.setState(
            {
              defaultToolList: this.state.toolList.slice(0, index),
              moreToolList: index ? this.state.toolList.slice(index) : []
            },
            () => {
              this.resetUl();
              this.forceUpdate();
            }
          );
        }
      } else {
        this.clientWidth = clientWidth;
        if (this.state.moreToolList.length) {
          let toolWidth = 30 + moreButtonWidth;
          for (let i4 = 0; i4 < list.length; i4++) {
            toolWidth += list[i4].clientWidth + 6;
          }
          const moreList = this.moreToolRef.current.querySelectorAll(`.${index_module_default35.moreTool} > div`);
          let moreIndex = null;
          let last = false;
          for (let i4 = 0; i4 < moreList.length; i4++) {
            toolWidth += moreList[i4].clientWidth + 6;
            if (toolWidth > clientWidth) {
              moreIndex = i4;
              break;
            } else if (i4 === moreList.length - 1) {
              moreIndex = i4;
              last = true;
            }
          }
          if (moreIndex !== null) {
            this.setState(
              {
                defaultToolList: this.state.defaultToolList.concat(this.state.moreToolList.slice(0, last ? moreIndex + 1 : moreIndex)),
                moreToolList: last ? [] : this.state.moreToolList.slice(moreIndex)
              },
              () => {
                this.resetUl();
                this.forceUpdate();
              }
            );
          }
        }
      }
    };
    resetLabel = (toolList) => {
      const componentManager = this.getContext().getPluginManager().getPluginByName(SHEET_UI_PLUGIN_NAME)?.getComponentManager();
      for (let i4 = 0; i4 < toolList.length; i4++) {
        const item = findLocale(toolList[i4], this.getLocale.bind(this));
        if (item.customLabel) {
          const Label = componentManager?.get(item.customLabel.name);
          if (Label) {
            const props = item.customLabel.props ?? {};
            item.label = <Label {...props} />;
          }
        }
        if (item.customSuffix) {
          const Suffix = componentManager?.get(item.customSuffix.name);
          if (Suffix) {
            const props = item.customSuffix.props ?? {};
            item.suffix = <Suffix {...props} />;
          }
        }
        if (item.children) {
          item.children = this.resetLabel(item.children);
        }
      }
      return toolList;
    };
    setToolbar = (toolList) => {
      this.setState(
        {
          toolList,
          defaultToolList: toolList
        },
        () => {
          this.setToolbarListWidth();
        }
      );
    };
    resetUl = () => {
      const wrapper = this.getContext().getPluginManager().getPluginByName(SHEET_UI_PLUGIN_NAME)?.getAppUIController().getSheetContainerController().getContentRef().current;
      const height = `${wrapper.offsetHeight}px`;
      const ul = this.toolbarRef.current.querySelectorAll("ul");
      for (let i4 = 0; i4 < ul.length; i4++) {
        ul[i4].style.maxHeight = height;
      }
    };
    componentDidMount() {
      this.props.getComponent?.(this);
      window.addEventListener("resize", this.debounceSetToolbarListWidth);
    }
    componentWillUnmount() {
      window.removeEventListener("resize", this.debounceSetToolbarListWidth);
    }
    // dom
    getToolbarList(list) {
      list = this.resetLabel(list);
      return list.map((item) => {
        if (item.toolbarType) {
          if (item.show) {
            return <Tooltip title={this.getLocale(item.tooltip)} placement="bottom"><Button_default unActive={item.unActive} className={index_module_default35.textButton} type="text" active={item.active} onClick={item.onClick}>{item.label}</Button_default></Tooltip>;
          }
        } else {
          if (item.show) {
            return <Select
              tooltip={this.getLocale(item.tooltip)}
              type={item.type}
              display={item.display}
              children={item.children}
              customLabel={item.customLabel}
              customSuffix={item.customSuffix}
              label={item.label}
              onClick={item.onClick}
              onPressEnter={item.onPressEnter}
              onMainClick={item.onMainClick}
              defaultColor={item.defaultColor}
              hideSelectedIcon={item.hideSelectedIcon}
              className={item.className}
            />;
          }
        }
        return null;
      });
    }
    render() {
      const { defaultToolList, moreToolList, showMore } = this.state;
      return <Container style={{ position: "relative" }}>
        <div className={`${index_module_default35.toolbarWarp} ${index_module_default35.toolbar}`} ref={this.toolbarRef}>
          {this.getToolbarList(defaultToolList)}
          <div ref={this.moreBtnRef} className={index_module_default35.moreButton} style={{ visibility: moreToolList.length ? "visible" : "hidden" }}><Tooltip title={this.getLocale("toolbar.toolMoreTip")} placement="bottom"><Button_default type="text" onClick={this.showMore}><div style={{ fontSize: "14px" }}>{this.getLocale("toolbar.toolMore")}</div></Button_default></Tooltip></div>
        </div>
        {moreToolList.length ? <div style={{ visibility: showMore ? "visible" : "hidden" }} className={`${index_module_default35.moreTool} ${index_module_default35.toolbar}`} ref={this.moreToolRef}>{this.getToolbarList(moreToolList)}</div> : ""}
      </Container>;
    }
  };
  __publicField(Toolbar, "contextType", AppContext);

  // ../../packages/ui-plugin-sheets/src/View/SheetContainer/SheetContainer.tsx
  var SheetContainer = class extends Component {
    leftContentLeft;
    leftContentTop;
    rightBorderX;
    rightBorderY;
    splitLeftRef = d();
    contentRef = d();
    constructor(props) {
      super();
      this.changeSkin(props.config.container, "default");
    }
    componentDidMount() {
      this.props.getComponent?.(this);
    }
    /**
     * split mouse down
     * @param e
     */
    handleSplitBarMouseDown = (e4) => {
      e4 = e4 || window.event;
      this.leftContentLeft = this.splitLeftRef.current?.getBoundingClientRect().left;
      this.leftContentTop = this.splitLeftRef.current?.getBoundingClientRect().top;
      const mainContainer = this.splitLeftRef.current?.parentElement;
      this.rightBorderX = mainContainer?.getBoundingClientRect()?.width;
      this.rightBorderY = mainContainer?.getBoundingClientRect()?.height;
      document.addEventListener("mousemove", this.handleSplitBarMouseMove, false);
      document.addEventListener("mouseup", this.handleSplitBarMouseUp, false);
    };
    /**
     * split mouse move
     * @param e
     */
    handleSplitBarMouseMove = (e4) => {
      const layout = this.props.config.layout?.sheetContainerConfig;
      e4 = e4 || window.event;
      let diffLeft = e4.clientX - this.leftContentLeft;
      let diffTop = e4.clientY - this.leftContentTop;
      diffLeft = diffLeft >= this.rightBorderX ? this.rightBorderX : diffLeft;
      diffTop = diffTop >= this.rightBorderY ? this.rightBorderY : diffTop;
      if (layout.contentSplit === "vertical") {
        this.splitLeftRef.current.style.height = `${diffTop}px`;
      } else {
        this.splitLeftRef.current.style.width = `${diffLeft}px`;
      }
    };
    /**
     * split mouse up
     * @param e
     */
    handleSplitBarMouseUp = (e4) => {
      document.removeEventListener("mousemove", this.handleSplitBarMouseMove, false);
      document.removeEventListener("mouseup", this.handleSplitBarMouseUp, false);
    };
    getContentRef() {
      return this.contentRef;
    }
    getSplitLeftRef() {
      return this.splitLeftRef;
    }
    /**
     * Modify Dom Skin
     */
    changeSkin(container, skin) {
      let root = document.documentElement;
      const id = typeof container === "string" ? container : container.id;
      const skins = {
        default: default_module_default
      };
      let currentSkin = skins[skin];
      currentSkin = Object.fromEntries(Object.keys(currentSkin).map((item) => [`--${item.replace(/([A-Z0-9])/g, "-$1").toLowerCase()}`, currentSkin[item]]));
      if (Tools.isIEBrowser()) {
        cssVars({
          // Options...
          // The container is invalid as rootElement, so the default setting is root.
          // Disadvantages: In ie11, only one set of skins can be used for multiple workbooks, and it is the skin set by the last workbook
          rootElement: root,
          // default
          variables: currentSkin
        });
      } else {
        let sheet = getSkinStyleSheet(id);
        sheet.insertRule(
          `#${id} ${JSON.stringify(currentSkin).replace(/"/g, "").replace(/,(?=--)/g, ";")}`
        );
      }
      function getSkinStyleSheet(id2) {
        const title = "universheet-skin-style";
        for (let i4 = 0; i4 < document.styleSheets.length; i4++) {
          if (document.styleSheets[i4].title === title) {
            deleteStyleRuleIndexBySelector(document.styleSheets[i4], id2);
            return document.styleSheets[i4];
          }
        }
        const head = document.head || document.getElementsByTagName("head")[0];
        const styleEle = document.createElement("style");
        styleEle.title = title;
        head.appendChild(styleEle);
        return document.styleSheets[document.styleSheets.length - 1];
      }
      function deleteStyleRuleIndexBySelector(skinStyleSheet, id2) {
        let index = 0;
        for (let i4 = 0; i4 < skinStyleSheet.cssRules.length; i4++) {
          const rule = skinStyleSheet.cssRules[i4];
          if (rule instanceof CSSStyleRule && rule.selectorText === `#${id2}`) {
            index = i4;
            skinStyleSheet.deleteRule(index);
            break;
          }
        }
      }
    }
    /**
     * Render the component's HTML
     *
     * @returns {void}
     */
    render() {
      const { methods } = this.props;
      const { layout } = this.props.config;
      const config = layout?.sheetContainerConfig;
      return <Container className={index_module_default28.layoutContainer}><Layout>
        <Sider style={{ display: config.outerLeft ? "block" : "none" }} />
        <Layout className={index_module_default28.mainContent} style={{ position: "relative" }}>
          <Header style={{ display: config.header ? "block" : "none" }}>
            {config.infoBar && <InfoBar {...methods.infoBar} />}
            {config.toolbar && <Toolbar {...methods.toolbar} />}
            {config.formulaBar && <FormulaBar {...methods.formulaBar} />}
          </Header>
          <Layout>
            <Sider
              style={{
                display: config.innerLeft ? "block" : "none"
              }}
            >{
              /* innerLeft */
            }</Sider>
            <Content className={config.contentSplit === "vertical" ? index_module_default28.contentContainerVertical : index_module_default28.contentContainerHorizontal}>
              <Slot {...methods.slot} />
              {!!config.contentSplit && <Container ref={this.splitLeftRef} className={index_module_default28.contentInnerLeftContainer}><div className={index_module_default28.hoverCursor} onMouseDown={this.handleSplitBarMouseDown} /></Container>}
              <Container onContextMenu={(e4) => e4.preventDefault()} ref={this.contentRef} className={index_module_default28.contentInnerRightContainer}>
                {config.rightMenu && <RightMenu {...methods.rightMenu} />}
                <RichText2 {...methods.cellEditor} />
              </Container>
              {
                /* extend main content */
              }
            </Content>
            <Sider
              style={{
                display: config.innerRight ? "block" : "none"
              }}
            >
              {
                /* innerRight */
              }
              {
                /* <SideGroup></SideGroup> */
              }
            </Sider>
          </Layout>
          <Footer
            style={{
              display: config.footer ? "block" : "none"
            }}
          >
            {config.sheetBar && <SheetBar {...methods.sheetBar} />}
            {config.countBar && <CountBar {...methods.countBar} />}
          </Footer>
        </Layout>
        <Sider
          style={{
            display: config.outerRight ? "block" : "none"
          }}
          className={index_module_default28.outerRightContainer}
        />
      </Layout></Container>;
    }
  };

  // ../../packages/ui-plugin-sheets/src/View/App.tsx
  var App = class extends Component {
    constructor(props) {
      super(props);
      this.state = {
        locale: this.props.locale
      };
    }
    setLocale(e4) {
      const value = e4.target.value;
      this.props.changeLocale(value);
      this.setState({
        locale: value
      });
    }
    render() {
      const { context, UIConfig } = this.props;
      const { locale } = this.state;
      return <AppContext.Provider
        value={{
          context,
          locale
        }}
      >
        <div
          style={{
            position: "fixed",
            right: "250px",
            top: "14px",
            fontSize: "14px",
            zIndex: 100
          }}
        >
          <span
            style={{
              display: "inline-block",
              width: 70,
              margin: "5px 0 0 5px"
            }}
          >Language</span>
          <select value={locale} onChange={this.setLocale.bind(this)} style={{ width: 70 }}>
            <option value="en">English</option>
            <option value="zh">{"\u4E2D\u6587"}</option>
          </select>
        </div>
        <SheetContainer {...UIConfig} />
      </AppContext.Provider>;
    }
  };

  // stylePlugin:D:\code\github\univer\packages\ui-plugin-sheets\src\View\Common\ColorSelect\index.module.less
  var index_module_default36 = {
    "colorSelect": "univer-color-select",
    "colorSelectLine": "univer-color-select-line"
  };

  // ../../packages/ui-plugin-sheets/src/View/Common/ColorSelect/ColorSelect.tsx
  var ColorSelect = class extends Component {
    componentDidMount() {
      const componentManager = this.getContext().getPluginManager().getPluginByName(SHEET_UI_PLUGIN_NAME)?.getComponentManager();
      let label = this.props.label;
      if (this.props.customLabel) {
        const Label = componentManager?.get(this.props.customLabel.name);
        label = <Label {...this.props.customLabel.props} />;
      }
      this.setState({
        label,
        color: this.props.color
      });
      this.props.getComponent?.(this);
    }
    componentWillReceiveProps(props) {
      this.setState({
        color: props.color
      });
    }
    setColor(color) {
      this.setState({
        color
      });
    }
    render() {
      return <div className={index_module_default36.colorSelect}>
        <div>{this.state.label}</div>
        <div className={index_module_default36.colorSelectLine} style={{ background: this.state.color }} />
      </div>;
    }
  };

  // ../../packages/ui-plugin-sheets/src/View/Common/Line/LineBold.tsx
  var LineBold = class extends Component {
    initialize() {
      this.state = {
        img: ""
      };
    }
    componentDidMount() {
      this.props.getComponent?.(this);
    }
    componentWillReceiveProps(props) {
      this.setState({
        img: props.img
      });
    }
    setImg(img = "") {
      this.setState({
        img
      });
    }
    getImg(img) {
      if (!img)
        return null;
      const span = document.querySelector(".base-sheets-line-bold");
      const props = { width: span.offsetWidth };
      const componentManager = this.getContext().getPluginManager().getPluginByName(SHEET_UI_PLUGIN_NAME)?.getComponentManager();
      const Img = componentManager?.get(img);
      return <Img {...props} />;
    }
    render() {
      const { img } = this.state;
      const { label } = this.props;
      return <div style={{ paddingBottom: "3px", width: "100%", display: "flex", justifyContent: "space-between", alignItems: "center" }}>
        <span className="base-sheets-line-bold" style={{ position: "relative" }}>
          {this.getLocale(label)}
          <div style={{ width: "100%", height: 0, position: "absolute", left: 0, bottom: "14px" }}>{img.length ? this.getImg(img) : ""}</div>
        </span>
        <Icon_exports.RightIcon />
      </div>;
    }
  };

  // ../../packages/ui-plugin-sheets/src/View/Common/Line/LineColor.tsx
  var LineColor = class extends Component {
    initialize() {
      this.state = {
        color: this.props.color
      };
    }
    componentDidMount() {
      this.props.getComponent?.(this);
    }
    componentWillReceiveProps(props) {
      this.setState({
        color: props.color
      });
    }
    setColor(color) {
      this.setState({
        color
      });
    }
    render() {
      const { color } = this.state;
      const { label } = this.props;
      return <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
        <span style={{ display: "inline-block", borderBottom: `3px solid ${color}` }}>{this.getLocale(label)}</span>
        <Icon_exports.RightIcon />
      </div>;
    }
  };

  // ../../packages/ui-plugin-sheets/src/View/index.tsx
  var UI = class {
    constructor(props) {
      this._initialize(props);
    }
    static create(props) {
      return new UI(props);
    }
    _initialize(props) {
      let renderContainer;
      const container = props.container;
      if (typeof container === "string") {
        const containerDOM = document.getElementById(container);
        if (containerDOM == null) {
          renderContainer = document.createElement("div");
          renderContainer.id = container;
        } else {
          renderContainer = containerDOM;
        }
      } else if (isElement(container)) {
        renderContainer = container;
      } else {
        renderContainer = document.createElement("div");
        renderContainer.id = "univer";
      }
      D(<App {...props} />, renderContainer);
    }
  };

  // ../../packages/ui-plugin-sheets/src/Controller/RightMenuUIController.ts
  var RightMenuUIController = class {
    _plugin;
    _sheetPlugin;
    _rightMenu;
    _menuList;
    _config;
    constructor(plugin, config) {
      this._plugin = plugin;
      this._sheetPlugin = plugin.getUniver().getCurrentUniverSheetInstance().context.getPluginManager().getPluginByName("spreadsheet" /* SPREADSHEET */);
      this._config = Tools.deepMerge({}, DefaultRightMenuConfig, config);
      this._menuList = [
        {
          label: "rightClick.insertRow",
          onClick: () => this.insertRow(),
          show: this._config.InsertRow
        },
        {
          label: "rightClick.insertColumn",
          onClick: () => this.insertColumn(),
          show: this._config.InsertColumn
        },
        {
          customLabel: {
            name: RightMenuInput.name,
            props: {
              prefix: "rightClick.toTopAdd",
              suffix: "rightClick.row"
            }
          },
          show: this._config.AddRowTop
        },
        {
          customLabel: {
            name: RightMenuInput.name,
            props: {
              prefix: "rightClick.toBottomAdd",
              suffix: "rightClick.row"
            }
          },
          show: this._config.AddRowBottom
        },
        {
          customLabel: {
            name: RightMenuInput.name,
            props: {
              prefix: "rightClick.toLeftAdd",
              suffix: "rightClick.column"
            }
          },
          show: this._config.AddColumnLeft
        },
        {
          customLabel: {
            name: RightMenuInput.name,
            props: {
              prefix: "rightClick.toRightAdd",
              suffix: "rightClick.column"
            }
          },
          show: this._config.AddColumnRight
        },
        {
          label: "rightClick.deleteSelectedRow",
          onClick: () => this.deleteRow(),
          show: this._config.DeleteRow
        },
        {
          label: "rightClick.deleteSelectedColumn",
          onClick: () => this.deleteColumn(),
          show: this._config.DeleteColumn
        },
        {
          label: "rightClick.hideSelectedRow",
          show: this._config.HideRow
        },
        {
          label: "rightClick.showHideRow",
          show: this._config.ShowRow
        },
        {
          customLabel: {
            name: RightMenuInput.name,
            props: {
              prefix: "rightClick.rowHeight",
              suffix: "px",
              onKeyUp: this.setRowHeight.bind(this)
            }
          },
          onClick: () => {
          },
          show: this._config.RowHeight
        },
        {
          label: "rightClick.hideSelectedColumn",
          show: this._config.HideColumn
        },
        {
          label: "rightClick.showHideColumn",
          show: this._config.ShowColumn
        },
        {
          customLabel: {
            name: RightMenuInput.name,
            props: {
              prefix: "rightClick.columnWidth",
              suffix: "px",
              onKeyUp: this.setColumnWidth.bind(this)
            }
          },
          show: this._config.ColumnWidth
        },
        {
          show: this._config.DeleteCell,
          customLabel: {
            name: RightMenuItem.name,
            props: {
              label: "rightClick.deleteCell"
            }
          },
          border: true,
          children: [
            {
              label: "rightClick.moveLeft",
              className: index_module_default30.rightMenuCenter,
              onClick: () => this.deleteCellLeft()
            },
            {
              label: "rightClick.moveUp",
              className: index_module_default30.rightMenuCenter,
              onClick: () => this.deleteCellTop()
            }
          ]
        },
        {
          label: "rightClick.clearContent",
          onClick: () => this.clearContent(),
          border: true,
          show: this._config.ClearContent
        }
        // {
        //     show: this._config.hideMatrix,
        //     customLabel: {
        //         name: RightMenuItem.name,
        //         props: {
        //             locale: 'rightClick.matrix',
        //         },
        //     },
        //     children: [
        //         {
        //             customLabel: {
        //                 name: RightMenuButton.name,
        //                 props: {
        //                     locale: 'rightClick.flip',
        //                     children: [
        //                         {
        //                             locale: 'rightClick.upAndDown',
        //                         },
        //                         {
        //                             locale: 'rightClick.leftAndRight',
        //                         },
        //                     ],
        //                 },
        //             },
        //         },
        //         {
        //             customLabel: {
        //                 name: RightMenuButton.name,
        //                 props: {
        //                     locale: 'rightClick.flip',
        //                     children: [
        //                         {
        //                             locale: 'rightClick.clockwise',
        //                         },
        //                         {
        //                             locale: 'rightClick.counterclockwise',
        //                         },
        //                     ],
        //                 },
        //             },
        //         },
        //         {
        //             locale: ['rightClick.transpose'],
        //         },
        //         {
        //             customLabel: {
        //                 name: RightMenuSelect.name,
        //                 props: {
        //                     locale: 'rightClick.matrixCalculation',
        //                     options: [
        //                         {
        //                             locale: 'rightClick.plus',
        //                         },
        //                         {
        //                             locale: 'rightClick.minus',
        //                         },
        //                         {
        //                             locale: 'rightClick.multiply',
        //                         },
        //                         {
        //                             locale: 'rightClick.divided',
        //                         },
        //                         {
        //                             locale: 'rightClick.power',
        //                         },
        //                         {
        //                             locale: 'rightClick.root',
        //                         },
        //                         {
        //                             locale: 'rightClick.log',
        //                         },
        //                     ],
        //                 },
        //             },
        //         },
        //         {
        //             customLabel: {
        //                 name: RightMenuButton.name,
        //                 props: {
        //                     locale: 'rightClick.delete0',
        //                     children: [
        //                         {
        //                             locale: 'rightClick.byRow',
        //                         },
        //                         {
        //                             locale: 'rightClick.byCol',
        //                         },
        //                     ],
        //                 },
        //             },
        //         },
        //         {
        //             customLabel: {
        //                 name: RightMenuButton.name,
        //                 props: {
        //                     locale: 'rightClick.removeDuplicate',
        //                     children: [
        //                         {
        //                             locale: 'rightClick.byRow',
        //                         },
        //                         {
        //                             locale: 'rightClick.byCol',
        //                         },
        //                     ],
        //                 },
        //             },
        //         },
        //     ],
        // },
      ];
      this._initialize();
    }
    // RightMenu
    getComponent = (ref) => {
      this._rightMenu = ref;
      this.setMenuList();
    };
    // 
    setMenuList() {
      this._rightMenu?.setMenuList(this._menuList);
    }
    setUIObserve(msg) {
      this._plugin.getContext().getObserverManager().requiredObserver("onUIChangeObservable", "core").notifyObservers(msg);
    }
    insertRow() {
      const msg = {
        name: "insertRow"
      };
      this.setUIObserve(msg);
    }
    insertColumn() {
      const msg = {
        name: "insertColumn"
      };
      this.setUIObserve(msg);
    }
    deleteRow() {
      const msg = {
        name: "deleteRow"
      };
      this.setUIObserve(msg);
    }
    deleteColumn() {
      const msg = {
        name: "deleteColumn"
      };
      this.setUIObserve(msg);
    }
    setRowHeight(e4) {
      if (e4.key !== "Enter") {
        return;
      }
      const height = e4.target.value;
      const msg = {
        name: "setRowHeight",
        value: height
      };
      this.setUIObserve(msg);
    }
    setColumnWidth(e4) {
      if (e4.key !== "Enter") {
        return;
      }
      const width = e4.target.value;
      const msg = {
        name: "setColumnWidth",
        value: width
      };
      this.setUIObserve(msg);
    }
    deleteCellLeft() {
      const msg = {
        name: "moveLeft"
      };
      this.setUIObserve(msg);
    }
    deleteCellTop() {
      const msg = {
        name: "moveTop"
      };
      this.setUIObserve(msg);
    }
    clearContent() {
      const msg = {
        name: "clearContent"
      };
      this.setUIObserve(msg);
    }
    _initialize() {
      this._plugin.getComponentManager().register(RightMenuInput.name, RightMenuInput);
      this._plugin.getComponentManager().register(RightMenuItem.name, RightMenuItem);
      this._sheetPlugin.getMainComponent().onPointerDownObserver.add((evt) => {
        if (evt.button === 2) {
          evt.preventDefault();
          this._rightMenu.handleContextMenu(evt);
        }
      });
    }
  };

  // ../../packages/ui-plugin-sheets/src/View/ToolBar/Const.ts
  var FONT_SIZE_CHILDREN = [
    {
      label: "9",
      value: 9
    },
    {
      label: "10",
      value: 10
    },
    {
      label: "11",
      value: 11
    },
    {
      label: "12",
      value: 12
    },
    {
      label: "14",
      value: 14
    },
    {
      label: "16",
      value: 16
    },
    {
      label: "18",
      value: 18
    },
    {
      label: "20",
      value: 20
    },
    {
      label: "22",
      value: 22
    },
    {
      label: "24",
      value: 24
    },
    {
      label: "26",
      value: 26
    },
    {
      label: "28",
      value: 28
    },
    {
      label: "36",
      value: 36
    },
    {
      label: "48",
      value: 48
    },
    {
      label: "72",
      value: 72
    }
  ];
  var FONT_FAMILY_CHILDREN = [
    {
      labelLocale: "fontFamily.TimesNewRoman",
      style: { "font-family": "Times New Roman" },
      value: "Times New Roman",
      selected: true
    },
    {
      labelLocale: "fontFamily.Arial",
      style: { "font-family": "Arial" },
      value: "Arial"
    },
    {
      labelLocale: "fontFamily.Tahoma",
      style: { "font-family": "Tahoma" },
      value: "Tahoma"
    },
    {
      labelLocale: "fontFamily.Verdana",
      style: { "font-family": "Verdana" },
      value: "Verdana"
    },
    {
      labelLocale: "fontFamily.MicrosoftAccorblack",
      style: { "font-family": "\u5FAE\u8F6F\u96C5\u9ED1" },
      value: "\u5FAE\u8F6F\u96C5\u9ED1"
    },
    {
      labelLocale: "fontFamily.SimSun",
      style: { "font-family": "\u5B8B\u4F53" },
      value: "\u5B8B\u4F53"
    },
    {
      labelLocale: "fontFamily.SimHei",
      style: { "font-family": "\u9ED1\u4F53" },
      value: "\u9ED1\u4F53"
    },
    {
      labelLocale: "fontFamily.Kaiti",
      style: { "font-family": "\u6977\u4F53" },
      value: "\u6977\u4F53"
    },
    {
      labelLocale: "fontFamily.FangSong",
      style: { "font-family": "\u4EFF\u5B8B" },
      value: "\u4EFF\u5B8B"
    },
    {
      labelLocale: "fontFamily.NSimSun",
      style: { "font-family": "\u65B0\u5B8B\u4F53" },
      value: "\u65B0\u5B8B\u4F53"
    },
    {
      labelLocale: "fontFamily.STXinwei",
      style: { "font-family": "\u534E\u6587\u65B0\u9B4F" },
      value: "\u534E\u6587\u65B0\u9B4F"
    },
    {
      labelLocale: "fontFamily.STXingkai",
      style: { "font-family": "\u534E\u6587\u884C\u6977" },
      value: "\u534E\u6587\u884C\u6977"
    },
    {
      labelLocale: "fontFamily.STLiti",
      style: { "font-family": "\u534E\u6587\u96B6\u4E66" },
      value: "\u534E\u6587\u96B6\u4E66"
    },
    {
      labelLocale: "fontFamily.HanaleiFill",
      style: { "font-family": "HanaleiFill" },
      value: "HanaleiFill"
    },
    {
      labelLocale: "fontFamily.Anton",
      style: { "font-family": "Anton" },
      value: "Anton"
    },
    {
      labelLocale: "fontFamily.Pacifico",
      style: { "font-family": "Pacifico" },
      value: "Pacifico"
    }
  ];
  var BORDER_LINE_CHILDREN = [
    {
      labelLocale: "borderLine.borderTop",
      customSuffix: {
        name: "TopBorderIcon"
      },
      value: "top"
    },
    {
      labelLocale: "borderLine.borderBottom",
      customSuffix: {
        name: "BottomBorderIcon"
      },
      value: "bottom"
    },
    {
      labelLocale: "borderLine.borderLeft",
      customSuffix: {
        name: "LeftBorderIcon"
      },
      value: "left"
    },
    {
      labelLocale: "borderLine.borderRight",
      customSuffix: {
        name: "RightBorderIcon"
      },
      value: "right",
      border: true
    },
    {
      labelLocale: "borderLine.borderNone",
      customSuffix: {
        name: "NoneBorderIcon"
      },
      value: "none"
    },
    {
      labelLocale: "borderLine.borderAll",
      customSuffix: {
        name: "FullBorderIcon"
      },
      value: "all",
      selected: true
    },
    {
      labelLocale: "borderLine.borderOutside",
      customSuffix: {
        name: "OuterBorderIcon"
      },
      value: "outside"
    },
    {
      labelLocale: "borderLine.borderInside",
      customSuffix: {
        name: "InnerBorderIcon"
      },
      value: "inside"
    },
    {
      labelLocale: "borderLine.borderHorizontal",
      customSuffix: {
        name: "StripingBorderIcon"
      },
      value: "horizontal"
    },
    {
      labelLocale: "borderLine.borderVertical",
      customSuffix: {
        name: "VerticalBorderIcon"
      },
      value: "vertical"
    }
  ];
  var BORDER_SIZE_CHILDREN = [
    {
      labelLocale: "borderLine.borderNone",
      value: 0 /* NONE */
    },
    {
      customLabel: {
        name: "BorderThin"
      },
      value: 1 /* THIN */
    },
    {
      customLabel: {
        name: "BorderHair"
      },
      value: 2 /* HAIR */
    },
    {
      customLabel: {
        name: "BorderDotted"
      },
      value: 3 /* DOTTED */
    },
    {
      customLabel: {
        name: "BorderDashed"
      },
      value: 4 /* DASHED */
    },
    {
      customLabel: {
        name: "BorderDashDot"
      },
      value: 3 /* DOTTED */
    },
    {
      customLabel: {
        name: "BorderDashDotDot"
      },
      value: 6 /* DASH_DOT_DOT */
    },
    {
      customLabel: {
        name: "BorderMedium"
      },
      value: 8 /* MEDIUM */
    },
    {
      customLabel: {
        name: "BorderMediumDashed"
      },
      value: 9 /* MEDIUM_DASHED */
    },
    {
      customLabel: {
        name: "BorderMediumDashDot"
      },
      value: 10 /* MEDIUM_DASH_DOT */
    },
    {
      customLabel: {
        name: "BorderMediumDashDotDot"
      },
      value: 11 /* MEDIUM_DASH_DOT_DOT */
    },
    {
      customLabel: {
        name: "BorderThick"
      },
      value: 13 /* THICK */
    }
  ];
  var MERGE_CHILDREN = [
    {
      labelLocale: "merge.all",
      value: "all"
    },
    {
      labelLocale: "merge.vertical",
      value: "vertical"
    },
    {
      labelLocale: "merge.horizontal",
      value: "horizontal"
    },
    {
      labelLocale: "merge.cancel",
      value: "cancel"
    }
  ];
  var HORIZONTAL_ALIGN_CHILDREN = [
    {
      labelLocale: "align.left",
      customSuffix: {
        name: "LeftAlignIcon"
      },
      value: 1
    },
    {
      labelLocale: "align.center",
      selected: true,
      customSuffix: {
        name: "CenterAlignIcon"
      },
      value: 2
    },
    {
      labelLocale: "align.right",
      customSuffix: {
        name: "RightAlignIcon"
      },
      value: 3
    }
  ];
  var VERTICAL_ALIGN_CHILDREN = [
    {
      labelLocale: "align.top",
      customSuffix: {
        name: "TopVerticalIcon"
      },
      value: 1
    },
    {
      labelLocale: "align.middle",
      customSuffix: {
        name: "CenterVerticalIcon"
      },
      value: 2
    },
    {
      labelLocale: "align.bottom",
      customSuffix: {
        name: "BottomVerticalIcon"
      },
      value: 3
    }
  ];
  var TEXT_WRAP_CHILDREN = [
    {
      labelLocale: "textWrap.overflow",
      customSuffix: {
        name: "OverflowIcon"
      },
      value: 1
    },
    {
      labelLocale: "textWrap.wrap",
      customSuffix: {
        name: "BrIcon"
      },
      value: 3
    },
    {
      labelLocale: "textWrap.clip",
      customSuffix: {
        name: "CutIcon"
      },
      value: 2
    }
  ];
  var TEXT_ROTATE_CHILDREN = [
    {
      labelLocale: "textRotate.none",
      customSuffix: {
        name: "TextRotateIcon"
      },
      value: 0
    },
    {
      labelLocale: "textRotate.angleUp",
      customSuffix: {
        name: "TextRotateAngleUpIcon"
      },
      value: -45
    },
    {
      labelLocale: "textRotate.angleDown",
      customSuffix: {
        name: "TextRotateAngleDownIcon"
      },
      value: 45
    },
    {
      labelLocale: "textRotate.vertical",
      customSuffix: {
        name: "TextRotateVerticalIcon"
      },
      value: "v"
    },
    {
      labelLocale: "textRotate.rotationUp",
      customSuffix: {
        name: "TextRotateRotationUpIcon"
      },
      value: -90
    },
    {
      labelLocale: "textRotate.rotationDown",
      customSuffix: {
        name: "TextRotateRotationDownIcon"
      },
      value: 90
    }
  ];

  // ../../packages/ui-plugin-sheets/src/Controller/ToolbarUIController.ts
  var ToolbarUIController = class {
    _plugin;
    _sheetPlugin;
    _toolbar;
    _toolList;
    _config;
    _lineColor;
    _lineBold;
    _colorSelect1;
    _textColor = "#000";
    _colorSelect2;
    _background = "#fff";
    _borderInfo = {
      type: "all" /* ALL */,
      color: "#000",
      style: 1
    };
    //
    constructor(plugin, config) {
      this._plugin = plugin;
      this._sheetPlugin = plugin.getContext().getUniver().getCurrentUniverSheetInstance().context.getPluginManager().getPluginByName("spreadsheet" /* SPREADSHEET */);
      this._config = Tools.deepMerge({}, DefaultToolbarConfig, config);
      this._toolList = [
        {
          toolbarType: 1,
          tooltip: "toolbar.undo",
          name: "undo",
          unActive: true,
          customLabel: {
            name: "ForwardIcon"
          },
          show: this._config.undo,
          onClick: () => {
            this.setUndo();
            this.hideTooltip();
          }
        },
        {
          toolbarType: 1,
          tooltip: "toolbar.redo",
          unActive: true,
          customLabel: {
            name: "BackIcon"
          },
          name: "redo",
          show: this._config.redo,
          onClick: () => {
            this.setRedo();
            this.hideTooltip();
          }
        },
        {
          type: 0,
          tooltip: "toolbar.font",
          className: index_module_default35.selectLabelString,
          name: "font",
          show: this._config.font,
          border: true,
          onMainClick: () => {
            this.hideTooltip();
          },
          onClick: (fontFamily) => {
            this.setFontFamily(fontFamily);
          },
          children: FONT_FAMILY_CHILDREN
        },
        {
          type: 1,
          tooltip: "toolbar.fontSize",
          label: String(DEFAULT_STYLES.fs),
          name: "fontSize",
          show: this._config.fontSize,
          onClick: (fontSize) => {
            this.setFontSize(fontSize);
          },
          onMainClick: () => {
            this.hideTooltip();
          },
          onPressEnter: (fontSize) => {
            this.setFontSize(fontSize);
            this.hideTooltip();
          },
          children: FONT_SIZE_CHILDREN
        },
        {
          toolbarType: 1,
          tooltip: "toolbar.bold",
          customLabel: {
            name: "BoldIcon"
          },
          active: false,
          name: "bold",
          show: this._config.bold,
          onClick: (e4, isBold) => {
            this.setFontWeight(isBold);
            this.hideTooltip();
          }
        },
        {
          toolbarType: 1,
          tooltip: "toolbar.italic",
          customLabel: {
            name: "ItalicIcon"
          },
          name: "italic",
          show: this._config.italic,
          onClick: (e4, isItalic) => {
            this.setFontStyle(isItalic);
            this.hideTooltip();
          }
        },
        {
          toolbarType: 1,
          tooltip: "toolbar.strikethrough",
          customLabel: {
            name: "DeleteLineIcon"
          },
          name: "strikethrough",
          show: this._config.strikethrough,
          onClick: (e4, isStrikethrough) => {
            this.hideTooltip();
            const strikethroughItem = this._toolList.find((item) => item.name === "strikethrough");
            if (!strikethroughItem)
              return;
            strikethroughItem.active = isStrikethrough;
            this.setStrikeThrough(isStrikethrough);
          }
        },
        {
          toolbarType: 1,
          tooltip: "toolbar.underline",
          customLabel: {
            name: "UnderLineIcon"
          },
          name: "underline",
          show: this._config.underline,
          onClick: (e4, isUnderLine) => {
            this.hideTooltip();
            const underlineItem = this._toolList.find((item) => item.name === "underline");
            if (!underlineItem)
              return;
            underlineItem.active = isUnderLine;
            this.setUnderline(isUnderLine);
          }
        },
        {
          type: 5,
          tooltip: "toolbar.textColor.main",
          customLabel: {
            name: SHEET_UI_PLUGIN_NAME + ColorSelect.name,
            props: {
              getComponent: (ref) => {
                this._colorSelect1 = ref;
              },
              color: "#000",
              customLabel: {
                name: "TextColorIcon"
              }
            }
          },
          onClick: () => {
            this.hideTooltip();
            const textColor = this._toolList.find((item) => item.name === "textColor");
            if (!textColor)
              return;
            if (!textColor.customLabel)
              return;
            if (!textColor.customLabel.props)
              return;
            textColor.customLabel.props.color = this._textColor;
            this.changeColor(this._textColor);
          },
          hideSelectedIcon: true,
          className: index_module_default35.selectColorPickerParent,
          children: [
            {
              customLabel: {
                name: SHEET_UI_PLUGIN_NAME + ColorPicker.name,
                props: {
                  onClick: (color, e4) => {
                    this._colorSelect1.setColor(color);
                    this._textColor = color;
                  }
                }
              },
              className: index_module_default35.selectColorPicker
            }
          ],
          name: "textColor",
          show: this._config.textColor
        },
        {
          type: 5,
          tooltip: "toolbar.fillColor.main",
          customLabel: {
            name: SHEET_UI_PLUGIN_NAME + ColorSelect.name,
            props: {
              getComponent: (ref) => {
                this._colorSelect2 = ref;
              },
              color: "#fff",
              customLabel: {
                name: "FillColorIcon"
              }
            }
          },
          onClick: () => {
            this.hideTooltip();
            const fillColor = this._toolList.find((item) => item.name === "fillColor");
            if (!fillColor)
              return;
            if (!fillColor.customLabel)
              return;
            if (!fillColor.customLabel.props)
              return;
            fillColor.customLabel.props.color = this._background;
            this.setBackground(this._background);
          },
          hideSelectedIcon: true,
          className: index_module_default35.selectColorPickerParent,
          children: [
            {
              customLabel: {
                name: SHEET_UI_PLUGIN_NAME + ColorPicker.name,
                props: {
                  onClick: (color, e4) => {
                    this._colorSelect2.setColor(color);
                    this._background = color;
                  }
                }
              },
              className: index_module_default35.selectColorPicker
            }
          ],
          name: "fillColor",
          show: this._config.fillColor
        },
        {
          type: 3,
          display: 1,
          show: this._config.border,
          tooltip: "toolbar.border.main",
          className: index_module_default35.selectDoubleString,
          onClick: (value) => {
            if (value) {
              this._borderInfo.type = value;
            }
            this.hideTooltip();
            this.setBorder();
          },
          name: "border",
          children: [
            ...BORDER_LINE_CHILDREN,
            {
              name: "borderColor",
              customLabel: {
                name: SHEET_UI_PLUGIN_NAME + LineColor.name,
                props: {
                  color: "#000",
                  label: "borderLine.borderColor",
                  getComponent: (ref) => this._lineColor = ref
                }
              },
              unSelectable: true,
              className: index_module_default35.selectColorPickerParent,
              children: [
                {
                  customLabel: {
                    name: SHEET_UI_PLUGIN_NAME + ColorPicker.name,
                    props: {
                      onClick: (color, e4) => {
                        this._lineColor.setColor(color);
                        this._borderInfo.color = color;
                        const borderItem = this._toolList.find((item) => item.name === "border");
                        const lineColor = borderItem?.children?.find((item) => item.name === "borderColor");
                        if (!lineColor)
                          return;
                        if (!lineColor.customLabel)
                          return;
                        if (!lineColor.customLabel.props)
                          return;
                        lineColor.customLabel.props.color = color;
                      }
                    }
                  },
                  className: index_module_default35.selectColorPicker,
                  onClick: (...arg) => {
                    arg[0].stopPropagation();
                  }
                }
              ]
            },
            {
              customLabel: {
                name: SHEET_UI_PLUGIN_NAME + LineBold.name,
                props: {
                  img: 0,
                  label: "borderLine.borderSize",
                  getComponent: (ref) => this._lineBold = ref
                }
              },
              onClick: (...arg) => {
                arg[0].stopPropagation();
                this._lineBold.setImg(BORDER_SIZE_CHILDREN[arg[2]].customLabel?.name);
                this._borderInfo.style = arg[1];
              },
              className: index_module_default35.selectLineBoldParent,
              unSelectable: true,
              children: BORDER_SIZE_CHILDREN
            }
          ]
        },
        {
          type: 5,
          tooltip: "toolbar.mergeCell.main",
          customLabel: {
            name: "MergeIcon"
          },
          show: this._config.mergeCell,
          onClick: (value) => {
            this.setMerge(value);
            this.hideTooltip();
          },
          name: "mergeCell",
          children: MERGE_CHILDREN
        },
        {
          type: 3,
          tooltip: "toolbar.horizontalAlignMode.main",
          className: index_module_default35.selectDoubleString,
          display: 1,
          name: "horizontalAlignMode",
          show: this._config.horizontalAlignMode,
          onClick: (value) => {
            this.setHorizontalAlignment(value);
            this.hideTooltip();
          },
          children: HORIZONTAL_ALIGN_CHILDREN
        },
        {
          type: 3,
          tooltip: "toolbar.verticalAlignMode.main",
          className: index_module_default35.selectDoubleString,
          display: 1,
          name: "verticalAlignMode",
          show: this._config.verticalAlignMode,
          onClick: (value) => {
            this.setVerticalAlignment(value);
            this.hideTooltip();
          },
          children: VERTICAL_ALIGN_CHILDREN
        },
        {
          type: 3,
          className: index_module_default35.selectDoubleString,
          tooltip: "toolbar.textWrapMode.main",
          display: 1,
          name: "textWrapMode",
          show: this._config.textWrapMode,
          onClick: (value) => {
            this.setWrapStrategy(value);
            this.hideTooltip();
          },
          children: TEXT_WRAP_CHILDREN
        },
        {
          type: 3,
          className: index_module_default35.selectDoubleString,
          name: "textRotateMode",
          tooltip: "toolbar.textRotateMode.main",
          display: 1,
          show: this._config.textRotateMode,
          onClick: (value) => {
            this.setTextRotation(value);
            this.hideTooltip();
          },
          children: TEXT_ROTATE_CHILDREN
        }
      ];
      this._initialize();
    }
    // Toolbar
    getComponent = (ref) => {
      this._toolbar = ref;
      this.setToolbar();
    };
    // toolbar
    addToolbarConfig(config) {
      const index = this._toolList.findIndex((item) => item.name === config.name);
      if (index > -1) {
        this._toolList.push(config);
      }
    }
    // toolbar
    deleteToolbarConfig(name) {
      const index = this._toolList.findIndex((item) => item.name === name);
      if (index > -1) {
        this._toolList.splice(index, 1);
      }
    }
    // toolbar
    setToolbar() {
      this._toolbar.setToolbar(this._toolList);
    }
    setUIObserve(msg) {
      this._plugin.getContext().getObserverManager().requiredObserver("onUIChangeObservable", "core").notifyObservers(msg);
    }
    changeColor(color) {
      const strikethroughItem = this._toolList.find((item) => item.name === "strikethrough");
      const underlineItem = this._toolList.find((item) => item.name === "underline");
      this.setFontColor(color);
      if (underlineItem) {
        this.setUnderline(underlineItem.active ?? false);
      }
      if (strikethroughItem) {
        this.setStrikeThrough(strikethroughItem.active ?? false);
      }
    }
    setUndo() {
      const msg = {
        name: "undo"
      };
      this.setUIObserve(msg);
    }
    setRedo() {
      const msg = {
        name: "redo"
      };
      this.setUIObserve(msg);
    }
    setFontFamily(fontFamily) {
      const msg = {
        name: "fontFamily",
        value: fontFamily
      };
      this.setUIObserve(msg);
    }
    setFontSize(fontSize) {
      const msg = {
        name: "fontSize",
        value: fontSize
      };
      this.setUIObserve(msg);
    }
    setFontWeight(isBold) {
      const msg = {
        name: "fontWeight",
        value: isBold
      };
      this.setUIObserve(msg);
    }
    setFontStyle(isItalic) {
      const msg = {
        name: "fontStyle",
        value: isItalic
      };
      this.setUIObserve(msg);
    }
    setStrikeThrough(isStrikethrough) {
      const msg = {
        name: "strikeThrough",
        value: isStrikethrough
      };
      this.setUIObserve(msg);
    }
    setUnderline(isUnderLine) {
      const msg = {
        name: "underLine",
        value: isUnderLine
      };
      this.setUIObserve(msg);
    }
    setFontColor(color) {
      const msg = {
        name: "fontColor",
        value: color
      };
      this.setUIObserve(msg);
    }
    setBackground(color) {
      const msg = {
        name: "background",
        value: color
      };
      this.setUIObserve(msg);
    }
    setMerge(value) {
      const msg = {
        name: "merge",
        value
      };
      this.setUIObserve(msg);
    }
    setTextRotation(value) {
      const msg = {
        name: "textRotation",
        value
      };
      this.setUIObserve(msg);
    }
    setWrapStrategy(value) {
      const msg = {
        name: "wrapStrategy",
        value
      };
      this.setUIObserve(msg);
    }
    setVerticalAlignment(value) {
      const msg = {
        name: "verticalAlignment",
        value
      };
      this.setUIObserve(msg);
    }
    setHorizontalAlignment(value) {
      const msg = {
        name: "horizontalAlignment",
        value
      };
      this.setUIObserve(msg);
    }
    setBorder() {
      const msg = {
        name: "borderInfo",
        value: this._borderInfo
      };
      this.setUIObserve(msg);
    }
    hideTooltip() {
      const dom = this._toolbar.base;
      const tooltip = dom.querySelectorAll(`.${index_module_default35.tooltipTitle}.${index_module_default35.bottom}`);
      tooltip.forEach((item) => {
        item.style.display = "none";
      });
    }
    _changeToolbarState(range2) {
      const workbook = this._plugin.getContext().getUniver().getCurrentUniverSheetInstance().getWorkBook();
      const worksheet = workbook.getActiveSheet();
      if (worksheet) {
        const isBold = range2.getFontWeight();
        const IsItalic = range2.getFontStyle();
        const strikeThrough = range2.getStrikeThrough();
        const fontSize = range2.getFontSize();
        const fontWeight = range2.getFontWeight();
        const fontName = range2.getFontFamily();
        const fontItalic = range2.getFontStyle();
        const underline = range2.getUnderline();
        const horizontalAlign = range2.getHorizontalAlignment() ?? 1 /* LEFT */;
        const verticalAlign = range2.getVerticalAlignment() ?? 3 /* BOTTOM */;
        const rotation = range2.getTextRotation();
        const warp = range2.getWrapStrategy() ?? 2 /* CLIP */;
        const bold = this._toolList.find((item) => item.name === "bold");
        const italic = this._toolList.find((item) => item.name === "italic");
        const textRotateModeItem = this._toolList.find((item) => item.name === "textRotateMode");
        const fontSizeItem = this._toolList.find((item) => item.name === "fontSize");
        const fontNameItem = this._toolList.find((item) => item.name === "font");
        const fontBoldItem = this._toolList.find((item) => item.name === "bold");
        const fontItalicItem = this._toolList.find((item) => item.name === "italic");
        const strikethroughItem = this._toolList.find((item) => item.name === "strikethrough");
        const underlineItem = this._toolList.find((item) => item.name === "underline");
        const horizontalAlignModeItem = this._toolList.find((item) => item.name === "horizontalAlignMode");
        const verticalAlignModeItem = this._toolList.find((item) => item.name === "verticalAlignMode");
        const textWrapMode = this._toolList.find((item) => item.name === "textWrapMode");
        if (bold) {
          bold.active = isBold === 1 /* BOLD */;
        }
        if (italic) {
          italic.active = IsItalic === 1 /* ITALIC */;
        }
        if (strikethroughItem) {
          strikethroughItem.active = !!(strikeThrough && strikeThrough.s);
        }
        if (fontNameItem) {
          fontNameItem.children?.forEach((item) => {
            item.selected = fontName === item.value;
          });
        }
        if (fontSizeItem) {
          fontSizeItem.label = fontSize.toString();
        }
        if (fontBoldItem) {
          fontBoldItem.active = !!fontWeight;
        }
        if (fontItalicItem) {
          fontItalicItem.active = !!fontItalic;
        }
        if (underlineItem) {
          underlineItem.active = !!(underline && underline.s);
        }
        if (horizontalAlignModeItem) {
          horizontalAlignModeItem.children?.forEach((item) => {
            item.selected = horizontalAlign === item.value;
          });
        }
        if (textRotateModeItem) {
          textRotateModeItem.children?.forEach((item) => {
            if (rotation.v) {
              item.selected = item.value === "v";
            } else {
              item.selected = rotation.a === item.value;
            }
          });
        }
        if (verticalAlignModeItem) {
          verticalAlignModeItem.children?.forEach((item) => {
            item.selected = verticalAlign === item.value;
          });
        }
        if (textWrapMode) {
          textWrapMode.children?.forEach((item) => {
            item.selected = warp === item.value;
          });
        }
        this.setToolbar();
      }
    }
    _initialize() {
      this._plugin.getComponentManager().register(SHEET_UI_PLUGIN_NAME + ColorSelect.name, ColorSelect);
      this._plugin.getComponentManager().register(SHEET_UI_PLUGIN_NAME + ColorPicker.name, ColorPicker);
      this._plugin.getComponentManager().register(SHEET_UI_PLUGIN_NAME + LineColor.name, LineColor);
      this._plugin.getComponentManager().register(SHEET_UI_PLUGIN_NAME + LineBold.name, LineBold);
      CommandManager.getCommandObservers().add(({ actions }) => {
        if (!actions || actions.length === 0)
          return;
        const action = actions[0];
        const currentUnitId = this._plugin.getContext().getUniver().getCurrentUniverSheetInstance().getWorkBook().getUnitId();
        const actionUnitId = action.getWorkBook().getUnitId();
        if (currentUnitId !== actionUnitId)
          return;
        const manager = this._sheetPlugin.getSelectionManager();
        const range2 = manager?.getCurrentCell();
        if (range2) {
          this._changeToolbarState(range2);
        }
      });
    }
  };

  // ../../packages/ui-plugin-sheets/src/Controller/CellEditorUIController.ts
  var CellEditorUIController = class {
    // Is it in editing state
    isEditMode;
    _richTextEle;
    _richTextEditEle;
    _richText;
    _plugin;
    _sheetPlugin;
    _cellEditExtensionManager;
    _keyboardManager;
    constructor(plugin) {
      this._plugin = plugin;
      this._sheetPlugin = plugin.getUniver().getCurrentUniverSheetInstance().context.getPluginManager().getPluginByName("spreadsheet" /* SPREADSHEET */);
      this._initialize();
    }
    // Get the RichText component
    getComponent = (ref) => {
      this._richText = ref;
      this._initRichText();
    };
    getCellEditor() {
      return this._richText;
    }
    hideEditContainer() {
      this._richTextEle.style.maxHeight = "1px";
      this._richTextEle.style.maxWidth = "1px";
      this._richTextEle.style.minWidth = `1px`;
      this._richTextEle.style.minHeight = `1px`;
      this._richTextEle.style.borderWidth = "0px";
      this._richTextEle.style.transform = "scale(0)";
    }
    /**
     * 1. When a printable character is entered, trigger editing
     * 2. When CompositionStart, trigger editing
     * @param clear Whether to clear the cell
     * @returns
     */
    enterEditMode(clear = false) {
      this.focusEditEle();
      if (this.isEditMode)
        return;
      setTimeout(() => {
        setLastCaretPosition(this._richTextEditEle);
      }, 1);
      this.isEditMode = true;
      const currentCell = this._sheetPlugin.getSelectionManager().getCurrentCellModel();
      if (!currentCell) {
        return false;
      }
      let startX;
      let endX;
      let startY;
      let endY;
      if (currentCell.isMerged) {
        const mergeInfo = currentCell.mergeInfo;
        startX = mergeInfo.startX;
        endX = mergeInfo.endX;
        startY = mergeInfo.startY;
        endY = mergeInfo.endY;
      } else {
        startX = currentCell.startX;
        endX = currentCell.endX;
        startY = currentCell.startY;
        endY = currentCell.endY;
      }
      const scrollX2 = this._sheetPlugin.getMainScene()?.getViewport("viewTop" /* VIEW_TOP */)?.actualScrollX || 0;
      const scrollY2 = this._sheetPlugin.getMainScene()?.getViewport("viewLeft" /* VIEW_LEFT */)?.actualScrollY || 0;
      this._richTextEle.style.left = `${startX - scrollX2}px`;
      this._richTextEle.style.top = `${startY - scrollY2}px`;
      this._richTextEle.style.minWidth = `${endX - startX}px`;
      this._richTextEle.style.minHeight = `${endY - startY}px`;
      this._richTextEle.style.borderWidth = "2px";
      const univerContainerContentRef = this._plugin.getAppUIController().getSheetContainerController().getContentRef();
      const sheetContentRect = getRefElement(univerContainerContentRef).getBoundingClientRect();
      this._richTextEle.style.maxWidth = `${sheetContentRect.width - startX + scrollX2}px`;
      this._richTextEle.style.maxHeight = `${sheetContentRect.height - startY + scrollY2}px`;
      this._richTextEle.style.transform = "";
      let cellValue = this._sheetPlugin.getCellEditorController().getSelectionValue();
      const cell = this._cellEditExtensionManager.handle({
        row: currentCell.row,
        column: currentCell.column,
        value: cellValue
      });
      if (cell) {
        cellValue = cell.value;
      }
      if (clear) {
        cellValue = "";
      }
      this._richText.setValue(cellValue);
      const style = this._sheetPlugin.getCellEditorController().getSelectionStyle();
      this._richTextEditEle.style.cssText = "";
      if (style) {
        this._richTextEditEle.style.cssText = handleStyleToString(style, true);
      }
      this._sheetPlugin.getCellEditorController().setCurrentEditRangeData();
    }
    exitEditMode() {
      this.focusEditEle();
      if (!this.isEditMode)
        return;
      this.isEditMode = false;
      const value = handleDomToJson(this._richTextEditEle);
      const text = this._richTextEditEle.innerText;
      let cell = {};
      if (typeof value === "string") {
        cell.v = value;
        cell.m = value;
      } else if (typeof value === "object") {
        cell.p = value;
        cell.v = text;
        cell.m = text;
      }
      const style = handleStringToStyle(this._richTextEditEle);
      if (Tools.isPlainObject(style)) {
        cell.s = style;
      }
      this._sheetPlugin.getCellEditorController().setCurrentEditRangeValue(cell);
      this.hideEditContainer();
    }
    focusEditEle() {
      setTimeout(() => {
        this._richTextEditEle.focus();
      }, 100);
    }
    getRichTextEle() {
      return this._richTextEle;
    }
    getRichTextEditEle() {
      return this._richTextEditEle;
    }
    _initialize() {
      const main = this._sheetPlugin.getMainComponent();
      main.onDblclickObserver.add((evt) => {
        if (evt.button !== 2) {
          this.enterEditMode();
        }
      });
      main.onPointerDownObserver.add((evt) => {
        this.exitEditMode();
        evt.preventDefault();
      });
      this._cellEditExtensionManager = new CellEditExtensionManager();
      this._keyboardManager = new KeyboardManager(this._plugin);
    }
    _initRichText() {
      this._richTextEle = getRefElement(this._richText.container);
      this._richTextEditEle = $$("div", this._richTextEle);
      this._richTextEditEle.focus();
      this.hideEditContainer();
      this._keyboardManager.handleKeyboardAction(this._richTextEditEle);
      this._handleKeyboardObserver();
      this._richText.hooks.set("onKeyDown", (event) => {
        this._plugin.getObserver("onRichTextKeyDownObservable")?.notifyObservers(event);
      });
      this._richText.hooks.set("onKeyUp", (event) => {
        this._plugin.getObserver("onRichTextKeyUpObservable")?.notifyObservers(event);
      });
    }
    _handleKeyboardObserver() {
      const onKeyDownObservable = this._plugin.getGlobalContext().getObserverManager().getObserver("onKeyDownObservable", "core");
      const onKeyCompositionStartObservable = this._plugin.getGlobalContext().getObserverManager().getObserver("onKeyCompositionStartObservable", "core");
      if (onKeyDownObservable && !onKeyDownObservable.hasObservers()) {
        onKeyDownObservable.add((evt) => {
          if (!evt.ctrlKey && isKeyPrintable(evt.key)) {
            this.enterEditMode(true);
          } else {
            switch (evt.key) {
              case "Enter":
                if (this.isEditMode) {
                  this.exitEditMode();
                  const currentCell = this._sheetPlugin.getSelectionManager().getCurrentCellModel();
                  if (!currentCell?.isMerged) {
                    this._sheetPlugin.getSelectionManager().move(3 /* BOTTOM */);
                  }
                } else {
                  this.enterEditMode();
                }
                break;
              case "Space":
                if (!this.isEditMode) {
                  this.enterEditMode(true);
                }
                break;
              case "ArrowUp":
                if (!this.isEditMode) {
                  this._sheetPlugin.getSelectionManager().move(2 /* TOP */);
                }
                break;
              case "ArrowDown":
                if (!this.isEditMode) {
                  this._sheetPlugin.getSelectionManager().move(3 /* BOTTOM */);
                }
                break;
              case "ArrowLeft":
                if (!this.isEditMode) {
                  this._sheetPlugin.getSelectionManager().move(0 /* LEFT */);
                }
                break;
              case "ArrowRight":
                if (!this.isEditMode) {
                  this._sheetPlugin.getSelectionManager().move(1 /* RIGHT */);
                }
                break;
              case "Tab":
                if (!this.isEditMode) {
                  this._sheetPlugin.getSelectionManager().move(1 /* RIGHT */);
                }
                evt.preventDefault();
                break;
              default:
                break;
            }
          }
        });
      }
      if (onKeyCompositionStartObservable && !onKeyCompositionStartObservable.hasObservers()) {
        onKeyCompositionStartObservable.add((evt) => {
          if (!this.isEditMode) {
            this.enterEditMode(true);
          }
        });
      }
    }
  };

  // ../../packages/ui-plugin-sheets/src/Controller/CountBarUIController.ts
  var CountBarUIController = class {
    _countBar;
    _plugin;
    constructor(plugin) {
      this._plugin = plugin;
      CommandManager.getActionObservers().add((event) => {
        const action = event.action;
        const data = event.data;
        const workbook = action.getWorkBook();
        const unitId = workbook.getUnitId();
        const currentWorkbook = this._plugin.getContext().getUniver().getCurrentUniverSheetInstance().getWorkBook();
        const currentUnitId = currentWorkbook.getUnitId();
        if (unitId === currentUnitId) {
          switch (data.actionName) {
            case SetZoomRatioAction.NAME: {
              this._refreshCountBarUI();
              break;
            }
          }
        }
      });
      const manager = plugin.getContext().getUniver().getCurrentUniverSheetInstance().context.getPluginManager().getRequirePluginByName("spreadsheet" /* SPREADSHEET */).getSelectionManager();
      plugin.getObserver("onChangeSelectionObserver")?.add(() => {
        const rangeList = manager.getActiveRangeList();
        if (rangeList && this._countBar) {
          this._totalRangeList(rangeList);
        }
      });
    }
    // changeRatio
    onChange = (v4) => {
      this._setUIObserve("onUIChangeObservable", { name: "changeZoom", value: Tools.numberFixed(parseFloat(v4) / 100, 2) });
    };
    // 
    setCountBar(content) {
      this._countBar.setValue({
        content
      });
    }
    // CountBar
    getComponent = (ref) => {
      this._countBar = ref;
      this._refreshComponent();
    };
    _totalRangeList(rangeList) {
      let rectList = rangeList.getRangeList();
      let recList = [];
      let plugin = this._plugin;
      let workbook = plugin.getContext().getUniver().getCurrentUniverSheetInstance().getWorkBook();
      let worksheet = workbook.getActiveSheet();
      let cellMatrix = worksheet.getCellMatrix();
      let avg = 0;
      let total = 0;
      let count = 0;
      for (let i4 = 0; i4 < rectList.length; i4++) {
        let rect = rectList[i4];
        for (let r4 = rect.startRow; r4 <= rect.endRow; r4++) {
          for (let c4 = rect.startColumn; c4 <= rect.endColumn; c4++) {
            if (recList.includes(`${r4}${c4}`)) {
              continue;
            }
            const cell = cellMatrix.getValue(r4, c4);
            if (cell) {
              let value = parseFloat(cell.v);
              if (!isNaN(value)) {
                count += 1;
                total += value;
              }
            }
            recList.push(`${r4}${c4}`);
          }
        }
      }
      if (count > 0) {
        avg = total / count;
      }
      this._countBar.setState({
        content: `\u5E73\u5747\u6570\uFF1A${Tools.numberFixed(avg, 2)} \u8BA1\u6570\uFF1A${Tools.numberFixed(total, 2)} \u6570\u91CF\uFF1A${count}`
      });
    }
    _refreshCountBarUI() {
    }
    _refreshComponent() {
      this._refreshCountBarUI();
    }
    _setUIObserve(type, msg) {
      this._plugin.getContext().getObserverManager().requiredObserver(type, "core").notifyObservers(msg);
    }
  };

  // ../../packages/ui-plugin-sheets/src/Controller/FormulaBarUIController.ts
  var FormulaBarUIController = class {
    _formulaBar;
    _plugin;
    _sheetPlugin;
    _cellInputExtensionManager;
    _namedRanges;
    constructor(plugin) {
      this._plugin = plugin;
      this._sheetPlugin = plugin.getUniver().getCurrentUniverSheetInstance().context.getPluginManager().getPluginByName("spreadsheet" /* SPREADSHEET */);
      this._initialize();
    }
    // Toolbar
    getComponent = (ref) => {
      this._formulaBar = ref;
      this._initFormulaBar();
    };
    getFormulaBar() {
      return this._formulaBar;
    }
    _initialize() {
      this._sheetPlugin.getObserver("onChangeSelectionObserver")?.add((selectionControl) => {
        const currentCell = selectionControl.model.currentCell;
        if (currentCell) {
          let currentRangeData;
          if (currentCell.isMerged) {
            const mergeInfo = currentCell.mergeInfo;
            currentRangeData = {
              startRow: mergeInfo.startRow,
              endRow: mergeInfo.endRow,
              startColumn: mergeInfo.startColumn,
              endColumn: mergeInfo.endColumn
            };
          } else {
            const { row, column } = currentCell;
            currentRangeData = {
              startRow: row,
              endRow: row,
              startColumn: column,
              endColumn: column
            };
          }
          const cellData = this._sheetPlugin.getWorkbook().getActiveSheet().getRange(currentRangeData).getObjectValue({ isIncludeStyle: true });
          if (cellData) {
            let cellValue = String(cellData.m || cellData.v || "");
            const cell = this._cellInputExtensionManager.handle({
              row: currentRangeData.startRow,
              column: currentRangeData.startColumn,
              value: cellValue
            });
            if (cell) {
              cellValue = cell.value;
            }
            this._formulaBar.setFormulaContent(cellValue);
          } else {
            this._formulaBar.setFormulaContent("");
          }
        }
      });
      this._cellInputExtensionManager = new CellInputExtensionManager();
    }
    _initFormulaBar() {
      this._namedRanges = this._sheetPlugin.getContext().getWorkBook().getConfig().namedRanges;
      const list = this._namedRanges.map((namedRange) => ({
        value: namedRange.name,
        label: namedRange.name
      }));
      this._formulaBar.setNamedRanges(list);
    }
  };

  // ../../packages/ui-plugin-sheets/src/Model/InfoBarModel.ts
  var InfoBarModel = class {
    constructor(_name) {
      this._name = _name;
    }
    get name() {
      return this._name;
    }
    setName(name) {
      this._name = name;
    }
  };

  // ../../packages/ui-plugin-sheets/src/Controller/InfoBarUIController.ts
  var InfoBarUIController = class {
    _infoBarModel;
    _infoBar;
    _plugin;
    _infoList;
    constructor(plugin) {
      this._plugin = plugin;
    }
    getComponent = (ref) => {
      this._infoBar = ref;
      this._refreshComponent();
      this.resetInfoList(this._infoList);
    };
    resetInfoList(list) {
      const locale = this._plugin.getContext().getLocale();
      for (let k5 in list) {
        if (list[k5].locale) {
          list[k5].label = locale.get(list[k5].locale);
        }
      }
      this._infoBar.setInfoList(list);
    }
    setSheetName(e4) {
      const target = e4.target;
      const name = target.value;
      this._infoBarModel.setName(name);
    }
    _refreshComponent() {
      const name = this._plugin.getUniver().getCurrentUniverSheetInstance().getWorkBook().getConfig().name;
      this._infoBarModel = new InfoBarModel(name);
      this._infoList = {
        back: {
          locale: "info.return"
        },
        rename: {
          locale: "info.tips"
        },
        update: {
          locale: "info.detailUpdate"
        },
        save: {
          locale: "info.detailSave"
        },
        sheet: {
          label: name,
          onBlur: (e4) => {
            this.setSheetName(e4);
          }
        }
      };
    }
  };

  // ../../packages/ui-plugin-sheets/src/Controller/SheetBarUIContruller.ts
  var SheetBarUIController = class {
    _sheetBar;
    _plugin;
    _sheetUl;
    _dataId;
    _sheetIndex;
    _sheetList;
    _menuList;
    constructor(plugin) {
      let that = this;
      this._plugin = plugin;
      this._sheetUl = [
        {
          locale: "sheetConfig.delete",
          onClick: () => {
            that.setUIObserve("onUIChangeObservable", { name: "deleteSheet", value: this._dataId });
          }
        },
        {
          locale: "sheetConfig.copy",
          onClick: () => {
            that.setUIObserve("onUIChangeObservable", { name: "copySheet" });
          }
        },
        {
          locale: "sheetConfig.rename",
          onClick: () => {
            this._sheetBar.reNameSheet(this._dataId);
          }
        },
        {
          locale: "sheetConfig.changeColor",
          border: true,
          className: index_module_default32.selectColorPickerParent,
          children: [
            {
              customLabel: {
                name: this._plugin.getPluginName() + ColorPicker.name,
                props: {
                  onClick: (color) => {
                    this.setUIObserve("onUIChangeObservable", {
                      name: "changeSheetColor",
                      value: {
                        color,
                        sheetId: this._dataId
                      }
                    });
                  }
                }
              },
              className: index_module_default32.selectColorPicker
            }
          ]
        },
        {
          locale: "sheetConfig.hide",
          onClick: () => {
            that.setUIObserve("onUIChangeObservable", { name: "hideSheet", value: this._dataId });
          }
        },
        {
          locale: "sheetConfig.unhide",
          onClick: () => {
            this._sheetBar.ref.current.showMenu(true);
            that.setUIObserve("onUIChangeObservable", { name: "unHideSheet", value: this._dataId });
          },
          border: true
        }
      ];
      this._plugin.getPluginByName(SHEET_UI_PLUGIN_NAME)?.getComponentManager().register(this._plugin.getPluginName() + ColorPicker.name, ColorPicker);
      CommandManager.getActionObservers().add((event) => {
        const action = event.action;
        const data = event.data;
        const workbook = action.getWorkBook();
        const unitId = workbook.getUnitId();
        const currentWorkbook = this._plugin.getUniver().getCurrentUniverSheetInstance().getWorkBook();
        const currentUnitId = currentWorkbook.getUnitId();
        if (unitId === currentUnitId) {
          switch (data.actionName) {
            case SetWorkSheetActivateAction.NAME:
            case SetSheetOrderAction.NAME:
            case InsertSheetAction.NAME:
            case RemoveSheetAction.NAME:
            case SetWorkSheetNameAction.NAME:
            case InsertSheetAction.NAME:
            case SetTabColorAction.NAME:
            case SetWorkSheetStatusAction.NAME:
            case SetWorkSheetHideAction.NAME: {
              this._refreshSheetData();
              this._refreshSheetBarUI();
              break;
            }
          }
        }
      });
      this._plugin.getPluginByName(SHEET_UI_PLUGIN_NAME)?.getComponentManager().register(this._plugin.getPluginName() + ColorPicker.name, ColorPicker);
    }
    getComponent = (ref) => {
      this._sheetBar = ref;
      this._refreshComponent();
    };
    resetLabel(label) {
      const locale = this._plugin.getGlobalContext().getLocale();
      let str = "";
      if (label instanceof Array) {
        label.forEach((item) => {
          if (item.includes(".")) {
            str += locale.get(item);
          } else {
            str += item;
          }
        });
      } else {
        if (label.includes(".")) {
          str = locale.get(label);
        } else {
          str += label;
        }
      }
      return str;
    }
    findLocale(obj) {
      for (let k5 in obj) {
        if (k5 === "locale") {
          obj.label = this.resetLabel(obj[k5]);
        } else if (k5.endsWith("Locale")) {
          const index = k5.indexOf("Locale");
          obj[k5.slice(0, index)] = this.resetLabel(obj[k5]);
        } else if (!obj[k5].$$typeof) {
          if (Object.prototype.toString.call(obj[k5]) === "[object Object]") {
            this.findLocale(obj[k5]);
          } else if (Object.prototype.toString.call(obj[k5]) === "[object Array]") {
            obj[k5] = this.resetSheetUl(obj[k5]);
          }
        }
      }
      return obj;
    }
    setUIObserve(type, msg) {
      this._plugin.getContext().getObserverManager().requiredObserver(type, "core").notifyObservers(msg);
    }
    getSheetBar() {
      return this._sheetBar;
    }
    getDataId() {
      return this._dataId;
    }
    getSheetList() {
      return this._sheetList;
    }
    getMenuList() {
      return this._menuList;
    }
    resetSheetUl(sheetUl) {
      for (let i4 = 0; i4 < sheetUl.length; i4++) {
        let item = sheetUl[i4];
        item = this.findLocale(item);
        if (item.children) {
          item.children = this.resetSheetUl(item.children);
        }
      }
      return sheetUl;
    }
    selectSheet() {
    }
    deleteSheet() {
    }
    sortMenu(index, hidden, hideIndex) {
    }
    copySheet() {
    }
    addSheet = (position, config) => {
      this.setUIObserve("onUIChangeObservable", {
        name: "addSheet",
        value: {
          position,
          config
        }
      });
    };
    hideSheet() {
    }
    unHideSheet() {
      this._sheetBar.ref.current.showSelect();
    }
    moveSheet(direct) {
    }
    changeSheetName = (event) => {
      this.setUIObserve("onUIChangeObservable", {
        name: "renameSheet",
        value: {
          sheetId: this._dataId,
          sheetName: event.target.innerText
        }
      });
    };
    contextMenu(e4) {
      this._sheetBar.contextMenu(e4);
    }
    dragEnd = (element) => {
      let list = [];
      let sheetId = this._dataId;
      Array.from(element).forEach((node) => {
        const item = this._sheetList.find((ele) => ele.sheetId === node.dataset.id);
        if (item) {
          list.push(item);
        }
      });
      list.forEach((ele, index) => {
        if (ele.sheetId === sheetId) {
          this._plugin.getUniver().getCurrentUniverSheetInstance().getWorkBook().setSheetOrder(ele.sheetId, index);
        }
      });
    };
    _refreshSheetBarUI() {
      this._sheetBar.setValue({
        sheetList: this._sheetList,
        sheetUl: this._sheetUl,
        menuList: this._menuList,
        selectSheet: (event, data) => {
          this._dataId = data.item.sheetId;
          const sheet = this._plugin.getUniver().getCurrentUniverSheetInstance().getWorkBook().getSheetBySheetId(this._dataId);
          if (sheet) {
            sheet.activate();
          }
        },
        contextMenu: (e4) => {
          const target = e4.currentTarget;
          this._dataId = target.dataset.id;
        },
        changeSheetName: (event) => {
        },
        dragEnd: (elements) => {
        }
      });
    }
    _refreshSheetData() {
      const workbook = this._plugin.getUniver().getCurrentUniverSheetInstance().getWorkBook();
      const sheets = workbook.getSheets();
      this._menuList = sheets.map((sheet, index) => ({
        label: sheet.getName(),
        index: String(index),
        sheetId: sheet.getSheetId(),
        hidden: sheet.isSheetHidden(),
        selected: sheet.getStatus() === 1,
        onClick: (e4) => {
          const target = e4.currentTarget;
          this._dataId = target.dataset.id;
          sheet.showSheet();
          sheet.activate();
        }
      }));
      this._sheetList = sheets.filter((sheet) => !sheet.isSheetHidden()).map((sheet, index) => ({
        sheetId: sheet.getSheetId(),
        label: sheet.getName(),
        index: String(index),
        selected: sheet.getStatus() === 1,
        color: sheet.getTabColor(),
        onDown: (e4) => {
          const target = e4.currentTarget;
          this._dataId = target.dataset.id;
        },
        onClick: (e4) => {
          const target = e4.currentTarget;
          this._dataId = target.dataset.id;
          sheet.activate();
        }
      }));
      this._sheetIndex = sheets.findIndex((sheet) => sheet.getStatus() === 1);
      if (this._sheetIndex > -1) {
        this._dataId = sheets[this._sheetIndex].getSheetId();
      }
    }
    _refreshComponent() {
      this._sheetUl = this.resetSheetUl(this._sheetUl);
      this._refreshSheetData();
      this._refreshSheetBarUI();
    }
  };

  // ../../packages/ui-plugin-sheets/src/Controller/SlotController.ts
  var SlotController = class {
    _slotGroup = /* @__PURE__ */ new Map();
    _slot;
    getComponent = (ref) => {
      this._slot = ref;
    };
    addSlot(name, slot, cb) {
      if (this._slotGroup.get(name))
        return;
      this._slotGroup.set(name, {
        component: slot.component,
        props: slot.props ?? {}
      });
      this.setSlot(cb);
    }
    getSlot(name) {
      const slotGroup = this._slot.getSlotGroup();
      return slotGroup.get(name);
    }
    removeSlot(name) {
      this._slotGroup.delete(name);
      this.setSlot();
    }
    setSlot(cb) {
      this._slot?.setSlotGroup(this._slotGroup, cb);
    }
  };

  // ../../packages/ui-plugin-sheets/src/Controller/SheetContainerUIController.ts
  var SheetContainerUIController = class {
    _plugin;
    _sheetContainer;
    _toolbarController;
    _slotController;
    _cellEditorUIController;
    _formulaBarUIController;
    _infoBarController;
    _rightMenuController;
    _countBarController;
    _sheetBarController;
    _config;
    _dragManager;
    _eventManager;
    constructor(plugin) {
      this._plugin = plugin;
      this._config = this._plugin.getConfig();
      this._initialize();
      this._slotController = new SlotController();
      this._toolbarController = new ToolbarUIController(this._plugin, this._config.layout?.toolbarConfig);
      this._cellEditorUIController = new CellEditorUIController(this._plugin);
      this._formulaBarUIController = new FormulaBarUIController(this._plugin);
      this._infoBarController = new InfoBarUIController(this._plugin);
      this._rightMenuController = new RightMenuUIController(this._plugin, this._config.layout?.rightMenuConfig);
      this._countBarController = new CountBarUIController(this._plugin);
      this._sheetBarController = new SheetBarUIController(this._plugin);
    }
    getUIConfig() {
      const config = {
        context: this._plugin.getContext(),
        config: this._config,
        changeLocale: this.changeLocale,
        getComponent: this.getComponent,
        // props
        methods: {
          toolbar: {
            getComponent: this._toolbarController.getComponent
          },
          cellEditor: {
            getComponent: this._cellEditorUIController.getComponent
          },
          formulaBar: {
            getComponent: this._formulaBarUIController.getComponent
          },
          infoBar: {
            getComponent: this._infoBarController.getComponent
            // renameSheet: this._infoBarController.renameSheet,
          },
          rightMenu: {
            getComponent: this._rightMenuController.getComponent
          },
          countBar: {
            getComponent: this._countBarController.getComponent,
            onChange: this._countBarController.onChange
          },
          sheetBar: {
            getComponent: this._sheetBarController.getComponent,
            addSheet: this._sheetBarController.addSheet,
            selectSheet: this._sheetBarController.selectSheet,
            dragEnd: this._sheetBarController.dragEnd,
            changeSheetName: this._sheetBarController.changeSheetName
          },
          slot: {
            getComponent: this._slotController.getComponent
          }
        }
      };
      return config;
    }
    // SheetContainer
    getComponent = (ref) => {
      this._sheetContainer = ref;
      this._plugin.getObserver("onUIDidMount")?.notifyObservers(this._sheetContainer);
      this._initSheetContainer();
    };
    /**
     * Change language
     * @param {String} lang new language
     *
     * e: {target: HTMLSelectElement } reference from  https://stackoverflow.com/a/48443771
     *
     */
    changeLocale = (locale) => {
      this._plugin.getContext().getLocale().change(locale);
      this._plugin.getGlobalContext().getObserverManager().requiredObserver("onAfterChangeUILocaleObservable", "core").notifyObservers();
    };
    getContentRef() {
      return this._sheetContainer.getContentRef();
    }
    setEventManager() {
      const universheets = this._plugin.getUniver().getAllUniverSheetsInstance();
      universheets.forEach((universheet2) => {
        universheet2.getWorkBook().getContext().getPluginManager().getRequirePluginByName("spreadsheet" /* SPREADSHEET */).listenEventManager();
      });
    }
    getEventManager() {
      return this._eventManager;
    }
    getCellEditorUIController() {
      return this._cellEditorUIController;
    }
    getFormulaBarUIController() {
      return this._formulaBarUIController;
    }
    getMainSlotController() {
      return this._slotController;
    }
    UIDidMount(cb) {
      if (this._sheetContainer)
        return cb(this._sheetContainer);
      this._plugin.getObserver("onUIDidMount")?.add(() => cb(this._sheetContainer));
    }
    _initialize() {
      this._dragManager = new DragManager(this._plugin);
      this._eventManager = new EventManager(this._plugin);
      this.setEventManager();
    }
    _initSheetContainer() {
      this._dragManager.handleDragAction(getRefElement(this._sheetContainer));
    }
  };

  // ../../packages/ui-plugin-sheets/src/Controller/AppUIController.ts
  var AppUIController = class {
    _plugin;
    _sheetContainerController;
    constructor(plugin) {
      this._plugin = plugin;
      this._sheetContainerController = new SheetContainerUIController(this._plugin);
      const UIConfig = this._sheetContainerController.getUIConfig();
      UI.create({
        context: this._plugin.getGlobalContext(),
        locale: this._plugin.getGlobalContext().getLocale().getCurrentLocale(),
        changeLocale: this.changeLocale,
        UIConfig,
        container: this._plugin.getConfig().container
      });
    }
    /**
     * Change language
     * @param {String} lang new language
     *
     * e: {target: HTMLSelectElement } reference from  https://stackoverflow.com/a/48443771
     *
     */
    changeLocale = (locale) => {
      this._plugin.getGlobalContext().getLocale().change(locale);
      this._plugin.getGlobalContext().getObserverManager().requiredObserver("onAfterChangeUILocaleObservable", "core").notifyObservers();
    };
    getSheetContainerController() {
      return this._sheetContainerController;
    }
  };

  // ../../packages/ui-plugin-sheets/src/SheetUIPlugin.ts
  var SheetUIPlugin3 = class extends Plugin {
    _appUIController;
    _registerManager;
    _config;
    _componentManager;
    constructor(config) {
      super(SHEET_UI_PLUGIN_NAME);
      this._config = Tools.deepMerge({}, DefaultSheetUiConfig, config);
    }
    static create(config) {
      return new SheetUIPlugin3(config);
    }
    installTo(univerInstance) {
      univerInstance.installPlugin(this);
    }
    initialize(ctx) {
      installObserver(this);
      this.getLocale().load({
        zh: zh_default2,
        en: en_default2
      });
      this._componentManager = new ComponentManager();
      this._registerManager = new RegisterManager(this);
      this._appUIController = new AppUIController(this);
      this.initRender();
    }
    getConfig() {
      return this._config;
    }
    initRender() {
      const engine = this.getPluginByName("renderEngine" /* BASE_RENDER */)?.getEngine();
      let container = getRefElement(this._appUIController.getSheetContainerController().getContentRef());
      engine.setContainer(container);
      window.addEventListener("resize", () => {
        engine.resize();
      });
      setTimeout(() => {
        engine.resize();
      }, 0);
    }
    initUI() {
    }
    onMounted(ctx) {
      this.initialize(ctx);
    }
    onDestroy() {
    }
    getAppUIController() {
      return this._appUIController;
    }
    getComponentManager() {
      return this._componentManager;
    }
    /**
     * usage this._clipboardExtensionManager.handle(data);
     * @returns
     */
    getRegisterManager() {
      return this._registerManager;
    }
    /**
     * Formula Bar API
     * @param str
     */
    setFormulaContent(str) {
      this._appUIController.getSheetContainerController().getFormulaBarUIController().getFormulaBar().setFormulaContent(str);
    }
    /**
     * This API is used in plugins for initialization that depends on UI rendering
     * @param cb
     * @returns
     */
    UIDidMount(cb) {
      this._appUIController.getSheetContainerController().UIDidMount(cb);
    }
  };

  // ../../packages/sheets-plugin-formula/src/Basic/Const/DEFAULT_FORMULA_DATA.ts
  var DEFAULT_FORMULA_DATA_DEMO1 = {
    formulaData: {
      "workbook-01": {
        "sheet-0003": {
          "11": {
            "6": {
              formula: "=E12*F12",
              row: 11,
              column: 6,
              sheetId: "sheet-0003"
            }
          },
          "12": {
            "6": {
              formula: "=E13*F13",
              row: 12,
              column: 6,
              sheetId: "sheet-0003"
            }
          },
          "13": {
            "6": {
              formula: "=LAMBDA(x,x+2)(E14)",
              row: 13,
              column: 6,
              sheetId: "sheet-0003"
            }
          },
          "19": {
            "6": {
              formula: "=SUM(G12:G19)",
              row: 19,
              column: 6,
              sheetId: "sheet-0003"
            }
          }
        }
      }
    }
  };

  // ../../packages/sheets-plugin-formula/src/Basic/Const/FunctionList.ts
  var SelectCategoryType = [
    {
      locale: "formula.formulaMore.Math"
    },
    {
      locale: "formula.formulaMore.Statistical"
    },
    {
      locale: "formula.formulaMore.Lookup"
    },
    {
      locale: "formula.formulaMore.universheet"
    },
    {
      locale: "formula.formulaMore.dataMining"
    },
    {
      locale: "formula.formulaMore.Database"
    },
    {
      locale: "formula.formulaMore.Date"
    },
    {
      locale: "formula.formulaMore.Filter"
    },
    {
      locale: "formula.formulaMore.Financial"
    },
    {
      locale: "formula.formulaMore.Engineering"
    },
    {
      locale: "formula.formulaMore.Logical"
    },
    {
      locale: "formula.formulaMore.Operator"
    },
    {
      locale: "formula.formulaMore.Text"
    },
    {
      locale: "formula.formulaMore.Parser"
    },
    {
      locale: "formula.formulaMore.Array"
    },
    {
      locale: "formula.formulaMore.other"
    }
  ];
  var FunList = [
    {
      n: "SUMIF",
      t: 0,
      d: "formula.functionList.SUMIF.d",
      p: [
        {
          name: "formula.functionList.SUMIF.p.range.name",
          detail: "formula.functionList.SUMIF.p.range.detail",
          example: "A1:A10"
        },
        {
          name: "formula.functionList.SUMIF.p.rangeAll.name",
          detail: "formula.functionList.SUMIF.p.rangeAll.detail",
          example: '">20"'
        },
        {
          name: "formula.functionList.SUMIF.p.range1.name",
          detail: "formula.functionList.SUMIF.p.range1.detail",
          example: "B1:B10"
        }
      ]
    },
    {
      n: "SUMIF1",
      t: 1,
      d: "formula.functionList.SUMIF.d"
    },
    {
      n: "SUMIF2",
      t: 2,
      d: "formula.functionList.SUMIF.d"
    },
    {
      n: "SUMIF3",
      t: 3,
      d: "formula.functionList.SUMIF.d"
    },
    {
      n: "SUMIF4",
      t: 4,
      d: "formula.functionList.SUMIF.d"
    },
    {
      n: "SUMIF5",
      t: 5,
      d: "formula.functionList.SUMIF.d"
    },
    {
      n: "SUMIF6",
      t: 6,
      d: "formula.functionList.SUMIF.d"
    },
    {
      n: "SUMIF7",
      t: 7,
      d: "formula.functionList.SUMIF.d"
    }
  ];

  // ../../packages/sheets-plugin-formula/src/Basic/Const/PLUGIN_NAME.ts
  var FORMULA_PLUGIN_NAME = "formula";

  // ../../packages/sheets-plugin-formula/src/Model/Apply/SetFormulaRangeData.ts
  function SetFormulaRangeData(workbook, formulaData) {
    const formulaDataModel = workbook.getContext().getPluginManager().getRequirePluginByName(FORMULA_PLUGIN_NAME).getFormulaController().getDataModel();
    const result = Tools.deepClone(formulaDataModel.getFormulaData());
    formulaDataModel.setFormulaData(formulaData);
    return result;
  }

  // ../../packages/sheets-plugin-formula/src/Model/Action/SetFormulaRangeDataAction.ts
  var SetFormulaRangeDataAction = class extends SheetActionBase2 {
    constructor(actionData, commandUnit, observers) {
      super(actionData, commandUnit, observers);
      this._doActionData = {
        ...actionData
      };
      this._oldActionData = {
        ...actionData,
        formulaData: this.do()
      };
    }
    do() {
      return this.redo();
    }
    redo() {
      const { _workbook } = this;
      const { formulaData } = this._doActionData;
      return SetFormulaRangeData(_workbook, formulaData);
    }
    undo() {
      const { _workbook } = this;
      const { formulaData } = this._oldActionData;
      SetFormulaRangeData(_workbook, formulaData);
    }
    validate() {
      return false;
    }
  };

  // ../../packages/sheets-plugin-formula/src/Model/RegisterAction.ts
  CommandManager.register("SetFormulaRangeDataAction" /* SET_FORMULA_RANGE_DATA_ACTION */, SetFormulaRangeDataAction);

  // ../../packages/base-formula-engine/src/Basics/ErrorType.ts
  var ERROR_TYPE_SET = /* @__PURE__ */ new Set([
    "#DIV/0!" /* DIV_BY_ZERO */,
    "#NAME!" /* NAME */,
    "#VALUE!" /* VALUE */,
    "#NUM!" /* NUM */,
    "#NA!" /* NA */,
    "#CYCLE!" /* CYCLE */,
    "#REF!" /* REF */,
    "#SPILL!" /* SPILL */,
    "#CALC!" /* CALC */,
    "#ERROR!" /* ERROR */,
    "#GETTING_DATA" /* CONNECT */,
    "#NULL!" /* NULL */
  ]);

  // ../../packages/base-formula-engine/src/Basics/TokenType.ts
  var DEFAULT_TOKEN_TYPE_PARAMETER = "P_1";
  var DEFAULT_TOKEN_TYPE_ROOT = "R_1";
  var DEFAULT_TOKEN_TYPE_LAMBDA_PARAMETER = "L_1";
  var DEFAULT_TOKEN_TYPE_LAMBDA_RUNTIME_PARAMETER = "LR_1";

  // ../../packages/base-formula-engine/src/Analysis/LexerNode.ts
  var LexerNode = class {
    _parent;
    _token;
    _children = [];
    _lambdaId;
    _lambdaPrivacyVar;
    _lambdaParameter;
    getLambdaId() {
      return this._lambdaId;
    }
    setLambdaId(lambdaId) {
      this._lambdaId = lambdaId;
    }
    getLambdaPrivacyVar() {
      return this._lambdaPrivacyVar;
    }
    setLambdaPrivacyVar(lambdaPrivacyVar) {
      this._lambdaPrivacyVar = lambdaPrivacyVar;
    }
    getLambdaParameter() {
      return this._lambdaParameter;
    }
    setLambdaParameter(lambdaParameter) {
      this._lambdaParameter = lambdaParameter;
    }
    getParent() {
      return this._parent;
    }
    setParent(lexerNode) {
      this._parent = lexerNode;
    }
    getChildren() {
      return this._children;
    }
    setChildren(children) {
      this._children = children;
    }
    addChildren(children) {
      this._children.push(children);
    }
    getToken() {
      return this._token;
    }
    setToken(token) {
      this._token = token;
    }
    changeToParent(newParentLexerNode) {
      const parentNode = this.getParent();
      if (parentNode) {
        parentNode.removeChild(this);
      }
      this.setParent(newParentLexerNode);
      const childrenNode = newParentLexerNode.getChildren();
      childrenNode.push(this);
    }
    removeChild(lexerNode) {
      const childrenNode = this.getChildren();
      const childrenCount = childrenNode.length;
      for (let i4 = 0; i4 < childrenCount; i4++) {
        const child = childrenNode[i4];
        if (child === lexerNode) {
          childrenNode.splice(i4, 1);
          return;
        }
      }
    }
    serialize() {
      const token = this.getToken();
      const children = this.getChildren();
      const childrenSerialization = [];
      const childrenCount = children.length;
      for (let i4 = 0; i4 < childrenCount; i4++) {
        const item = children[i4];
        if (item instanceof LexerNode) {
          childrenSerialization.push(item.serialize());
        } else {
          childrenSerialization.push(item);
        }
      }
      return {
        token,
        children: childrenSerialization
      };
    }
  };

  // ../../packages/base-formula-engine/src/Basics/Token.ts
  var OPERATOR_TOKEN_PRIORITY = /* @__PURE__ */ new Map([
    ["<>" /* NOT_EQUAL */, 3],
    ["<" /* LESS_THAN */, 3],
    [">=" /* GREATER_THAN_OR_EQUAL */, 3],
    ["=" /* EQUALS */, 3],
    [">" /* GREATER_THAN */, 3],
    ["<=" /* LESS_THAN_OR_EQUAL */, 3],
    ["&" /* CONCATENATE */, 2],
    ["+" /* PLUS */, 2],
    ["-" /* MINUS */, 2],
    ["/" /* DIVIDED */, 1],
    ["*" /* MULTIPLY */, 1],
    ["^" /* POWER */, 0]
  ]);
  var OPERATOR_TOKEN_SET = new Set(OPERATOR_TOKEN_PRIORITY.keys());
  var OPERATOR_TOKEN_COMPARE_SET = /* @__PURE__ */ new Set([
    "=" /* EQUALS */,
    "<>" /* NOT_EQUAL */,
    ">" /* GREATER_THAN */,
    ">=" /* GREATER_THAN_OR_EQUAL */,
    "<" /* LESS_THAN */,
    "<=" /* LESS_THAN_OR_EQUAL */
  ]);
  var SUFFIX_TOKEN_SET = /* @__PURE__ */ new Set(["%" /* PERCENTAGE */, "#" /* POUND */]);

  // ../../packages/base-formula-engine/src/Analysis/Lexer.ts
  var LexerTreeMaker = class {
    // :
    constructor(_formulaString) {
      this._formulaString = _formulaString;
    }
    _currentLexerNode;
    _upLevel = 0;
    _segment = "";
    _bracketState = [];
    // ()
    _bracesState = 0;
    // {}
    _singleQuotationState = 0;
    // ''
    _doubleQuotationState = 0;
    // ""
    _lambdaState = false;
    // Lambda
    _colonState = false;
    _resetCurrentLexerNode() {
      this._currentLexerNode = new LexerNode();
    }
    _resetSegment() {
      this._segment = "";
    }
    _pushNodeToChildren(value, isUnshift = false) {
      if (value !== "") {
        const children = this._currentLexerNode.getChildren();
        if (!(value instanceof LexerNode) && this.isColonOpen()) {
          const subLexerNode_ref = new LexerNode();
          subLexerNode_ref.setToken(value);
          subLexerNode_ref.setParent(this._currentLexerNode);
          value = subLexerNode_ref;
        }
        if (isUnshift) {
          children.unshift(value);
        } else {
          children.push(value);
        }
      }
      if (this.isColonOpen()) {
        this._setAncestorCurrentLexerNode();
        this._closeColon();
      }
    }
    _openBracket(type = 0 /* NORMAL */) {
      this._bracketState.push(type);
    }
    _closeBracket() {
      this._bracketState.pop();
    }
    _getCurrentBracket() {
      const bracketState = this._bracketState;
      return bracketState[bracketState.length - 1];
    }
    _openBraces() {
      this._bracesState += 1;
    }
    _closeBraces() {
      this._bracesState -= 1;
    }
    _openSingleQuotation() {
      this._singleQuotationState += 1;
    }
    _closeSingleQuotation() {
      this._singleQuotationState -= 1;
    }
    _openDoubleQuotation() {
      this._doubleQuotationState += 1;
    }
    _closeDoubleQuotation() {
      this._doubleQuotationState -= 1;
    }
    _openLambda() {
      this._lambdaState = true;
    }
    _closeLambda() {
      this._lambdaState = false;
    }
    _openColon(upLevel) {
      this._upLevel = upLevel;
      this._colonState = true;
    }
    _closeColon() {
      this._upLevel = 0;
      this._colonState = false;
    }
    getUpLevel() {
      return this._upLevel;
    }
    isColonClose() {
      return this._colonState === false;
    }
    isColonOpen() {
      return this._colonState === true;
    }
    isDoubleQuotationClose() {
      return this._doubleQuotationState === 0;
    }
    isLambdaOpen() {
      return this._lambdaState === true;
    }
    isLambdaClose() {
      return this._lambdaState === false;
    }
    isSingleQuotationClose() {
      return this._singleQuotationState === 0;
    }
    isBracesClose() {
      return this._bracesState === 0;
    }
    isBracketClose() {
      return this._bracketState.length === 0;
    }
    _getLastChildCurrentLexerNode() {
      const children = this._currentLexerNode.getChildren();
      if (children && children.length > 0) {
        const lastNode = children[children.length - 1];
        if (lastNode instanceof LexerNode) {
          return lastNode;
        }
      }
      return false;
    }
    _getLastChildCurrent() {
      const children = this._currentLexerNode.getChildren();
      if (children && children.length > 0) {
        const lastNode = children[children.length - 1];
        return lastNode;
      }
      return false;
    }
    _setParentCurrentLexerNode() {
      const parent = this._currentLexerNode.getParent();
      if (parent) {
        this._currentLexerNode = parent;
        return true;
      }
      return false;
    }
    _setAncestorCurrentLexerNode() {
      const parent = this._currentLexerNode?.getParent();
      let state = false;
      if (parent && parent.getToken() === DEFAULT_TOKEN_TYPE_LAMBDA_PARAMETER) {
        if (parent?.getParent()?.getParent()) {
          this._currentLexerNode = this._currentLexerNode.getParent()?.getParent().getParent();
          state = true;
        }
      } else {
        if (parent?.getParent()) {
          this._currentLexerNode = this._currentLexerNode.getParent().getParent();
          state = true;
        }
      }
      for (let i4 = 0; i4 < this._upLevel; i4++) {
        this._currentLexerNode = this._currentLexerNode?.getParent();
        if (this._currentLexerNode) {
          state = true;
        } else {
          state = false;
        }
      }
      return state;
    }
    _segmentCount() {
      return this._segment.trim().length;
    }
    _pushSegment(value) {
      this._segment += value;
    }
    _setCurrentLexerNode(subLexerNode, isUnshift = false) {
      this._pushNodeToChildren(subLexerNode, isUnshift);
      subLexerNode.setParent(this._currentLexerNode);
      this._currentLexerNode = subLexerNode;
    }
    _newAndPushCurrentLexerNode(token, isUnshift = false) {
      const subLexerNode = new LexerNode();
      subLexerNode.setToken(token);
      this._setCurrentLexerNode(subLexerNode, isUnshift);
    }
    _getTopNode(lexerNode) {
      let parentNode = lexerNode;
      while (parentNode.getParent()) {
        parentNode = parentNode.getParent();
      }
      return parentNode;
    }
    _removeLastChild() {
      const children = this._currentLexerNode.getChildren();
      children.splice(-1);
    }
    _findPreviousToken(data, index) {
      while (index >= 0) {
        const token = data[index];
        if (token !== " ") {
          return token;
        }
        index--;
      }
    }
    getCurrentLexerNode() {
      return this._currentLexerNode;
    }
    treeMaker() {
      this._resetCurrentLexerNode();
      this._currentLexerNode.setToken(DEFAULT_TOKEN_TYPE_ROOT);
      const state = this._nodeMaker(this._formulaString);
      this._currentLexerNode = this._getTopNode(this._currentLexerNode);
      return this._currentLexerNode;
    }
    suffixExpressionHandler(lexerNode) {
      const children = lexerNode.getChildren();
      if (!children) {
        return;
      }
      const childrenCount = children.length;
      const baseStack = [];
      const symbolStack = [];
      for (let i4 = 0; i4 < childrenCount; i4++) {
        const node = children[i4];
        if (!(node instanceof LexerNode)) {
          const char = node.trim();
          if (char === "") {
            continue;
          }
          if (OPERATOR_TOKEN_SET.has(char)) {
            while (symbolStack.length > 0) {
              const lastSymbol = symbolStack[symbolStack.length - 1]?.trim();
              if (!lastSymbol || lastSymbol === "(" /* OPEN_BRACKET */) {
                break;
              }
              const lastSymbolPriority = OPERATOR_TOKEN_PRIORITY.get(lastSymbol);
              const charPriority = OPERATOR_TOKEN_PRIORITY.get(char);
              if (!lastSymbolPriority || !charPriority) {
                break;
              }
              if (charPriority > lastSymbolPriority) {
                baseStack.push(symbolStack.pop());
              } else {
                break;
              }
            }
            symbolStack.push(node);
          } else if (char === "(" /* OPEN_BRACKET */) {
            symbolStack.push(node);
          } else if (char === ")" /* CLOSE_BRACKET */) {
            while (symbolStack.length > 0) {
              const lastSymbol = symbolStack[symbolStack.length - 1]?.trim();
              if (!lastSymbol) {
                break;
              }
              if (lastSymbol === "(" /* OPEN_BRACKET */) {
                symbolStack.pop();
                break;
              }
              baseStack.push(symbolStack.pop());
            }
          } else {
            baseStack.push(node);
          }
        } else {
          this.suffixExpressionHandler(node);
          baseStack.push(node);
        }
      }
      while (symbolStack.length > 0) {
        baseStack.push(symbolStack.pop());
      }
      lexerNode.setChildren(baseStack);
    }
    _negativeCondition(prevString) {
      if (OPERATOR_TOKEN_SET.has(prevString) || prevString === "(" /* OPEN_BRACKET */ || prevString === "," /* COMMA */) {
        return true;
      }
      return false;
    }
    _nodeMaker(formulaString) {
      if (formulaString.substring(0, 1) === "=" /* EQUALS */) {
        formulaString = formulaString.substring(1);
      }
      const formulaStringArray = formulaString.split("");
      const formulaStringArrayCount = formulaStringArray.length;
      let cur = 0;
      this._resetSegment();
      while (cur < formulaStringArrayCount) {
        const currentString = formulaStringArray[cur];
        if (currentString === "(" /* OPEN_BRACKET */ && this.isSingleQuotationClose() && this.isDoubleQuotationClose()) {
          if (this._segmentCount() > 0 || this.isLambdaOpen()) {
            if (this.isLambdaClose()) {
              this._newAndPushCurrentLexerNode(this._segment);
              this._resetSegment();
            }
            this._openBracket(1 /* FUNCTION */);
            this._closeLambda();
            const nextCurrentString = formulaStringArray[cur + 1];
            if (nextCurrentString && nextCurrentString === ")" /* CLOSE_BRACKET */) {
              if (!this._setParentCurrentLexerNode() && cur !== formulaStringArrayCount - 1) {
                return "#VALUE!" /* VALUE */;
              }
              cur++;
            } else if (nextCurrentString) {
              this._newAndPushCurrentLexerNode(DEFAULT_TOKEN_TYPE_PARAMETER);
            }
          } else {
            this._pushNodeToChildren(currentString);
            this._openBracket(0 /* NORMAL */);
          }
        } else if (currentString === ")" /* CLOSE_BRACKET */ && this.isSingleQuotationClose() && this.isDoubleQuotationClose()) {
          this._pushNodeToChildren(this._segment);
          this._resetSegment();
          const currentBracket = this._getCurrentBracket();
          if (currentBracket === 0 /* NORMAL */) {
            this._pushNodeToChildren(currentString);
          } else if (currentBracket === 1 /* FUNCTION */) {
            const nextCurrentString = formulaStringArray[cur + 1];
            if (nextCurrentString && nextCurrentString === "(" /* OPEN_BRACKET */) {
              if (!this._setParentCurrentLexerNode() && cur !== formulaStringArrayCount - 1) {
                return "#VALUE!" /* VALUE */;
              }
              this._newAndPushCurrentLexerNode(DEFAULT_TOKEN_TYPE_LAMBDA_PARAMETER, true);
              this._openLambda();
            } else {
              if (!this._setAncestorCurrentLexerNode() && cur !== formulaStringArrayCount - 1) {
                return "#VALUE!" /* VALUE */;
              }
            }
          } else {
            return "#VALUE!" /* VALUE */;
          }
          this._closeBracket();
        } else if (currentString === "{" /* OPEN_BRACES */ && this.isSingleQuotationClose() && this.isDoubleQuotationClose()) {
          this._pushSegment(currentString);
          this._openBraces();
        } else if (currentString === "}" /* CLOSE_BRACES */ && this.isSingleQuotationClose() && this.isDoubleQuotationClose()) {
          this._pushSegment(currentString);
          this._pushNodeToChildren(this._segment);
          this._resetSegment();
          this._closeBraces();
        } else if (currentString === '"' /* DOUBLE_QUOTATION */ && this.isSingleQuotationClose() && this.isBracesClose()) {
          if (this.isDoubleQuotationClose()) {
            this._openDoubleQuotation();
          } else {
            const nextCurrentString = formulaStringArray[cur + 1];
            if (nextCurrentString && nextCurrentString === '"' /* DOUBLE_QUOTATION */) {
              cur++;
            } else {
              this._closeDoubleQuotation();
            }
          }
          this._pushSegment(currentString);
        } else if (currentString === "'" /* SINGLE_QUOTATION */ && this.isDoubleQuotationClose()) {
          if (this.isSingleQuotationClose()) {
            this._openSingleQuotation();
          } else {
            const nextCurrentString = formulaStringArray[cur + 1];
            if (nextCurrentString && nextCurrentString === "'" /* SINGLE_QUOTATION */) {
              cur++;
            } else {
              this._closeSingleQuotation();
            }
          }
          this._pushSegment(currentString);
        } else if (currentString === "," /* COMMA */ && this.isSingleQuotationClose() && this.isDoubleQuotationClose() && this.isBracesClose()) {
          const currentBracket = this._getCurrentBracket();
          if (currentBracket === 1 /* FUNCTION */) {
            this._pushNodeToChildren(this._segment);
            this._resetSegment();
            if (!this._setParentCurrentLexerNode() && cur !== formulaStringArrayCount - 1) {
              return "#VALUE!" /* VALUE */;
            }
            this._newAndPushCurrentLexerNode(DEFAULT_TOKEN_TYPE_PARAMETER);
          } else {
            return "#VALUE!" /* VALUE */;
          }
        } else if (currentString === ":" /* COLON */ && this.isSingleQuotationClose() && this.isDoubleQuotationClose() && this.isBracesClose()) {
          const subLexerNode_op = new LexerNode();
          subLexerNode_op.setToken(currentString);
          const subLexerNode_left = new LexerNode();
          subLexerNode_left.setToken(DEFAULT_TOKEN_TYPE_PARAMETER);
          subLexerNode_left.setParent(subLexerNode_op);
          const subLexerNode_right = new LexerNode();
          subLexerNode_right.setToken(DEFAULT_TOKEN_TYPE_PARAMETER);
          subLexerNode_right.setParent(subLexerNode_op);
          subLexerNode_op.getChildren().push(subLexerNode_left, subLexerNode_right);
          let subLexerNode_main = subLexerNode_op;
          let upLevel = 0;
          if (this._segmentCount() > 0) {
            let subLexerNode_minus;
            let subLexerNode_at;
            let sliceLength = 0;
            if (new RegExp("-" /* MINUS */, "g").test(this._segment)) {
              subLexerNode_minus = new LexerNode();
              subLexerNode_minus.setToken("-" /* MINUS */);
              sliceLength++;
            }
            if (new RegExp("@" /* AT */, "g").test(this._segment)) {
              subLexerNode_at = new LexerNode();
              subLexerNode_at.setToken("@" /* AT */);
              if (subLexerNode_minus) {
                subLexerNode_minus.addChildren(subLexerNode_at);
                subLexerNode_at.setParent(subLexerNode_minus);
              }
              sliceLength++;
            }
            if (sliceLength > 0) {
              this._segment = this._segment.slice(sliceLength);
            }
            upLevel = sliceLength;
            if (subLexerNode_at) {
              subLexerNode_at.addChildren(subLexerNode_op);
              subLexerNode_op.setParent(subLexerNode_at);
              if (subLexerNode_at.getParent()) {
                subLexerNode_main = subLexerNode_at.getParent();
              } else {
                subLexerNode_main = subLexerNode_at;
              }
            } else if (subLexerNode_minus) {
              subLexerNode_main = subLexerNode_minus;
              subLexerNode_minus.addChildren(subLexerNode_op);
              subLexerNode_op.setParent(subLexerNode_minus);
            }
            const subLexerNode_ref = new LexerNode();
            subLexerNode_ref.setToken(this._segment);
            subLexerNode_ref.setParent(subLexerNode_left);
            subLexerNode_left.getChildren().push(subLexerNode_ref);
            this._resetSegment();
          } else {
            const lastChildNode = this._getLastChildCurrentLexerNode();
            if (lastChildNode) {
              lastChildNode.changeToParent(subLexerNode_left);
            }
          }
          this._setCurrentLexerNode(subLexerNode_main);
          this._currentLexerNode = subLexerNode_right;
          this._openColon(upLevel);
        } else if (SUFFIX_TOKEN_SET.has(currentString) && this.isSingleQuotationClose() && this.isDoubleQuotationClose()) {
          this._pushNodeToChildren(this._segment);
          const subLexerNode = new LexerNode();
          subLexerNode.setToken(currentString);
          const lastChildNode = this._getLastChildCurrent();
          if (lastChildNode instanceof LexerNode) {
            lastChildNode.changeToParent(subLexerNode);
          } else if (lastChildNode !== false) {
            subLexerNode.getChildren().push(lastChildNode);
            this._removeLastChild();
          }
          this._pushNodeToChildren(subLexerNode);
          subLexerNode.setParent(this._currentLexerNode);
          this._resetSegment();
        } else if (OPERATOR_TOKEN_SET.has(currentString) && this.isSingleQuotationClose() && this.isDoubleQuotationClose()) {
          let trimSegment = this._segment.trim();
          if (currentString === "-" /* MINUS */ && trimSegment === "") {
            const prevString = this._findPreviousToken(formulaStringArray, cur - 1) || "";
            if (this._negativeCondition(prevString)) {
              this._pushSegment("-" /* MINUS */);
              cur++;
              continue;
            }
          } else if (this._segment.length > 0 && trimSegment === "") {
            trimSegment = this._segment;
          } else {
            this._pushNodeToChildren(this._segment);
            trimSegment = "";
          }
          if (currentString === "<" /* LESS_THAN */ || currentString === ">" /* GREATER_THAN */) {
            const nextCurrentString = formulaStringArray[cur + 1];
            if (nextCurrentString && OPERATOR_TOKEN_SET.has(currentString + nextCurrentString)) {
              this._pushNodeToChildren(trimSegment + currentString + nextCurrentString);
              cur++;
            } else {
              this._pushNodeToChildren(trimSegment + currentString);
            }
          } else {
            this._pushNodeToChildren(trimSegment + currentString);
          }
          this._resetSegment();
        } else {
          this._pushSegment(currentString);
        }
        cur++;
      }
      this._pushNodeToChildren(this._segment);
    }
  };

  // ../../packages/base-formula-engine/src/Basics/Registry.ts
  var FORMULA_AST_NODE_REGISTRY = Registry2.create();
  var FORMULA_FUNCTION_REGISTRY = RegistryAsMap.create();

  // ../../packages/base-formula-engine/src/AstNode/NodeType.ts
  var NODE_ORDER_MAP = /* @__PURE__ */ new Map([
    ["ReferenceNode" /* REFERENCE */, 7],
    ["ValueNode" /* VALUE */, 9],
    ["OperatorNode" /* OPERATOR */, 8],
    ["FunctionNode" /* FUNCTION */, 6],
    ["LambdaNode" /* LAMBDA */, 1],
    ["LambdaNodeParameter" /* LAMBDA_PARAMETER */, 2],
    ["Root" /* ROOT */, 10],
    ["UnionNode" /* UNION */, 3],
    ["PrefixNode" /* PREFIX */, 4],
    ["SuffixNode" /* SUFFIX */, 5]
  ]);

  // ../../packages/base-formula-engine/src/AstNode/BaseAstNode.ts
  var BaseAstNode = class {
    constructor(_token) {
      this._token = _token;
    }
    _children = [];
    _parent;
    _valueObject;
    _calculateState = false;
    _async = false;
    _address = false;
    get nodeType() {
      return "Base" /* BASE */;
    }
    isAsync() {
      return this._async;
    }
    isAddress() {
      return this._address;
    }
    setAsync() {
      this._async = true;
    }
    setAddress() {
      this._address = true;
    }
    getParent() {
      return this._parent;
    }
    setParent(node) {
      this._parent = node;
      node.addChildren(this);
    }
    getChildren() {
      return this._children;
    }
    addChildren(...astNode) {
      this._children.push(...astNode);
    }
    getToken() {
      return this._token;
    }
    setValue(value) {
      this._valueObject = value;
    }
    getValue() {
      return this._valueObject;
    }
    isCalculated() {
      return this._calculateState;
    }
    setCalculated() {
      this._calculateState = true;
    }
    execute(interpreterDatasetConfig, runtimeData) {
    }
    async executeAsync(interpreterDatasetConfig) {
      return Promise.resolve(0 /* SUCCESS */);
    }
    serialize() {
      const token = this.getToken();
      const children = this.getChildren();
      const childrenSerialization = [];
      const childrenCount = children.length;
      for (let i4 = 0; i4 < childrenCount; i4++) {
        const item = children[i4];
        childrenSerialization.push(item.serialize());
      }
      const result = {
        token,
        nodeType: this.nodeType
      };
      if (childrenCount > 0) {
        result.children = childrenSerialization;
      }
      return result;
    }
  };
  var BaseAstNodeFactory = class {
    get zIndex() {
      return 0;
    }
    create(param, parserDataLoader) {
      let token;
      if (param instanceof LexerNode) {
        token = param.getToken();
      } else {
        token = param;
      }
      return new BaseAstNode(token);
    }
    checkAndCreateNodeType(param, parserDataLoader) {
      return false;
    }
  };

  // ../../packages/base-formula-engine/src/AstNode/AstRootNode.ts
  var AstRootNode = class extends BaseAstNode {
    get nodeType() {
      return "Root" /* ROOT */;
    }
    execute() {
      const children = this.getChildren();
      const node = children[0];
      this.setValue(node.getValue());
    }
  };
  var AstRootNodeFactory = class extends BaseAstNodeFactory {
    get zIndex() {
      return NODE_ORDER_MAP.get("Root" /* ROOT */) || 100;
    }
    checkAndCreateNodeType(param) {
      if (!(param instanceof LexerNode)) {
        return false;
      }
      const token = param.getToken();
      if (token === DEFAULT_TOKEN_TYPE_ROOT) {
        return new AstRootNode(DEFAULT_TOKEN_TYPE_ROOT);
      }
      return false;
    }
  };
  FORMULA_AST_NODE_REGISTRY.add(new AstRootNodeFactory());

  // ../../packages/base-formula-engine/src/Basics/ObjectClassType.ts
  var ObjectClassType = class {
    isErrorObject() {
      return false;
    }
    isAsyncObject() {
      return false;
    }
    isReferenceObject() {
      return false;
    }
    isValueObject() {
      return false;
    }
  };

  // ../../packages/base-formula-engine/src/OtherObject/ErrorValueObject.ts
  var _ErrorValueObject = class extends ObjectClassType {
    constructor(_errorType) {
      super();
      this._errorType = _errorType;
    }
    getErrorType() {
      return this._errorType;
    }
    isErrorObject() {
      return true;
    }
    static create(errorType) {
      if (this.errorMap.has(errorType)) {
        return this.errorMap.get(errorType);
      } else {
        const errorValueObject = new _ErrorValueObject(errorType);
        this.errorMap.set(errorType, errorValueObject);
        return errorValueObject;
      }
    }
  };
  var ErrorValueObject = _ErrorValueObject;
  __publicField(ErrorValueObject, "errorMap", /* @__PURE__ */ new Map());

  // ../../packages/base-formula-engine/src/AstNode/ErrorNode.ts
  var ErrorNode = class extends BaseAstNode {
    get nodeType() {
      return "ErrorNode" /* ERROR */;
    }
    _errorValueObject;
    constructor(errorType) {
      super(errorType);
      this._errorValueObject = ErrorValueObject.create(errorType);
    }
    getValue() {
      return this._errorValueObject;
    }
    static create(errorType) {
      return new ErrorNode(errorType);
    }
  };

  // ../../packages/base-formula-engine/src/Functions/BaseFunction.ts
  var BaseFunction = class {
    get name() {
      return "";
    }
    isAsync() {
      return false;
    }
    isAddress() {
      return false;
    }
    calculate(...arg) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    checkArrayType(variant) {
      return variant.isReferenceObject() || variant.isValueObject() && variant.isArray();
    }
    static create() {
      if (this.functionMap.has(this.name)) {
        return this.functionMap.get(this.name);
      }
      return new this();
    }
  };
  __publicField(BaseFunction, "functionMap", /* @__PURE__ */ new Map());

  // ../../packages/base-formula-engine/src/Functions/meta/Compare.ts
  var FUNCTION_NAME = "COMPARE";
  var Compare = class extends BaseFunction {
    get name() {
      return FUNCTION_NAME;
    }
    _compareType;
    setCompareType(token) {
      this._compareType = token;
    }
    calculate(variant1, variant2) {
      if (variant1.isErrorObject() || variant2.isErrorObject()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      let result;
      if (this.checkArrayType(variant1) && this.checkArrayType(variant2)) {
        result = variant1.toArrayValueObject().compare(variant2.toArrayValueObject(), this._compareType);
      } else if (this.checkArrayType(variant1)) {
        result = variant1.toArrayValueObject().compare(variant2, this._compareType);
      } else if (this.checkArrayType(variant2)) {
        result = variant1.compare(variant2.toArrayValueObject(), this._compareType);
      } else {
        result = variant1.compare(variant2, this._compareType);
      }
      return result;
    }
  };
  FORMULA_FUNCTION_REGISTRY.add(FUNCTION_NAME, Compare.create());

  // ../../packages/base-formula-engine/src/Functions/meta/Divided.ts
  var FUNCTION_NAME2 = "DIVIDED";
  var Divided = class extends BaseFunction {
    get name() {
      return FUNCTION_NAME2;
    }
    calculate(variant1, variant2) {
      if (variant1.isErrorObject() || variant2.isErrorObject()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (variant2.getValue() === 0) {
        return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
      }
      let result;
      if (this.checkArrayType(variant1) && this.checkArrayType(variant2)) {
        result = variant1.toArrayValueObject().divided(variant2.toArrayValueObject());
      } else if (this.checkArrayType(variant1)) {
        result = variant1.toArrayValueObject().divided(variant2);
      } else if (this.checkArrayType(variant2)) {
        result = variant1.divided(variant2.toArrayValueObject());
      } else {
        result = variant1.divided(variant2);
      }
      return result;
    }
  };
  FORMULA_FUNCTION_REGISTRY.add(FUNCTION_NAME2, Divided.create());

  // ../../packages/base-formula-engine/src/Functions/meta/Minus.ts
  var FUNCTION_NAME3 = "MINUS";
  var Minus = class extends BaseFunction {
    get name() {
      return FUNCTION_NAME3;
    }
    calculate(variant1, variant2) {
      if (variant1.isErrorObject() || variant2.isErrorObject()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      return variant1.minus(variant2);
    }
  };
  FORMULA_FUNCTION_REGISTRY.add(FUNCTION_NAME3, Minus.create());

  // ../../packages/base-formula-engine/src/Functions/meta/Multiply.ts
  var FUNCTION_NAME4 = "MULTIPLY";
  var Multiply = class extends BaseFunction {
    get name() {
      return FUNCTION_NAME4;
    }
    calculate(variant1, variant2) {
      if (variant1.isErrorObject() || variant2.isErrorObject()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      let result;
      if (this.checkArrayType(variant1) && this.checkArrayType(variant2)) {
        result = variant1.toArrayValueObject().multiply(variant2.toArrayValueObject());
      } else if (this.checkArrayType(variant1)) {
        result = variant1.toArrayValueObject().multiply(variant2);
      } else if (this.checkArrayType(variant2)) {
        result = variant1.multiply(variant2.toArrayValueObject());
      } else {
        result = variant1.multiply(variant2);
      }
      return result;
    }
  };
  FORMULA_FUNCTION_REGISTRY.add(FUNCTION_NAME4, Multiply.create());

  // ../../packages/base-formula-engine/src/Functions/meta/Plus.ts
  var FUNCTION_NAME5 = "PLUS";
  var Plus = class extends BaseFunction {
    get name() {
      return FUNCTION_NAME5;
    }
    calculate(variant1, variant2) {
      if (variant1.isErrorObject() || variant2.isErrorObject()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      let result;
      if (this.checkArrayType(variant1) && this.checkArrayType(variant2)) {
        result = variant1.toArrayValueObject().plus(variant2.toArrayValueObject());
      } else if (this.checkArrayType(variant1)) {
        result = variant1.toArrayValueObject().plus(variant2);
      } else if (this.checkArrayType(variant2)) {
        result = variant1.plus(variant2.toArrayValueObject());
      } else {
        result = variant1.plus(variant2);
      }
      return result;
    }
  };
  FORMULA_FUNCTION_REGISTRY.add(FUNCTION_NAME5, Plus.create());

  // ../../packages/base-formula-engine/src/Functions/meta/Union.ts
  var FUNCTION_NAME6 = "UNION";
  var Union = class extends BaseFunction {
    get name() {
      return FUNCTION_NAME6;
    }
    _compareType;
    setCompareType(token) {
      this._compareType = token;
    }
    calculate(variant1, variant2) {
      if (variant1.isErrorObject() || variant2.isErrorObject()) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      if (!variant1.isReferenceObject() || !variant2.isReferenceObject()) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      variant1 = variant1;
      variant2 = variant2;
      if (variant1.isCell() && variant2.isCell()) {
        return variant1.unionBy(variant2);
      } else if (variant1.isRow() && variant2.isRow()) {
        return variant1.unionBy(variant2);
      } else if (variant1.isColumn() && variant2.isColumn()) {
        return variant1.unionBy(variant2);
      }
      return ErrorValueObject.create("#REF!" /* REF */);
    }
  };
  FORMULA_FUNCTION_REGISTRY.add(FUNCTION_NAME6, Union.create());

  // ../../packages/base-formula-engine/src/Basics/Calculate.ts
  function reverseCompareOperator(operator) {
    let result;
    switch (operator) {
      case "=" /* EQUALS */:
        result = "<>" /* NOT_EQUAL */;
        break;
      case ">" /* GREATER_THAN */:
        result = "<=" /* LESS_THAN_OR_EQUAL */;
        break;
      case ">=" /* GREATER_THAN_OR_EQUAL */:
        result = "<" /* LESS_THAN */;
        break;
      case "<" /* LESS_THAN */:
        result = ">=" /* GREATER_THAN_OR_EQUAL */;
        break;
      case "<=" /* LESS_THAN_OR_EQUAL */:
        result = ">" /* GREATER_THAN */;
        break;
      case "<>" /* NOT_EQUAL */:
        result = "=" /* EQUALS */;
        break;
    }
    return result;
  }
  function fromObjectToString(array) {
    return "";
  }

  // ../../packages/base-formula-engine/src/ValueObject/BaseValueObject.ts
  var BaseValueObject = class extends ObjectClassType {
    constructor(_rawValue) {
      super();
      this._rawValue = _rawValue;
    }
    isValueObject() {
      return true;
    }
    getValue() {
      return 0;
    }
    getArrayValue() {
      return [];
    }
    setValue(value) {
    }
    setArrayValue(value) {
    }
    isArray() {
      return false;
    }
    isString() {
      return false;
    }
    isNumber() {
      return false;
    }
    isBoolean() {
      return false;
    }
    isError() {
      return false;
    }
    getNegative() {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    getReciprocal() {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    plus(valueObject) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    minus(valueObject) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    multiply(valueObject) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    divided(valueObject) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    compare(valueObject, operator) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    concatenateFront(valueObject) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    concatenateBack(valueObject) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    plusBy(value) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    minusBy(value) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    multiplyBy(value) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    dividedBy(value) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    compareBy(value, operator) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    concatenate(value, concatenateType = 0 /* FRONT */) {
      let currentValue = this.getValue().toString();
      if (typeof value === "string") {
        if (concatenateType === 0 /* FRONT */) {
          currentValue = value + currentValue;
        } else {
          currentValue += value;
        }
      } else if (typeof value === "number") {
        if (concatenateType === 0 /* FRONT */) {
          currentValue = value.toString() + currentValue;
        } else {
          currentValue += value.toString();
        }
      } else if (typeof value === "boolean") {
        const booleanString = value ? "TRUE" : "FALSE";
        if (concatenateType === 0 /* FRONT */) {
          currentValue = booleanString + currentValue;
        } else {
          currentValue += booleanString;
        }
      }
      this.setValue(currentValue);
      return this;
    }
  };

  // ../../packages/base-formula-engine/src/ValueObject/BooleanValueObject.ts
  var BooleanValueObject = class extends BaseValueObject {
    _value;
    constructor(rawValue, isForce = false) {
      super(rawValue);
      if (isForce) {
        this._value = rawValue;
        return;
      }
      if (typeof rawValue === "boolean") {
        this._value = rawValue;
      } else if (typeof rawValue === "string") {
        const rawValueUpper = rawValue.toLocaleUpperCase();
        if (rawValueUpper === "TRUE" /* TRUE */) {
          this._value = true;
        } else if (rawValueUpper === "FALSE" /* FALSE */) {
          this._value = false;
        }
      } else {
        if (rawValue === 1) {
          this._value = true;
        } else {
          this._value = false;
        }
      }
    }
    _convertTonNumber() {
      const currentValue = this.getValue();
      let result = 0;
      if (currentValue) {
        result = 1;
      }
      return new NumberValueObject(result, true);
    }
    getValue() {
      return this._value;
    }
    isBoolean() {
      return true;
    }
    getNegative() {
      const currentValue = this.getValue();
      let result = 0;
      if (currentValue) {
        result = 1;
      }
      return new NumberValueObject(-result, true);
    }
    getReciprocal() {
      const currentValue = this.getValue();
      if (currentValue) {
        return new NumberValueObject(1, true);
      } else {
        return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
      }
    }
    plus(valueObject) {
      return this._convertTonNumber().plus(valueObject);
    }
    minus(valueObject) {
      return this._convertTonNumber().minus(valueObject);
    }
    multiply(valueObject) {
      return this._convertTonNumber().multiply(valueObject);
    }
    divided(valueObject) {
      return this._convertTonNumber().divided(valueObject);
    }
    compare(valueObject, operator) {
      return this._convertTonNumber().compare(valueObject, operator);
    }
    concatenateFront(valueObject) {
      return this._convertTonNumber().concatenateFront(valueObject);
    }
    concatenateBack(valueObject) {
      return this._convertTonNumber().concatenateBack(valueObject);
    }
  };

  // ../../packages/base-formula-engine/src/ValueObject/NumberValueObject.ts
  var NumberValueObject = class extends BaseValueObject {
    _value = 0;
    constructor(rawValue, isForce = false) {
      super(rawValue);
      if (isForce) {
        this._value = rawValue;
        return;
      }
      this._value = Number(rawValue);
    }
    getValue() {
      return this._value;
    }
    setValue(value) {
      this._value = value;
    }
    isNumber() {
      return true;
    }
    getNegative() {
      return new NumberValueObject(0).minus(this);
    }
    getReciprocal() {
      return new NumberValueObject(1).divided(this);
    }
    plus(valueObject) {
      if (valueObject.isArray()) {
        return valueObject.plus(this);
      }
      return this.plusBy(valueObject.getValue());
    }
    equalZero() {
      return this._value === 0;
    }
    minus(valueObject) {
      if (valueObject.isArray()) {
        const o4 = valueObject.getNegative();
        if (o4.isErrorObject()) {
          return o4;
        }
        return o4.plus(this);
      }
      return this.minusBy(valueObject.getValue());
    }
    multiply(valueObject) {
      if (valueObject.isArray()) {
        return valueObject.multiply(this);
      }
      return this.multiplyBy(valueObject.getValue());
    }
    divided(valueObject) {
      if (valueObject.isArray()) {
        const o4 = valueObject.getReciprocal();
        if (o4.isErrorObject()) {
          return o4;
        }
        return o4.multiply(this);
      }
      return this.dividedBy(valueObject.getValue());
    }
    concatenateFront(valueObject) {
      if (valueObject.isArray()) {
        return valueObject.concatenateBack(this);
      }
      return this.concatenate(valueObject.getValue(), 0 /* FRONT */);
    }
    concatenateBack(valueObject) {
      if (valueObject.isArray()) {
        return valueObject.concatenateFront(this);
      }
      return this.concatenate(valueObject.getValue(), 1 /* BACK */);
    }
    compare(valueObject, operator) {
      if (valueObject.isArray()) {
        const o4 = valueObject.getReciprocal();
        if (o4.isErrorObject()) {
          return o4;
        }
        return o4.compare(this, reverseCompareOperator(operator));
      }
      return this.compareBy(valueObject.getValue(), operator);
    }
    plusBy(value) {
      let currentValue = this.getValue();
      if (typeof value === "string") {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      } else if (typeof value === "number") {
        this.setValue(currentValue + value);
      } else if (typeof value === "boolean") {
        this.setValue(currentValue + (value ? 1 : 0));
      }
      return this;
    }
    minusBy(value) {
      let currentValue = this.getValue();
      if (typeof value === "string") {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      } else if (typeof value === "number") {
        this.setValue(currentValue - value);
      } else if (typeof value === "boolean") {
        this.setValue(currentValue - (value ? 1 : 0));
      }
      return this;
    }
    multiplyBy(value) {
      let currentValue = this.getValue();
      if (typeof value === "string") {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      } else if (typeof value === "number") {
        this.setValue(currentValue * value);
      } else if (typeof value === "boolean") {
        this.setValue(currentValue * (value ? 1 : 0));
      }
      return this;
    }
    dividedBy(value) {
      let currentValue = this.getValue();
      if (typeof value === "string") {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      } else if (typeof value === "number") {
        if (value === 0) {
          return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
        }
        this.setValue(currentValue / value);
      } else if (typeof value === "boolean") {
        if (value === false) {
          return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
        }
        this.setValue(currentValue / 1);
      }
      return this;
    }
    compareBy(value, operator) {
      let currentValue = this.getValue();
      let result = false;
      if (typeof value === "string") {
        switch (operator) {
          case "=" /* EQUALS */:
          case ">" /* GREATER_THAN */:
          case ">=" /* GREATER_THAN_OR_EQUAL */:
            result = false;
            break;
          case "<" /* LESS_THAN */:
          case "<=" /* LESS_THAN_OR_EQUAL */:
          case "<>" /* NOT_EQUAL */:
            result = true;
            break;
        }
      } else if (typeof value === "number") {
        switch (operator) {
          case "=" /* EQUALS */:
            result = currentValue === value;
            break;
          case ">" /* GREATER_THAN */:
            result = currentValue > value;
            break;
          case ">=" /* GREATER_THAN_OR_EQUAL */:
            result = currentValue >= value;
            break;
          case "<" /* LESS_THAN */:
            result = currentValue < value;
            break;
          case "<=" /* LESS_THAN_OR_EQUAL */:
            result = currentValue <= value;
            break;
          case "<>" /* NOT_EQUAL */:
            result = currentValue !== value;
            break;
        }
      } else if (typeof value === "boolean") {
        switch (operator) {
          case "=" /* EQUALS */:
          case ">" /* GREATER_THAN */:
          case ">=" /* GREATER_THAN_OR_EQUAL */:
            result = false;
            break;
          case "<" /* LESS_THAN */:
          case "<=" /* LESS_THAN_OR_EQUAL */:
          case "<>" /* NOT_EQUAL */:
            result = true;
            break;
        }
      }
      return new BooleanValueObject(result);
    }
  };

  // ../../packages/base-formula-engine/src/Functions/Count.ts
  var FUNCTION_NAME7 = "COUNT";
  var Count = class extends BaseFunction {
    get name() {
      return FUNCTION_NAME7;
    }
    calculate(...variants) {
      let accumulatorAll = new NumberValueObject(0);
      for (let i4 = 0; i4 < variants.length; i4++) {
        let variant = variants[i4];
        if (variant.isReferenceObject() || variant.isValueObject() && variant.isArray()) {
          variant.iterator((valueObject, row, column) => {
            if (!valueObject.isErrorObject() && !valueObject.isString()) {
              accumulatorAll = accumulatorAll.plusBy(1);
            }
          });
        } else if (!variant.isString()) {
          accumulatorAll = accumulatorAll.plusBy(1);
        }
      }
      return accumulatorAll;
    }
  };
  FORMULA_FUNCTION_REGISTRY.add(FUNCTION_NAME7, Count.create());

  // ../../packages/base-formula-engine/src/Functions/Sum.ts
  var FUNCTION_NAME8 = "SUM";
  var Sum = class extends BaseFunction {
    get name() {
      return FUNCTION_NAME8;
    }
    calculate(...variants) {
      let accumulatorAll = new NumberValueObject(0);
      for (let i4 = 0; i4 < variants.length; i4++) {
        let variant = variants[i4];
        if (variant.isErrorObject()) {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        if (variant.isReferenceObject() || variant.isValueObject() && variant.isArray()) {
          let isSkip = false;
          variant.iterator((valueObject, row, column) => {
            if (valueObject.isErrorObject()) {
              isSkip = true;
              return false;
            }
            accumulatorAll = accumulatorAll.plus(valueObject);
          });
          if (isSkip) {
            return ErrorValueObject.create("#VALUE!" /* VALUE */);
          }
        } else {
          accumulatorAll = accumulatorAll.plus(variant);
        }
      }
      return accumulatorAll;
    }
  };
  FORMULA_FUNCTION_REGISTRY.add(FUNCTION_NAME8, Sum.create());

  // ../../packages/base-formula-engine/src/Functions/Average.ts
  var FUNCTION_NAME9 = "AVERAGE";
  var Average = class extends BaseFunction {
    get name() {
      return FUNCTION_NAME9;
    }
    calculate(...variants) {
      const accumulatorSum = Sum.create().calculate(...variants);
      const accumulatorCount = Count.create().calculate(...variants);
      if (accumulatorSum.isErrorObject() || accumulatorCount.isErrorObject()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      return accumulatorSum.divided(accumulatorCount);
    }
  };
  FORMULA_FUNCTION_REGISTRY.add(FUNCTION_NAME9, Average.create());

  // ../../packages/base-formula-engine/src/Functions/Concatenate.ts
  var FUNCTION_NAME10 = "CONCATENATE";
  var Concatenate = class extends BaseFunction {
    get name() {
      return FUNCTION_NAME10;
    }
    calculate(numberVar, powerVar) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
  };
  FORMULA_FUNCTION_REGISTRY.add(FUNCTION_NAME10, Concatenate.create());

  // ../../packages/base-formula-engine/src/Functions/Max.ts
  var FUNCTION_NAME11 = "MAX";
  var Max = class extends BaseFunction {
    get name() {
      return FUNCTION_NAME11;
    }
    _validator(accumulatorAll, valueObject) {
      const validator = accumulatorAll.compare(valueObject, "<" /* LESS_THAN */);
      if (validator.getValue()) {
        accumulatorAll = valueObject;
      }
      return accumulatorAll;
    }
    calculate(...variants) {
      let accumulatorAll = new NumberValueObject(-Infinity);
      for (let i4 = 0; i4 < variants.length; i4++) {
        let variant = variants[i4];
        if (variant.isReferenceObject() || variant.isValueObject() && variant.isArray()) {
          variant.iterator((valueObject, row, column) => {
            if (!valueObject.isErrorObject() && !valueObject.isString()) {
              accumulatorAll = this._validator(accumulatorAll, valueObject);
            }
          });
        } else if (!variant.isString()) {
          accumulatorAll = this._validator(accumulatorAll, variant);
        }
      }
      return accumulatorAll;
    }
  };
  FORMULA_FUNCTION_REGISTRY.add(FUNCTION_NAME11, Max.create());

  // ../../packages/base-formula-engine/src/Functions/Min.ts
  var FUNCTION_NAME12 = "MIN";
  var Min = class extends BaseFunction {
    get name() {
      return FUNCTION_NAME12;
    }
    _validator(accumulatorAll, valueObject) {
      const validator = accumulatorAll.compare(valueObject, ">" /* GREATER_THAN */);
      if (validator.getValue()) {
        accumulatorAll = valueObject;
      }
      return accumulatorAll;
    }
    calculate(...variants) {
      let accumulatorAll = new NumberValueObject(Infinity);
      for (let i4 = 0; i4 < variants.length; i4++) {
        let variant = variants[i4];
        if (variant.isReferenceObject() || variant.isValueObject() && variant.isArray()) {
          variant.iterator((valueObject, row, column) => {
            if (!valueObject.isErrorObject() && !valueObject.isString()) {
              accumulatorAll = this._validator(accumulatorAll, valueObject);
            }
          });
        } else if (!variant.isString()) {
          accumulatorAll = this._validator(accumulatorAll, variant);
        }
      }
      return accumulatorAll;
    }
  };
  FORMULA_FUNCTION_REGISTRY.add(FUNCTION_NAME12, Min.create());

  // ../../packages/base-formula-engine/src/Functions/Power.ts
  var FUNCTION_NAME13 = "POWER";
  var Power = class extends BaseFunction {
    get name() {
      return FUNCTION_NAME13;
    }
    calculate(numberVar, powerVar) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
  };
  FORMULA_FUNCTION_REGISTRY.add(FUNCTION_NAME13, Power.create());

  // ../../packages/base-formula-engine/src/Basics/Regex.ts
  var UNIT_NAME_REGEX = `'?\\[((?![\\/?:"<>|*\\\\]).)*\\]`;
  var SHEET_NAME_REGEX = "((?![\\[\\]\\/?*\\\\]).)*!";
  var ABSOLUTE_SYMBOL = "$";
  var RANGE_SYMBOL = "\\s*?:\\s*?";
  var PROJECTION_SYMBOL = "@";
  var ARRAY_SYMBOL = "#";
  var SIMPLE_SINGLE_RANGE_REGEX = `\\${ABSOLUTE_SYMBOL}?[A-Za-z]+\\${ABSOLUTE_SYMBOL}?[0-9]+`;
  var REFERENCE_MULTIPLE_RANGE_REGEX = `^(${PROJECTION_SYMBOL})?(${UNIT_NAME_REGEX})?(${SHEET_NAME_REGEX})?${SIMPLE_SINGLE_RANGE_REGEX}${RANGE_SYMBOL}${SIMPLE_SINGLE_RANGE_REGEX}$`;
  var REFERENCE_SINGLE_RANGE_REGEX = `^(${UNIT_NAME_REGEX})?(${SHEET_NAME_REGEX})?\\s*?${SIMPLE_SINGLE_RANGE_REGEX}(${ARRAY_SYMBOL})?$`;
  var REFERENCE_REGEX_ROW = `^(${UNIT_NAME_REGEX})?(${SHEET_NAME_REGEX})?\\${ABSOLUTE_SYMBOL}?[0-9]+${RANGE_SYMBOL}\\${ABSOLUTE_SYMBOL}?[0-9]+$`;
  var REFERENCE_REGEX_COLUMN = `^(${UNIT_NAME_REGEX})?(${SHEET_NAME_REGEX})?\\${ABSOLUTE_SYMBOL}?[A-Za-z]+${RANGE_SYMBOL}\\${ABSOLUTE_SYMBOL}?[A-Za-z]+$`;
  var REFERENCE_REGEX_SINGLE_ROW = `^(${UNIT_NAME_REGEX})?(${SHEET_NAME_REGEX})?\\s*?\\${ABSOLUTE_SYMBOL}?[0-9]+$`;
  var REFERENCE_REGEX_SINGLE_COLUMN = `^(${UNIT_NAME_REGEX})?(${SHEET_NAME_REGEX})?\\s*?\\${ABSOLUTE_SYMBOL}?[A-Za-z]+$`;
  var TABLE_NAME_REGEX = `((?![~!@#$%^&*()_+<>?:,./;\u2019\uFF0C\u3002\u3001\u2018\uFF1A\u201C\u300A\u300B\uFF1F~\uFF01@#\uFFE5%\u2026\u2026\uFF08\uFF09\u3010\u3011\\[\\]\\/\\\\]).)+`;
  var TABLE_TITLE_REGEX = `\\[#.+\\]\\s*?,\\s*?`;
  var TABLE_CONTENT_REGEX = `\\[((?<!#).)*\\]`;
  var TABLE_MULTIPLE_COLUMN_REGEX = `${TABLE_CONTENT_REGEX}${RANGE_SYMBOL}${TABLE_CONTENT_REGEX}`;
  var REFERENCE_TABLE_ALL_COLUMN_REGEX = `^(${UNIT_NAME_REGEX})?${TABLE_NAME_REGEX}$`;
  var REFERENCE_TABLE_SINGLE_COLUMN_REGEX = `^(${UNIT_NAME_REGEX})?${TABLE_NAME_REGEX}(${TABLE_CONTENT_REGEX}|\\[${TABLE_TITLE_REGEX}${TABLE_CONTENT_REGEX}\\])+$`;
  var REFERENCE_TABLE_MULTIPLE_COLUMN_REGEX = `^(${UNIT_NAME_REGEX})?${TABLE_NAME_REGEX}(\\[${TABLE_MULTIPLE_COLUMN_REGEX}\\])?$|^${TABLE_NAME_REGEX}(\\[${TABLE_TITLE_REGEX}${TABLE_MULTIPLE_COLUMN_REGEX}\\])?$`;
  var $SUPER_TABLE_COLUMN_REGEX = /[.*?]/g;
  var $ARRAY_VALUE_REGEX = /{.*?}/g;

  // ../../packages/base-formula-engine/src/ValueObject/StringValueObject.ts
  var StringValueObject = class extends BaseValueObject {
    _value;
    constructor(rawValue, isForce = false) {
      super(rawValue);
      if (isForce) {
        this._value = rawValue;
        return;
      }
      let value = rawValue.toString();
      if (value.charAt(0) === '"' && value.charAt(value.length - 1) === '"') {
        value = value.slice(1, -1);
        value = value.replace(/""/g, '"');
      }
      this._value = value;
    }
    getValue() {
      return this._value;
    }
    isString() {
      return true;
    }
    concatenateFront(valueObject) {
      if (valueObject.isArray()) {
        return valueObject.concatenateBack(this);
      }
      return this.concatenate(valueObject.getValue(), 0 /* FRONT */);
    }
    concatenateBack(valueObject) {
      if (valueObject.isArray()) {
        return valueObject.concatenateFront(this);
      }
      return this.concatenate(valueObject.getValue(), 1 /* BACK */);
    }
    compare(valueObject, operator) {
      if (valueObject.isArray()) {
        const o4 = valueObject.getReciprocal();
        if (o4.isErrorObject()) {
          return o4;
        }
        return o4.compare(this, reverseCompareOperator(operator));
      }
      return this.compareBy(valueObject.getValue(), operator);
    }
    compareBy(value, operator) {
      let currentValue = this.getValue();
      let result = false;
      if (typeof value === "string") {
        switch (operator) {
          case "=" /* EQUALS */:
            result = currentValue === value;
            break;
          case ">" /* GREATER_THAN */:
            result = currentValue > value;
            break;
          case ">=" /* GREATER_THAN_OR_EQUAL */:
            result = currentValue >= value;
            break;
          case "<" /* LESS_THAN */:
            result = currentValue < value;
            break;
          case "<=" /* LESS_THAN_OR_EQUAL */:
            result = currentValue <= value;
            break;
          case "<>" /* NOT_EQUAL */:
            result = currentValue !== value;
            break;
        }
      } else if (typeof value === "number") {
        switch (operator) {
          case "=" /* EQUALS */:
          case ">" /* GREATER_THAN */:
          case ">=" /* GREATER_THAN_OR_EQUAL */:
            result = true;
            break;
          case "<" /* LESS_THAN */:
          case "<=" /* LESS_THAN_OR_EQUAL */:
          case "<>" /* NOT_EQUAL */:
            result = false;
            break;
        }
      } else if (typeof value === "boolean") {
        switch (operator) {
          case "=" /* EQUALS */:
          case ">" /* GREATER_THAN */:
          case ">=" /* GREATER_THAN_OR_EQUAL */:
            result = false;
            break;
          case "<" /* LESS_THAN */:
          case "<=" /* LESS_THAN_OR_EQUAL */:
          case "<>" /* NOT_EQUAL */:
            result = true;
            break;
        }
      }
      return new BooleanValueObject(result);
    }
  };

  // ../../packages/base-formula-engine/src/ValueObject/ValueObjectFactory.ts
  var ValueObjectFactory = class {
    static create(rawValue) {
      if (typeof rawValue === "boolean") {
        return new BooleanValueObject(rawValue, true);
      } else if (typeof rawValue === "string") {
        const rawValueUpper = rawValue.toLocaleUpperCase();
        if (rawValueUpper === "TRUE" /* TRUE */ || rawValueUpper === "FALSE" /* FALSE */) {
          return new BooleanValueObject(rawValueUpper);
        } else if (!isNaN(Number(rawValue))) {
          return new NumberValueObject(rawValue);
        } else if ($ARRAY_VALUE_REGEX.test(rawValue)) {
          return new ArrayValueObject(rawValue);
        } else {
          return new StringValueObject(rawValue);
        }
      } else if (typeof rawValue === "number") {
        return new NumberValueObject(rawValue, true);
      }
      return ErrorValueObject.create("#NA!" /* NA */);
    }
  };

  // ../../packages/base-formula-engine/src/ValueObject/ArrayValueObject.ts
  var ArrayValueObject = class extends BaseValueObject {
    _value;
    _rowCount;
    _columnCount;
    _formatValue(rawValue) {
      if (!(rawValue instanceof String)) {
        rawValue = rawValue;
        this._rowCount = rawValue.rowCount;
        this._columnCount = rawValue.columnCount;
        return rawValue.calculateValueList;
      }
      rawValue = rawValue.slice(1, -1);
      const rowArray = rawValue.split(";");
      const rowArrayCount = rowArray.length;
      const result = [];
      let maxColumnCount = 0;
      for (let r4 = 0; r4 < rowArrayCount; r4++) {
        const columnRaw = rowArray[r4];
        const columnArray = columnRaw.split(",");
        const columnArrayCount = columnArray.length;
        if (maxColumnCount < columnArrayCount) {
          maxColumnCount = columnArrayCount;
        }
        const row = [];
        for (let c4 = 0; c4 < columnArrayCount; c4++) {
          const cellRaw = columnArray[c4];
          row.push(ValueObjectFactory.create(cellRaw));
        }
        result.push(row);
      }
      this._rowCount = rowArrayCount;
      this._columnCount = maxColumnCount;
      return result;
    }
    constructor(rawValue) {
      if (rawValue instanceof String) {
        super(rawValue);
      } else {
        const rawString = fromObjectToString(rawValue);
        super(rawString);
      }
      this._value = this._formatValue(rawValue);
    }
    getRowCount() {
      return this._rowCount;
    }
    setRowCount(rowCount) {
      this._rowCount = rowCount;
    }
    getColumnCount() {
      return this._columnCount;
    }
    setColumnCount(columnCount) {
      this._columnCount = columnCount;
    }
    getArrayValue() {
      return this._value;
    }
    setArrayValue(value) {
      this._value = value;
    }
    isArray() {
      return true;
    }
    getRangePosition() {
      let startRow = 0;
      let rowCount = this.getRowCount();
      let startColumn = 0;
      let columnCount = this.getColumnCount();
      return {
        startRow,
        endRow: rowCount - 1,
        startColumn,
        endColumn: columnCount - 1
      };
    }
    iterator(callback) {
      const { startRow, endRow, startColumn, endColumn } = this.getRangePosition();
      const valueList = this.getArrayValue();
      for (let r4 = startRow; r4 <= endRow; r4++) {
        for (let c4 = startColumn; c4 <= endColumn; c4++) {
          if (callback(valueList[r4][c4], r4, c4) === false) {
            return;
          }
        }
      }
    }
    _batchOperator(valueObject, batchOperatorType, operator) {
      if (valueObject.isArray()) {
        let rowCount2 = valueObject.getRowCount();
        let columnCount2 = valueObject.getColumnCount();
        if (rowCount2 < this._rowCount) {
          rowCount2 = this._rowCount;
        }
        if (columnCount2 < this._columnCount) {
          columnCount2 = this._columnCount;
        }
        const result2 = [];
        const valueObjectList = valueObject.getArrayValue();
        for (let r4 = 0; r4 < rowCount2; r4++) {
          const rowList = [];
          for (let c4 = 0; c4 < columnCount2; c4++) {
            const currentValue = this._value?.[r4]?.[c4];
            const opValue = valueObjectList?.[r4]?.[c4];
            if (currentValue && opValue) {
              if (currentValue.isErrorObject() || opValue.isErrorObject()) {
                rowList[c4] = ErrorValueObject.create("#VALUE!" /* VALUE */);
              } else {
                switch (batchOperatorType) {
                  case 1 /* PLUS */:
                    rowList[c4] = currentValue.plus(opValue);
                    break;
                  case 0 /* MINUS */:
                    rowList[c4] = currentValue.minus(opValue);
                    break;
                  case 2 /* MULTIPLY */:
                    rowList[c4] = currentValue.multiply(opValue);
                    break;
                  case 3 /* DIVIDED */:
                    rowList[c4] = currentValue.divided(opValue);
                    break;
                  case 4 /* COMPARE */:
                    if (!operator) {
                      rowList[c4] = ErrorValueObject.create("#VALUE!" /* VALUE */);
                    } else {
                      rowList[c4] = currentValue.compare(opValue, operator);
                    }
                    break;
                  case 5 /* CONCATENATE_FRONT */:
                    rowList[c4] = currentValue.concatenateFront(opValue);
                    break;
                  case 6 /* CONCATENATE_BACK */:
                    rowList[c4] = currentValue.concatenateBack(opValue);
                    break;
                }
              }
            } else if (currentValue) {
              rowList[c4] = currentValue;
            } else if (opValue) {
              rowList[c4] = opValue;
            } else {
              rowList[c4] = ErrorValueObject.create("#VALUE!" /* VALUE */);
            }
          }
          result2.push(rowList);
        }
        this.setArrayValue(result2);
        this.setRowCount(rowCount2);
        this.setColumnCount(columnCount2);
        return this;
      }
      let rowCount = this._rowCount;
      let columnCount = this._columnCount;
      const result = [];
      for (let r4 = 0; r4 < rowCount; r4++) {
        const rowList = [];
        for (let c4 = 0; c4 < columnCount; c4++) {
          const currentValue = this._value?.[r4]?.[c4];
          if (currentValue && valueObject) {
            if (currentValue.isErrorObject() || valueObject.isErrorObject()) {
              rowList[c4] = ErrorValueObject.create("#VALUE!" /* VALUE */);
            } else {
              switch (batchOperatorType) {
                case 1 /* PLUS */:
                  rowList[c4] = currentValue.plus(valueObject);
                  break;
                case 0 /* MINUS */:
                  rowList[c4] = currentValue.minus(valueObject);
                  break;
                case 2 /* MULTIPLY */:
                  rowList[c4] = currentValue.multiply(valueObject);
                  break;
                case 3 /* DIVIDED */:
                  rowList[c4] = currentValue.divided(valueObject);
                  break;
                case 4 /* COMPARE */:
                  if (!operator) {
                    rowList[c4] = ErrorValueObject.create("#VALUE!" /* VALUE */);
                  } else {
                    rowList[c4] = currentValue.compare(valueObject, operator);
                  }
                  break;
                case 5 /* CONCATENATE_FRONT */:
                  rowList[c4] = currentValue.concatenateFront(valueObject);
                  break;
                case 6 /* CONCATENATE_BACK */:
                  rowList[c4] = currentValue.concatenateBack(valueObject);
                  break;
              }
            }
          } else if (currentValue) {
            rowList[c4] = currentValue;
          } else if (valueObject) {
            rowList[c4] = valueObject;
          } else {
            rowList[c4] = ErrorValueObject.create("#VALUE!" /* VALUE */);
          }
        }
        result.push(rowList);
      }
      this.setArrayValue(result);
      this.setRowCount(rowCount);
      this.setColumnCount(columnCount);
      return this;
    }
    plus(valueObject) {
      return this._batchOperator(valueObject, 1 /* PLUS */);
    }
    minus(valueObject) {
      return this._batchOperator(valueObject, 0 /* MINUS */);
    }
    multiply(valueObject) {
      return this._batchOperator(valueObject, 2 /* MULTIPLY */);
    }
    divided(valueObject) {
      return this._batchOperator(valueObject, 3 /* DIVIDED */);
    }
    compare(valueObject, operator) {
      return this._batchOperator(valueObject, 4 /* COMPARE */, operator);
    }
    concatenateFront(valueObject) {
      return this._batchOperator(valueObject, 5 /* CONCATENATE_FRONT */);
    }
    concatenateBack(valueObject) {
      return this._batchOperator(valueObject, 6 /* CONCATENATE_BACK */);
    }
  };

  // ../../packages/base-formula-engine/src/ReferenceObject/BaseReferenceObject.ts
  var BaseReferenceObject = class extends ObjectClassType {
    constructor(_token) {
      super();
      this._token = _token;
    }
    _forcedSheetId;
    _forcedSheetName;
    _defaultSheetId;
    _rangeData;
    _unitData;
    _rowCount = 0;
    _columnCount = 0;
    _defaultUnitId;
    _forcedUnitId;
    _runtimeData;
    getRangePosition() {
      let startRow = this._rangeData.startRow;
      let endRow = this._rangeData.endRow;
      let startColumn = this._rangeData.startColumn;
      let endColumn = this._rangeData.endColumn;
      if (startRow === -1) {
        startRow = 0;
      }
      if (startColumn === -1) {
        startColumn = 0;
      }
      if (endRow === -1) {
        endRow = this._rowCount - 1;
      }
      if (endColumn === -1) {
        endColumn = this._columnCount - 1;
      }
      return {
        startRow,
        endRow,
        startColumn,
        endColumn
      };
    }
    isReferenceObject() {
      return true;
    }
    iterator(callback) {
      const { startRow, endRow, startColumn, endColumn } = this.getRangePosition();
      for (let r4 = startRow; r4 <= endRow; r4++) {
        for (let c4 = startColumn; c4 <= endColumn; c4++) {
          const cell = this.getCellData(r4, c4);
          let result = false;
          if (!cell) {
            result = callback(new NumberValueObject(0, true), r4, c4);
            continue;
          }
          const resultObjectValue = this.getCellValueObject(cell);
          result = callback(resultObjectValue, r4, c4);
          if (result === false) {
            return;
          }
        }
      }
    }
    getRangeData() {
      return this._rangeData;
    }
    setRangeData(rangeData) {
      this._rangeData = rangeData;
    }
    getUnitId() {
      if (this._forcedUnitId) {
        return this._forcedUnitId;
      }
      return this._defaultUnitId;
    }
    getSheetId() {
      if (this._forcedSheetId) {
        return this._forcedSheetId;
      }
      return this._defaultSheetId;
    }
    setForcedUnitIdDirect(unitId) {
      this._forcedUnitId = unitId;
    }
    getForcedUnitId() {
      return this._forcedUnitId;
    }
    setForcedSheetId(sheetNameMap) {
      this._forcedSheetId = sheetNameMap[this._forcedSheetName];
    }
    setForcedSheetIdDirect(sheetId) {
      this._forcedSheetId = sheetId;
    }
    getForcedSheetId() {
      return this._forcedSheetId;
    }
    setForcedSheetName(sheetName) {
      this._forcedSheetName = sheetName;
    }
    getForcedSheetName() {
      return this._forcedSheetName;
    }
    setDefaultSheetId(sheetId) {
      this._defaultSheetId = sheetId;
    }
    getDefaultSheetId() {
      return this._defaultSheetId;
    }
    setDefaultUnitId(sheetId) {
      this._defaultUnitId = sheetId;
    }
    getDefaultUnitId() {
      return this._defaultUnitId;
    }
    getUnitData() {
      return this._unitData;
    }
    setUnitData(unitData) {
      this._unitData = unitData;
    }
    getRuntimeData() {
      return this._runtimeData;
    }
    setRuntimeData(runtimeData) {
      this._runtimeData = runtimeData;
    }
    getRowCount() {
      return this._rowCount;
    }
    setRowCount(rowCount) {
      this._rowCount = rowCount;
    }
    getColumnCount() {
      return this._columnCount;
    }
    setColumnCount(columnCount) {
      this._columnCount = columnCount;
    }
    isCell() {
      return false;
    }
    isColumn() {
      return false;
    }
    isRow() {
      return false;
    }
    isRange() {
      return false;
    }
    isTable() {
      return false;
    }
    unionBy(referenceObject) {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    unionRange(rangeData1, rangeData2) {
      return {
        startRow: -1,
        startColumn: -1,
        endRow: -1,
        endColumn: -1
      };
    }
    getCellValueObject(cell) {
      const value = cell.v || 0;
      if (ERROR_TYPE_SET.has(value)) {
        return ErrorValueObject.create(value);
      } else if (cell.t === 2 /* BOOLEAN */) {
        return new BooleanValueObject(value);
      } else if (cell.t === 3 /* FORCE_STRING */ || cell.t === 0 /* STRING */) {
        return new StringValueObject(value);
      } else {
        return new NumberValueObject(value);
      }
    }
    getCellByRow(row) {
      return this.getCellByPosition(row);
    }
    getCellByColumn(column) {
      return this.getCellByPosition(void 0, column);
    }
    getCurrentActiveSheetData() {
      return this._unitData[this.getUnitId()][this.getSheetId()];
    }
    getCurrentRuntimeSheetData() {
      return this._runtimeData?.[this.getUnitId()]?.[this.getSheetId()];
    }
    getCellData(row, column) {
      const activeSheetData = this.getCurrentActiveSheetData();
      const activeRuntimeData = this.getCurrentRuntimeSheetData();
      return activeRuntimeData?.getValue(row, column) || activeSheetData.getValue(row, column);
    }
    getCellByPosition(row, column) {
      if (!row) {
        row = this._rangeData.startRow;
      }
      if (!column) {
        column = this._rangeData.startColumn;
      }
      const cell = this.getCellData(row, column);
      if (!cell) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      return this.getCellValueObject(cell);
    }
    toArrayValueObject() {
      const { startRow, endRow, startColumn, endColumn } = this.getRangePosition();
      const rowSize = endRow - startRow + 1;
      const columnSize = endColumn - startColumn + 1;
      const arrayValueList = new Array(rowSize);
      this.iterator((valueObject, rowIndex, columnIndex) => {
        const row = rowIndex - startRow;
        const column = columnIndex - startColumn;
        if (!arrayValueList[row]) {
          arrayValueList[row] = new Array(columnSize);
        }
        arrayValueList[row][column] = valueObject;
      });
      const arrayValueObject = {
        calculateValueList: arrayValueList,
        rowCount: arrayValueList.length,
        columnCount: arrayValueList[0].length
      };
      return new ArrayValueObject(arrayValueObject);
    }
    toUnitRange() {
      return {
        rangeData: this._rangeData,
        sheetId: this.getSheetId(),
        unitId: this.getUnitId()
      };
    }
  };

  // ../../packages/base-formula-engine/src/ReferenceObject/RangeReferenceObject.ts
  var RangeReferenceObject = class extends BaseReferenceObject {
    constructor(rangeData, forcedSheetId, forcedUnitId) {
      super("");
      this.setRangeData(rangeData);
      if (forcedSheetId) {
        this.setForcedSheetIdDirect(forcedSheetId);
      }
      if (forcedUnitId) {
        this.setForcedUnitIdDirect(forcedUnitId);
      }
    }
    isRange() {
      return true;
    }
  };

  // ../../packages/base-formula-engine/src/ReferenceObject/CellReferenceObject.ts
  var CellReferenceObject = class extends BaseReferenceObject {
    constructor(token) {
      super(token);
      const grid = referenceToGrid(token);
      this.setForcedSheetName(grid.sheetName);
      this.setRangeData(grid.rangeData);
    }
    _createRange(newRangeData) {
      const rangeReferenceObject = new RangeReferenceObject(newRangeData, this.getForcedSheetId(), this.getForcedUnitId());
      rangeReferenceObject.setUnitData(this.getUnitData());
      rangeReferenceObject.setDefaultSheetId(this.getDefaultSheetId());
      rangeReferenceObject.setRowCount(this.getRowCount());
      rangeReferenceObject.setColumnCount(this.getColumnCount());
      rangeReferenceObject.setDefaultUnitId(this.getDefaultUnitId());
      rangeReferenceObject.setRuntimeData(this.getRuntimeData());
      const forceId = this.getForcedUnitId();
      if (forceId != null) {
        rangeReferenceObject.setForcedSheetIdDirect(this.getForcedUnitId());
      }
      return rangeReferenceObject;
    }
    isCell() {
      return true;
    }
    unionBy(referenceObject) {
      if (!referenceObject.isCell()) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      const cellReferenceObject = referenceObject;
      const newRangeData = this.unionRange(this.getRangeData(), cellReferenceObject.getRangeData());
      return this._createRange(newRangeData);
    }
    unionRange(rangeData1, rangeData2) {
      const startRow1 = rangeData1.startRow;
      const startColumn1 = rangeData1.startColumn;
      const startRow2 = rangeData2.startRow;
      const startColumn2 = rangeData2.startColumn;
      let rangeData = {
        startRow: -1,
        startColumn: -1,
        endRow: -1,
        endColumn: -1
      };
      if (startRow1 > startRow2) {
        rangeData.startRow = startRow2;
        rangeData.endRow = startRow1;
      } else {
        rangeData.startRow = startRow1;
        rangeData.endRow = startRow2;
      }
      if (startColumn1 > startColumn2) {
        rangeData.startColumn = startColumn2;
        rangeData.endColumn = startColumn1;
      } else {
        rangeData.startColumn = startColumn1;
        rangeData.endColumn = startColumn2;
      }
      return rangeData;
    }
  };

  // ../../packages/base-formula-engine/src/Functions/Offset.ts
  var FUNCTION_NAME14 = "OFFSET";
  var Offset = class extends BaseFunction {
    get name() {
      return FUNCTION_NAME14;
    }
    calculate(reference, rows, columns, height, width) {
      return new CellReferenceObject("A5");
    }
  };
  FORMULA_FUNCTION_REGISTRY.add(FUNCTION_NAME14, Offset.create());

  // ../../packages/base-formula-engine/src/Functions/Indirect.ts
  var FUNCTION_NAME15 = "INDIRECT";
  var Indirect = class extends BaseFunction {
    get name() {
      return FUNCTION_NAME15;
    }
    calculate(refText, a1) {
      return new CellReferenceObject("A5");
    }
  };
  FORMULA_FUNCTION_REGISTRY.add(FUNCTION_NAME15, Indirect.create());

  // ../../packages/base-formula-engine/src/Basics/ParserDataLoader.ts
  var ParserDataLoader = class {
    _astNodeFactoryArray = [];
    _functionMap = /* @__PURE__ */ new Map();
    // 18.5.1.2 table (Table)
    _tableMap = /* @__PURE__ */ new Map();
    // 18.5.1.2 table (Table) for I18N
    _tableOptionMap = /* @__PURE__ */ new Map();
    // 18.2.6 definedNames (Defined Names)
    _definedNameMap = /* @__PURE__ */ new Map();
    _lambdaRuntime;
    _initialNode() {
      this.registerNode(...FORMULA_AST_NODE_REGISTRY.getData().sort(sortRules));
    }
    _initialFunction() {
      this._functionMap = FORMULA_FUNCTION_REGISTRY.getData();
    }
    registerNode(...nodeFactories) {
      this._astNodeFactoryArray.push(...nodeFactories);
    }
    registerFunction(...functions) {
      for (let i4 = 0; i4 < functions.length; i4++) {
        const func = functions[i4];
        this._functionMap.set(func.name, func);
      }
    }
    registerTable(tableName, reference) {
      this._tableMap.set(tableName, reference);
    }
    registerDefinedName(name, reference) {
      this._definedNameMap.set(name, reference);
    }
    registerTableOptionMap(tableOption, tableOptionType) {
      this._tableOptionMap.set(tableOption, tableOptionType);
    }
    getTableOptionMap() {
      return this._tableOptionMap;
    }
    getFunctionMap() {
      return this._functionMap;
    }
    getAstNodeFactoryArray() {
      return this._astNodeFactoryArray;
    }
    getTableMap() {
      return this._tableMap;
    }
    getDefinedNameMap() {
      return this._definedNameMap;
    }
    getExecutor(functionToken) {
      return this._functionMap.get(functionToken);
    }
    getLambdaRuntime() {
      return this._lambdaRuntime;
    }
    setLambdaRuntime(lambdaRuntime) {
      this._lambdaRuntime = lambdaRuntime;
    }
    hasLambdaRuntime() {
      return this._lambdaRuntime != null;
    }
    hasExecutor(functionToken) {
      return this._functionMap.has(functionToken);
    }
    initialize() {
      this._initialNode();
      this._initialFunction();
    }
  };

  // ../../packages/base-formula-engine/src/AstNode/PrefixNode.ts
  var PrefixNode = class extends BaseAstNode {
    constructor(_operatorString, _functionExecutor) {
      super(_operatorString);
      this._operatorString = _operatorString;
      this._functionExecutor = _functionExecutor;
    }
    get nodeType() {
      return "PrefixNode" /* PREFIX */;
    }
    _handlerAT(value, interpreterDatasetConfig) {
      if (!value.isReferenceObject()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const currentValue = value;
      if (currentValue.isCell()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const currentRow = interpreterDatasetConfig?.currentRow || 0;
      const currentColumn = interpreterDatasetConfig?.currentColumn || 0;
      if (currentValue.isRow()) {
        return currentValue.getCellByColumn(currentColumn);
      } else if (currentValue.isColumn()) {
        return currentValue.getCellByRow(currentRow);
      } else if (currentValue.isRange()) {
        return currentValue.getCellByPosition();
      } else if (currentValue.isTable()) {
        return currentValue.getCellByPosition();
      }
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    execute(interpreterDatasetConfig) {
      const children = this.getChildren();
      const value = children[0].getValue();
      let result;
      if (this._operatorString === "-" /* MINUS */) {
        result = this._functionExecutor.calculate(new NumberValueObject(0), value);
      } else if (this._operatorString === "@" /* AT */) {
        result = this._handlerAT(value, interpreterDatasetConfig);
      } else {
        result = ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      this.setValue(result);
    }
  };
  var PrefixNodeFactory = class extends BaseAstNodeFactory {
    get zIndex() {
      return NODE_ORDER_MAP.get("PrefixNode" /* PREFIX */) || 100;
    }
    checkAndCreateNodeType(param, parserDataLoader) {
      if (!(param instanceof LexerNode)) {
        return false;
      }
      const token = param.getToken();
      const tokenTrim = token.trim();
      if (tokenTrim.charAt(0) === '"' && tokenTrim.charAt(tokenTrim.length - 1) === '"') {
        return false;
      }
      let functionName = "";
      if (tokenTrim === "-" /* MINUS */) {
        functionName = "MINUS";
      } else if (tokenTrim === "@" /* AT */) {
        return new PrefixNode(tokenTrim);
      } else {
        return false;
      }
      const functionExecutor = parserDataLoader.getExecutor(functionName);
      if (!functionExecutor) {
        console.error("No function " + token);
        return ErrorNode.create("#NAME!" /* NAME */);
      }
      return new PrefixNode(tokenTrim, functionExecutor);
    }
  };
  FORMULA_AST_NODE_REGISTRY.add(new PrefixNodeFactory());

  // ../../packages/base-formula-engine/src/AstNode/FunctionNode.ts
  var FunctionNode = class extends BaseAstNode {
    constructor(token, _functionExecutor) {
      super(token);
      this._functionExecutor = _functionExecutor;
      if (this._functionExecutor.isAsync()) {
        this.setAsync();
      }
      if (this._functionExecutor.isAddress()) {
        this.setAddress();
      }
    }
    get nodeType() {
      return "FunctionNode" /* FUNCTION */;
    }
    async executeAsync() {
      const variants = [];
      const children = this.getChildren();
      const childrenCount = children.length;
      for (let i4 = 0; i4 < childrenCount; i4++) {
        variants.push(children[i4].getValue());
      }
      const resultVariant = this._functionExecutor.calculate(...variants);
      if (resultVariant.isAsyncObject()) {
        this.setValue(await resultVariant.getValue());
      } else {
        this.setValue(resultVariant);
      }
      return Promise.resolve(0 /* SUCCESS */);
    }
    execute() {
      const variants = [];
      const children = this.getChildren();
      const childrenCount = children.length;
      for (let i4 = 0; i4 < childrenCount; i4++) {
        variants.push(children[i4].getValue());
      }
      const resultVariant = this._functionExecutor.calculate(...variants);
      this.setValue(resultVariant);
    }
  };
  var FunctionNodeFactory = class extends BaseAstNodeFactory {
    get zIndex() {
      return NODE_ORDER_MAP.get("FunctionNode" /* FUNCTION */) || 100;
    }
    create(token, parserDataLoader) {
      const functionExecutor = parserDataLoader.getExecutor(token);
      if (!functionExecutor) {
        console.error("No function " + token);
        return ErrorNode.create("#NAME!" /* NAME */);
      }
      return new FunctionNode(token, functionExecutor);
    }
    checkAndCreateNodeType(param, parserDataLoader) {
      if (typeof param === "string") {
        return false;
      }
      const token = param.getToken();
      let tokenTrim = token.trim().toUpperCase();
      let minusPrefixNode;
      let atPrefixNode;
      const prefix = tokenTrim.slice(0, 2);
      let sliceLength = 0;
      if (new RegExp("-" /* MINUS */, "g").test(prefix)) {
        const functionExecutor = parserDataLoader.getExecutor("MINUS");
        minusPrefixNode = new PrefixNode("-" /* MINUS */, functionExecutor);
        sliceLength++;
      }
      if (new RegExp("@" /* AT */, "g").test(prefix)) {
        atPrefixNode = new PrefixNode("@" /* AT */);
        if (minusPrefixNode) {
          atPrefixNode.setParent(minusPrefixNode);
        }
        sliceLength++;
      }
      if (sliceLength > 0) {
        tokenTrim = tokenTrim.slice(sliceLength);
      }
      if (parserDataLoader?.hasExecutor(tokenTrim)) {
        const functionNode = this.create(tokenTrim, parserDataLoader);
        if (atPrefixNode) {
          functionNode.setParent(atPrefixNode);
        } else if (minusPrefixNode) {
          functionNode.setParent(minusPrefixNode);
        }
        return functionNode;
      }
      return false;
    }
  };
  FORMULA_AST_NODE_REGISTRY.add(new FunctionNodeFactory());

  // ../../packages/base-formula-engine/src/AstNode/LambdaNode.ts
  var LAMBDA_TOKEN = "LAMBDA";
  var LambdaNode = class extends BaseAstNode {
    constructor(token, _lambdaId) {
      super(token);
      this._lambdaId = _lambdaId;
    }
    get nodeType() {
      return "LambdaNode" /* LAMBDA */;
    }
    getLambdaId() {
      return this._lambdaId;
    }
    execute() {
      const children = this.getChildren();
      const childrenCount = children.length;
      this.setValue(children[childrenCount - 1].getValue());
    }
  };
  var LambdaNodeFactory = class extends BaseAstNodeFactory {
    get zIndex() {
      return NODE_ORDER_MAP.get("LambdaNode" /* LAMBDA */) || 100;
    }
    _updateLambdaStatement(functionStatementNode, lambdaId, currentLambdaPrivacyVar) {
      this._updateTree(functionStatementNode, lambdaId, currentLambdaPrivacyVar);
    }
    _updateTree(functionStatementNode, lambdaId, currentLambdaPrivacyVar) {
      const children = functionStatementNode.getChildren();
      const childrenCount = children.length;
      for (let i4 = 0; i4 < childrenCount; i4++) {
        const node = children[i4];
        if (node instanceof LexerNode) {
          this._updateTree(node, lambdaId, currentLambdaPrivacyVar);
        } else {
          const token = node.trim();
          if (currentLambdaPrivacyVar.has(token)) {
            const newNode = new LexerNode();
            newNode.setToken(DEFAULT_TOKEN_TYPE_LAMBDA_RUNTIME_PARAMETER);
            newNode.setLambdaId(lambdaId);
            newNode.setLambdaPrivacyVar(currentLambdaPrivacyVar);
            newNode.setLambdaParameter(token);
            children[i4] = newNode;
          }
        }
      }
    }
    create(param, parserDataLoader) {
      const children = param.getChildren();
      const lambdaVar = children[0];
      const parameterArray = children.slice(1, -1);
      const functionStatementNode = children[children.length - 1];
      if (!(lambdaVar instanceof LexerNode && functionStatementNode instanceof LexerNode)) {
        return ErrorNode.create("#NAME!" /* NAME */);
      }
      if (lambdaVar.getToken() !== DEFAULT_TOKEN_TYPE_LAMBDA_PARAMETER) {
        return ErrorNode.create("#NAME!" /* NAME */);
      }
      const lambdaVarChildren = lambdaVar.getChildren();
      if (parameterArray.length !== lambdaVarChildren.length) {
        return ErrorNode.create("#VALUE!" /* VALUE */);
      }
      const lambdaId = Tools.generateRandomId(8);
      const lambdaRuntime = parserDataLoader.getLambdaRuntime();
      const currentLambdaPrivacyVar = /* @__PURE__ */ new Map();
      for (let i4 = 0; i4 < parameterArray.length; i4++) {
        const parameter = parameterArray[i4];
        if (parameter instanceof LexerNode) {
          const variant = parameter.getChildren()[0];
          currentLambdaPrivacyVar.set(variant, null);
        } else {
          return ErrorNode.create("#VALUE!" /* VALUE */);
        }
      }
      lambdaRuntime.registerLambdaPrivacyVar(lambdaId, currentLambdaPrivacyVar);
      this._updateLambdaStatement(functionStatementNode, lambdaId, currentLambdaPrivacyVar);
      return new LambdaNode(param.getToken(), lambdaId);
    }
    checkAndCreateNodeType(param, parserDataLoader) {
      if (!(param instanceof LexerNode)) {
        return false;
      }
      const token = param.getToken().trim().toUpperCase();
      if (token !== LAMBDA_TOKEN) {
        return false;
      }
      return this.create(param, parserDataLoader);
    }
  };
  FORMULA_AST_NODE_REGISTRY.add(new LambdaNodeFactory());

  // ../../packages/base-formula-engine/src/AstNode/LambdaParameterNode.ts
  var LambdaParameterNode = class extends BaseAstNode {
    constructor(token, _lambdaParameter, _currentLambdaPrivacyVar) {
      super(token);
      this._lambdaParameter = _lambdaParameter;
      this._currentLambdaPrivacyVar = _currentLambdaPrivacyVar;
    }
    get nodeType() {
      return "LambdaNodeParameter" /* LAMBDA_PARAMETER */;
    }
    execute() {
      const node = this._currentLambdaPrivacyVar.get(this._lambdaParameter);
      if (!node) {
        this.setValue(ErrorValueObject.create("#SPILL!" /* SPILL */));
      } else {
        this.setValue(node.getValue());
      }
    }
  };
  var LambdaParameterNodeFactory = class extends BaseAstNodeFactory {
    get zIndex() {
      return NODE_ORDER_MAP.get("LambdaNodeParameter" /* LAMBDA_PARAMETER */) || 100;
    }
    create(param) {
      const lambdaId = param.getLambdaId();
      const currentLambdaPrivacyVar = param.getLambdaPrivacyVar();
      const lambdaParameter = param.getLambdaParameter();
      if (!currentLambdaPrivacyVar) {
        return new ErrorNode("#SPILL!" /* SPILL */);
      }
      return new LambdaParameterNode(param.getToken(), lambdaParameter, currentLambdaPrivacyVar);
    }
    checkAndCreateNodeType(param) {
      if (!(param instanceof LexerNode)) {
        return false;
      }
      const token = param.getToken().trim();
      if (token !== DEFAULT_TOKEN_TYPE_LAMBDA_RUNTIME_PARAMETER) {
        return false;
      }
      return this.create(param);
    }
  };
  FORMULA_AST_NODE_REGISTRY.add(new LambdaParameterNodeFactory());

  // ../../packages/base-formula-engine/src/AstNode/OperatorNode.ts
  var PLUS_EXECUTOR_NAME = "PLUS";
  var MINUS_EXECUTOR_NAME = "MINUS";
  var MULTIPLY_EXECUTOR_NAME = "MULTIPLY";
  var DIVIDED_EXECUTOR_NAME = "DIVIDED";
  var CONCATENATE_EXECUTOR_NAME = "CONCATENATE";
  var POWER_EXECUTOR_NAME = "POWER";
  var COMPARE_EXECUTOR_NAME = "COMPARE";
  var OperatorNode = class extends BaseAstNode {
    constructor(_operatorString, _functionExecutor) {
      super(_operatorString);
      this._operatorString = _operatorString;
      this._functionExecutor = _functionExecutor;
    }
    get nodeType() {
      return "OperatorNode" /* OPERATOR */;
    }
    execute() {
      const children = this.getChildren();
      if (this._functionExecutor.name === COMPARE_EXECUTOR_NAME) {
        this._functionExecutor.setCompareType(this.getToken());
      }
      this.setValue(this._functionExecutor.calculate(children[0].getValue(), children[1].getValue()));
    }
  };
  var OperatorNodeFactory = class extends BaseAstNodeFactory {
    get zIndex() {
      return NODE_ORDER_MAP.get("OperatorNode" /* OPERATOR */) || 100;
    }
    create(param, parserDataLoader) {
      let functionName = "";
      const tokenTrim = param;
      if (tokenTrim === "+" /* PLUS */) {
        functionName = PLUS_EXECUTOR_NAME;
      } else if (tokenTrim === "-" /* MINUS */) {
        functionName = MINUS_EXECUTOR_NAME;
      } else if (tokenTrim === "*" /* MULTIPLY */) {
        functionName = MULTIPLY_EXECUTOR_NAME;
      } else if (tokenTrim === "/" /* DIVIDED */) {
        functionName = DIVIDED_EXECUTOR_NAME;
      } else if (tokenTrim === "&" /* CONCATENATE */) {
        functionName = CONCATENATE_EXECUTOR_NAME;
      } else if (tokenTrim === "^" /* POWER */) {
        functionName = POWER_EXECUTOR_NAME;
      } else if (OPERATOR_TOKEN_COMPARE_SET.has(tokenTrim)) {
        functionName = COMPARE_EXECUTOR_NAME;
      }
      const functionExecutor = parserDataLoader.getExecutor(functionName);
      if (!functionExecutor) {
        console.error("No function " + param);
        return ErrorNode.create("#NAME!" /* NAME */);
      }
      return new OperatorNode(tokenTrim, functionExecutor);
    }
    checkAndCreateNodeType(param, parserDataLoader) {
      if (param instanceof LexerNode) {
        return false;
      }
      const tokenTrim = param.trim();
      if (tokenTrim.charAt(0) === '"' && tokenTrim.charAt(tokenTrim.length - 1) === '"') {
        return false;
      }
      if (OPERATOR_TOKEN_SET.has(tokenTrim)) {
        return this.create(tokenTrim, parserDataLoader);
      }
      return false;
    }
  };
  FORMULA_AST_NODE_REGISTRY.add(new OperatorNodeFactory());

  // ../../packages/base-formula-engine/src/ReferenceObject/RowReferenceObject.ts
  var RowReferenceObject = class extends BaseReferenceObject {
    constructor(token) {
      super(token);
      const grid = referenceToGrid(token);
      this.setForcedSheetName(grid.sheetName);
      const rangeData = {
        startColumn: -1,
        startRow: grid.rangeData.startRow,
        endColumn: -1,
        endRow: -1
      };
      this.setRangeData(rangeData);
    }
    isRow() {
      return true;
    }
    unionBy(referenceObject) {
      if (!referenceObject.isRow()) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      const rowReferenceObject = referenceObject;
      if (rowReferenceObject.getForcedSheetName() !== void 0) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      const currentRangeData = this.getRangeData();
      if (currentRangeData.endRow !== -1) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      const newRow = rowReferenceObject.getRangeData().startRow;
      const row = currentRangeData.startRow;
      if (newRow > row) {
        currentRangeData.endRow = newRow;
      } else {
        currentRangeData.startRow = newRow;
        currentRangeData.endRow = row;
      }
      return this;
    }
  };

  // ../../packages/base-formula-engine/src/ReferenceObject/ColumnReferenceObject.ts
  var ColumnReferenceObject = class extends BaseReferenceObject {
    constructor(token) {
      super(token);
      const grid = referenceToGrid(token);
      this.setForcedSheetName(grid.sheetName);
      const rangeData = {
        startColumn: grid.rangeData.startColumn,
        startRow: -1,
        endColumn: -1,
        endRow: -1
      };
      this.setRangeData(rangeData);
    }
    isColumn() {
      return true;
    }
    unionBy(referenceObject) {
      if (!referenceObject.isColumn()) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      const columnReferenceObject = referenceObject;
      if (columnReferenceObject.getForcedSheetName() !== void 0) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      const currentRangeData = this.getRangeData();
      if (currentRangeData.endColumn !== -1) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      const newColumn = columnReferenceObject.getRangeData().startColumn;
      const column = currentRangeData.startColumn;
      if (newColumn > column) {
        currentRangeData.endColumn = newColumn;
      } else {
        currentRangeData.startColumn = newColumn;
        currentRangeData.endColumn = column;
      }
      return this;
    }
  };

  // ../../packages/base-formula-engine/src/ReferenceObject/TableReferenceObject.ts
  var TableReferenceObject = class extends BaseReferenceObject {
    constructor(token, _tableData, _columnDataString, tableOptionMap) {
      super(token);
      this._tableData = _tableData;
      this._columnDataString = _columnDataString;
      const sheetId = this._tableData.sheetId;
      const rangeData = this._tableData.rangeData;
      const titleMap = this._tableData.titleMap;
      this.setForcedSheetIdDirect(sheetId);
      const columnData = this._stringToColumnData(this._columnDataString, titleMap, tableOptionMap);
      const startColumn = columnData.startColumn;
      const endColumn = columnData.endColumn;
      const type = columnData.type;
      let startRow = -1;
      let endRow = -1;
      const tableStartRow = rangeData.startRow;
      const tableEndRow = rangeData.startColumn;
      if (type === "#All" /* ALL */) {
        startRow = tableStartRow;
        endRow = tableEndRow;
      } else if (type === "#Data" /* DATA */) {
        startRow = tableStartRow + 1;
        endRow = tableEndRow;
      } else if (type === "#Headers" /* HEADERS */) {
        startRow = tableStartRow;
        endRow = tableStartRow;
      } else if (type === "#Totals" /* TOTALS */) {
        startRow = tableEndRow;
        endRow = tableEndRow;
      }
      this.setRangeData({
        startColumn,
        endColumn,
        startRow,
        endRow
      });
    }
    _stringToColumnData(columnDataString, titleMap, tableOptionMap) {
      columnDataString = columnDataString.substring(1, -1);
      const commaIndex = columnDataString.indexOf("," /* COMMA */);
      let startColumn = -1;
      let endColumn = -1;
      let type = "#All" /* ALL */;
      if (commaIndex === -1) {
        const data = this._columnHandler(columnDataString, titleMap);
        startColumn = data.startColumn;
        endColumn = data.endColumn;
      } else {
        const rowString = columnDataString.substring(0, commaIndex).substring(1, -1);
        const columnString = columnDataString.substring(commaIndex + 1);
        const data = this._columnHandler(columnString, titleMap, true);
        startColumn = data.startColumn;
        endColumn = data.endColumn;
        type = tableOptionMap.get(rowString);
        if (!type) {
          type = "#All" /* ALL */;
        }
      }
      return {
        startColumn,
        endColumn,
        type
      };
    }
    _columnHandler(rightString, titleMap, isSingle = false) {
      let startColumn = -1;
      let endColumn = -1;
      const colonIndex = rightString.indexOf(":" /* COLON */);
      if ($SUPER_TABLE_COLUMN_REGEX.test(rightString)) {
        const startColumnString = rightString.substring(0, colonIndex).substring(1, -1);
        const endColumnString = rightString.substring(colonIndex + 1).substring(1, -1);
        startColumn = titleMap[startColumnString];
        endColumn = titleMap[endColumnString];
      } else {
        if (isSingle) {
          rightString = rightString.substring(1, -1);
        }
        startColumn = titleMap[rightString];
        endColumn = startColumn;
      }
      return {
        startColumn,
        endColumn
      };
    }
    isTable() {
      return true;
    }
  };

  // ../../packages/base-formula-engine/src/AstNode/ReferenceNode.ts
  var ReferenceNode = class extends BaseAstNode {
    constructor(_operatorString, _referenceObject) {
      super(_operatorString);
      this._operatorString = _operatorString;
      this._referenceObject = _referenceObject;
    }
    get nodeType() {
      return "ReferenceNode" /* REFERENCE */;
    }
    execute(interpreterCalculateProps, runtimeData) {
      const props = interpreterCalculateProps;
      if (props) {
        this._referenceObject.setUnitData(props.unitData);
        this._referenceObject.setDefaultSheetId(props.currentSheetId);
        this._referenceObject.setForcedSheetId(props.sheetNameMap);
        this._referenceObject.setRowCount(props.rowCount);
        this._referenceObject.setColumnCount(props.columnCount);
        this._referenceObject.setDefaultUnitId(props.currentUnitId);
      }
      if (runtimeData) {
        this._referenceObject.setRuntimeData(runtimeData);
      }
      this.setValue(this._referenceObject);
    }
  };
  var ReferenceNodeFactory = class extends BaseAstNodeFactory {
    get zIndex() {
      return NODE_ORDER_MAP.get("ReferenceNode" /* REFERENCE */) || 100;
    }
    checkAndCreateNodeType(param, parserDataLoader) {
      let isLexerNode = false;
      let tokenTrim;
      if (param instanceof LexerNode) {
        isLexerNode = true;
        tokenTrim = param.getToken().trim();
      } else {
        tokenTrim = param.trim();
      }
      if (!isLexerNode && tokenTrim.charAt(0) === '"' && tokenTrim.charAt(tokenTrim.length - 1) === '"') {
        return false;
      }
      if (new RegExp(REFERENCE_SINGLE_RANGE_REGEX).test(tokenTrim)) {
        return new ReferenceNode(tokenTrim, new CellReferenceObject(tokenTrim));
      }
      if (isLexerNode && new RegExp(REFERENCE_REGEX_SINGLE_ROW).test(tokenTrim)) {
        return new ReferenceNode(tokenTrim, new RowReferenceObject(tokenTrim));
      }
      if (isLexerNode && new RegExp(REFERENCE_REGEX_SINGLE_COLUMN).test(tokenTrim)) {
        return new ReferenceNode(tokenTrim, new ColumnReferenceObject(tokenTrim));
      }
      const nameMap = parserDataLoader.getDefinedNameMap();
      if (!isLexerNode && nameMap.has(tokenTrim)) {
        const nameString = nameMap.get(tokenTrim);
        const lexerTreeMaker = new LexerTreeMaker(nameString);
        const lexerNode = lexerTreeMaker.treeMaker();
        lexerTreeMaker.suffixExpressionHandler(lexerNode);
        return new ErrorNode("#VALUE!" /* VALUE */);
      }
      const tableMap = parserDataLoader.getTableMap();
      const $regex = $SUPER_TABLE_COLUMN_REGEX;
      const tableName = tokenTrim.replace($regex, "");
      if (!isLexerNode && tableMap.has(tableName)) {
        const columnResult = $regex.exec(tokenTrim);
        let columnDataString = "";
        if (columnResult) {
          columnDataString = columnResult[0];
        }
        const tableData = tableMap.get(tableName);
        const tableOption = parserDataLoader.getTableOptionMap();
        return new ReferenceNode(tokenTrim, new TableReferenceObject(tokenTrim, tableData, columnDataString, tableOption));
      }
      return false;
    }
  };
  FORMULA_AST_NODE_REGISTRY.add(new ReferenceNodeFactory());

  // ../../packages/base-formula-engine/src/AstNode/SuffixNode.ts
  var SuffixNode = class extends BaseAstNode {
    constructor(_operatorString, _functionExecutor) {
      super(_operatorString);
      this._operatorString = _operatorString;
      this._functionExecutor = _functionExecutor;
    }
    get nodeType() {
      return "SuffixNode" /* SUFFIX */;
    }
    _handlerPound(value, interpreterDatasetConfig) {
      if (!value.isReferenceObject()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (!value.isCell()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const cellValue = value;
      const rangeData = cellValue.getRangeData();
      const unitId = cellValue.getUnitId();
      const sheetId = cellValue.getSheetId();
      const formulaData = interpreterDatasetConfig?.formulaData;
      const formulaString = formulaData?.[unitId]?.[sheetId]?.[rangeData.startRow]?.[rangeData.startColumn]?.formula;
      if (!formulaString) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const lexerTreeMaker = new LexerTreeMaker(formulaString);
      const lexerNode = lexerTreeMaker.treeMaker();
      lexerTreeMaker.suffixExpressionHandler(lexerNode);
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    execute(interpreterCalculateProps) {
      const children = this.getChildren();
      const value = children[0].getValue();
      let result;
      if (this._operatorString === "%" /* PERCENTAGE */) {
        result = this._functionExecutor.calculate(value, new NumberValueObject(100));
      } else if (this._operatorString === "#" /* POUND */) {
        result = this._handlerPound(value, interpreterCalculateProps);
      } else {
        result = ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      this.setValue(result);
    }
  };
  var SuffixNodeFactory = class extends BaseAstNodeFactory {
    get zIndex() {
      return NODE_ORDER_MAP.get("SuffixNode" /* SUFFIX */) || 100;
    }
    checkAndCreateNodeType(param, parserDataLoader) {
      if (!(param instanceof LexerNode)) {
        return false;
      }
      const tokenTrim = param.getToken().trim();
      if (tokenTrim.charAt(0) === '"' && tokenTrim.charAt(tokenTrim.length - 1) === '"') {
        return false;
      }
      let functionName = "";
      if (tokenTrim === "%" /* PERCENTAGE */) {
        functionName = "DIVIDED";
      } else if (tokenTrim === "#" /* POUND */) {
        return new SuffixNode(tokenTrim);
      } else {
        return false;
      }
      const functionExecutor = parserDataLoader.getExecutor(functionName);
      if (!functionExecutor) {
        console.error("No function " + param);
        return ErrorNode.create("#NAME!" /* NAME */);
      }
      return new SuffixNode(tokenTrim, functionExecutor);
    }
  };
  FORMULA_AST_NODE_REGISTRY.add(new SuffixNodeFactory());

  // ../../packages/base-formula-engine/src/AstNode/UnionNode.ts
  var UNION_EXECUTOR_NAME = "UNION";
  var UnionNode = class extends BaseAstNode {
    constructor(_operatorString, _functionExecutor) {
      super(_operatorString);
      this._operatorString = _operatorString;
      this._functionExecutor = _functionExecutor;
    }
    get nodeType() {
      return "UnionNode" /* UNION */;
    }
    execute() {
      const children = this.getChildren();
      const leftNode = children[0].getValue();
      const rightNode = children[1].getValue();
      let result;
      if (this._operatorString === ":" /* COLON */) {
        result = this._functionExecutor.calculate(leftNode, rightNode);
      } else {
        result = ErrorValueObject.create("#NAME!" /* NAME */);
      }
      this.setValue(result);
    }
  };
  var UnionNodeFactory = class extends BaseAstNodeFactory {
    get zIndex() {
      return NODE_ORDER_MAP.get("UnionNode" /* UNION */) || 100;
    }
    create(param, parserDataLoader) {
      const functionExecutor = parserDataLoader.getExecutor(UNION_EXECUTOR_NAME);
      if (!functionExecutor) {
        console.error("No function " + param);
        return ErrorNode.create("#NAME!" /* NAME */);
      }
      return new UnionNode(param, functionExecutor);
    }
    checkAndCreateNodeType(param, parserDataLoader) {
      if (!(param instanceof LexerNode)) {
        return false;
      }
      const token = param.getToken();
      const tokenTrim = token.trim();
      if (tokenTrim.charAt(0) === '"' && tokenTrim.charAt(tokenTrim.length - 1) === '"') {
        return false;
      }
      if (tokenTrim !== ":" /* COLON */) {
        return false;
      }
      return this.create(tokenTrim, parserDataLoader);
    }
  };
  FORMULA_AST_NODE_REGISTRY.add(new UnionNodeFactory());

  // ../../packages/base-formula-engine/src/AstNode/ValueNode.ts
  var ValueNode = class extends BaseAstNode {
    constructor(_operatorString) {
      super(_operatorString);
      this._operatorString = _operatorString;
    }
    get nodeType() {
      return "ValueNode" /* VALUE */;
    }
    execute() {
      this.setValue(ValueObjectFactory.create(this._operatorString));
    }
  };
  var ValueNodeFactory = class extends BaseAstNodeFactory {
    get zIndex() {
      return NODE_ORDER_MAP.get("ValueNode" /* VALUE */) || 100;
    }
    _checkValueNode(token) {
      if (isNaN(Number(token))) {
        const tokenTrim = token.trim();
        const startToken = tokenTrim.charAt(0);
        const endToken = tokenTrim.charAt(tokenTrim.length - 1);
        if (startToken === '"' && endToken === '"') {
          return this.create(tokenTrim);
        } else if (startToken === "{" && endToken === "}") {
          return this.create(tokenTrim);
        } else if (tokenTrim === "TRUE" /* TRUE */ || tokenTrim === "FALSE" /* FALSE */) {
          return this.create(tokenTrim);
        }
      } else {
        return this.create(token);
      }
      return false;
    }
    create(param) {
      return new ValueNode(param);
    }
    checkAndCreateNodeType(param) {
      if (param instanceof LexerNode) {
        return false;
      }
      return this._checkValueNode(param);
    }
  };
  FORMULA_AST_NODE_REGISTRY.add(new ValueNodeFactory());

  // ../../packages/base-formula-engine/src/Basics/LambdaRuntime.ts
  var LambdaRuntime = class {
    // lambdaId: { key: BaseAstNode }
    _lambdaPrivacyVar = /* @__PURE__ */ new Map();
    registerLambdaPrivacyVar(lambdaId, lambdaVar) {
      this._lambdaPrivacyVar.set(lambdaId, lambdaVar);
    }
    getCurrentPrivacyVar(lambdaId) {
      return this._lambdaPrivacyVar.get(lambdaId);
    }
  };

  // ../../packages/base-formula-engine/src/Analysis/Parser.ts
  var _AstTreeMaker = class {
    _parserDataLoader = new ParserDataLoader();
    _astNodeFactoryList;
    parse(lexerNode) {
      this._astNodeFactoryList = FORMULA_AST_NODE_REGISTRY.getData();
      this._parserDataLoader.setLambdaRuntime(new LambdaRuntime());
      const astNode = new AstRootNode(DEFAULT_TOKEN_TYPE_ROOT);
      const node = this._parse(lexerNode, astNode);
      return node;
    }
    _lambdaParameterHandler(lexerNode, parent) {
      const lambdaId = parent.getLambdaId();
      const parentAstNode = new AstRootNode(DEFAULT_TOKEN_TYPE_ROOT);
      const lambdaRuntime = this._parserDataLoader.getLambdaRuntime();
      const currentLambdaPrivacyVar = lambdaRuntime.getCurrentPrivacyVar(lambdaId);
      if (!currentLambdaPrivacyVar) {
        return false;
      }
      const currentLambdaPrivacyVarKeys = [...currentLambdaPrivacyVar.keys()];
      const children = lexerNode.getChildren();
      const childrenCount = children.length;
      for (let i4 = 0; i4 < childrenCount; i4++) {
        const item = children[i4];
        let astNode = false;
        if (item instanceof LexerNode) {
          astNode = this._parse(item, parentAstNode);
        } else {
          return false;
        }
      }
      const parentChildren = parentAstNode.getChildren();
      const parentChildrenCount = parentChildren.length;
      for (let i4 = 0; i4 < parentChildrenCount; i4++) {
        const item = parentChildren[i4];
        currentLambdaPrivacyVar.set(currentLambdaPrivacyVarKeys[i4], item);
      }
      parentAstNode.setParent(parent);
      return parent;
    }
    _getTopParent(node) {
      let parent = node;
      while (parent.getParent()) {
        parent = parent.getParent();
        console.log(parent);
      }
      return parent;
    }
    _parse(lexerNode, parent) {
      const children = lexerNode.getChildren();
      const childrenCount = children.length;
      const calculateStack = [];
      let currentAstNode = false;
      if (lexerNode.getToken() === DEFAULT_TOKEN_TYPE_PARAMETER) {
        currentAstNode = parent;
      } else {
        if (lexerNode.getToken() === DEFAULT_TOKEN_TYPE_LAMBDA_PARAMETER) {
          let resultNode = this._lambdaParameterHandler(lexerNode, parent);
          if (resultNode === false) {
            resultNode = ErrorNode.create("#ERROR!" /* ERROR */);
          }
          return resultNode;
        }
        currentAstNode = this._checkAstNode(lexerNode);
        if (currentAstNode === false) {
          return ErrorNode.create("#ERROR!" /* ERROR */);
        }
      }
      for (let i4 = 0; i4 < childrenCount; i4++) {
        if (currentAstNode.nodeType === "LambdaNode" /* LAMBDA */ && parent.nodeType !== "LambdaNode" /* LAMBDA */ && i4 !== 0 && i4 !== childrenCount - 1) {
          continue;
        }
        const item = children[i4];
        let astNode = false;
        if (item instanceof LexerNode) {
          astNode = this._parse(item, currentAstNode);
          if (astNode === currentAstNode) {
            continue;
          }
        } else {
          astNode = this._checkAstNode(item);
        }
        if (astNode === false) {
          return ErrorNode.create("#ERROR!" /* ERROR */);
        }
        astNode = this._getTopParent(astNode);
        switch (astNode.nodeType) {
          case "ErrorNode" /* ERROR */:
            return astNode;
          case "FunctionNode" /* FUNCTION */:
            calculateStack.push(astNode);
            break;
          case "LambdaNode" /* LAMBDA */:
            calculateStack.push(astNode);
            break;
          case "LambdaNodeParameter" /* LAMBDA_PARAMETER */:
            calculateStack.push(astNode);
            break;
          case "OperatorNode" /* OPERATOR */:
            const parameterNode1 = calculateStack.pop();
            const parameterNode2 = calculateStack.pop();
            if (parameterNode2) {
              parameterNode2.setParent(astNode);
            } else {
              return ErrorNode.create("#ERROR!" /* ERROR */);
            }
            if (parameterNode1) {
              parameterNode1.setParent(astNode);
            } else {
              return ErrorNode.create("#ERROR!" /* ERROR */);
            }
            calculateStack.push(astNode);
            break;
          case "ReferenceNode" /* REFERENCE */:
            calculateStack.push(astNode);
            break;
          case "Root" /* ROOT */:
            calculateStack.push(astNode);
            break;
          case "UnionNode" /* UNION */:
            calculateStack.push(astNode);
            break;
          case "ValueNode" /* VALUE */:
            calculateStack.push(astNode);
            break;
          case "PrefixNode" /* PREFIX */:
            calculateStack.push(astNode);
            break;
          case "SuffixNode" /* SUFFIX */:
            calculateStack.push(astNode);
            break;
        }
      }
      const calculateStackCount = calculateStack.length;
      for (let i4 = 0; i4 < calculateStackCount; i4++) {
        const item = calculateStack[i4];
        item.setParent(currentAstNode);
      }
      return currentAstNode;
    }
    _checkAstNode(item) {
      let astNode = false;
      const astNodeFactoryListCount = this._astNodeFactoryList.length;
      for (let x4 = 0; x4 < astNodeFactoryListCount; x4++) {
        const astNodeFactory = this._astNodeFactoryList[x4];
        astNode = astNodeFactory.checkAndCreateNodeType(item, this._parserDataLoader);
        if (astNode !== false) {
          break;
        }
      }
      return astNode;
    }
    _findTopNode() {
    }
    getDataLoader() {
      return this._parserDataLoader;
    }
    static create() {
      if (!this.maker) {
        this.maker = new _AstTreeMaker();
        this.maker._parserDataLoader.initialize();
      }
      return this.maker;
    }
  };
  var AstTreeMaker = _AstTreeMaker;
  __publicField(AstTreeMaker, "maker");

  // ../../packages/base-formula-engine/src/Interpreter/Interpreter.ts
  var Interpreter = class {
    constructor(_interpreterDatasetConfig) {
      this._interpreterDatasetConfig = _interpreterDatasetConfig;
    }
    _runtimeData = {};
    _unitArrayFormulaData = {};
    _checkAsyncNode(node, resultList) {
      const children = node.getChildren();
      const childrenCount = children.length;
      for (let i4 = 0; i4 < childrenCount; i4++) {
        const item = children[i4];
        resultList.push(item.isAsync());
        this._checkAsyncNode(item, resultList);
      }
    }
    async _executeAsync(node) {
      const children = node.getChildren();
      const childrenCount = children.length;
      for (let i4 = 0; i4 < childrenCount; i4++) {
        const item = children[i4];
        this._executeAsync(item);
      }
      if (node.nodeType === "FunctionNode" /* FUNCTION */ && node.isAsync()) {
        await node.executeAsync(this._interpreterDatasetConfig);
      } else {
        node.execute(this._interpreterDatasetConfig, this._runtimeData);
      }
      return Promise.resolve(0 /* SUCCESS */);
    }
    _execute(node) {
      const children = node.getChildren();
      const childrenCount = children.length;
      for (let i4 = 0; i4 < childrenCount; i4++) {
        const item = children[i4];
        this._execute(item);
      }
      node.execute(this._interpreterDatasetConfig, this._runtimeData);
      return 0 /* SUCCESS */;
    }
    _objectValueToCellValue(objectValue) {
      if (objectValue.isErrorObject()) {
        return {
          v: objectValue.getErrorType(),
          t: 0 /* STRING */
        };
      } else if (objectValue.isValueObject()) {
        const vo = objectValue;
        const v4 = vo.getValue();
        if (vo.isNumber()) {
          return {
            v: v4,
            t: 1 /* NUMBER */
          };
        } else if (vo.isBoolean()) {
          return {
            v: v4,
            t: 2 /* BOOLEAN */
          };
        } else {
          return {
            v: v4,
            t: 0 /* STRING */
          };
        }
      }
    }
    async executeAsync(node) {
      if (!node) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      await this._executeAsync(node);
      const value = node.getValue();
      return Promise.resolve(value);
    }
    execute(node) {
      if (!node) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      this._execute(node);
      return node.getValue();
    }
    executePreCalculateNode(node) {
      node.execute(this._interpreterDatasetConfig, this._runtimeData);
      return node.getValue();
    }
    checkAsyncNode(node) {
      const result = [];
      this._checkAsyncNode(node, result);
      for (let i4 = 0, len = result.length; i4 < len; i4++) {
        const item = result[i4];
        if (item === true) {
          return true;
        }
      }
      return false;
    }
    setRuntimeData(row, column, sheetId, unitId, functionVariant) {
      if (this._runtimeData[unitId] === void 0) {
        this._runtimeData[unitId] = {};
      }
      const unitData = this._runtimeData[unitId];
      if (unitData[sheetId] === void 0) {
        unitData[sheetId] = new ObjectMatrix();
      }
      if (this._unitArrayFormulaData[unitId] === void 0) {
        this._unitArrayFormulaData[unitId] = {};
      }
      const arrayFormulaData = this._unitArrayFormulaData[unitId];
      if (arrayFormulaData[sheetId] === void 0) {
        arrayFormulaData[sheetId] = new ObjectMatrix();
      }
      const sheetData = unitData[sheetId];
      const arrayData = arrayFormulaData[sheetId];
      if (functionVariant.isReferenceObject() || functionVariant.isValueObject() && functionVariant.isArray()) {
        const objectValueRefOrArray = functionVariant;
        const { startRow, startColumn, endRow, endColumn } = objectValueRefOrArray.getRangePosition();
        objectValueRefOrArray.iterator((valueObject, rowIndex, columnIndex) => {
          sheetData.setValue(rowIndex - startRow + row, columnIndex - startColumn + column, this._objectValueToCellValue(valueObject));
        });
        arrayData.setValue(row, column, {
          startRow: row,
          startColumn: column,
          endRow: endRow - startRow + 1 + row,
          endColumn: endColumn - startColumn + 1 + column
        });
      } else {
        sheetData.setValue(row, column, this._objectValueToCellValue(functionVariant));
      }
    }
    getSheetData(unitId) {
      return this._runtimeData[unitId];
    }
    getSheetArrayFormula(unitId) {
      return this._unitArrayFormulaData[unitId];
    }
    getUnitData() {
      return this._runtimeData;
    }
    getUnitArrayFormula() {
      return this._unitArrayFormulaData;
    }
    setProps(interpreterDatasetConfig) {
      this._interpreterDatasetConfig = interpreterDatasetConfig;
    }
    setCurrentPosition(row, column, sheetId, unitId) {
      if (!this._interpreterDatasetConfig) {
        return;
      }
      this._interpreterDatasetConfig.currentRow = row;
      this._interpreterDatasetConfig.currentColumn = column;
      this._interpreterDatasetConfig.currentSheetId = sheetId;
      this._interpreterDatasetConfig.currentUnitId = unitId;
    }
    // static interpreter: Interpreter;
    static create(interpreterDatasetConfig) {
      return new Interpreter(interpreterDatasetConfig);
    }
  };

  // ../../packages/base-formula-engine/src/Basics/CacheLRU.ts
  var FORMULA_AST_CACHE_LRU_COUNT = 1e5;
  var FormulaAstLRU = class {
    _cache = new LRUMap(FORMULA_AST_CACHE_LRU_COUNT);
    _hash(formulaString) {
      return hashAlgorithm(formulaString);
    }
    set(formulaString, node) {
      const hash = this._hash(formulaString);
      this._cache.set(hash, node);
    }
    get(formulaString) {
      const hash = this._hash(formulaString);
      return this._cache.get(hash);
    }
  };
  var FormulaASTCache = new FormulaAstLRU();

  // ../../packages/base-formula-engine/src/Analysis/Tools.ts
  function generateAstNode(formulaString) {
    let astNode = FormulaASTCache.get(formulaString);
    if (astNode) {
      return astNode;
    }
    const lexerTreeMaker = new LexerTreeMaker(formulaString);
    const lexerNode = lexerTreeMaker.treeMaker();
    lexerTreeMaker.suffixExpressionHandler(lexerNode);
    const astTreeMaker = AstTreeMaker.create();
    astNode = astTreeMaker.parse(lexerNode);
    FormulaASTCache.set(formulaString, astNode);
    return astNode;
  }

  // ../../packages/base-formula-engine/src/Dependency/DependencyTree.ts
  var FormulaDependencyTree = class {
    node;
    children = [];
    parents = [];
    _state = 0 /* DEFAULT */;
    formula;
    row;
    column;
    sheetId;
    unitId;
    rangeList = [];
    _pushParent(tree) {
      this.parents.push(tree);
    }
    setAdded() {
      this._state = 1 /* ADDED */;
    }
    isAdded() {
      return this._state === 1 /* ADDED */;
    }
    setSkip() {
      this._state = 2 /* SKIP */;
    }
    isSkip() {
      return this._state === 2 /* SKIP */;
    }
    compareRangeData(rangeData) {
      const startRow = rangeData.startRow;
      const startColumn = rangeData.startColumn;
      const endRow = rangeData.endRow;
      const endColumn = rangeData.endColumn;
      if (this.row < startRow || this.row > endRow || this.column < startColumn || this.column > endColumn) {
        return false;
      }
      return true;
    }
    dependencyRange(dependencyRangeList) {
      if (this.rangeList.length === 0) {
        return false;
      }
      for (let r4 = 0, len = this.rangeList.length; r4 < len; r4++) {
        const unitRange = this.rangeList[r4];
        const unitId = unitRange.unitId;
        const sheetId = unitRange.sheetId;
        const rangeData = unitRange.rangeData;
        if (!dependencyRangeList.has(unitId)) {
          continue;
        }
        const sheetRangeMap = dependencyRangeList.get(unitId);
        if (!sheetRangeMap.has(sheetId)) {
          continue;
        }
        const dependencyRange = sheetRangeMap.get(sheetId);
        const { startRow, startColumn, endRow, endColumn } = dependencyRange;
        if (rangeData.startRow > endRow || rangeData.endRow < startRow || rangeData.startColumn > endColumn || rangeData.endColumn < startColumn) {
          continue;
        } else {
          return true;
        }
      }
      return false;
    }
    pushChildren(tree) {
      this.children.push(tree);
      tree._pushParent(this);
    }
    pushRangeList(range2) {
      this.rangeList.push(range2);
    }
    dependency(dependenceTree) {
      if (this.rangeList.length === 0) {
        return false;
      }
      for (let r4 = 0, len = this.rangeList.length; r4 < len; r4++) {
        const unitRange = this.rangeList[r4];
        const unitId = unitRange.unitId;
        const sheetId = unitRange.sheetId;
        const rangeData = unitRange.rangeData;
        if (dependenceTree.unitId === unitId && dependenceTree.sheetId === sheetId && dependenceTree.compareRangeData(rangeData)) {
          return true;
        }
      }
      return false;
    }
  };

  // ../../packages/base-formula-engine/src/Dependency/FormulaDependency.ts
  var FormulaDependencyGenerator = class {
    constructor(_formulaData, _forceCalculate = false) {
      this._formulaData = _formulaData;
      this._forceCalculate = _forceCalculate;
    }
    _updateRangeFlattenCache = /* @__PURE__ */ new Map();
    updateRangeFlatten(updateRangeList) {
      if (this._forceCalculate) {
        return;
      }
      this._updateRangeFlattenCache = /* @__PURE__ */ new Map();
      for (let i4 = 0; i4 < updateRangeList.length; i4++) {
        const gridRange = updateRangeList[i4];
        const range2 = gridRange.rangeData;
        const sheetId = gridRange.sheetId;
        const unitId = gridRange.unitId;
        this._addFlattenCache(unitId, sheetId, range2);
      }
    }
    _addFlattenCache(unitId, sheetId, rangeData) {
      let unitMatrix = this._updateRangeFlattenCache.get(unitId);
      if (!unitMatrix) {
        unitMatrix = /* @__PURE__ */ new Map();
        this._updateRangeFlattenCache.set(unitId, unitMatrix);
      }
      unitMatrix.set(sheetId, rangeData);
    }
    _isPreCalculateNode(node) {
      if (node.nodeType === "UnionNode" /* UNION */) {
        return true;
      }
      if (node.nodeType === "PrefixNode" /* PREFIX */ && node.getToken() === "@" /* AT */) {
        return true;
      }
      if (node.nodeType === "SuffixNode" /* SUFFIX */ && node.getToken() === "#" /* POUND */) {
        return true;
      }
      return false;
    }
    _nodeTraversalRef(node, result) {
      const children = node.getChildren();
      const childrenCount = children.length;
      for (let i4 = 0; i4 < childrenCount; i4++) {
        const item = children[i4];
        if (this._isPreCalculateNode(item)) {
          result.push(item);
          continue;
        } else if (item.nodeType === "ReferenceNode" /* REFERENCE */) {
          result.push(item);
        }
        this._nodeTraversalRef(item, result);
      }
    }
    _nodeTraversalReferenceFunction(node, result) {
      const children = node.getChildren();
      const childrenCount = children.length;
      for (let i4 = 0; i4 < childrenCount; i4++) {
        const item = children[i4];
        if (item.nodeType === "FunctionNode" /* FUNCTION */ && item.isAddress()) {
          result.push(item);
          continue;
        }
        this._nodeTraversalReferenceFunction(item, result);
      }
    }
    async _executeNode(node, formulaInterpreter) {
      let value;
      if (formulaInterpreter.checkAsyncNode(node)) {
        value = await formulaInterpreter.executeAsync(node);
      } else {
        value = formulaInterpreter.execute(node);
      }
      return value;
    }
    async _getRangeListByNode(node, formulaInterpreter) {
      const preCalculateNodeList = [];
      const referenceFunctionList = [];
      this._nodeTraversalRef(node, preCalculateNodeList);
      this._nodeTraversalReferenceFunction(node, referenceFunctionList);
      const rangeList = [];
      for (let i4 = 0, len = preCalculateNodeList.length; i4 < len; i4++) {
        const node2 = preCalculateNodeList[i4];
        let value = await this._executeNode(node2, formulaInterpreter);
        const gridRange = value.toUnitRange();
        rangeList.push(gridRange);
      }
      for (let i4 = 0, len = referenceFunctionList.length; i4 < len; i4++) {
        const node2 = referenceFunctionList[i4];
        let value = await this._executeNode(node2, formulaInterpreter);
        const gridRange = value.toUnitRange();
        rangeList.push(gridRange);
      }
      return rangeList;
    }
    _includeTree(tree) {
      const unitId = tree.unitId;
      const sheetId = tree.sheetId;
      if (!this._updateRangeFlattenCache.has(unitId)) {
        return false;
      }
      const sheetRangeMap = this._updateRangeFlattenCache.get(unitId);
      if (!sheetRangeMap.has(sheetId)) {
        return false;
      }
      const rangeData = sheetRangeMap.get(sheetId);
      if (tree.compareRangeData(rangeData)) {
        return true;
      }
      return false;
    }
    _getUpdateTreeListAndMakeDependency(treeList) {
      const newTreeList = [];
      const existTree = /* @__PURE__ */ new Set();
      for (let i4 = 0, len = treeList.length; i4 < len; i4++) {
        const tree = treeList[i4];
        for (let m4 = 0, mLen = treeList.length; m4 < mLen; m4++) {
          const treeMatch = treeList[m4];
          if (tree === treeMatch) {
            continue;
          }
          if (tree.dependency(treeMatch)) {
            tree.pushChildren(treeMatch);
          }
        }
        if ((this._forceCalculate || tree.dependencyRange(this._updateRangeFlattenCache) || this._includeTree(tree)) && !existTree.has(tree)) {
          newTreeList.push(tree);
          existTree.add(tree);
        }
      }
      return newTreeList;
    }
    _calculateRunList(treeList) {
      let stack = treeList;
      const formulaRunList = [];
      while (stack.length > 0) {
        let tree = stack.pop();
        if (tree === void 0 || tree.isSkip()) {
          continue;
        }
        if (tree.isAdded()) {
          formulaRunList.push(tree);
          continue;
        }
        const cacheStack = [];
        for (let i4 = 0, len = tree.parents.length; i4 < len; i4++) {
          const parentTree = tree.parents[i4];
          cacheStack.push(parentTree);
        }
        if (cacheStack.length == 0) {
          formulaRunList.push(tree);
          tree.setSkip();
        } else {
          tree.setAdded();
          stack.push(tree);
          stack = stack.concat(cacheStack);
        }
      }
      return formulaRunList.reverse();
    }
    async generate(updateRangeList = [], interpreterDatasetConfig) {
      this.updateRangeFlatten(updateRangeList);
      const formulaInterpreter = Interpreter.create(interpreterDatasetConfig);
      const formulaDataKeys = Object.keys(this._formulaData);
      const treeList = [];
      for (let unitId of formulaDataKeys) {
        const sheetData = this._formulaData[unitId];
        const sheetDataKeys = Object.keys(sheetData);
        for (let sheetId of sheetDataKeys) {
          const matrixData = new ObjectMatrix(sheetData[sheetId]);
          matrixData.forValue((row, column, formulaData) => {
            const formulaString = formulaData.formula;
            const node = generateAstNode(formulaString);
            const FDtree = new FormulaDependencyTree();
            FDtree.node = node;
            FDtree.formula = formulaString;
            FDtree.unitId = unitId;
            FDtree.sheetId = sheetId;
            FDtree.row = row;
            FDtree.column = column;
            treeList.push(FDtree);
          });
        }
      }
      for (let i4 = 0, len = treeList.length; i4 < len; i4++) {
        const tree = treeList[i4];
        formulaInterpreter.setCurrentPosition(tree.row, tree.column, tree.sheetId, tree.unitId);
        const rangeList = await this._getRangeListByNode(tree.node, formulaInterpreter);
        for (let r4 = 0, rLen = rangeList.length; r4 < rLen; r4++) {
          tree.pushRangeList(rangeList[r4]);
        }
      }
      const updateTreeList = this._getUpdateTreeListAndMakeDependency(treeList);
      return Promise.resolve(this._calculateRunList(updateTreeList));
    }
    static create(formulaData, forceCalculate = false) {
      return new FormulaDependencyGenerator(formulaData, forceCalculate);
    }
  };

  // ../../packages/base-formula-engine/src/FormulaEnginePlugin.tsx
  var FormulaEnginePlugin = class extends Plugin {
    constructor(config) {
      super("formulaEngine");
    }
    /**
     *
     * @param unitId
     * @param formulaData
     * @param interpreterDatasetConfig
     * @param forceCalculate force calculate all formula, and ignore dependency relationship
     * @param updateRangeList input external unit data for multi workbook
     * @returns
     */
    async execute(unitId, formulaData, interpreterDatasetConfig, forceCalculate = false, updateRangeList = []) {
      const dependencyGenerator = FormulaDependencyGenerator.create(formulaData, forceCalculate);
      const treeList = await dependencyGenerator.generate(updateRangeList, interpreterDatasetConfig);
      const interpreter = Interpreter.create(interpreterDatasetConfig);
      for (let i4 = 0, len = treeList.length; i4 < len; i4++) {
        const tree = treeList[i4];
        const astNode = tree.node;
        let value;
        interpreter.setCurrentPosition(tree.row, tree.column, tree.sheetId, tree.unitId);
        if (interpreter.checkAsyncNode(astNode)) {
          value = await interpreter.executeAsync(astNode);
        } else {
          value = interpreter.execute(astNode);
        }
        interpreter.setRuntimeData(tree.row, tree.column, tree.sheetId, tree.unitId, value);
      }
      return {
        sheetData: interpreter.getSheetData(unitId),
        arrayFormulaData: interpreter.getSheetArrayFormula(unitId)
      };
    }
    calculate(formulaString) {
      this.getObserver("onBeforeFormulaCalculateObservable")?.notifyObservers(formulaString);
      const lexerTreeMaker = new LexerTreeMaker(formulaString);
      const lexerNode = lexerTreeMaker.treeMaker();
      lexerTreeMaker.suffixExpressionHandler(lexerNode);
      this.getObserver("onAfterFormulaLexerObservable")?.notifyObservers(lexerNode);
      const astTreeMaker = AstTreeMaker.create();
      const astNode = astTreeMaker.parse(lexerNode);
      const interpreter = Interpreter.create();
      if (interpreter.checkAsyncNode(astNode)) {
        const resultPromise = interpreter.executeAsync(astNode);
        resultPromise.then((value) => {
          console.log("formulaResult", value);
        });
      } else {
        console.log(interpreter.execute(astNode));
      }
    }
    initialize() {
    }
    onMapping(IOC) {
    }
    onMounted(ctx) {
      this.initialize();
    }
    onDestroy() {
    }
    static create(config) {
      return new FormulaEnginePlugin(config);
    }
  };

  // ../../packages/sheets-plugin-formula/src/Locale/zh.ts
  var zh_default4 = {
    formula: {
      formulaLabel: "\u6C42\u548C",
      formulaRightLabel: "\u66F4\u591A\u516C\u5F0F",
      ok: "\u786E\u5B9A",
      cancel: "\u53D6\u6D88",
      clearValidation: "\u6E05\u9664\u9A8C\u8BC1",
      formula: {
        sum: "\u6C42\u548C",
        average: "\u5E73\u5747\u503C",
        count: "\u8BA1\u6570",
        max: "\u6700\u5927\u503C",
        min: "\u6700\u5C0F\u503C",
        if: "if\u516C\u5F0F\u751F\u6210\u5668",
        more: "\u66F4\u591A\u51FD\u6570..."
      },
      functionList: {
        SUMIF: {
          d: "\u5BF9\u8303\u56F4\u4E2D\u7B26\u5408\u6307\u5B9A\u6761\u4EF6\u7684\u503C\u6C42\u548C\u3002",
          p: {
            range: {
              name: "\u8303\u56F4",
              detail: "\u8981\u6839\u636E\u6761\u4EF6\u8FDB\u884C\u68C0\u6D4B\u7684\u8303\u56F4\u3002"
            },
            rangeAll: {
              name: "\u6761\u4EF6",
              detail: "\u8981\u5E94\u7528\u4E8E\u8303\u56F4\u7684\u6A21\u5F0F\u6216\u6D4B\u8BD5\u6761\u4EF6\u3002\n\n\u5982\u679C\u8303\u56F4\u5305\u542B\u7684\u662F\u8981\u68C0\u6D4B\u7684\u6587\u672C\uFF0C\u5219\u6761\u4EF6\u5FC5\u987B\u4E3A\u5B57\u7B26\u4E32\u3002\u6761\u4EF6\u53EF\u4EE5\u5305\u542B\u901A\u914D\u7B26\uFF0C\u5305\u62EC\u7528\u4E8E\u5339\u914D\u5355\u4E2A\u5B57\u7B26\u7684?\u6216\u7528\u4E8E\u5339\u914D\u96F6\u4E2A\u6216\u8FDE\u7EED\u591A\u4E2A\u5B57\u7B26\u7684*\u3002\u8981\u5339\u914D\u95EE\u53F7\u661F\u53F7\u672C\u8EAB\uFF0C\u8BF7\u5728\u8BE5\u5B57\u7B26\u524D\u9762\u52A0\u4E0A\u6CE2\u6D6A\u53F7(~)\u524D\u7F00\uFF08\u5373~?\u548C~*\uFF09\u3002\u5B57\u7B26\u4E32\u6761\u4EF6\u5FC5\u987B\u7528\u5F15\u53F7\u62EC\u8D77\u6765\u3002\u51FD\u6570\u4F1A\u68C0\u67E5\u8303\u56F4\u4E2D\u7684\u6BCF\u4E2A\u5355\u5143\u683C\u4E0E\u6761\u4EF6\u662F\u5426\u76F8\u7B49\u6216\u5339\u914D\uFF08\u5982\u679C\u4F7F\u7528\u4E86\u901A\u914D\u7B26\uFF09\u3002\n\n\u5982\u679C\u8303\u56F4\u5305\u542B\u7684\u662F\u8981\u68C0\u6D4B\u7684\u6570\u5B57\uFF0C\u5219\u6761\u4EF6\u53EF\u4EE5\u662F\u5B57\u7B26\u4E32\u4E5F\u53EF\u4EE5\u662F\u6570\u5B57\u3002\u5982\u679C\u7ED9\u5B9A\u7684\u6761\u4EF6\u662F\u4E00\u4E2A\u6570\u5B57\uFF0C\u5219\u68C0\u67E5\u8303\u56F4\u4E2D\u7684\u6BCF\u4E2A\u5355\u5143\u683C\u662F\u5426\u7B49\u4E8E\u6761\u4EF6\u3002\u53E6\u5916\uFF0C\u6761\u4EF6\u4E5F\u53EF\u80FD\u662F\u5305\u542B\u6570\u5B57\u7684\u5B57\u7B26\u4E32\uFF08\u4E5F\u5C06\u5BF9\u5176\u8FDB\u884C\u76F8\u7B49\u68C0\u6D4B\uFF09\uFF0C\u6216\u8005\u5E26\u6709\u4EE5\u4E0B\u524D\u7F00\u7684\u6570\u5B57\uFF1A=\uFF08\u68C0\u67E5\u662F\u5426\u76F8\u7B49\uFF09\u3001>\uFF08\u68C0\u67E5\u8303\u56F4\u5355\u5143\u683C\u7684\u503C\u662F\u5426\u5927\u4E8E\u6761\u4EF6\u503C\uFF09\u6216<\uFF08\u68C0\u67E5\u8303\u56F4\u5355\u5143\u683C\u7684\u503C\u662F\u5426\u5C0F\u4E8E\u6761\u4EF6\u503C\uFF09"
            },
            range1: {
              name: "\u6C42\u548C\u8303\u56F4",
              detail: "\u8981\u6C42\u548C\u7684\u8303\u56F4\uFF08\u5982\u679C\u4E0E\u8303\u56F4\u4E0D\u540C\uFF09\u3002"
            }
          }
        },
        TAN: {
          d: "\u8FD4\u56DE\u5DF2\u77E5\u89D2\u5EA6\u7684\u6B63\u5207\u503C\u3002",
          p: {
            rangeNumber: {
              name: "\u89D2\u5EA6",
              detail: "\u8981\u6C42\u5176\u6B63\u5207\u503C\u7684\u89D2\u5EA6\uFF0C\u4EE5\u5F27\u5EA6\u8868\u793A\u3002"
            }
          }
        },
        TANH: {
          d: "\u8FD4\u56DE\u7ED9\u5B9A\u5B9E\u6570\u7684\u53CC\u66F2\u6B63\u5207\u503C\u3002",
          p: {
            rangeNumber: {
              name: "\u503C",
              detail: "\u8981\u8BA1\u7B97\u5176\u53CC\u66F2\u6B63\u5207\u503C\u7684\u5B9E\u6570\u3002"
            }
          }
        },
        CEILING: {
          d: "\u5C06\u6570\u503C\u5411\u4E0A\u53D6\u6574\u4E3A\u6700\u63A5\u8FD1\u7684\u6307\u5B9A\u56E0\u6570\u7684\u500D\u6570\u3002",
          p: {
            rangeNumber: {
              name: "\u503C",
              detail: "\u8981\u5411\u4E0A\u820D\u5165\u7684\u6570\u503C\u3002"
            },
            rangeNumber1: {
              name: "\u56E0\u6570",
              detail: "\u8981\u5C06\u503C\u820D\u5165\u5230\u6B64\u6570\u7684\u6574\u6570\u500D\u3002"
            }
          }
        },
        ATAN: {
          d: "\u8FD4\u56DE\u6570\u503C\u7684\u53CD\u6B63\u5207\u503C\uFF0C\u4EE5\u5F27\u5EA6\u8868\u793A\u3002",
          p: {
            rangeNumber: {
              name: "\u503C",
              detail: "\u8981\u8BA1\u7B97\u5176\u53CD\u6B63\u5207\u503C\u7684\u6570\u503C\u3002"
            }
          }
        },
        ASINH: {
          d: "\u8FD4\u56DE\u6570\u503C\u7684\u53CD\u53CC\u66F2\u6B63\u5F26\u503C\u3002",
          p: {
            rangeNumber: {
              name: "\u503C",
              detail: "\u8981\u8BA1\u7B97\u5176\u53CD\u53CC\u66F2\u6B63\u5F26\u503C\u7684\u6570\u503C\u3002"
            }
          }
        },
        ABS: {
          d: "\u8FD4\u56DE\u6570\u503C\u7684\u7EDD\u5BF9\u503C\u3002",
          p: {
            rangeNumber: {
              name: "value",
              detail: "\u8981\u8FD4\u56DE\u5176\u7EDD\u5BF9\u503C\u7684\u6570\u3002"
            }
          }
        },
        COUNTBLANK: {
          d: "\u8FD4\u56DE\u7ED9\u5B9A\u8303\u56F4\u5185\u7684\u7A7A\u5355\u5143\u683C\u6570\u3002",
          p: {
            range: {
              name: "\u8303\u56F4",
              detail: "\u8981\u7EDF\u8BA1\u7A7A\u767D\u5355\u5143\u683C\u6570\u91CF\u7684\u8303\u56F4\u3002"
            }
          }
        },
        COSH: {
          d: "\u8FD4\u56DE\u7ED9\u5B9A\u5B9E\u6570\u7684\u53CC\u66F2\u4F59\u5F26\u503C\u3002",
          p: {
            rangeNumber: {
              name: "\u503C",
              detail: "\u8981\u8BA1\u7B97\u5176\u53CC\u66F2\u4F59\u5F26\u503C\u7684\u5B9E\u6570\u503C\u3002"
            }
          }
        },
        COUNTIF: {
          d: "\u8FD4\u56DE\u8303\u56F4\u5185\u6EE1\u8DB3\u67D0\u4E2A\u6761\u4EF6\u7684\u5355\u5143\u683C\u7684\u6570\u91CF\u3002",
          p: {
            range: {
              name: "\u8303\u56F4",
              detail: "\u8981\u6839\u636E\u6761\u4EF6\u8FDB\u884C\u68C0\u6D4B\u7684\u8303\u56F4\u3002"
            },
            rangeAll: {
              name: "\u6761\u4EF6",
              detail: "\u8981\u5E94\u7528\u4E8E\u8303\u56F4\u7684\u6A21\u5F0F\u6216\u6D4B\u8BD5\u6761\u4EF6\u3002\n\n\u5982\u679C\u8303\u56F4\u5305\u542B\u7684\u662F\u8981\u68C0\u6D4B\u7684\u6587\u672C\uFF0C\u5219\u6761\u4EF6\u5FC5\u987B\u4E3A\u5B57\u7B26\u4E32\u3002\u6761\u4EF6\u53EF\u4EE5\u5305\u542B\u901A\u914D\u7B26\uFF0C\u5305\u62EC\u7528\u4E8E\u5339\u914D\u5355\u4E2A\u5B57\u7B26\u7684?\u6216\u7528\u4E8E\u5339\u914D\u96F6\u4E2A\u6216\u8FDE\u7EED\u591A\u4E2A\u5B57\u7B26\u7684*\u3002\u8981\u5339\u914D\u95EE\u53F7\u661F\u53F7\u672C\u8EAB\uFF0C\u8BF7\u5728\u8BE5\u5B57\u7B26\u524D\u9762\u52A0\u4E0A\u6CE2\u6D6A\u53F7(~)\u524D\u7F00\uFF08\u5373~?\u548C~*\uFF09\u3002\u5B57\u7B26\u4E32\u6761\u4EF6\u5FC5\u987B\u7528\u5F15\u53F7\u62EC\u8D77\u6765\u3002\u51FD\u6570\u4F1A\u68C0\u67E5\u8303\u56F4\u4E2D\u7684\u6BCF\u4E2A\u5355\u5143\u683C\u4E0E\u6761\u4EF6\u662F\u5426\u76F8\u7B49\u6216\u5339\u914D\uFF08\u5982\u679C\u4F7F\u7528\u4E86\u901A\u914D\u7B26\uFF09\u3002\n\n\u5982\u679C\u8303\u56F4\u5305\u542B\u7684\u662F\u8981\u68C0\u6D4B\u7684\u6570\u5B57\uFF0C\u5219\u6761\u4EF6\u53EF\u4EE5\u662F\u5B57\u7B26\u4E32\u4E5F\u53EF\u4EE5\u662F\u6570\u5B57\u3002\u5982\u679C\u7ED9\u5B9A\u7684\u6761\u4EF6\u662F\u4E00\u4E2A\u6570\u5B57\uFF0C\u5219\u68C0\u67E5\u8303\u56F4\u4E2D\u7684\u6BCF\u4E2A\u5355\u5143\u683C\u662F\u5426\u7B49\u4E8E\u6761\u4EF6\u3002\u53E6\u5916\uFF0C\u6761\u4EF6\u4E5F\u53EF\u80FD\u662F\u5305\u542B\u6570\u5B57\u7684\u5B57\u7B26\u4E32\uFF08\u4E5F\u5C06\u5BF9\u5176\u8FDB\u884C\u76F8\u7B49\u68C0\u6D4B\uFF09\uFF0C\u6216\u8005\u5E26\u6709\u4EE5\u4E0B\u524D\u7F00\u7684\u6570\u5B57\uFF1A=\u3001>\u3001>=\u3001<\u6216<=\uFF0C\u8FD9\u4E9B\u6761\u4EF6\u5C06\u5206\u522B\u7528\u4E8E\u68C0\u67E5\u8303\u56F4\u4E2D\u7684\u5355\u5143\u683C\u662F\u5426\u7B49\u4E8E\u3001\u5927\u4E8E\u3001\u5927\u4E8E\u7B49\u4E8E\u3001\u5C0F\u4E8E\u3001\u5C0F\u4E8E\u7B49\u4E8E\u6761\u4EF6\u503C\u3002"
            }
          }
        },
        ERFC: {
          d: "\u8FD4\u56DE\u6570\u503C\u7684\u4E92\u8865\u9AD8\u65AF\u8BEF\u5DEE\u51FD\u6570\u3002",
          p: {
            rangeNumber: {
              name: "z",
              detail: "\u8981\u4E3A\u5176\u8BA1\u7B97\u4E92\u8865\u9AD8\u65AF\u8BEF\u5DEE\u51FD\u6570\u7684\u6570\u503C\u3002"
            }
          }
        },
        VLOOKUP: {
          d: "\u7EB5\u5411\u67E5\u627E\u3002\u5728\u8303\u56F4\u7684\u7B2C\u4E00\u5217\u4E2D\u81EA\u4E0A\u800C\u4E0B\u641C\u7D22\u67D0\u4E2A\u952E\u503C\uFF0C\u5E76\u8FD4\u56DE\u6240\u627E\u5230\u7684\u884C\u4E2D\u6307\u5B9A\u5355\u5143\u683C\u7684\u503C\u3002",
          p: {
            rangeAll: {
              name: "\u641C\u7D22\u952E\u503C",
              detail: '\u8981\u641C\u7D22\u7684\u503C\uFF0C\u5982 42\u3001"Cats" \u6216 I24\u3002'
            },
            rangeAll1: {
              name: "\u8303\u56F4",
              detail: "\u8981\u8FDB\u884C\u641C\u7D22\u7684\u8303\u56F4\u3002VLOOKUP \u5C06\u5728\u8BE5\u8303\u56F4\u7684\u7B2C\u4E00\u5217\u4E2D\u641C\u7D22\u641C\u7D22\u952E\u503C\u4E2D\u6307\u5B9A\u7684\u952E\u503C\u3002"
            },
            rangeNumber: {
              name: "\u7D22\u5F15",
              detail: "\u8981\u8FD4\u56DE\u7684\u503C\u7684\u5217\u7D22\u5F15\uFF0C\u8303\u56F4\u4E2D\u7684\u7B2C\u4E00\u5217\u7F16\u53F7\u4E3A 1\u3002\n\n\u5982\u679C\u7D22\u5F15\u4E0D\u662F\u4ECB\u4E8E 1 \u548C\u8303\u56F4\u4E2D\u7684\u5217\u6570\u4E4B\u95F4\uFF0C\u5C06\u8FD4\u56DE #VALUE! \u3002"
            },
            rangeAll2: {
              name: "\u5DF2\u6392\u5E8F",
              detail: "[\u9ED8\u8BA4\u503C\u4E3A TRUE() ] - \u6307\u793A\u8981\u641C\u7D22\u7684\u5217\uFF08\u6307\u5B9A\u8303\u56F4\u7684\u7B2C\u4E00\u5217\uFF09\u662F\u5426\u5DF2\u6392\u5E8F\u3002\u5927\u591A\u6570\u60C5\u51B5\u4E0B\uFF0C\u5EFA\u8BAE\u8BBE\u4E3A FALSE()\u3002\n\n\u5EFA\u8BAE\u5C06\u5DF2\u6392\u5E8F\u8BBE\u4E3A FALSE\u3002\u5982\u679C\u8BBE\u4E3A FALSE\uFF0C\u5C06\u8FD4\u56DE\u5B8C\u5168\u5339\u914D\u9879\u3002\u5982\u679C\u5B58\u5728\u591A\u4E2A\u5339\u914D\u503C\uFF0C\u5C06\u8FD4\u56DE\u627E\u5230\u7684\u7B2C\u4E00\u4E2A\u503C\u5BF9\u5E94\u7684\u5355\u5143\u683C\u7684\u5185\u5BB9\uFF0C\u5982\u679C\u627E\u4E0D\u5230\u5339\u914D\u503C\uFF0C\u5219\u8FD4\u56DE #N/A\u3002\n\n\u5982\u679C\u5C06\u5DF2\u6392\u5E8F\u8BBE\u4E3A TRUE \u6216\u7701\u7565\uFF0C\u5C06\u8FD4\u56DE\uFF08\u5C0F\u4E8E\u6216\u7B49\u4E8E\u641C\u7D22\u952E\u503C\u7684\uFF09\u6700\u63A5\u8FD1\u7684\u5339\u914D\u9879\u3002\u5982\u679C\u641C\u7D22\u7684\u5217\u4E2D\u6240\u6709\u7684\u503C\u5747\u5927\u4E8E\u641C\u7D22\u952E\u503C\uFF0C\u5219\u8FD4\u56DE #N/A\u3002"
            }
          }
        },
        TIME: {
          d: "\u5C06\u7ED9\u5B9A\u7684\u5C0F\u65F6\u3001\u5206\u949F\u548C\u79D2\u8F6C\u6362\u4E3A\u65F6\u95F4\u3002",
          p: {
            rangeNumber: {
              name: "\u5C0F\u65F6",
              detail: "0\uFF08\u96F6\uFF09\u5230 32767 \u4E4B\u95F4\u7684\u6570\u5B57\uFF0C\u4EE3\u8868\u5C0F\u65F6\u3002\n\n\u4EFB\u4F55\u5927\u4E8E 23 \u7684\u503C\u90FD\u4F1A\u9664\u4EE5 24\uFF0C\u4F59\u6570\u5C06\u4F5C\u4E3A\u5C0F\u65F6\u503C\u3002"
            },
            rangeNumber1: {
              name: "\u5206\u949F",
              detail: "0\uFF08\u96F6\uFF09\u5230 32767 \u4E4B\u95F4\u7684\u6570\u5B57\uFF0C\u4EE3\u8868\u5206\u949F\u3002\n\n\u4EFB\u4F55\u5927\u4E8E 59 \u7684\u503C\u5C06\u8F6C\u6362\u4E3A\u5C0F\u65F6\u548C\u5206\u949F\u3002"
            },
            rangeNumber2: {
              name: "\u79D2",
              detail: "0\uFF08\u96F6\uFF09\u5230 32767 \u4E4B\u95F4\u7684\u6570\u5B57\uFF0C\u4EE3\u8868\u79D2\u3002\n\n\u4EFB\u4F55\u5927\u4E8E 59 \u7684\u503C\u5C06\u8F6C\u6362\u4E3A\u5C0F\u65F6\u3001\u5206\u949F\u548C\u79D2\u3002"
            }
          }
        },
        EFFECT: {
          d: "\u6839\u636E\u540D\u4E49\u5229\u7387\u53CA\u6BCF\u5E74\u7684\u590D\u5229\u8BA1\u606F\u671F\u6570\u6765\u8BA1\u7B97\u5B9E\u9645\u5E74\u5229\u7387\u3002",
          p: {
            rangeNumber: {
              name: "nominal_rate",
              detail: "\u6BCF\u5E74\u7684\u540D\u4E49\u5229\u7387\u3002"
            },
            rangeNumber1: {
              name: "npery",
              detail: "\u6BCF\u5E74\u7684\u590D\u5229\u8BA1\u7B97\u671F\u6570\u3002"
            }
          }
        },
        BIN2DEC: {
          d: "\u5C06\u4E8C\u8FDB\u5236\u6570\u8F6C\u6362\u4E3A\u5341\u8FDB\u5236\u6570\u3002",
          p: {
            rangeAll: {
              name: "number",
              detail: '\u8981\u8F6C\u6362\u4E3A\u5341\u8FDB\u5236\u6570\u7684\u5E26\u7B26\u53F7\u768410\u4F4D\u4E8C\u8FDB\u5236\u6570\u503C\uFF08\u4EE5\u5B57\u7B26\u4E32\u5F62\u5F0F\u63D0\u4F9B\uFF09\u3002\n\n\u5E26\u7B26\u53F7\u7684\u4E8C\u8FDB\u5236\u6570\u7684\u6700\u9AD8\u4F4D\u662F\u7B26\u53F7\u4F4D\uFF1B\u4E5F\u5C31\u662F\u8BF4\uFF0C\u8D1F\u6570\u662F\u4EE5\u4E8C\u7684\u8865\u7801\u5F62\u5F0F\u8868\u793A\u7684\u3002\n\n\u5BF9\u4E8E\u6B64\u51FD\u6570\uFF0C\u6700\u5927\u7684\u6B63\u6570\u8F93\u5165\u503C\u4E3A0111111111\uFF0C\u6700\u5C0F\u7684\u8D1F\u6570\u8F93\u5165\u503C\u4E3A1000000000\u3002\n\n\u5982\u679C\u6240\u63D0\u4F9B\u7684\u5E26\u7B26\u53F7\u7684\u4E8C\u8FDB\u5236\u6570\u662F\u6709\u6548\u7684\u4E8C\u8FDB\u5236\u6570\uFF0C\u4F1A\u81EA\u52A8\u5C06\u5176\u8F6C\u6362\u4E3A\u76F8\u5E94\u7684\u5B57\u7B26\u4E32\u8F93\u5165\u3002\u4F8B\u5982\uFF0CBIN2DEC(100)\u548CBIN2DEC("100")\u5F97\u51FA\u7684\u7ED3\u679C\u76F8\u540C\uFF0C\u5747\u4E3A4\u3002'
            }
          }
        },
        TRUE: {
          d: "\u8FD4\u56DE\u903B\u8F91\u503C TRUE\u3002"
        },
        NE: {
          d: "\u5982\u679C\u6307\u5B9A\u7684\u503C\u4E0D\u76F8\u7B49\uFF0C\u5219\u8FD4\u56DE\u201CTRUE\u201D\uFF1B\u5426\u5219\u8FD4\u56DE\u201CFALSE\u201D\u3002\u76F8\u5F53\u4E8E\u201C<>\u201D\u8FD0\u7B97\u7B26\u3002",
          p: {
            rangeAll: {
              name: "value1",
              detail: "\u7B2C\u4E00\u4E2A\u503C\u3002"
            },
            rangeAll1: {
              name: "value2",
              detail: "\u8981\u68C0\u67E5\u662F\u5426\u4E0E value1 \u4E0D\u76F8\u7B49\u7684\u503C\u3002"
            }
          }
        },
        SEX_BY_IDCARD: {
          d: "\u6839\u636E\u4E2D\u56FD\u8EAB\u4EFD\u8BC1\u53F7\u8BA1\u7B97\u51FA\u6027\u522B\u3002\u652F\u630115\u4F4D\u621618\u4F4D\u8EAB\u4EFD\u8BC1",
          p: {
            rangeAll: {
              name: "\u8EAB\u4EFD\u8BC1\u53F7",
              detail: "15\u4F4D\u6216\u800518\u4F4D\u7684\u8EAB\u4EFD\u8BC1\u53F7\u6216\u8303\u56F4\u3002"
            }
          }
        }
      },
      formulaMore: {
        valueTitle: "\u503C",
        tipSelectDataRange: "\u9009\u53D6\u6570\u636E\u8303\u56F4",
        tipDataRangeTile: "\u6570\u636E\u8303\u56F4",
        findFunctionTitle: "\u67E5\u627E\u51FD\u6570",
        tipInputFunctionName: "\u8BF7\u8F93\u5165\u60A8\u8981\u67E5\u627E\u7684\u51FD\u6570\u540D\u79F0\u6216\u51FD\u6570\u529F\u80FD\u7684\u7B80\u8981\u63CF\u8FF0",
        whole: "\u5168\u90E8",
        Math: "\u6570\u5B66",
        Statistical: "\u7EDF\u8BA1",
        Lookup: "\u67E5\u627E",
        universheet: "UniverSheet\u5185\u7F6E",
        dataMining: "\u6570\u636E\u6316\u6398",
        Database: "\u6570\u636E\u6E90",
        Date: "\u65E5\u671F",
        Filter: "\u8FC7\u6EE4\u5668",
        Financial: "\u8D22\u52A1",
        Engineering: "\u5DE5\u7A0B\u8BA1\u7B97",
        Logical: "\u903B\u8F91",
        Operator: "\u8FD0\u7B97\u7B26",
        Text: "\u6587\u672C",
        Parser: "\u8F6C\u6362\u5DE5\u5177",
        Array: "\u6570\u7EC4",
        other: "\u5176\u5B83",
        selectFunctionTitle: "\u9009\u62E9\u51FD\u6570",
        calculationResult: "\u8BA1\u7B97\u7ED3\u679C",
        tipSuccessText: "\u6210\u529F",
        tipParamErrorText: "\u53C2\u6570\u7C7B\u578B\u9519\u8BEF",
        helpClose: "\u5173\u95ED",
        helpCollapse: "\u6536\u8D77",
        helpExample: "\u793A\u4F8B",
        helpAbstract: "\u6458\u8981",
        execfunctionError: '\u63D0\u793A", "\u516C\u5F0F\u5B58\u5728\u9519\u8BEF',
        execfunctionSelfError: "\u516C\u5F0F\u4E0D\u53EF\u5F15\u7528\u5176\u672C\u8EAB\u7684\u5355\u5143\u683C",
        execfunctionSelfErrorResult: "\u516C\u5F0F\u4E0D\u53EF\u5F15\u7528\u5176\u672C\u8EAB\u7684\u5355\u5143\u683C\uFF0C\u4F1A\u5BFC\u81F4\u8BA1\u7B97\u7ED3\u679C\u4E0D\u51C6\u786E",
        allowRepeatText: "\u53EF\u91CD\u590D",
        allowOptionText: "\u53EF\u9009",
        selectCategory: "\u6216\u9009\u62E9\u7C7B\u522B"
      },
      ifFormula: {
        tipNotBelongToIf: "\u8BE5\u5355\u5143\u683C\u51FD\u6570\u4E0D\u5C5E\u4E8Eif\u516C\u5F0F\uFF01",
        tipSelectCell: "\u8BF7\u9009\u62E9\u5355\u5143\u683C\u63D2\u5165\u51FD\u6570",
        ifGenCompareValueTitle: "\u6BD4\u8F83\u503C",
        ifGenSelectCellTitle: "\u70B9\u51FB\u9009\u62E9\u5355\u5143\u683C",
        ifGenRangeTitle: "\u8303\u56F4",
        ifGenRangeTo: "\u81F3",
        ifGenRangeEvaluate: "\u8303\u56F4\u8BC4\u4F30",
        ifGenSelectRangeTitle: "\u70B9\u51FB\u9009\u62E9\u8303\u56F4",
        ifGenCutWay: "\u5212\u5206\u65B9\u5F0F",
        ifGenCutSame: "\u5212\u5206\u503C\u76F8\u540C",
        ifGenCutNpiece: "\u5212\u5206\u4E3AN\u4EFD",
        ifGenCutCustom: "\u81EA\u5B9A\u4E49\u8F93\u5165",
        ifGenCutConfirm: "\u751F\u6210",
        ifGenTipSelectCell: "\u9009\u62E9\u5355\u5143\u683C",
        ifGenTipSelectCellPlace: "\u8BF7\u9009\u62E9\u5355\u5143\u683C",
        ifGenTipSelectRange: "\u9009\u62E9\u5355\u8303\u56F4",
        ifGenTipSelectRangePlace: "\u8BF7\u9009\u62E9\u8303\u56F4",
        ifGenTipNotNullValue: "\u6BD4\u8F83\u503C\u4E0D\u80FD\u4E3A\u7A7A\uFF01",
        ifGenTipLableTitile: "\u6807\u7B7E",
        ifGenTipRangeNotforNull: "\u8303\u56F4\u4E0D\u80FD\u4E3A\u7A7A\uFF01",
        ifGenTipCutValueNotforNull: "\u5212\u5206\u503C\u4E0D\u80FD\u4E3A\u7A7A\uFF01",
        ifGenTipNotGenCondition: "\u6CA1\u6709\u751F\u6210\u53EF\u7528\u7684\u6761\u4EF6\uFF01"
      }
    }
  };

  // ../../packages/sheets-plugin-formula/src/Locale/en.ts
  var en_default4 = {
    formula: {
      formulaLabel: "SUM",
      formulaRightLabel: "more formule",
      ok: "Ok",
      cancel: "Cancel",
      clearValidation: "Clear Validation",
      formula: {
        sum: "sum",
        average: "average",
        count: "count",
        max: "max",
        min: "min",
        if: "If formula generator",
        more: "More functions..."
      },
      functionList: {
        SUMIF: {
          d: "Returns a conditional sum across a range.",
          p: {
            range: {
              name: "range",
              detail: "The range which is tested against `criterion`."
            },
            rangeAll: {
              name: "criterion",
              detail: "The pattern or test to apply to `range`."
            },
            range1: {
              name: "sum_range",
              detail: "The range to be summed, if different from `range`."
            }
          }
        },
        TAN: {
          d: "Returns the tangent of an angle provided in radians.",
          p: {
            rangeNumber: {
              name: "angle",
              detail: "The angle to find the tangent of, in radians."
            }
          }
        },
        TANH: {
          d: "Returns the hyperbolic tangent of any real number.",
          p: {
            rangeNumber: {
              name: "value",
              detail: "Any real value to calculate the hyperbolic tangent of."
            }
          }
        },
        CEILING: {
          d: "Rounds a number up to the nearest integer multiple of specified significance `factor`.",
          p: {
            rangeNumber: {
              name: "value",
              detail: "The value to round up to the nearest integer multiple of `factor`."
            },
            rangeNumber1: {
              name: "factor",
              detail: "The number to whose multiples `value` will be rounded."
            }
          }
        },
        ATAN: {
          d: "Returns the inverse tangent of a value, in radians.",
          p: {
            rangeNumber: {
              name: "value",
              detail: "The value for which to calculate the inverse tangent."
            }
          }
        },
        ASINH: {
          d: "Returns the inverse hyperbolic sine of a number.",
          p: {
            rangeNumber: {
              name: "value",
              detail: "The value for which to calculate the inverse hyperbolic sine."
            }
          }
        },
        ABS: {
          d: "Returns the absolute value of a number.",
          p: {
            rangeNumber: {
              name: "value",
              detail: "The number of which to return the absolute value."
            }
          }
        },
        COUNTBLANK: {
          d: "Returns the number of empty values in a list of values and ranges.",
          p: {
            range: {
              name: "value1",
              detail: "The first value or range in which to count the number of blanks."
            }
          }
        },
        COSH: {
          d: "Returns the hyperbolic cosine of any real number.",
          p: {
            rangeNumber: {
              name: "value",
              detail: "Any real value to calculate the hyperbolic cosine of."
            }
          }
        },
        COUNTIF: {
          d: "Returns a conditional count across a range.",
          p: {
            range: {
              name: "range",
              detail: "The range that is tested against `criterion`."
            },
            rangeAll: {
              name: "criterion",
              detail: "The pattern or test to apply to `range`."
            }
          }
        },
        ERFC: {
          d: "Returns the complementary Gauss error function of a value.",
          p: {
            rangeNumber: {
              name: "z",
              detail: "The number for which to calculate the complementary Gauss error function."
            }
          }
        },
        VLOOKUP: {
          d: "Vertical lookup. Searches down the first column of a range for a key and returns the value of a specified cell in the row found.",
          p: {
            rangeAll: {
              name: "search_key",
              detail: 'The value to search for. For example, `42`, `"Cats"`, or `I24`.'
            },
            rangeAll1: {
              name: "range",
              detail: "The range to consider for the search. The first column in the range is searched for the key specified in `search_key`. "
            },
            rangeNumber: {
              name: "index",
              detail: "The column index of the value to be returned, where the first column in `range` is numbered 1."
            },
            rangeAll2: {
              name: "is_sorted",
              detail: "Indicates whether the column to be searched (the first column of the specified range) is sorted, in which case the closest match for `search_key` will be returned."
            }
          }
        },
        TIME: {
          d: "Converts a provided hour, minute, and second into a time.",
          p: {
            rangeNumber: {
              name: "hour",
              detail: "0The hour component of the time."
            },
            rangeNumber1: {
              name: "minute",
              detail: "The minute component of the time."
            },
            rangeNumber2: {
              name: "second",
              detail: "The second component of the time."
            }
          }
        },
        EFFECT: {
          d: "Calculates the annual effective interest rate given the nominal rate and number of compounding periods per year.",
          p: {
            rangeNumber: {
              name: "nominal_rate",
              detail: "The nominal interest rate per year."
            },
            rangeNumber1: {
              name: "periods_per_year",
              detail: "The number of compounding periods per year."
            }
          }
        },
        BIN2DEC: {
          d: "Converts a signed binary number to decimal format.",
          p: {
            rangeAll: {
              name: "signed_binary_number",
              detail: "The signed 10-bit binary value to be converted to decimal, provided as a string."
            }
          }
        },
        TRUE: {
          d: "Returns the logical value `TRUE`."
        },
        NE: {
          d: "Returns `TRUE` if two specified values are not equal and `FALSE` otherwise. Equivalent to the `!=` operator.",
          p: {
            rangeAll: {
              name: "value1",
              detail: "The first value."
            },
            rangeAll1: {
              name: "value2",
              detail: "The value to test against `value1` for inequality."
            }
          }
        },
        SEX_BY_IDCARD: {
          d: "Calculate gender based on Chinese ID number. Support 15 or 18",
          p: {
            rangeAll: {
              name: "ID number",
              detail: "15-digit or 18-digit ID number or range."
            }
          }
        }
      },
      functiontype: {
        "0": "Math",
        "1": "Statistical",
        "2": "Lookup",
        "3": "UniverSheet",
        "4": "Data Mining",
        "5": "Database",
        "6": "Date",
        "7": "Filter",
        "8": "Financial",
        "9": "Engineering",
        "10": "Logical",
        "11": "Operator",
        "12": "Text",
        "13": "Parser",
        "14": "Array",
        "15": "Other"
      },
      formulaMore: {
        valueTitle: "Value",
        tipSelectDataRange: "Select data range",
        tipDataRangeTile: "Data range",
        findFunctionTitle: "Search function",
        tipInputFunctionName: "Function name or brief description of function",
        whole: "Whole",
        Math: "Math",
        Statistical: "Statistical",
        Lookup: "Lookup",
        universheet: "UniverSheet",
        dataMining: "Data Mining",
        Database: "Database",
        Date: "Date",
        Filter: "Filter",
        Financial: "Financial",
        Engineering: "Engineering",
        Logical: "Logical",
        Operator: "Operator",
        Text: "Text",
        Parser: "Parser",
        Array: "Array",
        other: "Other",
        selectFunctionTitle: "Select a function",
        calculationResult: "Result",
        tipSuccessText: "Success",
        tipParamErrorText: "Parameter type error",
        helpClose: "Close",
        helpCollapse: "Collapse",
        helpExample: "Example",
        helpAbstract: "Abstract",
        execfunctionError: "Error in the formula",
        execfunctionSelfError: "The formula cannot refer to its own cell",
        execfunctionSelfErrorResult: "The formula cannot refer to its own cell, which will lead to inaccurate calculation results",
        allowRepeatText: "Repeat",
        allowOptionText: "Option",
        selectCategory: "Or select a category"
      },
      ifFormula: {
        tipNotBelongToIf: "This cell function does not belong to the if formula!",
        tipSelectCell: "Please select the cell to insert the function",
        ifGenCompareValueTitle: "Comparison value",
        ifGenSelectCellTitle: "Click to select cell",
        ifGenRangeTitle: "Range",
        ifGenRangeTo: "to",
        ifGenRangeEvaluate: "Range evaluate",
        ifGenSelectRangeTitle: "Click to select range",
        ifGenCutWay: "Partition way",
        ifGenCutSame: "Same Partition value",
        ifGenCutNpiece: "Partition by N",
        ifGenCutCustom: "Custom",
        ifGenCutConfirm: "Confirm",
        ifGenTipSelectCell: "Select cells",
        ifGenTipSelectCellPlace: "Please select cells",
        ifGenTipSelectRange: "Select range",
        ifGenTipSelectRangePlace: "Please select range",
        ifGenTipNotNullValue: "The comparison value cannot be empty!",
        ifGenTipLableTitile: "Label",
        ifGenTipRangeNotforNull: "The range cannot be empty!",
        ifGenTipCutValueNotforNull: "The partition value cannot be empty!",
        ifGenTipNotGenCondition: "No conditions are available for generation!"
      }
    }
  };

  // ../../packages/sheets-plugin-formula/src/Model/FormulaDataModel.ts
  var FormulaDataModel = class {
    _formulaData = {};
    _arrayFormulaData = {};
    _calculationChain = [];
    _recalculationMode = "Automatic" /* AUTOMATIC */;
    constructor(config) {
      if (config?.formulaData) {
        this._formulaData = config.formulaData;
      }
      if (config?.calculationChain) {
        this._calculationChain = config.calculationChain;
      }
      if (config?.recalculationMode) {
        this._recalculationMode = config.recalculationMode;
      }
    }
    getFormulaData() {
      return this._formulaData;
    }
    setFormulaData(value) {
      this._formulaData = value;
    }
    getArrayFormulaData() {
      return this._arrayFormulaData;
    }
    setArrayFormulaData(value) {
      Object.keys(value).forEach((sheetId) => {
        const arrayFormula = value[sheetId];
        if (!this._arrayFormulaData[sheetId]) {
          this._arrayFormulaData[sheetId] = new ObjectMatrix();
        }
        arrayFormula.forValue((r4, c4, v4) => {
          this._arrayFormulaData[sheetId].setValue(r4, c4, v4);
        });
      });
    }
  };

  // ../../packages/sheets-plugin-formula/src/View/UI/FormulaLabel.tsx
  var FormulaLabel = class extends Component {
    // private _render: BaseComponentRender;
    initialize() {
    }
    render() {
      const { label } = this.props;
      return <div style={{ display: "flex", alignItems: "center" }}>
        <Icon_exports.Data.SumIcon />
        {label}
      </div>;
    }
  };

  // ../../packages/sheets-plugin-formula/src/Controller/ArrayFormulaLineController.ts
  var LINE_COLOR = "#3969b9";
  var ArrayFormulaLineControl = class {
    /**
     * Create ArrayFormLineController
     * @param plugin
     */
    constructor(_plugin, _sheetId, _range) {
      this._plugin = _plugin;
      this._sheetId = _sheetId;
      this._range = _range;
      this._sheetPlugin = this._plugin.getContext().getPluginManager().getPluginByName("spreadsheet" /* SPREADSHEET */);
      this._initialize();
    }
    _sheetPlugin;
    _leftControl;
    _rightControl;
    _topControl;
    _bottomControl;
    _arrayFormulaLine;
    _initialize() {
      const { startRow, startColumn, endRow, endColumn } = this._range;
      const sheetId = this._sheetId;
      let workbook = this.getWorkBook();
      let worksheet = workbook.getSheetBySheetId(sheetId);
      if (worksheet == null) {
        throw new Error(`not found sheet from id: ${sheetId}`);
      }
      let rowTitleWidth = worksheet.getConfig().rowTitle.width;
      let columnTitleHeight = worksheet.getConfig().columnTitle.height;
      let rowManager = worksheet.getRowManager();
      let columnManager = worksheet.getColumnManager();
      let totalHeight = 0;
      let totalWidth = 0;
      for (let i4 = startRow; i4 < endRow; i4++) {
        totalHeight += rowManager.getRowHeight(i4);
      }
      for (let i4 = startColumn; i4 < endColumn; i4++) {
        totalWidth += columnManager.getColumnWidth(i4);
      }
      let offsetLeft = 0;
      let offsetTop = 0;
      for (let i4 = 0; i4 <= startRow - 1; i4++) {
        offsetTop += rowManager.getRowHeight(i4);
      }
      for (let i4 = 0; i4 <= startColumn - 1; i4++) {
        offsetLeft += columnManager.getColumnWidth(i4);
      }
      this._arrayFormulaLine = new Rect("__ArrayFormulaLineControl__" /* line */, {
        stroke: LINE_COLOR,
        strokeWidth: 1,
        left: offsetLeft + rowTitleWidth,
        top: offsetTop + columnTitleHeight,
        height: totalHeight,
        width: totalWidth,
        evented: false
      });
      this.getSheetViewScene().addObject(this._arrayFormulaLine);
    }
    /**
     * Return SheetView
     * @returns
     */
    getSheetView() {
      return this._sheetPlugin.getCanvasView().getSheetView();
    }
    /**
     * Return WorkBook
     * @returns Workbook
     */
    getWorkBook() {
      return this._sheetPlugin.getWorkbook();
    }
    /**
     * Return SheetView Scene
     * @returns
     */
    getSheetViewScene() {
      return this._sheetPlugin.getCanvasView().getSheetView().getScene();
    }
    dispose() {
      this._leftControl?.dispose();
      this._rightControl?.dispose();
      this._topControl?.dispose();
      this._bottomControl?.dispose();
      this._arrayFormulaLine?.dispose();
    }
  };

  // ../../packages/sheets-plugin-formula/src/Controller/FormulaController.tsx
  var FormulaController = class {
    constructor(_plugin, config) {
      this._plugin = _plugin;
      this._formulaDataModel = new FormulaDataModel(config);
      this._context = this._plugin.getContext();
      this._sheetPlugin = this._plugin.getContext().getPluginManager().getRequirePluginByName("spreadsheet" /* SPREADSHEET */);
      this._sheetUIPlugin = this._plugin.getUniver().getGlobalContext().getPluginManager().getRequirePluginByName(SHEET_UI_PLUGIN_NAME);
      this._activeSheetId = this._sheetPlugin.getWorkbook().getActiveSheet().getSheetId();
      this._initialize();
    }
    _formulaDataModel;
    _formulaEngine;
    _context;
    _interpreterCalculatePropsCache;
    _sheetPlugin;
    _sheetUIPlugin;
    _activeSheetId;
    _arrayFormulaLineControls = [];
    _initialize() {
      this._sheetPlugin.getContext().getContextObserver("onAfterChangeActiveSheetObservable").add(() => {
        this._activeSheetId = this._sheetPlugin.getWorkbook().getActiveSheet().getSheetId();
        this.clearArrayFormulaLineControl();
        this.renderArrayFormulaLineControl();
      });
      this._sheetPlugin.getObserver("onChangeSelectionObserver")?.add(() => {
        this.clearArrayFormulaLineControl();
        this.renderArrayFormulaLineControl();
      });
    }
    _initRegisterComponent() {
      this._plugin.getContext().getUniver().getGlobalContext().getPluginManager().getRequirePluginByName(SHEET_UI_PLUGIN_NAME).getAppUIController().getSheetContainerController().getMainSlotController().addSlot(FORMULA_PLUGIN_NAME + FormulaLabel.name, {
        component: FormulaLabel
      });
    }
    getDataModel() {
      return this._formulaDataModel;
    }
    setFormulaEngine(formulaEngine) {
      this._formulaEngine = formulaEngine;
    }
    getFormulaEngine() {
      return this._formulaEngine;
    }
    toInterpreterCalculateProps(isRefresh = true) {
      if (isRefresh || !this._interpreterCalculatePropsCache) {
        this._interpreterCalculatePropsCache = this._toInterpreterCalculateProps();
      }
      return this._interpreterCalculatePropsCache;
    }
    getCommandManager() {
      return this._context.getCommandManager();
    }
    getWorkbook() {
      return this._context.getWorkBook();
    }
    getUnitId() {
      return this.getWorkbook().getUnitId();
    }
    _toInterpreterCalculateProps() {
      const workbook = this._context.getWorkBook();
      const sheets = workbook.getSheets();
      const sheetData = {};
      const unitData = {};
      const sheetNameMap = {};
      const currentUnitId = workbook.getUnitId();
      for (let sheet of sheets) {
        sheetData[sheet.getSheetId()] = sheet.getCellMatrix();
        sheetNameMap[sheet.getName()] = sheet.getSheetId();
      }
      unitData[currentUnitId] = sheetData;
      const formulaData = this._formulaDataModel.getFormulaData();
      const activeSheet = workbook.getActiveSheet();
      const rowCount = activeSheet.getRowCount();
      const columnCount = activeSheet.getColumnCount();
      return {
        unitData,
        formulaData,
        sheetNameMap,
        currentRow: -1,
        currentColumn: -1,
        currentSheetId: "",
        currentUnitId,
        rowCount,
        columnCount
      };
    }
    addArrayFormulaData(value) {
      this._formulaDataModel.setArrayFormulaData(value);
      this.clearArrayFormulaLineControl();
      this.renderArrayFormulaLineControl();
    }
    clearArrayFormulaLineControl() {
      const arrayFormulaLineControls = this._arrayFormulaLineControls;
      if (arrayFormulaLineControls.length > 0) {
        for (let control of arrayFormulaLineControls) {
          control.dispose();
        }
      }
      this._arrayFormulaLineControls = [];
    }
    renderArrayFormulaLineControl() {
      const arrayFormulaData = this._formulaDataModel.getArrayFormulaData();
      const arrayFormula = arrayFormulaData[this._activeSheetId];
      if (!arrayFormula)
        return;
      const currentCellData = this._sheetPlugin.getSelectionManager().getCurrentCellData();
      arrayFormula.forValue((r4, c4, v4) => {
        const { startRow, startColumn, endRow, endColumn } = v4;
        if (currentCellData) {
          const { startRow: row, startColumn: column } = currentCellData;
          if (row >= startRow && row < endRow && column >= startColumn && column < endColumn) {
            this._arrayFormulaLineControls.push(new ArrayFormulaLineControl(this._plugin, this._activeSheetId, v4));
          }
        }
      });
    }
  };

  // ../../packages/sheets-plugin-formula/src/Controller/FirstLoader.ts
  function firstLoader(formulaController) {
    const dataModel = formulaController.getDataModel();
    const engine = formulaController.getFormulaEngine();
    const sheetDataPromise = engine.execute(formulaController.getUnitId(), dataModel.getFormulaData(), formulaController.toInterpreterCalculateProps(), true);
    const commandManager = formulaController.getCommandManager();
    const workBook = formulaController.getWorkbook();
    sheetDataPromise.then((data) => {
      if (!data)
        return;
      const { sheetData, arrayFormulaData } = data;
      if (!sheetData) {
        return;
      }
      const sheetIds = Object.keys(sheetData);
      const actionList = [];
      for (let i4 = 0, len = sheetIds.length; i4 < len; i4++) {
        const sheetId = sheetIds[i4];
        const cellData = sheetData[sheetId];
        cellData.forValue((row, column, mainCell) => {
          const action = {
            actionName: "SetRangeDataAction" /* SET_RANGE_DATA_ACTION */,
            sheetId,
            cellValue: {
              [row]: {
                [column]: mainCell
              }
            }
          };
          actionList.push(ActionOperation.make(action).removeCollaboration().removeUndo().removeExtension().getAction());
        });
      }
      const command = new Command({ WorkBookUnit: workBook }, ...actionList);
      commandManager.invoke(command);
    });
  }

  // ../../packages/sheets-plugin-formula/src/Basic/Register/FormulaCellEditExtension.ts
  var FormulaCellEditExtension = class extends BaseCellEditExtension {
    setValue(value) {
      this._cell.value = value;
    }
    execute() {
      this.setValue(this._value);
    }
  };
  var FormulaCellEditExtensionFactory = class extends BaseCellEditExtensionFactory {
    get zIndex() {
      return 0;
    }
    create(cell, value) {
      return new FormulaCellEditExtension(cell, value);
    }
    check(cell) {
      const unitId = this._plugin.getContext().getWorkBook().getUnitId();
      let formula = this.checkFormulaValue(cell) || this.checkArrayFormValue(cell, unitId);
      if (formula !== "" && !formula) {
        return false;
      }
      return this.create(cell, formula);
    }
    checkFormulaValue(cell) {
      const { row, column } = cell;
      let formula;
      const formulaData = this._plugin.getFormulaController().getDataModel().getFormulaData();
      Object.keys(formulaData).forEach((unitId) => {
        const sheetData = formulaData[unitId];
        const sheetIds = Object.keys(sheetData);
        for (let i4 = 0, len = sheetIds.length; i4 < len; i4++) {
          const sheetId = sheetIds[i4];
          const cellData = sheetData[sheetId];
          Object.keys(cellData).forEach((cellRow) => {
            const rowArray = cellData[cellRow];
            rowArray.forEach((cellColumn, value) => {
              if (Number(cellRow) === row && cellColumn === column) {
                formula = this._plugin.getFormulaPromptController().cellInputHandler.functionHTMLGenerate(value.formula);
                return false;
              }
            });
          });
        }
      });
      return formula;
    }
    checkArrayFormValue(cell, unitId) {
      const { row, column } = cell;
      let formula;
      const arrayFormulaData = this._plugin.getFormulaController().getDataModel().getArrayFormulaData();
      if (!arrayFormulaData)
        return null;
      Object.keys(arrayFormulaData).forEach((sheetId) => {
        const sheetData = arrayFormulaData[sheetId];
        sheetData.forValue((rowIndex, columnIndex, value) => {
          const { startRow, startColumn, endRow, endColumn } = value;
          if (row >= startRow && row < endRow && column >= startColumn && column < endColumn) {
            formula = "";
            this._plugin.getContext().getPluginManager().getRequirePluginByName(SHEET_UI_PLUGIN_NAME).setFormulaContent("");
            return false;
          }
        });
      });
      return formula;
    }
  };

  // ../../packages/sheets-plugin-formula/src/Basic/Register/FormulaCellInputExtension.ts
  var FormulaCellInputExtension = class extends BaseCellInputExtension {
    setValue(value) {
      this._cell.value = value;
    }
    execute() {
      this.setValue(this._value);
    }
  };
  var FormulaCellInputExtensionFactory = class extends BaseCellInputExtensionFactory {
    get zIndex() {
      return 0;
    }
    create(cell, value) {
      return new FormulaCellInputExtension(cell, value);
    }
    check(cell) {
      const unitId = this._plugin.getContext().getWorkBook().getUnitId();
      let formula = this.checkFormulaValue(cell) || this.checkArrayFormValue(cell, unitId);
      if (!formula) {
        return false;
      }
      return this.create(cell, formula);
    }
    checkFormulaValue(cell) {
      const { row, column } = cell;
      let formula;
      const formulaData = this._plugin.getFormulaController().getDataModel().getFormulaData();
      Object.keys(formulaData).forEach((unitId) => {
        const sheetData = formulaData[unitId];
        const sheetIds = Object.keys(sheetData);
        for (let i4 = 0, len = sheetIds.length; i4 < len; i4++) {
          const sheetId = sheetIds[i4];
          const cellData = sheetData[sheetId];
          Object.keys(cellData).forEach((cellRow) => {
            const rowArray = cellData[cellRow];
            rowArray.forEach((cellColumn, value) => {
              if (Number(cellRow) === row && cellColumn === column) {
                formula = value.formula;
                return false;
              }
            });
          });
        }
      });
      return formula;
    }
    checkArrayFormValue(cell, unitId) {
      const { row, column } = cell;
      let formula;
      const formulaData = this._plugin.getFormulaController().getDataModel().getFormulaData();
      const arrayFormulaData = this._plugin.getFormulaController().getDataModel().getArrayFormulaData();
      if (!arrayFormulaData)
        return null;
      Object.keys(arrayFormulaData).forEach((sheetId) => {
        const sheetData = arrayFormulaData[sheetId];
        sheetData.forValue((rowIndex, columnIndex, value) => {
          const { startRow, startColumn, endRow, endColumn } = value;
          if (row >= startRow && row < endRow && column >= startColumn && column < endColumn) {
            const cellData = formulaData[unitId][sheetId];
            formula = cellData[startRow].get(startColumn).formula;
            return false;
          }
        });
      });
      return formula;
    }
  };

  // ../../packages/sheets-plugin-formula/src/Basic/Register/FormulaActionExtension.ts
  var FormulaActionExtension = class extends BaseActionExtension {
    execute() {
      const engine = this._plugin.getFormulaEngine();
      const formulaController = this._plugin.getFormulaController();
      const formulaDataModel = formulaController.getDataModel();
      const formulaData = Tools.deepClone(formulaDataModel.getFormulaData());
      const unitId = this._plugin.getContext().getWorkBook().getUnitId();
      const actionDataList = this.actionDataList;
      const unitRange = [];
      let isCalculate = false;
      actionDataList.forEach((actionData) => {
        if (actionData.operation != null && !ActionOperation.hasExtension(actionData)) {
          return false;
        }
        if (actionData.actionName !== "SetRangeDataAction" /* SET_RANGE_DATA_ACTION */) {
          return false;
        }
        const { sheetId, cellValue } = actionData;
        if (Tools.isEmptyObject(formulaData))
          return;
        if (!formulaData[unitId][sheetId]) {
          formulaData[unitId][sheetId] = {};
        }
        const cellData = new ObjectMatrix(formulaData[unitId][sheetId]);
        if (cellValue == null) {
          return;
        }
        const rangeMatrix = new ObjectMatrix(cellValue);
        let isArrayForm = false;
        rangeMatrix.forValue((r4, c4, cell) => {
          const arrayFormCellRangeData = this.checkArrayFormValue(r4, c4);
          const formulaString = cell.m;
          if (arrayFormCellRangeData && formulaString === "") {
            isArrayForm = true;
            isCalculate = true;
            unitRange.push({
              unitId,
              sheetId,
              rangeData: arrayFormCellRangeData
            });
          } else if (Tools.isStringNumber(formulaString)) {
            isCalculate = true;
            const formulaCell = cellData.getRow(r4)?.get(c4);
            if (formulaCell) {
              cellData.deleteValue(r4, c4);
            }
          } else if (isFormulaString(formulaString)) {
            isCalculate = true;
            cellData.setValue(r4, c4, {
              formula: formulaString,
              row: r4,
              column: c4,
              sheetId
            });
          }
        });
        if (!isArrayForm) {
          unitRange.push({
            unitId,
            sheetId,
            rangeData: rangeMatrix.getDataRange()
          });
        }
      });
      if (unitRange.length === 0 || !isCalculate)
        return;
      engine.execute(unitId, formulaData, formulaController.toInterpreterCalculateProps(), false, unitRange).then((data) => {
        const { sheetData, arrayFormulaData } = data;
        if (!sheetData) {
          console.error("No sheetData from Formula Engine!");
          return;
        }
        if (arrayFormulaData) {
          this._plugin.getFormulaController().addArrayFormulaData(arrayFormulaData);
        }
        const sheetIds = Object.keys(sheetData);
        const actionDatas = [];
        sheetIds.forEach((sheetId) => {
          const cellData = sheetData[sheetId];
          cellData.forValue((r4, c4, value) => {
            const cellCalculate = cellData.getValue(r4, c4);
            if (cellCalculate && cellCalculate.p) {
              delete cellCalculate.p;
            }
            if (cellCalculate && Number.isNaN(cellCalculate.v)) {
              cellCalculate.v = 0;
            }
            const action = {
              actionName: "SetRangeDataAction" /* SET_RANGE_DATA_ACTION */,
              sheetId,
              cellValue: {
                [r4]: {
                  [c4]: cellCalculate || {}
                }
              }
            };
            const actionData = ActionOperation.make(action).removeCollaboration().removeUndo().removeExtension().getAction();
            actionDatas.push(actionData);
          });
        });
        const setFormulaDataAction = {
          actionName: "SetFormulaRangeDataAction" /* SET_FORMULA_RANGE_DATA_ACTION */,
          sheetId: actionDataList[0].sheetId,
          // Any sheetId can be passed in, it has no practical effect
          formulaData
        };
        const workBook = this._plugin.getContext().getWorkBook();
        const commandManager = this._plugin.getContext().getCommandManager();
        const command = new Command({ WorkBookUnit: workBook }, ...actionDatas, setFormulaDataAction);
        commandManager.invoke(command);
      });
    }
    checkArrayFormValue(row, column) {
      let formula;
      const arrayFormulaData = this._plugin.getFormulaController().getDataModel().getArrayFormulaData();
      if (!arrayFormulaData)
        return null;
      Object.keys(arrayFormulaData).forEach((sheetId) => {
        const sheetData = arrayFormulaData[sheetId];
        sheetData.forValue((rowIndex, columnIndex, value) => {
          const { startRow, startColumn, endRow, endColumn } = value;
          if (row >= startRow && row < endRow && column >= startColumn && column < endColumn) {
            formula = {
              startRow,
              endRow: startRow,
              startColumn,
              endColumn: startColumn
            };
            return false;
          }
        });
      });
      return formula;
    }
  };
  var FormulaActionExtensionFactory = class extends BaseActionExtensionFactory2 {
    get zIndex() {
      return 1;
    }
    create(actionDataList) {
      return new FormulaActionExtension(actionDataList, this._plugin);
    }
  };

  // ../../packages/sheets-plugin-formula/src/Basic/Observer.ts
  function install2(plugin) {
    plugin.pushToObserve("onSearchFormulaModalDidMountObservable");
    plugin.pushToObserve("onSearchItemDidMountObservable");
    plugin.pushToObserve("onSearchFunctionDidMountObservable");
    plugin.pushToObserve("onHelpFunctionDidMountObservable");
  }

  // stylePlugin:D:\code\github\univer\packages\sheets-plugin-formula\src\View\UI\SearchFormulaModal\index.module.less
  var index_module_default37 = {
    "functionModal": "univer-function-modal",
    "functionSearch": "univer-function-search",
    "functionSelect": "univer-function-select",
    "functionLabel": "univer-function-label",
    "functionSelector": "univer-function-selector",
    "selectButton": "univer-select-button",
    "functionList": "univer-function-list",
    "functionLists": "univer-function-lists",
    "functionListsItem": "univer-function-lists-item",
    "functionListsItemActive": "univer-function-lists-item-active",
    "functionParamModal": "univer-function-param-modal",
    "functionParamList": "univer-function-param-list",
    "functionParamDesc": "univer-function-param-desc",
    "functionParamDescDetails": "univer-function-param-desc-details",
    "functionBtn": "univer-function-btn",
    "btn": "univer-btn"
  };

  // ../../packages/sheets-plugin-formula/src/View/UI/SearchFormulaModal/SearchFormulaContent.tsx
  var SearchFormulaContent = class extends Component {
    _render;
    functionListRef = d();
    initialize() {
      const component = this.getContext().getPluginManager().getPluginByName("ComponentSheet");
      this._render = component.getComponentRender();
      const functionList = this.props.funList.children?.filter((item) => item.t === 0);
      this.state = {
        functionList,
        type: 0
      };
    }
    changeInput(e4) {
      const value = e4.target.value;
      let { functionList, type } = this.state;
      if (value) {
        functionList = functionList?.filter((item) => {
          if (item.n?.includes(value) || item.d?.includes(value)) {
            return item;
          }
          return null;
        });
      } else {
        functionList = this.props.funList.children?.filter((item) => item.t === type);
      }
      this.setState({
        functionList
      });
    }
    selectType(value, index) {
      const { funList } = this.props;
      const children = funList.children?.filter((item) => item.t === index);
      this.setState(
        {
          functionList: children,
          type: index
        },
        () => {
          this.highLightLi(0);
        }
      );
    }
    componentDidMount() {
      this.highLightLi(0);
    }
    highLightLi(index) {
      const item = this.functionListRef.current.querySelectorAll(`.${index_module_default37.functionListsItem}`);
      for (let i4 = 0; i4 < item.length; i4++) {
        item[i4].classList.remove(index_module_default37.functionListsItemActive);
      }
      item[index].classList.add(index_module_default37.functionListsItemActive);
      item[index].click();
    }
    handleClick(item, index) {
      const { funList } = this.props;
      this.highLightLi(index);
      funList.onClick(item);
    }
    render() {
      const Input2 = this._render.renderFunction("Input");
      const { input, select, funList } = this.props;
      const { functionList } = this.state;
      if (!input)
        return;
      return <div className={index_module_default37.functionModal}>
        <div className={index_module_default37.functionSearch}>
          <div className={index_module_default37.functionLabel}>{input.label}</div>
          <Input2 placeholder={input.placeholder} onChange={debounce(this.changeInput.bind(this), 50)} />
        </div>
        <div className={index_module_default37.functionSelect}>
          <div className={index_module_default37.functionLabel}>{select.label}</div>
          <div className={index_module_default37.functionSelector}><Select onClick={this.selectType.bind(this)} type={0} children={select.children} hideSelectedIcon={true} /></div>
        </div>
        <div className={index_module_default37.functionList} ref={this.functionListRef}>
          <div className={index_module_default37.functionLabel}>{funList.label}</div>
          <ul className={index_module_default37.functionLists}>{functionList?.map((item, index) => <li className={`${index_module_default37.functionListsItem}`} onClick={() => this.handleClick(item, index)}>
            <div className={index_module_default37.functionListsItemName}>{item.n}</div>
            <div className={index_module_default37.functionListsItemDetail}>{item.d}</div>
          </li>)}</ul>
        </div>
      </div>;
    }
  };

  // ../../packages/sheets-plugin-formula/src/View/UI/SearchFormulaModal/SearchFormulaModal.tsx
  var SearchFormulaModal = class extends Component {
    _render;
    initialize() {
      const component = this._context.getPluginManager().getPluginByName("ComponentSheet");
      this._render = component.getComponentRender();
      this.state = {
        modalData: []
      };
    }
    componentDidMount() {
      const plugin = this._context.getPluginManager().getPluginByName(FORMULA_PLUGIN_NAME);
      plugin.getObserver("onSearchFormulaModalDidMountObservable").notifyObservers(this);
    }
    setModal(modalData) {
      const SheetPlugin3 = this._context.getPluginManager().getPluginByName("spreadsheet" /* SPREADSHEET */);
      modalData.forEach((item) => {
        const Label = SheetPlugin3.getRegisterComponent(item.children.name);
        if (Label) {
          const props = item.children.props ?? {};
          item.modal = <Label {...props} />;
        }
      });
      this.setState({
        modalData
      });
    }
    render() {
      const Modal2 = this._render.renderFunction("Modal");
      const { modalData } = this.state;
      return <>{modalData.map((item) => {
        if (!item.show)
          return;
        return <Modal2 isDrag={true} mask={item.mask} title={item.label?.funParams.n} visible={item.show} group={item.group} onCancel={item.onCancel}>{item.modal}</Modal2>;
      })}</>;
    }
  };

  // ../../packages/sheets-plugin-formula/src/View/UI/SearchFormulaModal/SearchItem.tsx
  var SearchItem = class extends Component {
    initialize() {
      this.state = {
        description: {},
        rangeList: [],
        index: 0
      };
    }
    componentDidMount() {
      const plugin = this.getContext().getPluginManager().getPluginByName(FORMULA_PLUGIN_NAME);
      plugin.getObserver("onSearchItemDidMountObservable").notifyObservers(this);
      const { funParams } = this.props;
      const description = funParams?.funParams.p?.[0];
      this.setState({
        description
      });
    }
    handleClick(index) {
      const { funParams } = this.props;
      const description = funParams?.funParams.p?.[index];
      this.setState({
        description,
        index
      });
    }
    changeRange(range2) {
      const { index, rangeList } = this.state;
      rangeList[index] = range2;
      this.setState({
        rangeList
      });
    }
    render() {
      const { funParams, calc, onTableClick } = this.props;
      const { description, rangeList } = this.state;
      if (!funParams)
        return;
      return <div className={index_module_default37.functionParamModal}>
        <div className={index_module_default37.functionParamList}>{funParams.funParams?.p?.map((item, index) => <div>
          <span>
            {item.name}
            {"\uFF1A"}
          </span>
          <CellRange onTableClick={onTableClick} value={rangeList[index]} onClick={() => this.handleClick(index)} />
          <span>
            {"="}
            {"{}"}
          </span>
        </div>)}</div>
        <div className={index_module_default37.functionParamDesc}>
          <div className={index_module_default37.functionParamDescDetail}>{funParams.funParams?.d}</div>
          <div className={index_module_default37.functionParamDescDetails}><p>
            {description.name}
            {": "}
            {description.detail}
          </p></div>
        </div>
        <div className={index_module_default37.functionParamResult}>
          {calc}
          {"="}
          {}
        </div>
      </div>;
    }
  };

  // ../../packages/sheets-plugin-formula/src/Controller/SearchFormulaModalController.ts
  var SearchFormulaController = class {
    _plugin;
    _modalData;
    _formulaModal;
    _searchItem;
    _funParams;
    _cellRangeModalData;
    constructor(plugin) {
      this._plugin = plugin;
      this._funParams = {
        funParams: {}
      };
      this._modalData = [
        {
          name: "SearchFormula",
          show: false,
          group: [
            {
              locale: "button.confirm",
              type: "primary",
              onClick: this.showSearchItemModal.bind(this)
            },
            {
              locale: "button.cancel"
            }
          ],
          onCancel: () => this.showFormulaModal("SearchFormula", false),
          children: {
            name: FORMULA_PLUGIN_NAME + SearchFormulaContent.name,
            props: {
              input: {
                locale: "formula.formulaMore.findFunctionTitle",
                placeholderLocale: "formula.formulaMore.tipInputFunctionName"
              },
              select: {
                locale: "formula.formulaMore.selectCategory",
                children: SelectCategoryType
              },
              funList: {
                onClick: this.selectFunParams.bind(this),
                locale: "formula.formulaMore.selectFunctionTitle",
                children: FunList
              }
            }
          }
        },
        {
          name: "SearchItem",
          label: this._funParams,
          show: false,
          mask: false,
          group: [
            {
              locale: "button.confirm",
              type: "primary"
            },
            {
              locale: "button.cancel"
            }
          ],
          onCancel: () => this.showFormulaModal("SearchItem", false),
          children: {
            name: FORMULA_PLUGIN_NAME + SearchItem.name,
            props: {
              funParams: this._funParams,
              calcLocale: "formula.formulaMore.calculationResult",
              range: "A1:B10",
              onTableClick: () => this.showCellRangeModal(true)
            }
          }
        }
      ];
      this._cellRangeModalData = {
        name: "cellRangeModal",
        titleLocale: "formula.formulaMore.tipSelectDataRange",
        show: false,
        mask: false,
        group: [
          {
            locale: "button.confirm",
            type: "primary"
          }
        ],
        onCancel: () => this.showFormulaModal("cellRangeModal", false),
        children: {
          props: {
            placeholderLocale: ""
          }
        }
      };
      this._initialize();
    }
    _initialize() {
      this._plugin.getObserver("onSearchFormulaModalDidMountObservable").add((component) => {
        this._formulaModal = component;
        this._modalData = this._resetLabel(this._modalData);
        this._cellRangeModalData = this._resetLabel(this._cellRangeModalData);
      });
      this._plugin.getObserver("onSearchItemDidMountObservable").add((component) => {
        this._searchItem = component;
      });
      const sheetPlugin = this._plugin.getContext().getPluginManager().getPluginByName("spreadsheet" /* SPREADSHEET */);
      sheetPlugin.getObserver("onChangeSelectionObserver")?.add((selection) => {
        const info = selection.getCurrentCellInfo();
      });
    }
    _initRegisterComponent() {
      const sheetPlugin = this._plugin.getContext().getPluginManager().getPluginByName("spreadsheet" /* SPREADSHEET */);
      sheetPlugin.registerModal(FORMULA_PLUGIN_NAME + SearchFormulaModal.name, SearchFormulaModal);
      sheetPlugin.registerModal(FORMULA_PLUGIN_NAME + SearchItem.name, SearchItem);
      sheetPlugin.registerComponent(FORMULA_PLUGIN_NAME + SearchFormulaContent.name, SearchFormulaContent);
    }
    _resetLocale(label) {
      const locale = this._plugin.context.getLocale();
      let str = "";
      if (label instanceof Array) {
        label.forEach((item) => {
          if (item.includes(".")) {
            str += locale.get(item);
          } else {
            str += item;
          }
        });
      } else {
        if (label.includes(".")) {
          str = locale.get(label);
        } else {
          str += label;
        }
      }
      return str;
    }
    _findLocale(obj) {
      for (let k5 in obj) {
        if (k5 === "locale") {
          obj.label = this._resetLocale(obj[k5]);
        } else if (k5.endsWith("Locale")) {
          const index = k5.indexOf("Locale");
          obj[k5.slice(0, index)] = this._resetLocale(obj[k5]);
        } else if (!obj[k5].$$typeof) {
          if (Object.prototype.toString.call(obj[k5]) === "[object Object]") {
            this._findLocale(obj[k5]);
          } else if (Object.prototype.toString.call(obj[k5]) === "[object Array]") {
            this._resetLabel(obj[k5]);
          }
        }
      }
      return obj;
    }
    _resetLabel(list) {
      if (list instanceof Array) {
        for (let i4 = 0; i4 < list.length; i4++) {
          let item = list[i4];
          item = this._findLocale(item);
          if (item.children) {
            item.children = this._resetLabel(item.children);
          }
        }
        return list;
      }
      if (list instanceof Object) {
        list = this._findLocale(list);
        return list;
      }
    }
    selectFunParams(value) {
      this._funParams.funParams = value;
    }
    showFormulaModal(name, show) {
      const index = this._modalData.findIndex((item) => item.name === name);
      if (index > -1) {
        this._modalData[index].show = show;
        this._formulaModal.setModal(this._modalData);
      }
    }
    showCellRangeModal(show) {
      this._cellRangeModalData.show = show;
      const sheetPlugin = this._plugin.getPluginByName("spreadsheet" /* SPREADSHEET */);
      this.showFormulaModal("SearchItem", false);
    }
    showSearchItemModal() {
      this.showFormulaModal("SearchFormula", false);
      this.showFormulaModal("SearchItem", true);
    }
  };

  // stylePlugin:D:\code\github\univer\packages\sheets-plugin-formula\src\View\UI\FormulaPrompt\index.module.less
  var index_module_default38 = {
    "searchFunction": "univer-search-function",
    "formulaDetail": "univer-formula-detail",
    "searchFunctionActive": "univer-search-function-active",
    "helpFunction": "univer-help-function",
    "helpFunctionTitle": "univer-help-function-title",
    "helpFunctionContent": "univer-help-function-content",
    "helpFunctionContentParams": "univer-help-function-content-params",
    "helpFunctionContentTitle": "univer-help-function-content-title",
    "helpFunctionContentDetail": "univer-help-function-content-detail",
    "helpFunctionActive": "univer-help-function-active"
  };

  // ../../packages/sheets-plugin-formula/src/View/UI/FormulaPrompt/HelpFunction.tsx
  var HelpFunction = class extends Component {
    contentRef = d();
    initialize() {
      this.state = {
        activeIndex: 0,
        functionInfo: {},
        helpFormulaActive: false,
        position: {
          left: 0,
          top: 0
        }
      };
    }
    componentWillMount() {
    }
    componentDidMount() {
    }
    updateState(helpFormulaActive, activeIndex = 0, functionInfo = {}, position = { left: 0, top: 0 }, cb) {
      this.setState(
        {
          helpFormulaActive,
          functionInfo,
          activeIndex,
          position
        },
        cb
      );
    }
    getState() {
      return this.state;
    }
    getContentRef() {
      return this.contentRef;
    }
    render(props, state) {
      const { activeIndex, functionInfo, helpFormulaActive, position } = state;
      return <div
        className={index_module_default38.helpFunction}
        style={{ display: helpFormulaActive ? "block" : "none", position: "absolute", left: `${position.left}px`, top: `${position.top}px` }}
        ref={this.contentRef}
      >
        <div class={index_module_default38.helpFunctionTitle}><Help title={functionInfo.n} value={functionInfo.p} type="name" active={activeIndex} /></div>
        <div className={index_module_default38.helpFunctionContent}>
          <div>{this.getLocale("formula.formulaMore.helpExample")}</div>
          <Help title={functionInfo.n} value={functionInfo.p} type="example" active={activeIndex} />
          <Params title={this.getLocale("formula.formulaMore.helpAbstract")} value={this.getLocale(functionInfo.d)} />
          <>{functionInfo && functionInfo.p && functionInfo.p.map((item, i4) => <Params
            className={activeIndex === i4 ? index_module_default38.helpFunctionActive : ""}
            title={this.getLocale(item.name)}
            value={this.getLocale(item.detail)}
            active={activeIndex}
          />)}</>
        </div>
      </div>;
    }
  };
  var Params = (props) => <div className={`${index_module_default38.helpFunctionContentParams} ${props.className}`}>
    <div className={index_module_default38.helpFunctionContentTitle}>{props.title}</div>
    <div className={index_module_default38.helpFunctionContentDetail}>{props.value}</div>
  </div>;
  var Help = class extends Component {
    render(props, state) {
      return <div>
        <span>
          {props.title}
          {"("}
        </span>
        {props.value && props.value.map((item, i4) => <span className={props.active === i4 ? index_module_default38.helpFunctionActive : ""}>
          {this.getLocale(item[`${props.type}`])}
          {","}
        </span>)}
        <span>)</span>
      </div>;
    }
  };

  // ../../packages/sheets-plugin-formula/src/View/UI/FormulaPrompt/SearchFunction.tsx
  var SearchFunction = class extends Component {
    contentRef = d();
    initialize() {
      this.state = {
        lang: "",
        locale: [],
        formulaValue: "",
        functionList: [],
        selectIndex: 0,
        formula: [],
        searchActive: false,
        position: {
          left: 0,
          top: 0
        }
      };
    }
    componentDidMount() {
    }
    componentWillUpdate(nextProps) {
    }
    onKeyDown(event) {
    }
    getContentRef() {
      return this.contentRef;
    }
    /**
     *
     * @param searchActive
     * @param formula
     * @param selectIndex
     */
    updateState(searchActive, formula = [], selectIndex = 0, position = { left: 0, top: 0 }, cb) {
      this.setState({ searchActive, formula, selectIndex, position }, cb);
    }
    getState() {
      return this.state;
    }
    render(props, state) {
      const { selectIndex, formula, searchActive, position } = state;
      return <ul
        className={index_module_default38.searchFunction}
        onKeyDown={this.onKeyDown.bind(this)}
        style={{ display: searchActive ? "block" : "none", position: "absolute", left: `${position.left}px`, top: `${position.top}px` }}
        ref={this.contentRef}
      >{formula.map((item, i4) => <li className={selectIndex === i4 ? index_module_default38.searchFunctionActive : ""}>
        <div className={index_module_default38.formulaName}>{item.n}</div>
        <div className={index_module_default38.formulaDetail}>{this.getLocale(item.d)}</div>
      </li>)}</ul>;
    }
  };

  // ../../packages/sheets-plugin-formula/src/Controller/CellInputHandler.ts
  var LUCKY_COLOR = [
    "#c1232b",
    "#27727b",
    "#fcce10",
    "#e87c25",
    "#b5c334",
    "#fe8463",
    "#9bca63",
    "#fad860",
    "#f3a43b",
    "#60c0dd",
    "#d7504b",
    "#c6e579",
    "#f4e001",
    "#f0805a",
    "#26c0c0",
    "#c12e34",
    "#e6b600",
    "#0098d9",
    "#2b821d",
    "#005eaa",
    "#339ca8",
    "#cda819",
    "#32a487",
    "#3fb1e3",
    "#6be6c1",
    "#626c91",
    "#a0a7e6",
    "#c4ebad",
    "#96dee8"
  ];
  var CellInputHandler = class {
    functionHTMLIndex;
    functionRangeIndex;
    operator;
    operatorjson;
    rangestart;
    rangedrag_column_start;
    rangedrag_row_start;
    // inputValue: string;
    formula;
    functionlistPosition;
    funcName;
    paramindex;
    searchFunctionCell;
    editor;
    constructor(ele) {
      this.functionHTMLIndex = 0;
      this.functionRangeIndex = [];
      this.operator = "===|!==|<>|<=|>=|=|+|-|>|<|/|*|%|&|^";
      this.operatorjson = this.covertOperatorjson();
      this.rangestart = false;
      this.rangedrag_column_start = false;
      this.rangedrag_row_start = false;
      this.functionlistPosition = {};
      this.editor = ele;
    }
    covertOperatorjson() {
      let arr = this.operator.split("|");
      let op = {};
      for (let i4 = 0; i4 < arr.length; i4++) {
        op[arr[i4].toString()] = 1;
      }
      return op;
    }
    getFormula() {
      return this.formula || [];
    }
    getInputValue() {
      return this.editor.innerHTML;
    }
    /**
     * update value and html
     * @param value
     */
    setInputValue(value) {
      this.editor.innerHTML = xssDeal(value);
    }
    getHelpFormula() {
      return [this.funcName, this.paramindex];
    }
    getFunctionlistPosition() {
      return this.functionlistPosition;
    }
    /**
     * An entry that handles input events
     *
     * @param $input
     * @param kcode
     */
    functionInputHandler($input, kcode) {
      let _this = this;
      let $editer = $input;
      let value1 = $editer.innerHTML;
      let value1txt = $editer.textContent || "";
      setTimeout(() => {
        let value = $editer.textContent || "";
        let valuetxt = value;
        value = xssDeal(value);
        _this.funcName = null;
        if (value.length > 0 && value.substr(0, 1) === "=" && (kcode !== 229 || value.length === 1)) {
          value = _this.functionHTMLGenerate(value);
          value1 = _this.functionHTMLGenerate(value1txt);
          let currSelection = window.getSelection();
          if (currSelection) {
            if (currSelection?.anchorNode instanceof HTMLElement && currSelection.anchorNode?.matches("div")) {
              let editorlen = $$("span", $editer).length;
              _this.functionRangeIndex = [editorlen - 1, $$("span", $editer)[editorlen - 1].textContent.length];
            } else {
              _this.functionRangeIndex = [getNodeindex(currSelection.anchorNode?.parentNode), currSelection.anchorOffset];
            }
          } else {
            let textRange = document.selection.createRange();
            _this.functionRangeIndex = textRange;
          }
          $editer.innerHTML = value;
          _this.functionRange($editer, value, value1);
          _this.canceFunctionrangeSelected();
          if (kcode !== 46) {
          }
          _this.rangestart = false;
          _this.rangedrag_column_start = false;
          _this.rangedrag_row_start = false;
          const current = _this.getrangeseleciton();
          _this.helpFunctionExe($editer, current);
        } else if (value1txt.substr(0, 1) !== "=") {
        } else {
        }
      }, 1);
    }
    findrangeindex(v4, vp) {
      let _this = this;
      let re2 = /<span.*?>/g;
      let v_a_string = v4.replace(re2, "");
      let vp_a_string = vp.replace(re2, "");
      let v_a = v_a_string.split("</span>");
      let vp_a = vp_a_string.split("</span>");
      v_a.pop();
      vp_a.pop();
      let pfri = _this.functionRangeIndex;
      let spanlen = vp_a.length > v_a.length ? v_a.length : vp_a.length;
      let vplen = vp_a.length;
      let vlen = v_a.length;
      if (vplen === vlen) {
        let i4 = pfri[0];
        let p4 = vp_a[i4];
        let n3 = v_a[i4];
        if (p4 == null) {
          if (vp_a.length <= i4) {
            pfri = [vp_a.length - 1, vp_a.length - 1];
          } else if (v_a.length <= i4) {
            pfri = [v_a.length - 1, v_a.length - 1];
          }
          return pfri;
        }
        if (p4.length === n3.length) {
          if (vp_a[i4 + 1] != null && v_a[i4 + 1] != null && vp_a[i4 + 1].length < v_a[i4 + 1].length) {
            pfri[0] += 1;
            pfri[1] = 1;
          }
          return pfri;
        }
        if (p4.length > n3.length) {
          if (p4 != null && v_a[i4 + 1] != null && v_a[i4 + 1].substr(0, 1) === '"' && (p4.indexOf("{") > -1 || p4.indexOf("}") > -1)) {
            pfri[0] += 1;
            pfri[1] = 1;
          }
          return pfri;
        }
        if (p4.length < n3.length) {
          if (pfri[1] > n3.length) {
            pfri[1] = n3.length;
          }
          return pfri;
        }
      } else if (vplen > vlen) {
        let i4 = pfri[0];
        let p4 = vp_a[i4];
        let n3 = v_a[i4];
        if (n3 == null) {
          if (v_a[i4 - 1].indexOf("{") > -1) {
            pfri[0] -= 1;
            let start = v_a[i4 - 1].search("{");
            pfri[1] += start;
          } else {
            pfri[0] = 0;
            pfri[1] = 0;
          }
        } else if (p4.length === n3.length) {
          if (v_a[i4 + 1] != null && (v_a[i4 + 1].substr(0, 1) === '"' || v_a[i4 + 1].substr(0, 1) === "{" || v_a[i4 + 1].substr(0, 1) === "}")) {
            pfri[0] += 1;
            pfri[1] = 1;
          } else if (p4 != null && p4.length > 2 && p4.substr(0, 1) === '"' && p4.substr(p4.length - 1, 1) === '"') {
          } else if (v_a[i4] != null && v_a[i4] === '")') {
            pfri[1] = 1;
          } else if (v_a[i4] != null && v_a[i4] === '"}') {
            pfri[1] = 1;
          } else if (v_a[i4] != null && v_a[i4] === "{)") {
            pfri[1] = 1;
          } else {
            pfri[1] = n3.length;
          }
          return pfri;
        } else if (p4.length > n3.length) {
          if (v_a[i4 + 1] != null && (v_a[i4 + 1].substr(0, 1) === '"' || v_a[i4 + 1].substr(0, 1) === "{" || v_a[i4 + 1].substr(0, 1) === "}")) {
            pfri[0] += 1;
            pfri[1] = 1;
          }
          return pfri;
        } else if (p4.length < n3.length) {
          return pfri;
        }
        return pfri;
      } else if (vplen < vlen) {
        let i4 = pfri[0];
        let p4 = vp_a[i4];
        let n3 = v_a[i4];
        if (p4 == null) {
          pfri[0] = v_a.length - 1;
          if (n3 != null) {
            pfri[1] = n3.length;
          } else {
            pfri[1] = 1;
          }
        } else if (p4.length === n3.length) {
          if (vp_a[i4 + 1] != null && (vp_a[i4 + 1].substr(0, 1) === '"' || vp_a[i4 + 1].substr(0, 1) === "{" || vp_a[i4 + 1].substr(0, 1) === "}")) {
            pfri[1] = n3.length;
          } else if (v_a[i4 + 1] != null && v_a[i4 + 1].substr(0, 1) === '"' && (v_a[i4 + 1].substr(0, 1) === "{" || v_a[i4 + 1].substr(0, 1) === "}")) {
            pfri[0] += 1;
            pfri[1] = 1;
          } else if (n3 != null && n3.substr(0, 1) === '"' && n3.substr(n3.length - 1, 1) === '"' && p4.substr(0, 1) === '"' && p4.substr(p4.length - 1, 1) === ")") {
            pfri[1] = n3.length;
          } else if (n3 != null && n3.substr(0, 1) === "{" && n3.substr(n3.length - 1, 1) === "}" && p4.substr(0, 1) === "{" && p4.substr(p4.length - 1, 1) === ")") {
            pfri[1] = n3.length;
          } else {
            pfri[0] = pfri[0] + vlen - vplen;
            if (v_a.length > vp_a.length) {
              pfri[1] = v_a[i4 + 1].length;
            } else {
              pfri[1] = 1;
            }
          }
          return pfri;
        } else if (p4.length > n3.length) {
          if (p4 != null && p4.substr(0, 1) === '"') {
            pfri[1] = n3.length;
          } else if (v_a[i4 + 1] != null && /{.*?}/.test(v_a[i4 + 1])) {
            pfri[0] += 1;
            pfri[1] = v_a[i4 + 1].length;
          } else if (p4 != null && v_a[i4 + 1].substr(0, 1) === '"' && (p4.indexOf("{") > -1 || p4.indexOf("}") > -1)) {
            pfri[0] += 1;
            pfri[1] = 1;
          } else {
            pfri[0] = pfri[0] + vlen - vplen - 1;
            pfri[1] = v_a[i4 - 1].length;
          }
          return pfri;
        } else if (p4.length < n3.length) {
          return pfri;
        }
        return pfri;
      }
      return null;
    }
    setCaretPosition(textDom, children, pos) {
      try {
        let el = textDom;
        let range2 = document.createRange();
        let sel = window.getSelection();
        range2.setStart(el.childNodes[children], pos);
        range2.collapse(true);
        sel?.removeAllRanges();
        sel?.addRange(range2);
        el.focus();
      } catch (err) {
      }
    }
    functionRange(obj, v4, vp) {
      let _this = this;
      let currSelection = window.getSelection();
      let fri = _this.findrangeindex(v4, vp);
      if (fri == null && currSelection) {
        currSelection.selectAllChildren(obj[0]);
        currSelection.collapseToEnd();
      } else if (fri != null) {
        let span = $$("span", obj);
        _this.setCaretPosition(Array.isArray(span) ? span[fri[0]] : span, 0, fri[1]);
      }
    }
    functionHTMLGenerate(txt) {
      let _this = this;
      if (txt.length === 0 || txt.substr(0, 1) !== "=") {
        return txt;
      }
      _this.functionHTMLIndex = 0;
      return `<span dir="auto" class="universheet-formula-text-color">=</span>${_this.functionHTML(txt)}`;
    }
    functionHTML(txt) {
      let _this = this;
      if (_this.operatorjson == null) {
        let arr = _this.operator.split("|");
        let op = {};
        for (let i5 = 0; i5 < arr.length; i5++) {
          op[arr[i5].toString()] = 1;
        }
        _this.operatorjson = op;
      }
      if (txt.substr(0, 1) === "=") {
        txt = txt.substr(1);
      }
      let funcstack = txt.split("");
      let i4 = 0;
      let str = "";
      let function_str = "";
      let ispassby = true;
      let matchConfig = {
        bracket: 0,
        comma: 0,
        squote: 0,
        dquote: 0,
        braces: 0
      };
      while (i4 < funcstack.length) {
        let s4 = funcstack[i4];
        if (s4 === "(" && matchConfig.squote === 0 && matchConfig.dquote === 0 && matchConfig.braces === 0) {
          matchConfig.bracket += 1;
          if (str.length > 0) {
            function_str += `<span dir="auto" class="universheet-formula-text-func">${str}</span><span dir="auto" class="universheet-formula-text-lpar">(</span>`;
          } else {
            function_str += '<span dir="auto" class="universheet-formula-text-lpar">(</span>';
          }
          str = "";
        } else if (s4 === ")" && matchConfig.squote === 0 && matchConfig.dquote === 0 && matchConfig.braces === 0) {
          matchConfig.bracket -= 1;
          function_str += `${_this.functionHTML(str)}<span dir="auto" class="universheet-formula-text-rpar">)</span>`;
          str = "";
        } else if (s4 === "{" && matchConfig.squote === 0 && matchConfig.dquote === 0) {
          str += "{";
          matchConfig.braces += 1;
        } else if (s4 === "}" && matchConfig.squote === 0 && matchConfig.dquote === 0) {
          str += "}";
          matchConfig.braces -= 1;
        } else if (s4 === '"' && matchConfig.squote === 0) {
          if (matchConfig.dquote > 0) {
            if (str.length > 0) {
              function_str += `${str}"</span>`;
            } else {
              function_str += '"</span>';
            }
            matchConfig.dquote -= 1;
            str = "";
          } else {
            matchConfig.dquote += 1;
            if (str.length > 0) {
              function_str += `${_this.functionHTML(str)}<span dir="auto" class="universheet-formula-text-string">"`;
            } else {
              function_str += `<span dir="auto" class="universheet-formula-text-string">"`;
            }
            str = "";
          }
        } else if (s4 === "'" && matchConfig.dquote === 0) {
          str += "'";
          matchConfig.squote = matchConfig.squote === 0 ? 1 : 0;
        } else if (s4 === "," && matchConfig.squote === 0 && matchConfig.dquote === 0 && matchConfig.braces === 0) {
          function_str += `${_this.functionHTML(str)}<span dir="auto" class="universheet-formula-text-comma">,</span>`;
          str = "";
        } else if (s4 === "&" && matchConfig.squote === 0 && matchConfig.dquote === 0 && matchConfig.braces === 0) {
          if (str.length > 0) {
            function_str += `${_this.functionHTML(str)}<span dir="auto" class="universheet-formula-text-calc">&</span>`;
            str = "";
          } else {
            function_str += '<span dir="auto" class="universheet-formula-text-calc">&</span>';
          }
        } else if (s4 in _this.operatorjson && matchConfig.squote === 0 && matchConfig.dquote === 0 && matchConfig.braces === 0) {
          let s_next = "";
          if (i4 + 1 < funcstack.length) {
            s_next = funcstack[i4 + 1];
          }
          let p4 = i4 - 1;
          let s_pre = null;
          if (p4 >= 0) {
            do {
              s_pre = funcstack[p4--];
            } while (p4 >= 0 && s_pre === " ");
          }
          if (s4 + s_next in _this.operatorjson) {
            if (str.length > 0) {
              function_str += `${_this.functionHTML(str)}<span dir="auto" class="universheet-formula-text-calc">${s4}${s_next}</span>`;
              str = "";
            } else {
              function_str += `<span dir="auto" class="universheet-formula-text-calc">${s4}${s_next}</span>`;
            }
            i4++;
          } else if (!/[^0-9]/.test(s_next) && s4 === "-" && (s_pre === "(" || s_pre == null || s_pre === "," || s_pre === " " || s_pre in _this.operatorjson)) {
            str += s4;
          } else if (str.length > 0) {
            function_str += `${_this.functionHTML(str)}<span dir="auto" class="universheet-formula-text-calc">${s4}</span>`;
            str = "";
          } else {
            function_str += `<span dir="auto" class="universheet-formula-text-calc">${s4}</span>`;
          }
        } else {
          str += s4;
        }
        if (i4 === funcstack.length - 1) {
          if (_this.iscelldata(str.trim())) {
            function_str += `<span class="universheet-formula-functionrange-cell" rangeindex="${_this.functionHTMLIndex}" dir="auto" style="color:${LUCKY_COLOR[_this.functionHTMLIndex]};">${str}</span>`;
            _this.functionHTMLIndex++;
          } else if (matchConfig.dquote > 0) {
            function_str += `${str}</span>`;
          } else if (str.indexOf("</span>") === -1 && str.length > 0) {
            let regx = /{.*?}/;
            if (regx.test(str.trim())) {
              let arraytxt = regx.exec(str)[0];
              let arraystart = str.search(regx);
              let alltxt = "";
              if (arraystart > 0) {
                alltxt += `<span dir="auto" class="universheet-formula-text-color">${str.substr(0, arraystart)}</span>`;
              }
              alltxt += `<span dir="auto" style="color:#959a05" class="universheet-formula-text-array">${arraytxt}</span>`;
              if (arraystart + arraytxt.length < str.length) {
                alltxt += `<span dir="auto" class="universheet-formula-text-color">${str.substr(arraystart + arraytxt.length, str.length)}</span>`;
              }
              function_str += alltxt;
            } else {
              function_str += `<span dir="auto" class="universheet-formula-text-color">${str}</span>`;
            }
          }
        }
        i4++;
      }
      return function_str;
    }
    canceFunctionrangeSelected() {
    }
    iscelldata(txt) {
      let val = txt.split("!");
      let rangetxt;
      if (val.length > 1) {
        rangetxt = val[1];
      } else {
        rangetxt = val[0];
      }
      let reg_cell = /^(([a-zA-Z]+)|([$][a-zA-Z]+))(([0-9]+)|([$][0-9]+))$/g;
      let reg_cellRange = /^(((([a-zA-Z]+)|([$][a-zA-Z]+))(([0-9]+)|([$][0-9]+)))|((([a-zA-Z]+)|([$][a-zA-Z]+))))$/g;
      if (rangetxt.indexOf(":") === -1) {
        let row2 = parseInt(rangetxt.replace(/[^0-9]/g, "")) - 1;
        let col2 = Tools.ABCatNum(rangetxt.replace(/[^A-Za-z]/g, ""));
        if (!Number.isNaN(row2) && !Number.isNaN(col2) && rangetxt.toString().match(reg_cell)) {
          return true;
        }
        if (!Number.isNaN(row2)) {
          return false;
        }
        if (!Number.isNaN(col2)) {
          return false;
        }
        return false;
      }
      reg_cellRange = /^(((([a-zA-Z]+)|([$][a-zA-Z]+))(([0-9]+)|([$][0-9]+)))|((([a-zA-Z]+)|([$][a-zA-Z]+)))|((([0-9]+)|([$][0-9]+s))))$/g;
      rangetxt = rangetxt.split(":");
      let row = [];
      let col = [];
      row[0] = parseInt(rangetxt[0].replace(/[^0-9]/g, "")) - 1;
      row[1] = parseInt(rangetxt[1].replace(/[^0-9]/g, "")) - 1;
      if (row[0] > row[1]) {
        return false;
      }
      col[0] = Tools.ABCatNum(rangetxt[0].replace(/[^A-Za-z]/g, ""));
      col[1] = Tools.ABCatNum(rangetxt[1].replace(/[^A-Za-z]/g, ""));
      if (col[0] > col[1]) {
        return false;
      }
      if (rangetxt[0].toString().match(reg_cellRange) && rangetxt[1].toString().match(reg_cellRange)) {
        return true;
      }
      return false;
    }
    getrangeseleciton() {
      let currSelection = window.getSelection();
      let anchor = currSelection.anchorNode;
      let anchorOffset = currSelection.anchorOffset;
      let anchorLength = anchor?.parentElement.querySelectorAll("span");
      if (anchor?.parentNode?.nodeName === "SPAN" && anchorOffset !== 0) {
        let txt = anchor.textContent.trim();
        let lasttxt = "";
        if (txt.length === 0 && anchor.parentNode.previousSibling) {
          let ahr = anchor.parentNode.previousSibling;
          txt = ahr.textContent.trim();
          lasttxt = txt.substring(txt.length - 1, 1);
          return ahr;
        }
        lasttxt = txt.substring(anchorOffset - 1, 1);
        return anchor.parentNode;
      }
      if (anchor?.parentElement?.className === "universheet-rich-text-editor") {
        let txt = anchor.textContent?.trim();
        if (txt.length === 0 && anchor.parentElement.querySelectorAll("span").length > 1) {
          let ahr = anchor?.parentElement.querySelectorAll("span");
          const textContent = ahr[`${ahr.length - 2}`].textContent;
          txt = textContent && textContent.trim() || "";
          return ahr[anchorLength.length - 1];
        }
        return anchor.parentElement.querySelectorAll("span")[anchorLength.length - 1];
      }
      return null;
    }
    searchFunction($editer) {
      let _this = this;
      this.formula = [];
      let $cell = _this.getrangeseleciton();
      _this.searchFunctionCell = $cell;
      if ($cell == null || $editer == null) {
        return;
      }
      let inputContent = $editer.innerText;
      let searchtxt = $cell.textContent.toUpperCase();
      let reg = /^[a-zA-Z]|[a-zA-Z_]+$/;
      if (!reg.test(searchtxt) || inputContent.substr(0, 1) !== "=") {
        return;
      }
      let result = {
        f: [],
        s: [],
        t: []
      };
      let result_i = 0;
      for (let i4 = 0; i4 < FunList.length; i4++) {
        let item = FunList[i4];
        let n3 = item.n;
        if (!n3)
          continue;
        if (n3 === searchtxt) {
          result.f.unshift(item);
          result_i++;
        } else if (n3.substr(0, searchtxt.length) === searchtxt) {
          result.s.unshift(item);
          result_i++;
        } else if (n3.indexOf(searchtxt) > -1) {
          result.t.unshift(item);
          result_i++;
        }
        if (result_i >= 10) {
          break;
        }
      }
      let list = result.t.concat(result.s.concat(result.f));
      this.formula = list;
    }
    helpFunctionExe($editer, currSelection) {
      let _this = this;
      if (document.querySelectorAll("#universheet-formula-help-c").length === 0) {
        for (let i5 = 0; i5 < FunList.length; i5++) {
          const n3 = FunList[i5].n;
          if (!n3)
            continue;
          _this.functionlistPosition[n3] = i5;
        }
      }
      if (!currSelection) {
        return;
      }
      let $prev = currSelection;
      let $span = $editer.querySelectorAll("span");
      let currentIndex = [].indexOf.call(currSelection.parentNode.querySelectorAll(currSelection.tagName), currSelection);
      let i4 = currentIndex;
      if ($prev == null) {
        return;
      }
      let funcName = null;
      let paramindex = null;
      if ($span[`${i4}`].className === "universheet-rich-text-editor") {
        funcName = $span[`${i4}`].textContent;
      } else {
        let $cur = null;
        let exceptIndex = [-1, -1];
        while (--i4 > 0) {
          $cur = $span[`${i4}`];
          if ($cur.className === "universheet-formula-text-func" || $cur.textContent.trim().toUpperCase() in _this.functionlistPosition) {
            funcName = $cur.textContent;
            paramindex = null;
            let endstate = true;
            for (let a4 = i4; a4 <= currentIndex; a4++) {
              if (!paramindex) {
                paramindex = 0;
              }
              if (a4 >= exceptIndex[0] && a4 <= exceptIndex[1]) {
                continue;
              }
              $cur = $span[`${a4}`];
              if ($cur.className === "universheet-formula-text-rpar") {
                exceptIndex = [i4, a4];
                funcName = null;
                endstate = false;
                break;
              }
              if ($cur.className === "universheet-formula-text-comma") {
                paramindex++;
              }
            }
            if (endstate) {
              break;
            }
          }
        }
      }
      if (funcName == null) {
        return;
      }
      this.funcName = funcName;
      this.paramindex = paramindex;
    }
    searchFunctionEnter(funcName) {
      let _this = this;
      let functxt = funcName;
      let searchFunctionCell = _this.searchFunctionCell;
      searchFunctionCell.innerText = functxt;
      const span = document.createElement("span");
      span.dir = "auto";
      span.className = "universheet-formula-text-color";
      span.innerText = "(";
      insertAfter(span, searchFunctionCell);
      _this.setCaretPosition(span, 0, 1);
    }
  };
  function insertAfter(newElement, targetElement) {
    let parent = targetElement.parentNode;
    if (parent.lastChild === targetElement) {
      parent.appendChild(newElement);
    } else {
      parent.insertBefore(newElement, targetElement.nextSibling);
    }
  }

  // ../../packages/sheets-plugin-formula/src/Controller/FormulaPromptController.ts
  var FormulaPromptController = class {
    constructor(_plugin) {
      this._plugin = _plugin;
      this._context = this._plugin.getContext();
      this._sheetPlugin = this._plugin.getContext().getPluginManager().getRequirePluginByName("spreadsheet" /* SPREADSHEET */);
      this._sheetUIPlugin = this._plugin.getUniver().getGlobalContext().getPluginManager().getRequirePluginByName(SHEET_UI_PLUGIN_NAME);
      this._initRegisterComponent();
      this._initialize();
    }
    _context;
    _sheetPlugin;
    _sheetUIPlugin;
    _searchFunction;
    _helpFunction;
    cellInputHandler;
    richTextEle;
    richTextEditEle;
    _initRegisterComponent() {
      this._sheetUIPlugin.getAppUIController().getSheetContainerController().getMainSlotController().addSlot(
        FORMULA_PLUGIN_NAME + SearchFunction.name,
        {
          component: SearchFunction
        },
        () => {
          const searchFunction = this._sheetUIPlugin.getAppUIController().getSheetContainerController().getMainSlotController().getSlot(FORMULA_PLUGIN_NAME + SearchFunction.name);
          this._searchFunction = searchFunction;
        }
      );
      this._sheetUIPlugin.getAppUIController().getSheetContainerController().getMainSlotController().addSlot(
        FORMULA_PLUGIN_NAME + HelpFunction.name,
        {
          component: HelpFunction
        },
        () => {
          const helpFunction = this._sheetUIPlugin.getAppUIController().getSheetContainerController().getMainSlotController().getSlot(FORMULA_PLUGIN_NAME + HelpFunction.name);
          this._helpFunction = helpFunction;
        }
      );
    }
    _initialize() {
      this._sheetUIPlugin.UIDidMount(() => {
        const richTextEle = this._sheetUIPlugin.getAppUIController().getSheetContainerController().getCellEditorUIController()._richTextEle;
        this.richTextEle = richTextEle;
        this.richTextEditEle = $$("div", this.richTextEle);
        this.cellInputHandler = new CellInputHandler(this.richTextEditEle);
      });
      this._sheetUIPlugin.getObserver("onRichTextKeyDownObservable")?.add((event) => {
        let ctrlKey = event.ctrlKey;
        let altKey = event.altKey;
        let shiftKey = event.shiftKey;
        let kcode = event.keyCode;
        if (!(kcode >= 112 && kcode <= 123 || kcode <= 46 || kcode === 144 || kcode === 108 || event.ctrlKey || event.altKey || event.shiftKey && (kcode === 37 || kcode === 38 || kcode === 39 || kcode === 40 || kcode === 91 /* WIN */ || kcode === 92 /* WIN_R */ || kcode === 93 /* MENU */)) || kcode === 8 || kcode === 32 || kcode === 46 || event.ctrlKey && kcode === 86) {
          this.cellInputHandler.functionInputHandler(this.richTextEditEle, kcode);
        }
      });
      this._sheetUIPlugin.getObserver("onRichTextKeyUpObservable")?.add((event) => {
        let kcode = event.keyCode;
        if (kcode === 13 /* ENTER */) {
          this._searchFunction.updateState(false);
          this._helpFunction.updateState(false);
        } else if (!(kcode >= 112 && kcode <= 123 || kcode <= 46 || kcode === 144 || kcode === 108 || event.ctrlKey || event.altKey || event.shiftKey && (kcode === 37 || kcode === 38 || kcode === 39 || kcode === 40 || kcode === 91 /* WIN */ || kcode === 92 /* WIN_R */ || kcode === 93 /* MENU */)) || kcode === 8 || kcode === 32 || kcode === 46 || event.ctrlKey && kcode === 86) {
          this.cellInputHandler.searchFunction(this.richTextEditEle);
          const formula = this.cellInputHandler.getFormula();
          let helpFormula = this.cellInputHandler.getHelpFormula();
          let height = parseInt(this.richTextEle.style.minHeight);
          let width = parseInt(this.richTextEle.style.minWidth);
          let left = parseInt(this.richTextEle.style.left);
          let top = parseInt(this.richTextEle.style.top) + height;
          const sheetContainer = getRefElement(this._sheetUIPlugin.getAppUIController().getSheetContainerController().getContentRef());
          const screenW = sheetContainer.offsetWidth;
          const screenH = sheetContainer.offsetHeight;
          const position = {
            left,
            top
          };
          const getPosition = (component) => {
            const searchFunctionEle = getRefElement(component.getContentRef());
            const rootW = searchFunctionEle.offsetWidth;
            const rootH = searchFunctionEle.offsetHeight;
            const right = screenW - left > rootW;
            const bottom = screenH - top > rootH;
            if (!right) {
              left -= rootW - width;
            }
            if (!bottom) {
              top -= rootH + height;
            }
            return {
              left,
              top
            };
          };
          if (formula[0]) {
            this._searchFunction.updateState(true, formula, 0, position, () => {
              const position2 = getPosition(this._searchFunction);
              this._searchFunction.updateState(true, formula, 0, position2);
            });
            this._helpFunction.updateState(false);
          } else if (helpFormula[0]) {
            const functionName = helpFormula[0].toUpperCase();
            const functionInfo = FunList.find((item) => item.n === functionName) || {};
            this._helpFunction.updateState(true, helpFormula[1], functionInfo, position, () => {
              const position2 = getPosition(this._helpFunction);
              this._helpFunction.updateState(true, helpFormula[1], functionInfo, position2);
            });
            this._searchFunction.updateState(false);
          } else {
            this._searchFunction.updateState(false, formula);
            this._helpFunction.updateState(false);
          }
        }
        const value = this.cellInputHandler.getInputValue();
        if (value.length > 0 && value.substr(0, 1) === "=" && (kcode !== 229 || value.length === 1)) {
          if (kcode === 13) {
            event.preventDefault();
            event.stopPropagation();
            const searchFunctionState = this._searchFunction.getState();
            if (searchFunctionState.searchActive) {
              const func = searchFunctionState.formula[searchFunctionState.selectIndex];
              this.cellInputHandler.searchFunctionEnter(func.n);
            }
          }
        }
      });
    }
  };

  // ../../packages/sheets-plugin-formula/src/FormulaPlugin.tsx
  var FormulaPlugin = class extends Plugin {
    constructor(_config) {
      super(FORMULA_PLUGIN_NAME);
      this._config = _config;
    }
    _formulaController;
    _searchFormulaController;
    _formulaPromptController;
    _formulaActionExtensionFactory;
    static create(config) {
      return new FormulaPlugin(config);
    }
    installTo(universheetInstance) {
      universheetInstance.installPlugin(this);
      const context = this.getContext();
      let formulaEngine = context.getPluginManager().getPluginByName("formulaEngine");
      if (!formulaEngine) {
        formulaEngine = new FormulaEnginePlugin();
        universheetInstance.installPlugin(formulaEngine);
      }
      let sheetPlugin = context.getUniver().getGlobalContext().getPluginManager().getRequirePluginByName(SHEET_UI_PLUGIN_NAME);
      sheetPlugin?.UIDidMount(() => {
        this._formulaController = new FormulaController(this, this._config);
        this._searchFormulaController = new SearchFormulaController(this);
        this._formulaPromptController = new FormulaPromptController(this);
        this._formulaController.setFormulaEngine(formulaEngine);
        firstLoader(this._formulaController);
      });
    }
    initialize(context) {
      this.context = context;
      this.getLocale().load({
        en: en_default4,
        zh: zh_default4
      });
      this.registerExtension();
    }
    onMapping(IOC) {
    }
    onMounted(context) {
      install2(this);
      this.initialize(context);
    }
    onDestroy() {
      const actionRegister = this.context.getCommandManager().getActionExtensionManager().getRegister();
      actionRegister.delete(this._formulaActionExtensionFactory);
    }
    registerExtension() {
      const cellEditRegister = CellEditExtensionManager.create();
      cellEditRegister.add(new FormulaCellEditExtensionFactory(this));
      const cellInputRegister = CellInputExtensionManager.create();
      cellInputRegister.add(new FormulaCellInputExtensionFactory(this));
      const actionRegister = this.context.getCommandManager().getActionExtensionManager().getRegister();
      this._formulaActionExtensionFactory = new FormulaActionExtensionFactory(this);
      actionRegister.add(this._formulaActionExtensionFactory);
    }
    getFormulaEngine() {
      return this._formulaController.getFormulaEngine();
    }
    getFormulaController() {
      return this._formulaController;
    }
    getSearchFormulaController() {
      return this._searchFormulaController;
    }
    getFormulaPromptController() {
      return this._formulaPromptController;
    }
  };

  // ../../packages/common-plugin-data/src/Sheets/DEFAULT_WORKBOOK_DATA.ts
  var richTextTestFloat = {
    id: "d",
    drawings: {
      shapeTest1: {
        objectId: "shapeTest1",
        objectProperties: {
          title: "test shape",
          description: "test shape",
          size: {
            width: 100,
            height: 400
          },
          positionH: {
            relativeFrom: 1 /* COLUMN */,
            posOffset: 100
          },
          positionV: {
            relativeFrom: 6 /* PARAGRAPH */,
            posOffset: 160
          },
          angle: 0,
          imageProperties: {
            contentUrl: "https://cnbabylon.com/assets/img/agents.png"
          }
        },
        layoutType: 3 /* WRAP_SQUARE */,
        behindDoc: 0 /* FALSE */,
        wrapText: 0 /* BOTH_SIDES */
      }
    },
    lists: {
      unorderedTest: {
        listId: "unorderedTest",
        nestingLevel: [
          {
            bulletAlignment: 1 /* START */,
            glyphFormat: " %0",
            textStyle: {
              fs: 12
            },
            startNumber: 0,
            glyphSymbol: "\u25CF",
            hanging: 21,
            indentStart: 21
          },
          {
            bulletAlignment: 1 /* START */,
            glyphFormat: " %1",
            textStyle: {
              fs: 12
            },
            startNumber: 0,
            glyphSymbol: "\u25A0",
            hanging: 21,
            indentStart: 42
          },
          {
            bulletAlignment: 1 /* START */,
            glyphFormat: " %1",
            textStyle: {
              fs: 12
            },
            startNumber: 0,
            glyphSymbol: "\u25C6",
            hanging: 21,
            indentStart: 63
          }
        ]
      },
      testBullet: {
        listId: "testBullet",
        nestingLevel: [
          {
            bulletAlignment: 1 /* START */,
            glyphFormat: " %1.",
            textStyle: {
              fs: 12
            },
            startNumber: 0,
            glyphType: 7 /* ROMAN */,
            hanging: 21,
            indentStart: 21
          },
          {
            bulletAlignment: 1 /* START */,
            glyphFormat: " %1.%2)",
            textStyle: {
              fs: 12
            },
            startNumber: 0,
            glyphType: 7 /* ROMAN */,
            hanging: 21,
            indentStart: 42
          },
          {
            bulletAlignment: 1 /* START */,
            glyphFormat: " %1.%2.%3.",
            textStyle: {
              fs: 12
            },
            startNumber: 0,
            glyphType: 7 /* ROMAN */,
            hanging: 21,
            indentStart: 63
          }
        ]
      }
    },
    body: {
      blockElements: [
        {
          blockId: "oneParagraph",
          st: 0,
          ed: 15,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            bullet: {
              listId: "testBullet",
              nestingLevel: 0,
              textStyle: {
                fs: 20
              }
            },
            elements: [
              {
                eId: "oneElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u5728\u201C\u7B2C1\u9898\u201D\u5DE5\u4F5C\u8868\u4E2D\u5B8C\u6210\u4EE5\u4E0B\u64CD\u4F5C",
                  ts: {
                    fs: 12,
                    bg: {
                      rgb: "rgb(200,0,90)"
                    },
                    cl: {
                      rgb: "rgb(255,130,0)"
                    }
                  }
                }
              },
              {
                eId: "shapeTest1",
                et: 7 /* DRAWING */,
                st: 0,
                ed: 0
              },
              {
                eId: "smallSub",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u4E0A\u6807",
                  ts: {
                    fs: 14,
                    bg: {
                      rgb: "rgb(2,128,2)"
                    },
                    cl: {
                      rgb: "rgb(0,1,55)"
                    },
                    va: 2 /* SUPERSCRIPT */
                  }
                }
              },
              {
                eId: "twoElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u65E5\u671F\u5217\u5355\u5143\u683C\u6570\u636E\u9A8C\u8BC1\uFF0C\u9650\u5236\u53EA\u80FD\u8F93\u5165\u65E5\u671F\uFF08\u4ECB\u4E8E1949\u5E741\u67081\u65E5\u81F32099\u5E741\u67081\u65E5\uFF09",
                  ts: {
                    fs: 14,
                    bg: {
                      rgb: "rgb(90,128,255)"
                    },
                    cl: {
                      rgb: "rgb(0,1,255)"
                    }
                  }
                }
              }
            ]
          }
        },
        {
          blockId: "twoParagraph",
          st: 0,
          ed: 15,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            bullet: {
              listId: "testBullet",
              nestingLevel: 1,
              textStyle: {
                fs: 20
              }
            },
            elements: [
              {
                eId: "oneElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u7EC6\u5316\u57CB\u70B9\u4E0A\u62A5\u94FE\u8DEF\u548C\u6307\u6807\u65B9\u6848\u68B3\u7406"
                }
              },
              {
                eId: "twoElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u76EE\u524D\u901A\u8FC7\u6BCF\u65E5\u5B9A\u65F6\u4EFB\u52A1\u53D1\u9001\u62A5\u544A"
                }
              }
            ]
          }
        },
        {
          blockId: "threeParagraph",
          st: 0,
          ed: 15,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            bullet: {
              listId: "testBullet",
              nestingLevel: 0,
              textStyle: {
                fs: 20
              }
            },
            elements: [
              {
                eId: "oneElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u81EA2018\u5E74\u9996\u5C4A\u8FDB\u535A\u4F1A\u4E3E\u529E\u4EE5\u6765\uFF0C\u8FDB\u535A\u4F1A\u5DF2\u7ECF\u6210\u4E3A\u5168\u7403\u65B0\u54C1\u7684\u9996\u53D1\u5730\u3001\u524D\u6CBF\u6280\u672F\u7684\u9996\u9009\u5730\u3001\u521B\u65B0\u670D\u52A1\u7684\u9996\u63A8\u5730\u3002"
                }
              },
              {
                eId: "twoElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u4E2D\u56FD\u8FD9\u5341\u5E74\u201D\u5BF9\u5916\u5F00\u653E\u6210\u5C31\u5C55\u6E56\u5317\u5C55\u533A\u4E3B\u8981\u4EE5\u56FE\u6587\u3001\u56FE\u8868\u3001\u6570\u636E\u3001\u89C6\u9891\u3001\u4F01\u4E1A\u5C55\u54C1\u3001\u5B9E\u7269\u6A21\u578B\u3001\u5149\u7535\u79D1\u6280\u7B49\u4F53\u73B0\u6E56\u5317\u5341\u5E74\u5F00\u653E\u6210\u5C31\u3001\u91CD\u5927\u5F00\u653E\u5E73\u53F0\u53CA\u4EA7\u4E1A\u3002\u6E56\u5317\u7701\u5171\u8BA117\u5BB6\u4F01\u4E1A\u3001\u673A\u6784\u7684\u5C55\u54C1\u5C06\u5728\u8FD9\u4E00\u5C55\u533A\u5C55\u793A"
                }
              }
            ]
          }
        },
        {
          blockId: "fourParagraph",
          st: 0,
          ed: 15,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            bullet: {
              listId: "testBullet",
              nestingLevel: 1,
              textStyle: {
                fs: 20
              }
            },
            elements: [
              {
                eId: "oneElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u56FD\u5BB6\u4E3B\u5E2D\u4E60\u8FD1\u5E73\u4EE5\u89C6\u9891\u65B9\u5F0F\u51FA\u5E2D\u5728\u4E0A\u6D77\u4E3E\u884C\u7684\u7B2C\u4E94\u5C4A\u4E2D\u56FD\u56FD\u9645\u8FDB\u53E3\u535A\u89C8\u4F1A\u5F00\u5E55\u5F0F\u5E76\u53D1\u8868\u9898\u4E3A\u300A\u5171\u521B\u5F00\u653E\u7E41\u8363\u7684\u7F8E\u597D\u672A\u6765\u300B\u7684\u81F4\u8F9E"
                }
              },
              {
                eId: "twoElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u4E2D\u56FD\u5C06\u63A8\u52A8\u5404\u56FD\u5404\u65B9\u5171\u4EAB\u6DF1\u5316\u56FD\u9645\u5408\u4F5C\u673A\u9047\uFF0C\u5168\u9762\u6DF1\u5165\u53C2\u4E0E\u4E16\u754C\u8D38\u6613\u7EC4\u7EC7\u6539\u9769\u8C08\u5224"
                }
              }
            ]
          }
        },
        {
          blockId: "fiveParagraph",
          st: 0,
          ed: 15,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            bullet: {
              listId: "testBullet",
              nestingLevel: 2,
              textStyle: {
                fs: 20
              }
            },
            elements: [
              {
                eId: "oneElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u4E2D\u56FD\u7537\u6392\u4E24\u540D\u73B0\u5F79\u56FD\u624B\u5F6D\u4E16\u5764\u548C\u5F20\u79C9\u9F99\u5206\u522B\u6548\u529B\u7684\u4E09\u5F97\u5229\u592A\u9633\u9E1F\u548C\u4E1C\u4EAC\u5927\u718A\u672C\u8F6E\u906D\u9047\u3002"
                }
              },
              {
                eId: "twoElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u53CC\u65B9\u7ECF\u8FC7\u6FC0\u6218\uFF0C\u4E3B\u573A\u4F5C\u6218\u7684\u536B\u5195\u51A0\u519B\u4E09\u5F97\u5229\u6280\u9AD8\u4E00\u7B793-2\u9006\u8F6C\u51FB\u8D25\u5BF9\u624B\uFF0C\u529B\u593A\u7B2C3\u573A\u80DC\u5229"
                }
              }
            ]
          }
        }
      ]
    },
    documentStyle: {
      pageSize: {
        width: Infinity,
        height: Infinity
      },
      marginTop: 0,
      marginBottom: 0,
      marginRight: 2,
      marginLeft: 2
    }
  };
  var richTextTest2 = {
    id: "d",
    body: {
      blockElements: [
        {
          blockId: "oneParagraph",
          st: 0,
          ed: 15,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            elements: [
              {
                eId: "oneElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u5728\u201C\u7B2C1\u9898\u201D\u5DE5\u4F5C\u8868\u4E2D\u5B8C\u6210\u4EE5\u4E0B\u64CD\u4F5C",
                  ts: {
                    fs: 12,
                    bg: {
                      rgb: "rgb(200,0,90)"
                    },
                    cl: {
                      rgb: "rgb(255,130,0)"
                    }
                  }
                }
              },
              {
                eId: "twoElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u4E0A\u6807",
                  ts: {
                    fs: 14,
                    bg: {
                      rgb: "rgb(2,128,2)"
                    },
                    cl: {
                      rgb: "rgb(0,1,55)"
                    },
                    va: 2 /* SUPERSCRIPT */
                  }
                }
              },
              {
                eId: "twoElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u65E5\u671F\u5217\u5355\u5143\u683C\u6570\u636E\u9A8C\u8BC1\uFF0C\u9650\u5236\u53EA\u80FD\u8F93\u5165\u65E5\u671F\uFF08\u4ECB\u4E8E1949\u5E741\u67081\u65E5\u81F32099\u5E741\u67081\u65E5\uFF09",
                  ts: {
                    fs: 14,
                    bg: {
                      rgb: "rgb(90,128,255)"
                    },
                    cl: {
                      rgb: "rgb(0,1,255)"
                    }
                  }
                }
              }
            ]
          }
        }
      ]
    },
    documentStyle: {
      pageSize: {
        width: Infinity,
        height: Infinity
      },
      marginTop: 0,
      marginBottom: 0,
      marginRight: 2,
      marginLeft: 2
    }
  };
  var DEFAULT_WORKBOOK_DATA = {
    id: "workbook-01",
    theme: "default",
    locale: "en" /* EN */,
    creator: "univer",
    name: "universheet",
    skin: "default",
    socketUrl: "",
    socketEnable: 0 /* FALSE */,
    extensions: [],
    sheetOrder: ["sheet-01", "sheet-02", "sheet-03", "sheet-04", "sheet-05", "sheet-06"],
    pluginMeta: {},
    styles: {
      "1": {
        cl: {
          rgb: "blue"
        },
        fs: 16,
        bd: {
          t: {
            s: 9 /* MEDIUM_DASHED */,
            cl: {
              rgb: "black"
            }
          },
          l: {
            s: 9 /* MEDIUM_DASHED */,
            cl: {
              rgb: "black"
            }
          },
          r: {
            s: 13 /* THICK */,
            cl: {
              rgb: "black"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "red"
            }
          }
        },
        ht: 3
      },
      "2": {
        bg: {
          rgb: "rgb(200, 2, 0)"
        },
        fs: 24,
        ht: 3 /* RIGHT */,
        vt: 1 /* TOP */
      },
      "3": {
        ht: 3 /* RIGHT */,
        vt: 2 /* MIDDLE */,
        tb: 3 /* WRAP */,
        // va: BaselineOffset.SUPERSCRIPT,
        // cl: {
        //     rgb: 'rgb(0, 255, 0)',
        // },
        // st: {
        //     s: BooleanNumber.TRUE, // show
        // },
        bg: {
          rgb: "rgb(255, 255, 0)"
        },
        tr: {
          a: 45,
          v: 0 /* FALSE */
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "black"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "black"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "black"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "red"
            }
          }
        }
      },
      "4": {
        bg: {
          rgb: "rgb(0, 0, 255)"
        }
      },
      "5": {
        tb: 3 /* WRAP */
      }
    },
    timeZone: "GMT+8",
    createdTime: "2021-11-28 12:10:10",
    modifiedTime: "2021-11-29 12:10:10",
    appVersion: "3.0.0-alpha",
    lastModifiedBy: "univer",
    sheets: {
      "sheet-01": {
        type: 0 /* GRID */,
        id: "sheet-01",
        cellData: {
          "0": {
            "0": {
              s: "1",
              v: 1,
              m: "1"
            },
            "1": {
              s: "1",
              v: 1,
              m: "1"
            },
            "5": {
              s: "1",
              v: 8,
              m: "8"
            },
            "6": {
              s: "2",
              v: 8,
              m: "8"
            }
          },
          "1": {
            "0": {
              v: 1,
              m: "1"
            },
            "1": {
              v: 1,
              m: "1"
            },
            "2": {
              v: 80,
              m: "80",
              s: "3"
            },
            "3": {
              v: "\u5BCC\u6587\u672C\u7F16\u8F91",
              m: "\u5BCC\u6587\u672C\u7F16\u8F91",
              s: "2"
            }
          },
          "2": {
            "0": {
              v: 1111,
              m: "1111"
            },
            "1": {
              v: 1111,
              m: "1111"
            },
            "5": {
              s: "1",
              v: 8,
              m: "8"
            },
            "6": {
              s: "1",
              v: 8,
              m: "8"
            },
            "7": {
              s: "1",
              v: 8,
              m: "8"
            },
            "8": {
              s: "1",
              v: 8,
              m: "8"
            }
          },
          "3": {
            "0": {
              v: 1111,
              m: "1111"
            },
            "1": {
              v: 1111,
              m: "1111"
            }
          },
          "10": {
            "9": {
              v: 1111,
              s: "2",
              m: "1111"
            }
          },
          "13": {
            "9": {
              v: 1111,
              s: "4",
              m: "1111"
            }
          },
          "17": {
            "3": {
              v: "\u505A\u79FB\u52A8\u7AEF\u5F00\u53D1\u548C\u524D\u7AEF\u5F00\u53D1\u7684\u4EBA\u5458\uFF0C\u5BF9 MVC\u3001MVP\u3001MVVM \u8FD9\u51E0\u4E2A\u540D\u8BCD\u5E94\u8BE5\u90FD\u4E0D\u964C\u751F\uFF0C\u8FD9\u662F\u4E09\u4E2A\u6700\u5E38\u7528\u7684\u5E94\u7528\u67B6\u6784\u6A21\u5F0F\uFF0C\u76EE\u7684\u90FD\u662F\u4E3A\u4E86\u5C06\u4E1A\u52A1\u548C\u89C6\u56FE\u7684\u5B9E\u73B0\u4EE3\u7801\u5206\u79BB",
              s: "3",
              p: richTextTest2
            }
          },
          "20": {
            "10": {
              v: "\u5317\u4EAC\u9A6C\u62C9\u677E\u7EC4\u59D4\u4F1A\u529E\u516C\u5BA4\u4E00\u4F4D\u63A5\u7535\u8BDD\u7684\u5973\u58EB\u8BC1\u5B9E\uFF0C\u7684\u786E\u6709\u8FD9\u9879\u89C4\u5B9A\uFF0C\u5979\u8FD8\u79F02014\u5E74\u9A6C\u62C9\u677E\u7684\u9884\u767B\u8BB0\u5DE5\u4F5C\u5C06\u5728\u672C\u5468\u542F\u52A8\u3002\u5317\u4EAC\u9A6C\u62C9\u677E\u6BD4\u8D5B\u5C06\u572810\u670819\u65E5\u4E3E\u884C\u3002",
              s: "3"
            },
            "12": {
              s: "4"
            }
          },
          "29": {
            "13": {
              p: Tools.deepClone(richTextTest2),
              s: "4"
            }
          },
          "32": {
            "3": {
              p: richTextTestFloat,
              s: "5"
            }
          }
        },
        name: "sheet1",
        tabColor: "red",
        hidden: 0 /* FALSE */,
        freezeColumn: 1,
        rowCount: 1e3,
        columnCount: 20,
        freezeRow: 1,
        zoomRatio: 1,
        scrollTop: 200,
        scrollLeft: 100,
        defaultColumnWidth: 93,
        defaultRowHeight: 27,
        mergeData: [
          {
            startRow: 0,
            endRow: 1,
            startColumn: 0,
            endColumn: 1
          },
          {
            startRow: 2,
            endRow: 6,
            startColumn: 5,
            endColumn: 10
          },
          {
            startRow: 10,
            endRow: 12,
            startColumn: 9,
            endColumn: 12
          },
          {
            startRow: 10,
            endRow: 12,
            startColumn: 9,
            endColumn: 12
          },
          {
            startRow: 17,
            endRow: 21,
            startColumn: 3,
            endColumn: 6
          },
          {
            startRow: 13,
            endRow: 15,
            startColumn: 9,
            endColumn: 10
          },
          {
            startRow: 24,
            endRow: 27,
            startColumn: 9,
            endColumn: 10
          },
          {
            startRow: 32,
            endRow: 53,
            startColumn: 3,
            endColumn: 5
          }
        ],
        rowData: {
          "3": {
            h: 50,
            hd: 0 /* FALSE */
          },
          "4": {
            h: 60,
            hd: 0 /* FALSE */
          },
          "29": {
            h: 200,
            hd: 0 /* FALSE */
          }
        },
        columnData: {
          "5": {
            w: 100,
            hd: 0 /* FALSE */
          },
          "6": {
            w: 200,
            hd: 0 /* FALSE */
          },
          "13": {
            w: 300,
            hd: 0 /* FALSE */
          }
        },
        status: 1,
        showGridlines: 1,
        hideRow: [],
        hideColumn: [],
        rowTitle: {
          width: 46,
          hidden: 0 /* FALSE */
        },
        columnTitle: {
          height: 20,
          hidden: 0 /* FALSE */
        },
        selections: ["A2"],
        rightToLeft: 0 /* FALSE */,
        pluginMeta: {}
        // metaData: [],
      },
      "sheet-02": {
        type: 0 /* GRID */,
        id: "sheet-02",
        name: "sheet2",
        cellData: {
          "0": {
            "0": {
              s: "1",
              v: 1,
              m: "1"
            },
            "1": {
              s: "1",
              v: 1,
              m: "1"
            },
            "5": {
              s: "1",
              v: 8,
              m: "8"
            },
            "6": {
              s: "2",
              v: 8,
              m: "8"
            }
          },
          "20": {
            "0": {
              v: "sheet2",
              m: "sheet2"
            },
            "1": {
              v: "sheet2 - 2",
              m: "sheet2 - 2"
            }
          }
        }
      },
      "sheet-03": {
        type: 0 /* GRID */,
        id: "sheet-03",
        name: "sheet3"
      },
      "sheet-04": {
        type: 0 /* GRID */,
        id: "sheet-04",
        name: "sheet4"
      },
      "sheet-05": {
        type: 0 /* GRID */,
        id: "sheet-05",
        name: "sheet5"
      },
      "sheet-06": {
        type: 0 /* GRID */,
        id: "sheet-06",
        name: "sheet6"
      }
    },
    namedRanges: [
      {
        namedRangeId: "named-range-01",
        name: "namedRange01",
        range: {
          sheetId: "sheet-01",
          rangeData: {
            startRow: 0,
            startColumn: 0,
            endRow: 1,
            endColumn: 1
          }
        }
      },
      {
        namedRangeId: "named-range-02",
        name: "namedRange02",
        range: {
          sheetId: "sheet-01",
          rangeData: {
            startRow: 4,
            startColumn: 2,
            endRow: 5,
            endColumn: 3
          }
        }
      }
    ]
  };
  var DEFAULT_WORKBOOK_DATA_DOWN = {
    id: "workbook-02",
    theme: "default",
    locale: "en" /* EN */,
    creator: "univer",
    name: "universheet",
    skin: "default",
    socketUrl: "",
    socketEnable: 0 /* FALSE */,
    extensions: [],
    sheetOrder: [],
    pluginMeta: {},
    styles: {
      "1": {
        cl: {
          rgb: "green"
        },
        fs: 16,
        bd: {
          t: {
            s: 9 /* MEDIUM_DASHED */,
            cl: {
              rgb: "black"
            }
          },
          l: {
            s: 9 /* MEDIUM_DASHED */,
            cl: {
              rgb: "black"
            }
          },
          r: {
            s: 13 /* THICK */,
            cl: {
              rgb: "black"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "blue"
            }
          }
        },
        ht: 3
      },
      "2": {
        bg: {
          rgb: "rgb(2, 200, 0)"
        },
        fs: 24
      },
      "3": {
        ht: 3 /* RIGHT */,
        vt: 1 /* TOP */,
        tb: 3 /* WRAP */,
        // va: BaselineOffset.SUPERSCRIPT,
        // cl: {
        //     rgb: 'rgb(0, 255, 0)',
        // },
        // st: {
        //     s: BooleanNumber.TRUE, // show
        // },
        bg: {
          rgb: "rgb(255, 255, 0)"
        },
        tr: {
          a: 45,
          v: 0 /* FALSE */
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "black"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "black"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "black"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "red"
            }
          }
        }
      },
      "4": {
        bg: {
          rgb: "rgb(0, 0, 255)"
        }
      }
    },
    timeZone: "GMT+8",
    createdTime: "2021-11-28 12:10:10",
    modifiedTime: "2021-11-29 12:10:10",
    appVersion: "3.0.0-alpha",
    lastModifiedBy: "univer",
    sheets: {
      "sheet-0001": {
        type: 0 /* GRID */,
        id: "sheet-0001",
        cellData: {
          "0": {
            "0": {
              s: "1",
              v: 2,
              m: "2"
            },
            "1": {
              s: "1",
              v: 1,
              m: "1"
            },
            "5": {
              s: "1",
              v: 8,
              m: "8"
            },
            "6": {
              s: "2",
              v: 8,
              m: "8"
            }
          },
          "1": {
            "0": {
              v: 22,
              m: "22"
            },
            "1": {
              v: 22,
              m: "22"
            },
            "2": {
              v: 80,
              m: "80",
              s: "3"
            },
            "3": {
              v: "\u5BCC\u6587\u672C\u7F16\u8F91",
              m: "\u5BCC\u6587\u672C\u7F16\u8F91",
              s: "2"
            }
          },
          "2": {
            "0": {
              v: 2222,
              m: "2222"
            },
            "1": {
              v: 2222,
              m: "2222"
            },
            "5": {
              s: "1",
              v: 8,
              m: "8"
            },
            "6": {
              s: "1",
              v: 8,
              m: "8"
            },
            "7": {
              s: "1",
              v: 8,
              m: "8"
            },
            "8": {
              s: "1",
              v: 8,
              m: "8"
            }
          },
          "3": {
            "0": {
              v: 1111,
              m: "1111"
            },
            "1": {
              v: 1111,
              m: "1111"
            }
          },
          "10": {
            "9": {
              v: 1111,
              s: "2",
              m: "1111"
            }
          },
          "13": {
            "9": {
              v: 1111,
              s: "4",
              m: "1111"
            }
          },
          "17": {
            "3": {
              v: "\u505A\u79FB\u52A8\u7AEF\u5F00\u53D1\u548C\u524D\u7AEF\u5F00\u53D1\u7684\u4EBA\u5458\uFF0C\u5BF9 MVC\u3001MVP\u3001MVVM \u8FD9\u51E0\u4E2A\u540D\u8BCD\u5E94\u8BE5\u90FD\u4E0D\u964C\u751F\uFF0C\u8FD9\u662F\u4E09\u4E2A\u6700\u5E38\u7528\u7684\u5E94\u7528\u67B6\u6784\u6A21\u5F0F\uFF0C\u76EE\u7684\u90FD\u662F\u4E3A\u4E86\u5C06\u4E1A\u52A1\u548C\u89C6\u56FE\u7684\u5B9E\u73B0\u4EE3\u7801\u5206\u79BB",
              s: "3",
              p: richTextTest2
            }
          },
          "20": {
            "10": {
              v: "\u5317\u4EAC\u9A6C\u62C9\u677E\u7EC4\u59D4\u4F1A\u529E\u516C\u5BA4\u4E00\u4F4D\u63A5\u7535\u8BDD\u7684\u5973\u58EB\u8BC1\u5B9E\uFF0C\u7684\u786E\u6709\u8FD9\u9879\u89C4\u5B9A\uFF0C\u5979\u8FD8\u79F02014\u5E74\u9A6C\u62C9\u677E\u7684\u9884\u767B\u8BB0\u5DE5\u4F5C\u5C06\u5728\u672C\u5468\u542F\u52A8\u3002\u5317\u4EAC\u9A6C\u62C9\u677E\u6BD4\u8D5B\u5C06\u572810\u670819\u65E5\u4E3E\u884C\u3002",
              s: "3"
            },
            "12": {
              s: "4"
            }
          },
          "29": {
            "13": {
              p: Tools.deepClone(richTextTest2),
              s: "4"
            }
          }
        },
        name: "sheet0001",
        tabColor: "green",
        hidden: 0 /* FALSE */,
        freezeColumn: 1,
        rowCount: 1e3,
        columnCount: 20,
        freezeRow: 1,
        zoomRatio: 1,
        scrollTop: 200,
        scrollLeft: 100,
        defaultColumnWidth: 93,
        defaultRowHeight: 27,
        mergeData: [
          {
            startRow: 0,
            endRow: 1,
            startColumn: 0,
            endColumn: 1
          },
          {
            startRow: 2,
            endRow: 6,
            startColumn: 5,
            endColumn: 10
          },
          {
            startRow: 10,
            endRow: 12,
            startColumn: 9,
            endColumn: 12
          },
          {
            startRow: 10,
            endRow: 12,
            startColumn: 9,
            endColumn: 12
          },
          {
            startRow: 17,
            endRow: 21,
            startColumn: 3,
            endColumn: 6
          },
          {
            startRow: 13,
            endRow: 15,
            startColumn: 9,
            endColumn: 10
          },
          {
            startRow: 24,
            endRow: 27,
            startColumn: 9,
            endColumn: 10
          }
        ],
        rowData: {
          "3": {
            h: 50,
            hd: 0 /* FALSE */
          },
          "4": {
            h: 60,
            hd: 0 /* FALSE */
          },
          "29": {
            h: 200,
            hd: 0 /* FALSE */
          }
        },
        columnData: {
          "5": {
            w: 100,
            hd: 0 /* FALSE */
          },
          "6": {
            w: 200,
            hd: 0 /* FALSE */
          },
          "13": {
            w: 300,
            hd: 0 /* FALSE */
          }
        },
        status: 1,
        showGridlines: 1,
        hideRow: [],
        hideColumn: [],
        rowTitle: {
          width: 46,
          hidden: 0 /* FALSE */
        },
        columnTitle: {
          height: 20,
          hidden: 0 /* FALSE */
        },
        selections: ["A2"],
        rightToLeft: 0 /* FALSE */,
        pluginMeta: {}
        // metaData: [],
      },
      "sheet-0002": {
        type: 0 /* GRID */,
        id: "sheet-0002",
        name: "sheet0003"
      }
    },
    namedRanges: [
      {
        namedRangeId: "named-range-0001",
        name: "namedRange0001",
        range: {
          sheetId: "sheet-0001",
          rangeData: {
            startRow: 0,
            startColumn: 0,
            endRow: 1,
            endColumn: 1
          }
        }
      }
    ]
  };

  // ../../packages/common-plugin-data/src/Docs/DEFAULT_LIST.ts
  var DEFAULT_LIST_TEST = {
    unorderedTest: {
      listId: "unorderedTest",
      nestingLevel: [
        {
          bulletAlignment: 1 /* START */,
          glyphFormat: " %0",
          textStyle: {
            fs: 12
          },
          startNumber: 0,
          glyphSymbol: "\u25CF",
          hanging: 21,
          indentStart: 21
        },
        {
          bulletAlignment: 1 /* START */,
          glyphFormat: " %1",
          textStyle: {
            fs: 12
          },
          startNumber: 0,
          glyphSymbol: "\u25A0",
          hanging: 21,
          indentStart: 42
        },
        {
          bulletAlignment: 1 /* START */,
          glyphFormat: " %1",
          textStyle: {
            fs: 12
          },
          startNumber: 0,
          glyphSymbol: "\u25C6",
          hanging: 21,
          indentStart: 63
        }
      ]
    },
    testBullet: {
      listId: "testBullet",
      nestingLevel: [
        {
          bulletAlignment: 1 /* START */,
          glyphFormat: " %1.",
          textStyle: {
            fs: 12
          },
          startNumber: 0,
          glyphType: 7 /* ROMAN */,
          hanging: 21,
          indentStart: 21
        },
        {
          bulletAlignment: 1 /* START */,
          glyphFormat: " %1.%2)",
          textStyle: {
            fs: 12
          },
          startNumber: 0,
          glyphType: 7 /* ROMAN */,
          hanging: 21,
          indentStart: 42
        },
        {
          bulletAlignment: 1 /* START */,
          glyphFormat: " %1.%2.%3.",
          textStyle: {
            fs: 12
          },
          startNumber: 0,
          glyphType: 7 /* ROMAN */,
          hanging: 21,
          indentStart: 63
        }
      ]
    }
  };

  // ../../packages/common-plugin-data/src/Slides/RichText/PAGE5_RICHTEXT_1.ts
  var PAGE5_RICHTEXT_1 = {
    id: "d",
    lists: DEFAULT_LIST_TEST,
    body: {
      blockElements: [
        {
          blockId: "p1",
          st: 0,
          ed: 66,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            elements: [
              {
                eId: "e1",
                st: 0,
                ed: 66,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "What\u2019s New in the 2022 Gartner Hype Cycle for Emerging Technologies",
                  ts: {
                    bl: 1 /* TRUE */,
                    fs: 16,
                    cl: {
                      rgb: "rgb(255,255,255)"
                    }
                  }
                }
              }
            ]
          }
        },
        {
          blockId: "p2",
          st: 67,
          ed: 251,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            paragraphStyle: {
              spaceAbove: 20,
              indentFirstLine: 20
            },
            elements: [
              {
                eId: "e1",
                st: 67,
                ed: 251,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "Emerging technologies for 2022 fit into three main themes: evolving/expanding immersive experiences, accelerated artificial intelligence automation, and optimized technologist delivery.",
                  ts: {
                    fs: 12,
                    cl: {
                      rgb: "rgb(0,40,86)"
                    }
                  }
                }
              }
            ]
          }
        },
        {
          blockId: "p3",
          st: 252,
          ed: 401,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            paragraphStyle: {
              spaceAbove: 20,
              indentFirstLine: 20
            },
            elements: [
              {
                eId: "e1",
                st: 252,
                ed: 401,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "The 2022 Gartner Hype Cycle identifies 25 must-know emerging technologies designed to help enterprise architecture and technology innovation leaders: ",
                  ts: {
                    fs: 12,
                    cl: {
                      rgb: "rgb(249,249,249)"
                    }
                  }
                }
              }
            ]
          }
        },
        {
          blockId: "p4",
          st: 402,
          ed: 429,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            bullet: {
              listId: "testBullet",
              nestingLevel: 0,
              textStyle: {
                fs: 20,
                cl: {
                  rgb: "rgb(249,249,249)"
                }
              }
            },
            paragraphStyle: {
              lineSpacing: 1.5
            },
            elements: [
              {
                eId: "e1",
                st: 402,
                ed: 429,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "Expand immersive experiences",
                  ts: {
                    fs: 12,
                    cl: {
                      rgb: "rgb(249,249,249)"
                    }
                  }
                }
              }
            ]
          }
        },
        {
          blockId: "p13",
          st: 2020 + 28,
          ed: 2250 + 28,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            paragraphStyle: {
              indentFirstLine: 20
            },
            bullet: {
              listId: "testBullet",
              nestingLevel: 1,
              textStyle: {
                fs: 20
              }
            },
            elements: [
              {
                eId: "e1",
                st: 2020 + 28,
                ed: 2042 + 28,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "Decentralized identity ",
                  ts: {
                    fs: 12,
                    bl: 1 /* TRUE */
                  }
                }
              }
            ]
          }
        },
        {
          blockId: "p14",
          st: 2251 + 28,
          ed: 2393 + 28,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            paragraphStyle: {
              indentFirstLine: 20
            },
            bullet: {
              listId: "testBullet",
              nestingLevel: 1,
              textStyle: {
                fs: 20
              }
            },
            elements: [
              {
                eId: "e1",
                st: 2251 + 28,
                ed: 2265 + 28,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "Digital humans ",
                  ts: {
                    fs: 12,
                    bl: 1 /* TRUE */
                  }
                }
              }
            ]
          }
        },
        {
          blockId: "p5",
          st: 430,
          ed: 479,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            bullet: {
              listId: "testBullet",
              nestingLevel: 0,
              textStyle: {
                fs: 20,
                cl: {
                  rgb: "rgb(249,249,249)"
                }
              }
            },
            paragraphStyle: {
              lineSpacing: 1.5
            },
            elements: [
              {
                eId: "e1",
                st: 430,
                ed: 479,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "Accelerate artificial intelligence (AI) automation",
                  ts: {
                    fs: 12,
                    cl: {
                      rgb: "rgb(249,249,249)"
                    }
                  }
                }
              }
            ]
          }
        },
        {
          blockId: "p15",
          st: 2394 + 28,
          ed: 2582 + 28,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            paragraphStyle: {
              indentFirstLine: 20
            },
            bullet: {
              listId: "testBullet",
              nestingLevel: 1,
              textStyle: {
                fs: 20
              }
            },
            elements: [
              {
                eId: "e1",
                st: 2394 + 28,
                ed: 2422 + 28,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "Internal talent marketplaces ",
                  ts: {
                    fs: 12,
                    cl: {
                      rgb: "rgb(0, 0, 0)"
                    },
                    bl: 1 /* TRUE */
                  }
                }
              }
            ]
          }
        },
        {
          blockId: "p6",
          st: 480,
          ed: 510,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            bullet: {
              listId: "testBullet",
              nestingLevel: 0,
              textStyle: {
                fs: 20,
                cl: {
                  rgb: "rgb(249,249,249)"
                }
              }
            },
            paragraphStyle: {
              lineSpacing: 1.5
            },
            elements: [
              {
                eId: "e1",
                st: 480,
                ed: 510,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "Optimize technologist delivery ",
                  ts: {
                    fs: 12,
                    cl: {
                      rgb: "rgb(249,249,249)"
                    }
                  }
                }
              }
            ]
          }
        }
      ]
    },
    documentStyle: {
      pageSize: {
        width: void 0,
        height: void 0
      },
      marginTop: 0,
      marginBottom: 0,
      marginRight: 2,
      marginLeft: 2
    }
  };

  // ../../packages/common-plugin-data/src/Sheets/Demo/DEFAULT_WORKBOOK_DATA_DEMO.ts
  var richTextDemo = {
    id: "d",
    body: {
      blockElements: [
        {
          blockId: "oneParagraph",
          st: 0,
          ed: 15,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            elements: [
              {
                eId: "oneElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "Instructions:",
                  ts: {
                    cl: {
                      rgb: "rgb(92,92,92)"
                    }
                  }
                }
              },
              {
                eId: "breakElement",
                et: 2 /* PAGE_BREAK */,
                st: 0,
                ed: 0
              },
              {
                eId: "twoElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u2460Project division - Fill in the specific division of labor after the project is disassembled:",
                  ts: {
                    cl: {
                      rgb: "rgb(92,92,92)"
                    }
                  }
                }
              },
              {
                eId: "breakElement1",
                et: 2 /* PAGE_BREAK */,
                st: 0,
                ed: 0
              },
              {
                eId: "threeElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u2461Responsible Person - Enter the responsible person's name here:",
                  ts: {
                    cl: {
                      rgb: "rgb(92,92,92)"
                    }
                  }
                }
              },
              {
                eId: "breakElement2",
                et: 2 /* PAGE_BREAK */,
                st: 0,
                ed: 0
              },
              {
                eId: "fourElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u2462Date-The specific execution time of the project (detailed to the date of a certain month), and the gray color block marks the planned real-time time of the division of labor of the project (for example,",
                  ts: {
                    cl: {
                      rgb: "rgb(92,92,92)"
                    }
                  }
                }
              },
              {
                eId: "breakElement3",
                et: 2 /* PAGE_BREAK */,
                st: 0,
                ed: 0
              },
              {
                eId: "fiveElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "the specific execution time of [regional scene model arrangement and construction] is the 2 days marked in gray. ",
                  ts: {
                    cl: {
                      rgb: "rgb(92,92,92)"
                    }
                  }
                }
              }
            ],
            paragraphStyle: {
              spaceAbove: 10,
              lineSpacing: 1.2
            }
          }
        }
      ]
    },
    documentStyle: {
      pageSize: {
        width: Infinity,
        height: Infinity
      },
      marginTop: 0,
      marginBottom: 0,
      marginRight: 2,
      marginLeft: 2
    }
  };
  var richTextDemo1 = {
    id: "d",
    body: {
      blockElements: [
        {
          blockId: "oneParagraph",
          st: 0,
          ed: 15,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            elements: [
              {
                eId: "oneElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "No.",
                  ts: {
                    cl: {
                      rgb: "#000"
                    },
                    fs: 20
                  }
                }
              },
              {
                eId: "twoElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "2824163",
                  ts: {
                    cl: {
                      rgb: "rgb(255,0,0)"
                    },
                    fs: 20
                  }
                }
              }
            ]
          }
        }
      ]
    },
    documentStyle: {
      pageSize: {
        width: Infinity,
        height: Infinity
      },
      marginTop: 0,
      marginBottom: 0,
      marginRight: 2,
      marginLeft: 2
    }
  };
  var DEFAULT_WORKBOOK_DATA_DEMO = {
    id: "workbook-01",
    theme: "default",
    locale: "en" /* EN */,
    creator: "univer",
    name: "UniverSheet Demo",
    skin: "default",
    socketUrl: "",
    socketEnable: 0 /* FALSE */,
    extensions: [],
    sheetOrder: [],
    pluginMeta: {},
    styles: {
      "1": {
        fs: 30,
        vt: 2,
        bl: 1,
        pd: {
          l: 5
        }
      },
      "2": {
        vt: 2,
        bl: 1,
        bg: {
          rgb: "rgb(255,226,102)"
        },
        pd: {
          l: 5
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          }
        }
      },
      "3": {
        vt: 2,
        bl: 1,
        bg: {
          rgb: "rgb(255,226,102)"
        },
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          }
        }
      },
      "4": {
        bl: 1,
        vt: 2,
        pd: {
          l: 5
        },
        bg: {
          rgb: "rgb(255,226,102)"
        },
        ht: 2
      },
      "5": {
        vt: 2,
        pd: {
          l: 5
        }
      },
      "6": {
        vt: 2,
        ht: 2,
        fs: 12,
        cl: {
          rgb: "rgb(1,136,251)"
        }
      },
      "7": {
        vt: 2,
        pd: {
          l: 5
        },
        bg: {
          rgb: "rgb(255,251,224)"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          }
        }
      },
      "8": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "rgb(1,136,251)"
        },
        pd: {
          l: 5
        },
        bg: {
          rgb: "rgb(255,251,224)"
        }
      },
      "9": {
        vt: 2,
        pd: {
          l: 25
        }
      },
      "10": {
        bg: {
          rgb: "#bf9000"
        },
        pd: {
          l: 5
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "11": {
        vt: 2,
        ht: 2,
        fs: 24,
        bg: {
          rgb: "rgb(183,83,119)"
        },
        cl: {
          rgb: "#fff"
        }
      },
      "12": {
        bg: {
          rgb: "rgb(248,237,241)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "13": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(244,186,112)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "14": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(248,237,241)"
        },
        bd: {
          b: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(218,170,186)"
            }
          }
        }
      },
      "15": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(246,131,131)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "16": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(207,98,170)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "17": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(172,135,188)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "18": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(97,170,206)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "19": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "#fff"
        },
        bg: {
          rgb: "rgb(244,186,112,0.5)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "20": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "#fff"
        },
        bg: {
          rgb: "rgb(246,131,131,0.5)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "21": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "#fff"
        },
        bg: {
          rgb: "rgb(207,98,170,0.5)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "22": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "#fff"
        },
        bg: {
          rgb: "rgb(172,135,188,0.5)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "23": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "#fff"
        },
        bg: {
          rgb: "rgb(97,170,206,0.5)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "24": {
        bg: {
          rgb: "#3d85c6"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "25": {
        bg: {
          rgb: "#c27ba0"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "26": {
        bg: {
          rgb: "rgb(224, 102, 102)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "27": {
        bg: {
          rgb: "#f90"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "28": {
        bg: {
          rgb: "#76a5af"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "29": {
        bg: {
          rgb: "#38761d"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "30": {
        vt: 2,
        ht: 2,
        fs: 30,
        bl: 1,
        bg: {
          rgb: "#6fa8dc"
        },
        cl: {
          rgb: "#fff"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "31": {
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "32": {
        vt: 2,
        tb: 3,
        bd: {
          t: null,
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "33": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "34": {
        vt: 2,
        bd: {
          t: null,
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "35": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "#6fa8dc"
        },
        cl: {
          rgb: "#fff"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "36": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "37": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "#6fa8dc"
        },
        fs: 14,
        cl: {
          rgb: "#fff"
        },
        // tr: {
        //     a: 90,
        //     v: 1,
        // },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "38": {
        vt: 2,
        tb: 3,
        bg: {
          rgb: "#6fa8dc"
        },
        cl: {
          rgb: "#fff"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "39": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "#6fa8dc"
        },
        cl: {
          rgb: "#fff"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "40": {
        vt: 2,
        ht: 2,
        fs: 24,
        cl: {
          rgb: "rgb(125,133,22)"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "41": {
        ht: 3,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "42": {
        vt: 2,
        cl: {
          rgb: "rgb(125,133,22)"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "43": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "44": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "45": {
        vt: 2,
        tb: 3,
        pd: {
          l: 10,
          r: 10
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "46": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "47": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "48": {
        vt: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "49": {
        vt: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "50": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "51": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "52": {
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "53": {
        ht: 2,
        vt: 2,
        tr: {
          a: 90,
          v: 0
        },
        cl: {
          rgb: "rgb(125,133,22)"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "54": {
        bd: {
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "55": {
        ht: 3,
        vt: 3,
        tb: 3,
        bd: {
          t: null,
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "56": {
        vt: 2,
        ht: 2,
        fs: 30,
        bl: 1,
        bg: {
          rgb: "#9fc5e8"
        },
        cl: {
          rgb: "#fff"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "57": {
        ht: 1,
        vt: 2,
        tb: 3,
        bg: {
          rgb: "#6fa8dc"
        },
        cl: {
          rgb: "rgb(255,255,255)"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          }
        }
      }
    },
    timeZone: "GMT+8",
    createdTime: "2021-11-28 12:10:10",
    modifiedTime: "2021-11-29 12:10:10",
    appVersion: "3.0.0-alpha",
    lastModifiedBy: "univer",
    sheets: {
      "sheet-0004": {
        type: 0 /* GRID */,
        id: "sheet-0004",
        name: "sheet0004",
        cellData: {
          "0": {
            "0": {
              s: "40"
            },
            "1": {
              m: "Travel Declaration Form",
              s: "40"
            },
            "8": {
              p: richTextDemo1,
              s: "41"
            },
            "10": {
              s: "52"
            }
          },
          "1": {
            "1": {
              m: "Department:",
              s: "42"
            },
            "6": {
              m: "Application Date:",
              s: "42"
            }
          },
          "2": {
            "1": {
              m: "Business Trip Employee",
              s: "43"
            },
            "2": {
              s: "46"
            },
            "3": {
              m: "Position",
              s: "46"
            },
            "4": {
              s: "46"
            },
            "6": {
              s: "46",
              m: "Entourage"
            },
            "7": {
              s: "47"
            },
            "10": {
              m: "Borrower write-off",
              s: "53"
            }
          },
          "3": {
            "1": {
              m: "Business Trip Place",
              s: "44"
            },
            "2": {
              m: "                      To                      To                      To",
              s: "48"
            }
          },
          "4": {
            "1": {
              m: "Amount",
              s: "44"
            },
            "2": {
              m: "(Capital)         \u4E07        \u4EDF        \u4F70        \u62FE        \u5143        \u89D2        \u5206",
              s: "49"
            },
            "7": {
              m: "(Lower) \xA5",
              s: "48"
            }
          },
          "5": {
            "1": {
              m: "Departure Time",
              s: "44"
            },
            "2": {
              s: "49"
            },
            "3": {
              m: "ETR",
              s: "50"
            },
            "5": {
              s: "50"
            },
            "8": {
              m: "Days",
              s: "50"
            },
            "9": {
              s: "48"
            }
          },
          "6": {
            "1": {
              m: "Reasons",
              s: "44"
            },
            "2": {
              s: "48"
            }
          },
          "7": {
            "1": {
              m: "Applicant For Travel",
              s: "44"
            },
            "2": {
              s: "50"
            },
            "3": {
              m: "Administrator",
              s: "50"
            },
            "4": {
              s: "50"
            },
            "6": {
              m: "Financial Manager",
              s: "50"
            },
            "7": {
              s: "50"
            },
            "9": {
              m: "Payee",
              s: "51"
            }
          },
          "8": {
            "1": {
              m: "Department Head",
              s: "44"
            },
            "2": {
              s: "50"
            },
            "3": {
              m: "Manager",
              s: "50"
            },
            "4": {
              s: "50"
            },
            "6": {
              m: "Cashier",
              s: "50"
            },
            "7": {
              s: "50"
            },
            "9": {
              s: "51"
            }
          },
          "9": {
            "1": {
              m: "Record: The loan is used exclusively for travel expenses, and the travel expenses will not be written off without a business trip application.",
              s: "45"
            }
          }
        },
        tabColor: "blue",
        hidden: 0 /* FALSE */,
        freezeColumn: 1,
        rowCount: 13,
        columnCount: 14,
        freezeRow: 1,
        zoomRatio: 1,
        scrollTop: 200,
        scrollLeft: 100,
        defaultColumnWidth: 93,
        defaultRowHeight: 40,
        mergeData: [
          {
            startRow: 0,
            endRow: 1,
            startColumn: 10,
            endColumn: 10
          },
          {
            startRow: 0,
            endRow: 9,
            startColumn: 0,
            endColumn: 0
          },
          {
            startRow: 0,
            endRow: 0,
            startColumn: 1,
            endColumn: 7
          },
          {
            startRow: 0,
            endRow: 0,
            startColumn: 8,
            endColumn: 9
          },
          {
            startRow: 1,
            endRow: 1,
            startColumn: 1,
            endColumn: 4
          },
          {
            startRow: 1,
            endRow: 1,
            startColumn: 6,
            endColumn: 9
          },
          {
            startRow: 2,
            endRow: 2,
            startColumn: 4,
            endColumn: 5
          },
          {
            startRow: 2,
            endRow: 2,
            startColumn: 7,
            endColumn: 9
          },
          {
            startRow: 3,
            endRow: 3,
            startColumn: 2,
            endColumn: 9
          },
          {
            startRow: 4,
            endRow: 4,
            startColumn: 2,
            endColumn: 6
          },
          {
            startRow: 4,
            endRow: 4,
            startColumn: 7,
            endColumn: 9
          },
          {
            startRow: 5,
            endRow: 5,
            startColumn: 3,
            endColumn: 4
          },
          {
            startRow: 5,
            endRow: 5,
            startColumn: 5,
            endColumn: 7
          },
          {
            startRow: 6,
            endRow: 6,
            startColumn: 2,
            endColumn: 9
          },
          {
            startRow: 7,
            endRow: 7,
            startColumn: 4,
            endColumn: 5
          },
          {
            startRow: 8,
            endRow: 8,
            startColumn: 7,
            endColumn: 8
          },
          {
            startRow: 8,
            endRow: 8,
            startColumn: 4,
            endColumn: 5
          },
          {
            startRow: 7,
            endRow: 7,
            startColumn: 7,
            endColumn: 8
          },
          {
            startRow: 9,
            endRow: 9,
            startColumn: 1,
            endColumn: 9
          },
          {
            startRow: 2,
            endRow: 9,
            startColumn: 10,
            endColumn: 10
          }
        ],
        rowData: {
          "0": {
            h: 50
          },
          "1": {
            h: 20
          },
          "6": {
            h: 150
          },
          "9": {
            h: 30
          }
        },
        columnData: {
          "0": {
            w: 20
          },
          "1": {
            w: 180
          },
          "2": {
            w: 120
          },
          "4": {
            w: 60
          },
          "5": {
            w: 60
          },
          "7": {
            w: 30
          },
          "8": {
            w: 90
          },
          "10": {
            w: 40
          }
        },
        status: 1,
        showGridlines: 0,
        hideRow: [],
        hideColumn: [],
        rowTitle: {
          width: 46,
          hidden: 0 /* FALSE */
        },
        columnTitle: {
          height: 20,
          hidden: 0 /* FALSE */
        },
        selections: ["A2"],
        rightToLeft: 0 /* FALSE */,
        pluginMeta: {}
      },
      "sheet-0003": {
        type: 0 /* GRID */,
        id: "sheet-0003",
        name: "sheet0003",
        cellData: {
          "0": {
            "1": {
              m: "Purchase Orders ",
              s: "56"
            },
            "4": {
              s: "31"
            },
            "5": {
              m: "Number:",
              s: "32"
            },
            "6": {
              s: "31"
            },
            "7": {
              p: PAGE5_RICHTEXT_1,
              s: "57"
            }
          },
          "1": {
            "4": {
              s: "31"
            }
          },
          "2": {
            "4": {
              m: "[Company]:",
              s: "33"
            },
            "5": {
              s: "34"
            }
          },
          "3": {
            "4": {
              m: "[Adress]:",
              s: "33"
            },
            "5": {
              s: "34"
            }
          },
          "4": {
            "4": {
              m: "[TEL]:",
              s: "33"
            },
            "5": {
              s: "34"
            }
          },
          "5": {
            "4": {
              m: "[FAX]:",
              s: "33"
            },
            "5": {
              s: "34"
            }
          },
          "6": {
            "1": {
              s: "32"
            }
          },
          "7": {
            "1": {
              m: "Subscriber:",
              s: "32"
            },
            "2": {
              s: "34"
            },
            "3": {
              m: "Order Date:",
              s: "32"
            },
            "4": {
              s: "34"
            },
            "5": {
              m: "Telephone:",
              s: "32"
            },
            "6": {
              s: "34"
            }
          },
          "8": {
            "1": {
              m: "Payment:",
              s: "32"
            },
            "2": {
              s: "34"
            },
            "3": {
              m: "Delivery:",
              s: "32"
            },
            "4": {
              s: "34"
            },
            "5": {
              s: "32"
            },
            "6": {
              s: "32"
            }
          },
          "9": {
            "1": {
              s: "32"
            }
          },
          "10": {
            "1": {
              m: "SKU",
              s: "35"
            },
            "2": {
              m: "Product name ",
              s: "35"
            },
            "4": {
              m: "Quantity",
              s: "35"
            },
            "5": {
              m: "Price",
              s: "35"
            },
            "6": {
              m: "Amount",
              s: "35"
            }
          },
          "11": {
            "1": {
              s: "36"
            },
            "2": {
              s: "36"
            },
            "3": {
              s: "36"
            },
            "4": {
              s: "36",
              m: "1",
              v: "1"
            },
            "5": {
              s: "36",
              m: "10",
              v: "10"
            },
            "6": {
              s: "36",
              m: "10",
              v: "10"
            }
          },
          "12": {
            "1": {
              s: "36"
            },
            "2": {
              s: "36"
            },
            "3": {
              s: "36"
            },
            "4": {
              s: "36",
              m: "2",
              v: "2"
            },
            "5": {
              s: "36",
              m: "10",
              v: "10"
            },
            "6": {
              s: "36",
              m: "20",
              v: "20"
            }
          },
          "13": {
            "1": {
              s: "36"
            },
            "2": {
              s: "36"
            },
            "3": {
              s: "36"
            },
            "4": {
              s: "36",
              m: "2",
              v: "2"
            },
            "5": {
              s: "36",
              m: "2",
              v: "2"
            },
            "6": {
              s: "36"
            }
          },
          "14": {
            "1": {
              s: "36"
            },
            "2": {
              s: "36"
            },
            "3": {
              s: "36"
            },
            "4": {
              s: "36"
            },
            "5": {
              s: "36"
            },
            "6": {
              s: "36"
            }
          },
          "15": {
            "1": {
              s: "36"
            },
            "2": {
              s: "36"
            },
            "3": {
              s: "36"
            },
            "4": {
              s: "36"
            },
            "5": {
              s: "36"
            },
            "6": {
              s: "36"
            }
          },
          "16": {
            "1": {
              s: "36"
            },
            "2": {
              s: "36"
            },
            "3": {
              s: "36"
            },
            "4": {
              s: "36"
            },
            "5": {
              s: "36"
            },
            "6": {
              s: "36"
            }
          },
          "17": {
            "1": {
              s: "36"
            },
            "2": {
              s: "36"
            },
            "3": {
              s: "36"
            },
            "4": {
              s: "36"
            },
            "5": {
              s: "36"
            },
            "6": {
              s: "36"
            }
          },
          "18": {
            "1": {
              s: "36"
            },
            "2": {
              s: "36"
            },
            "3": {
              s: "36"
            },
            "4": {
              s: "36"
            },
            "5": {
              s: "36"
            },
            "6": {
              s: "36"
            }
          },
          "19": {
            "1": {
              m: "Remark ",
              s: "37"
            },
            "2": {
              m: "If there is any problem, please list the specific reasons in writing and fax to contact the company.",
              s: "38"
            },
            "5": {
              m: "Subtotal",
              s: "39"
            },
            "6": {
              s: "36"
            }
          },
          "20": {
            "5": {
              m: "Tax",
              s: "39"
            },
            "6": {
              s: "36"
            }
          },
          "21": {
            "5": {
              m: "Freight",
              s: "39"
            },
            "6": {
              s: "36"
            }
          },
          "22": {
            "5": {
              m: "Total ",
              s: "39"
            },
            "6": {
              s: "36"
            }
          },
          "23": {
            "1": {
              s: "32"
            }
          },
          "24": {
            "1": {
              m: "Approval of Responsible Person:",
              s: "55"
            },
            "2": {
              s: "34"
            },
            "3": {
              m: "Accountant:",
              s: "55"
            },
            "4": {
              s: "34"
            },
            "5": {
              m: "Responsible Person:",
              s: "55"
            },
            "6": {
              s: "34"
            }
          },
          "25": {
            "1": {
              m: "Company:",
              s: "55"
            },
            "2": {
              s: "34"
            },
            "3": {
              s: "32"
            },
            "4": {
              s: "32"
            },
            "5": {
              m: "Date:",
              s: "55"
            },
            "6": {
              s: "34"
            }
          },
          "26": {
            "1": {
              s: "54"
            }
          }
        },
        tabColor: "green",
        hidden: 0 /* FALSE */,
        freezeColumn: 1,
        rowCount: 100,
        columnCount: 8,
        freezeRow: 1,
        zoomRatio: 1,
        scrollTop: 200,
        scrollLeft: 100,
        defaultColumnWidth: 93,
        defaultRowHeight: 25,
        mergeData: [
          {
            startRow: 0,
            endRow: 5,
            startColumn: 1,
            endColumn: 3
          },
          {
            startRow: 1,
            endRow: 1,
            startColumn: 4,
            endColumn: 6
          },
          {
            startRow: 2,
            endRow: 2,
            startColumn: 5,
            endColumn: 6
          },
          {
            startRow: 3,
            endRow: 3,
            startColumn: 5,
            endColumn: 6
          },
          {
            startRow: 4,
            endRow: 4,
            startColumn: 5,
            endColumn: 6
          },
          {
            startRow: 5,
            endRow: 5,
            startColumn: 5,
            endColumn: 6
          },
          {
            startRow: 6,
            endRow: 6,
            startColumn: 1,
            endColumn: 6
          },
          {
            startRow: 9,
            endRow: 9,
            startColumn: 1,
            endColumn: 6
          },
          {
            startRow: 10,
            endRow: 10,
            startColumn: 2,
            endColumn: 3
          },
          {
            startRow: 11,
            endRow: 11,
            startColumn: 2,
            endColumn: 3
          },
          {
            startRow: 12,
            endRow: 12,
            startColumn: 2,
            endColumn: 3
          },
          {
            startRow: 13,
            endRow: 13,
            startColumn: 2,
            endColumn: 3
          },
          {
            startRow: 14,
            endRow: 14,
            startColumn: 2,
            endColumn: 3
          },
          {
            startRow: 15,
            endRow: 15,
            startColumn: 2,
            endColumn: 3
          },
          {
            startRow: 16,
            endRow: 16,
            startColumn: 2,
            endColumn: 3
          },
          {
            startRow: 17,
            endRow: 17,
            startColumn: 2,
            endColumn: 3
          },
          {
            startRow: 18,
            endRow: 18,
            startColumn: 2,
            endColumn: 3
          },
          {
            startRow: 19,
            endRow: 22,
            startColumn: 1,
            endColumn: 1
          },
          {
            startRow: 19,
            endRow: 22,
            startColumn: 2,
            endColumn: 4
          },
          {
            startRow: 23,
            endRow: 23,
            startColumn: 1,
            endColumn: 6
          },
          {
            startRow: 0,
            endRow: 26,
            startColumn: 0,
            endColumn: 0
          },
          {
            startRow: 0,
            endRow: 26,
            startColumn: 7,
            endColumn: 7
          },
          {
            startRow: 26,
            endRow: 26,
            startColumn: 1,
            endColumn: 6
          }
        ],
        rowData: {
          "9": {
            h: 10
          },
          "23": {
            h: 30
          },
          "24": {
            h: 70
          }
        },
        columnData: {
          "0": {
            w: 30
          },
          "1": {
            w: 80
          },
          "2": {
            w: 120
          },
          "3": {
            w: 80
          },
          "7": {
            w: 200
          }
        },
        status: 0,
        showGridlines: 0,
        hideRow: [],
        hideColumn: [],
        rowTitle: {
          width: 46,
          hidden: 0 /* FALSE */
        },
        columnTitle: {
          height: 20,
          hidden: 0 /* FALSE */
        },
        selections: ["A2"],
        rightToLeft: 0 /* FALSE */,
        pluginMeta: {}
      },
      "sheet-0002": {
        type: 0 /* GRID */,
        id: "sheet-0002",
        name: "sheet0003",
        cellData: {
          "0": {
            "0": {
              m: "Annual Work Schedule",
              s: "11"
            }
          },
          "1": {
            "0": {
              s: "12"
            },
            "1": {
              s: "12"
            },
            "16": {
              s: "12"
            }
          },
          "2": {
            "0": {
              s: "12"
            },
            "1": {
              m: "1/2",
              s: "13"
            },
            "4": {
              m: "3/8",
              s: "15"
            },
            "7": {
              m: "1/4",
              s: "16"
            },
            "10": {
              m: "1/4",
              s: "17"
            },
            "13": {
              m: "1/4",
              s: "18"
            },
            "16": {
              s: "12"
            }
          },
          "3": {
            "1": {
              s: "12"
            }
          },
          "4": {
            "0": {
              s: "12"
            },
            "1": {
              s: "12"
            },
            "2": {
              m: "Go to the party",
              s: "14"
            },
            "3": {
              m: "\u221A",
              s: "14"
            },
            "4": {
              s: "12"
            },
            "5": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "6": {
              m: "\u221A",
              s: "14"
            },
            "7": {
              s: "12"
            },
            "8": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "9": {
              m: "\u221A",
              s: "14"
            },
            "10": {
              s: "12"
            },
            "11": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "12": {
              s: "14"
            },
            "13": {
              s: "12"
            },
            "14": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "15": {
              m: "\u221A",
              s: "14"
            }
          },
          "5": {
            "0": {
              s: "12"
            },
            "1": {
              s: "12"
            },
            "2": {
              m: "Purchase  Products",
              s: "14"
            },
            "3": {
              m: "\u221A",
              s: "14"
            },
            "4": {
              s: "12"
            },
            "5": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "6": {
              m: "\u221A",
              s: "14"
            },
            "7": {
              s: "12"
            },
            "8": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "9": {
              s: "14"
            },
            "10": {
              s: "12"
            },
            "11": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "12": {
              s: "14"
            },
            "13": {
              s: "12"
            },
            "14": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "15": {
              m: "\u221A",
              s: "14"
            }
          },
          "6": {
            "0": {
              s: "12"
            },
            "1": {
              s: "12"
            },
            "2": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "3": {
              m: "\u221A",
              s: "14"
            },
            "4": {
              s: "12"
            },
            "5": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "6": {
              s: "14"
            },
            "7": {
              s: "12"
            },
            "8": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "9": {
              s: "14"
            },
            "10": {
              s: "12"
            },
            "11": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "12": {
              s: "14"
            },
            "13": {
              s: "12"
            },
            "14": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "15": {
              s: "14"
            }
          },
          "7": {
            "0": {
              s: "12"
            },
            "1": {
              s: "12"
            },
            "2": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "3": {
              s: "14"
            },
            "4": {
              s: "12"
            },
            "5": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "6": {
              s: "14"
            },
            "7": {
              s: "12"
            },
            "8": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "9": {
              s: "14"
            },
            "10": {
              s: "12"
            },
            "11": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "12": {
              s: "14"
            },
            "13": {
              s: "12"
            },
            "14": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "15": {
              s: "14"
            }
          },
          "8": {
            "0": {
              s: "12"
            },
            "1": {
              s: "12"
            },
            "2": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "3": {
              s: "14"
            },
            "4": {
              s: "12"
            },
            "5": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "6": {
              s: "14"
            },
            "7": {
              s: "12"
            },
            "8": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "9": {
              s: "14"
            },
            "10": {
              s: "12"
            },
            "11": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "12": {
              s: "14"
            },
            "13": {
              s: "12"
            },
            "14": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "15": {
              s: "14"
            }
          },
          "9": {
            "1": {
              s: "12"
            }
          },
          "10": {
            "1": {
              s: "12"
            },
            "2": {
              s: "19",
              m: "January"
            },
            "3": {
              s: "12"
            },
            "4": {
              s: "12"
            },
            "5": {
              s: "20",
              m: "February"
            },
            "6": {
              s: "12"
            },
            "7": {
              s: "12"
            },
            "8": {
              s: "21",
              m: "March"
            },
            "9": {
              s: "12"
            },
            "10": {
              s: "12"
            },
            "11": {
              s: "22",
              m: "April"
            },
            "12": {
              s: "12"
            },
            "13": {
              s: "12"
            },
            "14": {
              s: "23",
              m: "May"
            },
            "15": {
              s: "12"
            }
          },
          "11": {
            "1": {
              s: "12"
            }
          },
          "12": {
            "0": {
              s: "12"
            },
            "1": {
              m: "1/3",
              s: "13"
            },
            "4": {
              m: "3/5",
              s: "15"
            },
            "7": {
              m: "1/2",
              s: "16"
            },
            "10": {
              m: "3/4",
              s: "17"
            },
            "13": {
              m: "5/6",
              s: "18"
            },
            "16": {
              s: "12"
            }
          },
          "13": {
            "0": {
              s: "12"
            },
            "1": {
              s: "12"
            },
            "2": {
              m: "Go to the party",
              s: "14"
            },
            "3": {
              m: "\u221A",
              s: "14"
            },
            "4": {
              s: "12"
            },
            "5": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "6": {
              m: "\u221A",
              s: "14"
            },
            "7": {
              s: "12"
            },
            "8": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "9": {
              m: "\u221A",
              s: "14"
            },
            "10": {
              s: "12"
            },
            "11": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "12": {
              s: "14"
            },
            "13": {
              s: "12"
            },
            "14": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "15": {
              m: "\u221A",
              s: "14"
            }
          },
          "14": {
            "0": {
              s: "12"
            },
            "1": {
              s: "12"
            },
            "2": {
              m: "Purchase Products",
              s: "14"
            },
            "3": {
              m: "\u221A",
              s: "14"
            },
            "4": {
              s: "12"
            },
            "5": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "6": {
              m: "\u221A",
              s: "14"
            },
            "7": {
              s: "12"
            },
            "8": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "9": {
              s: "14"
            },
            "10": {
              s: "12"
            },
            "11": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "12": {
              s: "14"
            },
            "13": {
              s: "12"
            },
            "14": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "15": {
              m: "\u221A",
              s: "14"
            }
          },
          "15": {
            "0": {
              s: "12"
            },
            "1": {
              s: "12"
            },
            "2": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "3": {
              m: "\u221A",
              s: "14"
            },
            "4": {
              s: "12"
            },
            "5": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "6": {
              s: "14"
            },
            "7": {
              s: "12"
            },
            "8": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "9": {
              s: "14"
            },
            "10": {
              s: "12"
            },
            "11": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "12": {
              s: "14"
            },
            "13": {
              s: "12"
            },
            "14": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "15": {
              s: "14"
            }
          },
          "16": {
            "0": {
              s: "12"
            },
            "1": {
              s: "12"
            },
            "2": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "3": {
              s: "14"
            },
            "4": {
              s: "12"
            },
            "5": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "6": {
              s: "14"
            },
            "7": {
              s: "12"
            },
            "8": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "9": {
              s: "14"
            },
            "10": {
              s: "12"
            },
            "11": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "12": {
              s: "14"
            },
            "13": {
              s: "12"
            },
            "14": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "15": {
              s: "14"
            }
          },
          "17": {
            "0": {
              s: "12"
            },
            "1": {
              s: "12"
            },
            "2": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "3": {
              s: "14"
            },
            "4": {
              s: "12"
            },
            "5": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "6": {
              s: "14"
            },
            "7": {
              s: "12"
            },
            "8": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "9": {
              s: "14"
            },
            "10": {
              s: "12"
            },
            "11": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "12": {
              s: "14"
            },
            "13": {
              s: "12"
            },
            "14": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "15": {
              s: "14"
            }
          },
          "18": {
            "0": {
              s: "12"
            }
          },
          "25": {
            "0": {
              m: "\xB7",
              s: "123"
            }
          }
        },
        tabColor: "yellow",
        hidden: 0 /* FALSE */,
        freezeColumn: 1,
        rowCount: 26,
        columnCount: 17,
        freezeRow: 1,
        zoomRatio: 1,
        scrollTop: 200,
        scrollLeft: 100,
        defaultColumnWidth: 93,
        defaultRowHeight: 32,
        mergeData: [
          {
            startRow: 0,
            endRow: 0,
            startColumn: 0,
            endColumn: 16
          },
          {
            startRow: 1,
            endRow: 17,
            startColumn: 0,
            endColumn: 0
          },
          {
            startRow: 1,
            endRow: 17,
            startColumn: 16,
            endColumn: 16
          },
          {
            startRow: 1,
            endRow: 1,
            startColumn: 1,
            endColumn: 15
          },
          {
            startRow: 3,
            endRow: 3,
            startColumn: 1,
            endColumn: 15
          },
          {
            startRow: 2,
            endRow: 2,
            startColumn: 1,
            endColumn: 3
          },
          {
            startRow: 2,
            endRow: 2,
            startColumn: 4,
            endColumn: 6
          },
          {
            startRow: 2,
            endRow: 2,
            startColumn: 7,
            endColumn: 9
          },
          {
            startRow: 2,
            endRow: 2,
            startColumn: 10,
            endColumn: 12
          },
          {
            startRow: 2,
            endRow: 2,
            startColumn: 13,
            endColumn: 15
          },
          {
            startRow: 9,
            endRow: 9,
            startColumn: 1,
            endColumn: 15
          },
          {
            startRow: 11,
            endRow: 11,
            startColumn: 1,
            endColumn: 15
          },
          {
            startRow: 12,
            endRow: 12,
            startColumn: 1,
            endColumn: 3
          },
          {
            startRow: 12,
            endRow: 12,
            startColumn: 4,
            endColumn: 6
          },
          {
            startRow: 12,
            endRow: 12,
            startColumn: 7,
            endColumn: 9
          },
          {
            startRow: 12,
            endRow: 12,
            startColumn: 10,
            endColumn: 12
          },
          {
            startRow: 12,
            endRow: 12,
            startColumn: 13,
            endColumn: 15
          },
          {
            startRow: 18,
            endRow: 22,
            startColumn: 0,
            endColumn: 16
          }
        ],
        rowData: {
          "0": {
            h: 70
          },
          "3": {
            h: 20
          },
          "9": {
            h: 20
          },
          "10": {
            h: 40
          },
          "11": {
            h: 20
          }
        },
        columnData: {
          "0": {
            w: 50
          },
          "1": {
            w: 20
          },
          "2": {
            w: 150
          },
          "3": {
            w: 30
          },
          "4": {
            w: 20
          },
          "5": {
            w: 150
          },
          "6": {
            w: 30
          },
          "7": {
            w: 20
          },
          "8": {
            w: 150
          },
          "9": {
            w: 30
          },
          "10": {
            w: 20
          },
          "11": {
            w: 150
          },
          "12": {
            w: 30
          },
          "13": {
            w: 20
          },
          "14": {
            w: 150
          },
          "15": {
            w: 30
          },
          "16": {
            w: 50
          }
        },
        status: 0,
        showGridlines: 0,
        hideRow: [],
        hideColumn: [],
        rowTitle: {
          width: 46,
          hidden: 0 /* FALSE */
        },
        columnTitle: {
          height: 20,
          hidden: 0 /* FALSE */
        },
        selections: ["A2"],
        rightToLeft: 0 /* FALSE */,
        pluginMeta: {}
      },
      "sheet-0001": {
        type: 0 /* GRID */,
        id: "sheet-0001",
        cellData: {
          "0": {
            "0": {
              s: "1",
              m: "A Schedule of Items"
            }
          },
          "1": {
            "0": {
              s: "2",
              m: "Division of Project"
            },
            "1": {
              s: "3",
              m: "Responsible Person"
            },
            "2": {
              s: "4",
              m: "Date"
            }
          },
          "2": {
            "0": {
              m: "General Project Manager",
              s: "5"
            },
            "1": {
              m: "@XXX",
              s: "6"
            },
            "2": {
              m: "March 1",
              s: "5"
            },
            "3": {
              m: "March 2",
              s: "5"
            },
            "4": {
              m: "March 3",
              s: "5"
            },
            "5": {
              m: "March 4",
              s: "5"
            },
            "6": {
              m: "March 5",
              s: "5"
            },
            "7": {
              m: "March 6",
              s: "5"
            },
            "8": {
              m: "March 7",
              s: "5"
            },
            "9": {
              m: "March 8",
              s: "5"
            },
            "10": {
              m: "March 9",
              s: "5"
            },
            "11": {
              m: "March 10",
              s: "5"
            },
            "12": {
              m: "March 11",
              s: "5"
            },
            "13": {
              m: "March 12",
              s: "5"
            },
            "14": {
              m: "March 13",
              s: "5"
            }
          },
          "3": {
            "0": {
              m: "1\u3001Responsible Person of Model Section",
              s: "7"
            },
            "1": {
              m: "@George",
              s: "8"
            }
          },
          "4": {
            "0": {
              m: "Advertisement Signboard",
              s: "9"
            },
            "1": {
              m: "@Paul",
              s: "6"
            },
            "4": {
              s: "10"
            },
            "5": {
              s: "10"
            },
            "6": {
              s: "10"
            },
            "7": {
              s: "10"
            },
            "8": {
              s: "10"
            },
            "9": {
              s: "10"
            },
            "10": {
              s: "10"
            }
          },
          "5": {
            "0": {
              m: "Transport Ready",
              s: "9"
            },
            "1": {
              m: "@George",
              s: "6"
            }
          },
          "6": {
            "0": {
              m: "2\u3001Head of Special Effects Section",
              s: "7"
            },
            "1": {
              m: "@Paul",
              s: "8"
            }
          },
          "7": {
            "0": {
              m: "Render Output Parameter Test",
              s: "9"
            },
            "1": {
              m: "@Paul",
              s: "6"
            },
            "3": {
              s: "25"
            },
            "4": {
              s: "25"
            },
            "5": {
              s: "25"
            },
            "6": {
              s: "25"
            },
            "7": {
              s: "25"
            },
            "8": {
              s: "25"
            },
            "9": {
              s: "25"
            }
          },
          "8": {
            "0": {
              m: "Camera Moving Mirror",
              s: "9"
            },
            "1": {
              m: "@Paul",
              s: "6"
            }
          },
          "9": {
            "0": {
              m: "3\u3001Responsible Person of Rendering Section",
              s: "7"
            },
            "1": {
              m: "@Jennifer",
              s: "8"
            }
          },
          "10": {
            "0": {
              m: "Scene Dynamic Element Design",
              s: "9"
            },
            "7": {
              s: "27"
            },
            "8": {
              s: "27"
            },
            "9": {
              s: "27"
            },
            "10": {
              s: "27"
            },
            "11": {
              s: "27"
            }
          },
          "11": {
            "0": {
              m: "Sky Map Selection",
              s: "9"
            }
          },
          "12": {
            "0": {
              m: "Reference Scenario Data Collection",
              s: "9"
            }
          },
          "13": {
            "0": {
              m: "Scene Dynamic Element Design",
              s: "9"
            },
            "2": {
              s: "29"
            },
            "3": {
              s: "29"
            },
            "4": {
              s: "29"
            },
            "5": {
              s: "29"
            },
            "6": {
              s: "29"
            },
            "7": {
              s: "29"
            }
          },
          "14": {
            "0": {
              p: richTextDemo
            }
          }
        },
        name: "sheet0001",
        tabColor: "red",
        hidden: 0 /* FALSE */,
        freezeColumn: 1,
        rowCount: 15,
        columnCount: 15,
        freezeRow: 1,
        zoomRatio: 1,
        scrollTop: 200,
        scrollLeft: 100,
        defaultColumnWidth: 93,
        defaultRowHeight: 32,
        mergeData: [
          {
            startRow: 0,
            endRow: 0,
            startColumn: 0,
            endColumn: 14
          },
          {
            startRow: 1,
            endRow: 1,
            startColumn: 2,
            endColumn: 14
          },
          {
            startRow: 14,
            endRow: 14,
            startColumn: 0,
            endColumn: 14
          }
        ],
        rowData: {
          "0": {
            h: 70
          },
          "2": {
            h: 20
          },
          "3": {
            h: 20
          },
          "4": {
            h: 20
          },
          "5": {
            h: 20
          },
          "6": {
            h: 20
          },
          "7": {
            h: 20
          },
          "8": {
            h: 20
          },
          "9": {
            h: 20
          },
          "10": {
            h: 20
          },
          "11": {
            h: 20
          },
          "12": {
            h: 20
          },
          "13": {
            h: 20
          },
          "14": {
            h: 200
          }
        },
        columnData: {
          "0": {
            w: 250
          },
          "1": {
            w: 130
          },
          "2": {
            w: 60
          },
          "3": {
            w: 60
          },
          "4": {
            w: 60
          },
          "5": {
            w: 60
          },
          "6": {
            w: 60
          },
          "7": {
            w: 60
          },
          "8": {
            w: 60
          },
          "9": {
            w: 60
          },
          "10": {
            w: 60
          },
          "11": {
            w: 60
          },
          "12": {
            w: 60
          },
          "13": {
            w: 60
          },
          "14": {
            w: 60
          }
        },
        status: 0,
        showGridlines: 1,
        hideRow: [],
        hideColumn: [],
        rowTitle: {
          width: 46,
          hidden: 0 /* FALSE */
        },
        columnTitle: {
          height: 20,
          hidden: 0 /* FALSE */
        },
        selections: ["A2"],
        rightToLeft: 0 /* FALSE */,
        pluginMeta: {}
      }
    },
    namedRanges: [
      {
        namedRangeId: "named-rang",
        name: "namedRange",
        range: {
          sheetId: "sheet-0001",
          rangeData: {
            startRow: 0,
            startColumn: 0,
            endRow: 1,
            endColumn: 1
          }
        }
      }
    ]
  };

  // ../../packages/common-plugin-data/src/Sheets/Demo/DEFAULT_WORKBOOK_DATA_DEMO1.ts
  var DEFAULT_WORKBOOK_DATA_DEMO1 = {
    id: "workbook-01",
    theme: "default",
    locale: "en" /* EN */,
    creator: "univer",
    name: "universheet",
    skin: "default",
    socketUrl: "",
    socketEnable: 0 /* FALSE */,
    extensions: [],
    sheetOrder: [],
    pluginMeta: {},
    styles: {
      "1": {
        fs: 30,
        vt: 2,
        bl: 1,
        pd: {
          l: 5
        }
      },
      "2": {
        vt: 2,
        bl: 1,
        bg: {
          rgb: "rgb(255,226,102)"
        },
        pd: {
          l: 5
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          }
        }
      },
      "3": {
        vt: 2,
        bl: 1,
        bg: {
          rgb: "rgb(255,226,102)"
        },
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          }
        }
      },
      "4": {
        bl: 1,
        vt: 2,
        pd: {
          l: 5
        },
        bg: {
          rgb: "rgb(255,226,102)"
        },
        ht: 2
      },
      "5": {
        vt: 2,
        pd: {
          l: 5
        }
      },
      "6": {
        vt: 2,
        ht: 2,
        fs: 12,
        cl: {
          rgb: "rgb(1,136,251)"
        }
      },
      "7": {
        vt: 2,
        pd: {
          l: 5
        },
        bg: {
          rgb: "rgb(255,251,224)"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          }
        }
      },
      "8": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "rgb(1,136,251)"
        },
        pd: {
          l: 5
        },
        bg: {
          rgb: "rgb(255,251,224)"
        }
      },
      "9": {
        vt: 2,
        pd: {
          l: 25
        }
      },
      "10": {
        bg: {
          rgb: "#bf9000"
        },
        pd: {
          l: 5
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "11": {
        vt: 2,
        ht: 2,
        fs: 24,
        bg: {
          rgb: "rgb(183,83,119)"
        },
        cl: {
          rgb: "#fff"
        }
      },
      "12": {
        bg: {
          rgb: "rgb(248,237,241)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "13": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(244,186,112)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "14": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(248,237,241)"
        },
        bd: {
          b: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(218,170,186)"
            }
          }
        }
      },
      "15": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(246,131,131)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "16": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(207,98,170)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "17": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(172,135,188)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "18": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(97,170,206)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "19": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "#fff"
        },
        bg: {
          rgb: "rgb(244,186,112,0.5)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "20": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "#fff"
        },
        bg: {
          rgb: "rgb(246,131,131,0.5)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "21": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "#fff"
        },
        bg: {
          rgb: "rgb(207,98,170,0.5)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "22": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "#fff"
        },
        bg: {
          rgb: "rgb(172,135,188,0.5)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "23": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "#fff"
        },
        bg: {
          rgb: "rgb(97,170,206,0.5)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "24": {
        bg: {
          rgb: "#3d85c6"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "25": {
        bg: {
          rgb: "#c27ba0"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "26": {
        bg: {
          rgb: "rgb(224, 102, 102)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "27": {
        bg: {
          rgb: "#f90"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "28": {
        bg: {
          rgb: "#76a5af"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "29": {
        bg: {
          rgb: "#38761d"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "30": {
        vt: 2,
        ht: 2,
        fs: 30,
        bl: 1,
        bg: {
          rgb: "#6fa8dc"
        },
        cl: {
          rgb: "#fff"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "31": {
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "32": {
        vt: 2,
        tb: 3,
        bd: {
          t: null,
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "33": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "34": {
        vt: 2,
        bd: {
          t: null,
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "35": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "#6fa8dc"
        },
        cl: {
          rgb: "#fff"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "36": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "37": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "#6fa8dc"
        },
        fs: 14,
        cl: {
          rgb: "#fff"
        },
        // tr: {
        //     a: 90,
        //     v: 1,
        // },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "38": {
        vt: 2,
        tb: 3,
        bg: {
          rgb: "#6fa8dc"
        },
        cl: {
          rgb: "#fff"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "39": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "#6fa8dc"
        },
        cl: {
          rgb: "#fff"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "40": {
        vt: 2,
        ht: 2,
        fs: 24,
        cl: {
          rgb: "rgb(125,133,22)"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "41": {
        ht: 3,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "42": {
        vt: 2,
        cl: {
          rgb: "rgb(125,133,22)"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "43": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "44": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "45": {
        vt: 2,
        tb: 3,
        pd: {
          l: 10,
          r: 10
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "46": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "47": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "48": {
        vt: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "49": {
        vt: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "50": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "51": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "52": {
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "53": {
        ht: 2,
        vt: 2,
        tr: {
          a: 90,
          v: 1
        },
        cl: {
          rgb: "rgb(125,133,22)"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "54": {
        bd: {
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "55": {
        ht: 3,
        vt: 3,
        tb: 3,
        bd: {
          t: null,
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "56": {
        vt: 2,
        ht: 2,
        fs: 30,
        bl: 1,
        bg: {
          rgb: "#9fc5e8"
        },
        cl: {
          rgb: "#fff"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      }
    },
    timeZone: "GMT+8",
    createdTime: "2021-11-28 12:10:10",
    modifiedTime: "2021-11-29 12:10:10",
    appVersion: "3.0.0-alpha",
    lastModifiedBy: "univer",
    sheets: {
      "sheet-0003": {
        type: 0 /* GRID */,
        id: "sheet-0003",
        name: "sheet0003",
        cellData: {
          "0": {
            "1": {
              m: "Purchase Orders ",
              s: "56"
            },
            "4": {
              s: "31"
            },
            "5": {
              m: "Number:",
              s: "32"
            },
            "6": {
              s: "31"
            }
          },
          "1": {
            "4": {
              s: "31"
            }
          },
          "2": {
            "4": {
              m: "[Company]:",
              s: "33"
            },
            "5": {
              s: "34"
            }
          },
          "3": {
            "4": {
              m: "[Adress]:",
              s: "33"
            },
            "5": {
              s: "34"
            }
          },
          "4": {
            "4": {
              m: "[TEL]:",
              s: "33"
            },
            "5": {
              s: "34"
            }
          },
          "5": {
            "4": {
              m: "[FAX]:",
              s: "33"
            },
            "5": {
              s: "34"
            }
          },
          "6": {
            "1": {
              s: "32"
            }
          },
          "7": {
            "1": {
              m: "Subscriber:",
              s: "32"
            },
            "2": {
              s: "34"
            },
            "3": {
              m: "Order Date:",
              s: "32"
            },
            "4": {
              s: "34"
            },
            "5": {
              m: "Telephone:",
              s: "32"
            },
            "6": {
              s: "34"
            }
          },
          "8": {
            "1": {
              m: "Payment:",
              s: "32"
            },
            "2": {
              s: "34"
            },
            "3": {
              m: "Delivery:",
              s: "32"
            },
            "4": {
              s: "34"
            },
            "5": {
              s: "32"
            },
            "6": {
              s: "32"
            }
          },
          "9": {
            "1": {
              s: "32"
            }
          },
          "10": {
            "1": {
              m: "SKU",
              s: "35"
            },
            "2": {
              m: "Product name ",
              s: "35"
            },
            "4": {
              m: "Quantity",
              s: "35"
            },
            "5": {
              m: "Price",
              s: "35"
            },
            "6": {
              m: "Amount",
              s: "35"
            }
          },
          "11": {
            "1": {
              s: "36"
            },
            "2": {
              s: "36"
            },
            "3": {
              s: "36"
            },
            "4": {
              s: "36",
              m: "1",
              v: "1"
            },
            "5": {
              s: "36",
              m: "10",
              v: "10"
            },
            "6": {
              s: "36",
              m: "10",
              v: "10"
            }
          },
          "12": {
            "1": {
              s: "36"
            },
            "2": {
              s: "36"
            },
            "3": {
              s: "36"
            },
            "4": {
              s: "36",
              m: "2",
              v: "2"
            },
            "5": {
              s: "36",
              m: "10",
              v: "10"
            },
            "6": {
              s: "36",
              m: "20",
              v: "20"
            }
          },
          "13": {
            "1": {
              s: "36"
            },
            "2": {
              s: "36"
            },
            "3": {
              s: "36"
            },
            "4": {
              s: "36",
              m: "2",
              v: "2"
            },
            "5": {
              s: "36",
              m: "2",
              v: "2"
            },
            "6": {
              s: "36"
            }
          },
          "14": {
            "1": {
              s: "36"
            },
            "2": {
              s: "36"
            },
            "3": {
              s: "36"
            },
            "4": {
              s: "36"
            },
            "5": {
              s: "36"
            },
            "6": {
              s: "36"
            }
          },
          "15": {
            "1": {
              s: "36"
            },
            "2": {
              s: "36"
            },
            "3": {
              s: "36"
            },
            "4": {
              s: "36"
            },
            "5": {
              s: "36"
            },
            "6": {
              s: "36"
            }
          },
          "16": {
            "1": {
              s: "36"
            },
            "2": {
              s: "36"
            },
            "3": {
              s: "36"
            },
            "4": {
              s: "36"
            },
            "5": {
              s: "36"
            },
            "6": {
              s: "36"
            }
          },
          "17": {
            "1": {
              s: "36"
            },
            "2": {
              s: "36"
            },
            "3": {
              s: "36"
            },
            "4": {
              s: "36"
            },
            "5": {
              s: "36"
            },
            "6": {
              s: "36"
            }
          },
          "18": {
            "1": {
              s: "36"
            },
            "2": {
              s: "36"
            },
            "3": {
              s: "36"
            },
            "4": {
              s: "36"
            },
            "5": {
              s: "36"
            },
            "6": {
              s: "36"
            }
          },
          "19": {
            "1": {
              m: "Remark ",
              s: "37"
            },
            "2": {
              m: "If there is any problem, please list the specific reasons in writing and fax to contact the company.",
              s: "38"
            },
            "5": {
              m: "Subtotal",
              s: "39"
            },
            "6": {
              s: "36"
            }
          },
          "20": {
            "5": {
              m: "Tax",
              s: "39"
            },
            "6": {
              s: "36"
            }
          },
          "21": {
            "5": {
              m: "Freight",
              s: "39"
            },
            "6": {
              s: "36"
            }
          },
          "22": {
            "5": {
              m: "Total ",
              s: "39"
            },
            "6": {
              s: "36"
            }
          },
          "23": {
            "1": {
              s: "32"
            }
          },
          "24": {
            "1": {
              m: "Approval of Responsible Person:",
              s: "55"
            },
            "2": {
              s: "34"
            },
            "3": {
              m: "Accountant:",
              s: "55"
            },
            "4": {
              s: "34"
            },
            "5": {
              m: "Responsible Person:",
              s: "55"
            },
            "6": {
              s: "34"
            }
          },
          "25": {
            "1": {
              m: "Company:",
              s: "55"
            },
            "2": {
              s: "34"
            },
            "3": {
              s: "32"
            },
            "4": {
              s: "32"
            },
            "5": {
              m: "Date:",
              s: "55"
            },
            "6": {
              s: "34"
            }
          },
          "26": {
            "1": {
              s: "54"
            }
          }
        },
        tabColor: "green",
        hidden: 0 /* FALSE */,
        freezeColumn: 1,
        rowCount: 27,
        columnCount: 8,
        freezeRow: 1,
        zoomRatio: 1,
        scrollTop: 200,
        scrollLeft: 100,
        defaultColumnWidth: 93,
        defaultRowHeight: 25,
        mergeData: [
          {
            startRow: 0,
            endRow: 5,
            startColumn: 1,
            endColumn: 3
          },
          {
            startRow: 1,
            endRow: 1,
            startColumn: 4,
            endColumn: 6
          },
          {
            startRow: 2,
            endRow: 2,
            startColumn: 5,
            endColumn: 6
          },
          {
            startRow: 3,
            endRow: 3,
            startColumn: 5,
            endColumn: 6
          },
          {
            startRow: 4,
            endRow: 4,
            startColumn: 5,
            endColumn: 6
          },
          {
            startRow: 5,
            endRow: 5,
            startColumn: 5,
            endColumn: 6
          },
          {
            startRow: 6,
            endRow: 6,
            startColumn: 1,
            endColumn: 6
          },
          {
            startRow: 9,
            endRow: 9,
            startColumn: 1,
            endColumn: 6
          },
          {
            startRow: 10,
            endRow: 10,
            startColumn: 2,
            endColumn: 3
          },
          {
            startRow: 11,
            endRow: 11,
            startColumn: 2,
            endColumn: 3
          },
          {
            startRow: 12,
            endRow: 12,
            startColumn: 2,
            endColumn: 3
          },
          {
            startRow: 13,
            endRow: 13,
            startColumn: 2,
            endColumn: 3
          },
          {
            startRow: 14,
            endRow: 14,
            startColumn: 2,
            endColumn: 3
          },
          {
            startRow: 15,
            endRow: 15,
            startColumn: 2,
            endColumn: 3
          },
          {
            startRow: 16,
            endRow: 16,
            startColumn: 2,
            endColumn: 3
          },
          {
            startRow: 17,
            endRow: 17,
            startColumn: 2,
            endColumn: 3
          },
          {
            startRow: 18,
            endRow: 18,
            startColumn: 2,
            endColumn: 3
          },
          {
            startRow: 19,
            endRow: 22,
            startColumn: 1,
            endColumn: 1
          },
          {
            startRow: 19,
            endRow: 22,
            startColumn: 2,
            endColumn: 4
          },
          {
            startRow: 23,
            endRow: 23,
            startColumn: 1,
            endColumn: 6
          },
          {
            startRow: 0,
            endRow: 26,
            startColumn: 0,
            endColumn: 0
          },
          {
            startRow: 0,
            endRow: 26,
            startColumn: 7,
            endColumn: 7
          },
          {
            startRow: 26,
            endRow: 26,
            startColumn: 1,
            endColumn: 6
          }
        ],
        rowData: {
          "9": {
            h: 10
          },
          "23": {
            h: 30
          },
          "24": {
            h: 70
          }
        },
        columnData: {
          "0": {
            w: 30
          },
          "1": {
            w: 80
          },
          "2": {
            w: 120
          },
          "3": {
            w: 80
          },
          "7": {
            w: 30
          }
        },
        status: 1,
        showGridlines: 0,
        hideRow: [],
        hideColumn: [],
        rowTitle: {
          width: 46,
          hidden: 0 /* FALSE */
        },
        columnTitle: {
          height: 20,
          hidden: 0 /* FALSE */
        },
        selections: ["A2"],
        rightToLeft: 0 /* FALSE */,
        pluginMeta: {}
      }
    },
    namedRanges: [
      {
        namedRangeId: "named-rang",
        name: "namedRange",
        range: {
          sheetId: "sheet-0003",
          rangeData: {
            startRow: 0,
            startColumn: 0,
            endRow: 1,
            endColumn: 1
          }
        }
      }
    ]
  };

  // ../../packages/common-plugin-data/src/Sheets/Demo/DEFAULT_WORKBOOK_DATA_DEMO2.ts
  var DEFAULT_WORKBOOK_DATA_DEMO2 = {
    id: "workbook-01",
    theme: "default",
    locale: "en" /* EN */,
    creator: "univer",
    name: "universheet",
    skin: "default",
    socketUrl: "",
    socketEnable: 0 /* FALSE */,
    extensions: [],
    sheetOrder: [],
    pluginMeta: {},
    styles: {
      "1": {
        fs: 30,
        vt: 2,
        bl: 1,
        pd: {
          l: 5
        }
      },
      "2": {
        vt: 2,
        bl: 1,
        bg: {
          rgb: "rgb(255,226,102)"
        },
        pd: {
          l: 5
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          }
        }
      },
      "3": {
        vt: 2,
        bl: 1,
        bg: {
          rgb: "rgb(255,226,102)"
        },
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          }
        }
      },
      "4": {
        bl: 1,
        vt: 2,
        pd: {
          l: 5
        },
        bg: {
          rgb: "rgb(255,226,102)"
        },
        ht: 2
      },
      "5": {
        vt: 2,
        pd: {
          l: 5
        }
      },
      "6": {
        vt: 2,
        ht: 2,
        fs: 12,
        cl: {
          rgb: "rgb(1,136,251)"
        }
      },
      "7": {
        vt: 2,
        pd: {
          l: 5
        },
        bg: {
          rgb: "rgb(255,251,224)"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          }
        }
      },
      "8": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "rgb(1,136,251)"
        },
        pd: {
          l: 5
        },
        bg: {
          rgb: "rgb(255,251,224)"
        }
      },
      "9": {
        vt: 2,
        pd: {
          l: 25
        }
      },
      "10": {
        bg: {
          rgb: "#bf9000"
        },
        pd: {
          l: 5
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "11": {
        vt: 2,
        ht: 2,
        fs: 24,
        bg: {
          rgb: "rgb(183,83,119)"
        },
        cl: {
          rgb: "#fff"
        }
      },
      "12": {
        bg: {
          rgb: "rgb(248,237,241)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "13": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(244,186,112)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "14": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(248,237,241)"
        },
        bd: {
          b: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(218,170,186)"
            }
          }
        }
      },
      "15": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(246,131,131)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "16": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(207,98,170)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "17": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(172,135,188)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "18": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(97,170,206)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "19": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "#fff"
        },
        bg: {
          rgb: "rgb(244,186,112,0.5)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "20": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "#fff"
        },
        bg: {
          rgb: "rgb(246,131,131,0.5)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "21": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "#fff"
        },
        bg: {
          rgb: "rgb(207,98,170,0.5)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "22": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "#fff"
        },
        bg: {
          rgb: "rgb(172,135,188,0.5)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "23": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "#fff"
        },
        bg: {
          rgb: "rgb(97,170,206,0.5)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "24": {
        bg: {
          rgb: "#3d85c6"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "25": {
        bg: {
          rgb: "#c27ba0"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "26": {
        bg: {
          rgb: "rgb(224, 102, 102)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "27": {
        bg: {
          rgb: "#f90"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "28": {
        bg: {
          rgb: "#76a5af"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "29": {
        bg: {
          rgb: "#38761d"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "30": {
        vt: 2,
        ht: 2,
        fs: 30,
        bl: 1,
        bg: {
          rgb: "#6fa8dc"
        },
        cl: {
          rgb: "#fff"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "31": {
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "32": {
        vt: 2,
        tb: 3,
        bd: {
          t: null,
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "33": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "34": {
        vt: 2,
        bd: {
          t: null,
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "35": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "#6fa8dc"
        },
        cl: {
          rgb: "#fff"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "36": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "37": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "#6fa8dc"
        },
        fs: 14,
        cl: {
          rgb: "#fff"
        },
        // tr: {
        //     a: 90,
        //     v: 1,
        // },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "38": {
        vt: 2,
        tb: 3,
        bg: {
          rgb: "#6fa8dc"
        },
        cl: {
          rgb: "#fff"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "39": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "#6fa8dc"
        },
        cl: {
          rgb: "#fff"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "40": {
        vt: 2,
        ht: 2,
        fs: 24,
        cl: {
          rgb: "rgb(125,133,22)"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "41": {
        ht: 3,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "42": {
        vt: 2,
        cl: {
          rgb: "rgb(125,133,22)"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "43": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "44": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "45": {
        vt: 2,
        tb: 3,
        pd: {
          l: 10,
          r: 10
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "46": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "47": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "48": {
        vt: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "49": {
        vt: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "50": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "51": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "52": {
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "53": {
        ht: 2,
        vt: 2,
        tr: {
          a: 90,
          v: 1
        },
        cl: {
          rgb: "rgb(125,133,22)"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "54": {
        bd: {
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "55": {
        ht: 3,
        vt: 3,
        tb: 3,
        bd: {
          t: null,
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      }
    },
    timeZone: "GMT+8",
    createdTime: "2021-11-28 12:10:10",
    modifiedTime: "2021-11-29 12:10:10",
    appVersion: "3.0.0-alpha",
    lastModifiedBy: "univer",
    sheets: {
      "sheet-0002": {
        type: 0 /* GRID */,
        id: "sheet-0002",
        name: "sheet0003",
        cellData: {
          "0": {
            "0": {
              m: "Annual Work Schedule",
              s: "11"
            }
          },
          "1": {
            "0": {
              s: "12"
            },
            "1": {
              s: "12"
            },
            "16": {
              s: "12"
            }
          },
          "2": {
            "0": {
              s: "12"
            },
            "1": {
              m: "1/2",
              s: "13"
            },
            "4": {
              m: "3/8",
              s: "15"
            },
            "7": {
              m: "1/4",
              s: "16"
            },
            "10": {
              m: "1/4",
              s: "17"
            },
            "13": {
              m: "1/4",
              s: "18"
            },
            "16": {
              s: "12"
            }
          },
          "3": {
            "1": {
              s: "12"
            }
          },
          "4": {
            "0": {
              s: "12"
            },
            "1": {
              s: "12"
            },
            "2": {
              m: "Go to the party",
              s: "14"
            },
            "3": {
              m: "\u221A",
              s: "14"
            },
            "4": {
              s: "12"
            },
            "5": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "6": {
              m: "\u221A",
              s: "14"
            },
            "7": {
              s: "12"
            },
            "8": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "9": {
              m: "\u221A",
              s: "14"
            },
            "10": {
              s: "12"
            },
            "11": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "12": {
              s: "14"
            },
            "13": {
              s: "12"
            },
            "14": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "15": {
              m: "\u221A",
              s: "14"
            }
          },
          "5": {
            "0": {
              s: "12"
            },
            "1": {
              s: "12"
            },
            "2": {
              m: "Purchase  Products",
              s: "14"
            },
            "3": {
              m: "\u221A",
              s: "14"
            },
            "4": {
              s: "12"
            },
            "5": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "6": {
              m: "\u221A",
              s: "14"
            },
            "7": {
              s: "12"
            },
            "8": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "9": {
              s: "14"
            },
            "10": {
              s: "12"
            },
            "11": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "12": {
              s: "14"
            },
            "13": {
              s: "12"
            },
            "14": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "15": {
              m: "\u221A",
              s: "14"
            }
          },
          "6": {
            "0": {
              s: "12"
            },
            "1": {
              s: "12"
            },
            "2": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "3": {
              m: "\u221A",
              s: "14"
            },
            "4": {
              s: "12"
            },
            "5": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "6": {
              s: "14"
            },
            "7": {
              s: "12"
            },
            "8": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "9": {
              s: "14"
            },
            "10": {
              s: "12"
            },
            "11": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "12": {
              s: "14"
            },
            "13": {
              s: "12"
            },
            "14": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "15": {
              s: "14"
            }
          },
          "7": {
            "0": {
              s: "12"
            },
            "1": {
              s: "12"
            },
            "2": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "3": {
              s: "14"
            },
            "4": {
              s: "12"
            },
            "5": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "6": {
              s: "14"
            },
            "7": {
              s: "12"
            },
            "8": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "9": {
              s: "14"
            },
            "10": {
              s: "12"
            },
            "11": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "12": {
              s: "14"
            },
            "13": {
              s: "12"
            },
            "14": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "15": {
              s: "14"
            }
          },
          "8": {
            "0": {
              s: "12"
            },
            "1": {
              s: "12"
            },
            "2": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "3": {
              s: "14"
            },
            "4": {
              s: "12"
            },
            "5": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "6": {
              s: "14"
            },
            "7": {
              s: "12"
            },
            "8": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "9": {
              s: "14"
            },
            "10": {
              s: "12"
            },
            "11": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "12": {
              s: "14"
            },
            "13": {
              s: "12"
            },
            "14": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "15": {
              s: "14"
            }
          },
          "9": {
            "1": {
              s: "12"
            }
          },
          "10": {
            "1": {
              s: "12"
            },
            "2": {
              s: "19",
              m: "January"
            },
            "3": {
              s: "12"
            },
            "4": {
              s: "12"
            },
            "5": {
              s: "20",
              m: "February"
            },
            "6": {
              s: "12"
            },
            "7": {
              s: "12"
            },
            "8": {
              s: "21",
              m: "March"
            },
            "9": {
              s: "12"
            },
            "10": {
              s: "12"
            },
            "11": {
              s: "22",
              m: "April"
            },
            "12": {
              s: "12"
            },
            "13": {
              s: "12"
            },
            "14": {
              s: "23",
              m: "May"
            },
            "15": {
              s: "12"
            }
          },
          "11": {
            "1": {
              s: "12"
            }
          },
          "12": {
            "0": {
              s: "12"
            },
            "1": {
              m: "1/3",
              s: "13"
            },
            "4": {
              m: "3/5",
              s: "15"
            },
            "7": {
              m: "1/2",
              s: "16"
            },
            "10": {
              m: "3/4",
              s: "17"
            },
            "13": {
              m: "5/6",
              s: "18"
            },
            "16": {
              s: "12"
            }
          },
          "13": {
            "0": {
              s: "12"
            },
            "1": {
              s: "12"
            },
            "2": {
              m: "Go to the party",
              s: "14"
            },
            "3": {
              m: "\u221A",
              s: "14"
            },
            "4": {
              s: "12"
            },
            "5": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "6": {
              m: "\u221A",
              s: "14"
            },
            "7": {
              s: "12"
            },
            "8": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "9": {
              m: "\u221A",
              s: "14"
            },
            "10": {
              s: "12"
            },
            "11": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "12": {
              s: "14"
            },
            "13": {
              s: "12"
            },
            "14": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "15": {
              m: "\u221A",
              s: "14"
            }
          },
          "14": {
            "0": {
              s: "12"
            },
            "1": {
              s: "12"
            },
            "2": {
              m: "Purchase Products",
              s: "14"
            },
            "3": {
              m: "\u221A",
              s: "14"
            },
            "4": {
              s: "12"
            },
            "5": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "6": {
              m: "\u221A",
              s: "14"
            },
            "7": {
              s: "12"
            },
            "8": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "9": {
              s: "14"
            },
            "10": {
              s: "12"
            },
            "11": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "12": {
              s: "14"
            },
            "13": {
              s: "12"
            },
            "14": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "15": {
              m: "\u221A",
              s: "14"
            }
          },
          "15": {
            "0": {
              s: "12"
            },
            "1": {
              s: "12"
            },
            "2": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "3": {
              m: "\u221A",
              s: "14"
            },
            "4": {
              s: "12"
            },
            "5": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "6": {
              s: "14"
            },
            "7": {
              s: "12"
            },
            "8": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "9": {
              s: "14"
            },
            "10": {
              s: "12"
            },
            "11": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "12": {
              s: "14"
            },
            "13": {
              s: "12"
            },
            "14": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "15": {
              s: "14"
            }
          },
          "16": {
            "0": {
              s: "12"
            },
            "1": {
              s: "12"
            },
            "2": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "3": {
              s: "14"
            },
            "4": {
              s: "12"
            },
            "5": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "6": {
              s: "14"
            },
            "7": {
              s: "12"
            },
            "8": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "9": {
              s: "14"
            },
            "10": {
              s: "12"
            },
            "11": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "12": {
              s: "14"
            },
            "13": {
              s: "12"
            },
            "14": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "15": {
              s: "14"
            }
          },
          "17": {
            "0": {
              s: "12"
            },
            "1": {
              s: "12"
            },
            "2": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "3": {
              s: "14"
            },
            "4": {
              s: "12"
            },
            "5": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "6": {
              s: "14"
            },
            "7": {
              s: "12"
            },
            "8": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "9": {
              s: "14"
            },
            "10": {
              s: "12"
            },
            "11": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "12": {
              s: "14"
            },
            "13": {
              s: "12"
            },
            "14": {
              m: "\xD7\xD7\xD7\xD7\xD7",
              s: "14"
            },
            "15": {
              s: "14"
            }
          },
          "18": {
            "0": {
              s: "12"
            }
          },
          "25": {
            "0": {
              m: "\xB7",
              s: "123"
            }
          }
        },
        tabColor: "yellow",
        hidden: 0 /* FALSE */,
        freezeColumn: 1,
        rowCount: 26,
        columnCount: 17,
        freezeRow: 1,
        zoomRatio: 1,
        scrollTop: 200,
        scrollLeft: 100,
        defaultColumnWidth: 93,
        defaultRowHeight: 32,
        mergeData: [
          {
            startRow: 0,
            endRow: 0,
            startColumn: 0,
            endColumn: 16
          },
          {
            startRow: 1,
            endRow: 17,
            startColumn: 0,
            endColumn: 0
          },
          {
            startRow: 1,
            endRow: 17,
            startColumn: 16,
            endColumn: 16
          },
          {
            startRow: 1,
            endRow: 1,
            startColumn: 1,
            endColumn: 15
          },
          {
            startRow: 3,
            endRow: 3,
            startColumn: 1,
            endColumn: 15
          },
          {
            startRow: 2,
            endRow: 2,
            startColumn: 1,
            endColumn: 3
          },
          {
            startRow: 2,
            endRow: 2,
            startColumn: 4,
            endColumn: 6
          },
          {
            startRow: 2,
            endRow: 2,
            startColumn: 7,
            endColumn: 9
          },
          {
            startRow: 2,
            endRow: 2,
            startColumn: 10,
            endColumn: 12
          },
          {
            startRow: 2,
            endRow: 2,
            startColumn: 13,
            endColumn: 15
          },
          {
            startRow: 9,
            endRow: 9,
            startColumn: 1,
            endColumn: 15
          },
          {
            startRow: 11,
            endRow: 11,
            startColumn: 1,
            endColumn: 15
          },
          {
            startRow: 12,
            endRow: 12,
            startColumn: 1,
            endColumn: 3
          },
          {
            startRow: 12,
            endRow: 12,
            startColumn: 4,
            endColumn: 6
          },
          {
            startRow: 12,
            endRow: 12,
            startColumn: 7,
            endColumn: 9
          },
          {
            startRow: 12,
            endRow: 12,
            startColumn: 10,
            endColumn: 12
          },
          {
            startRow: 12,
            endRow: 12,
            startColumn: 13,
            endColumn: 15
          },
          {
            startRow: 18,
            endRow: 22,
            startColumn: 0,
            endColumn: 16
          }
        ],
        rowData: {
          "0": {
            h: 70
          },
          "3": {
            h: 20
          },
          "9": {
            h: 20
          },
          "10": {
            h: 40
          },
          "11": {
            h: 20
          }
        },
        columnData: {
          "0": {
            w: 50
          },
          "1": {
            w: 20
          },
          "2": {
            w: 150
          },
          "3": {
            w: 30
          },
          "4": {
            w: 20
          },
          "5": {
            w: 150
          },
          "6": {
            w: 30
          },
          "7": {
            w: 20
          },
          "8": {
            w: 150
          },
          "9": {
            w: 30
          },
          "10": {
            w: 20
          },
          "11": {
            w: 150
          },
          "12": {
            w: 30
          },
          "13": {
            w: 20
          },
          "14": {
            w: 150
          },
          "15": {
            w: 30
          },
          "16": {
            w: 50
          }
        },
        status: 1,
        showGridlines: 0,
        hideRow: [],
        hideColumn: [],
        rowTitle: {
          width: 46,
          hidden: 0 /* FALSE */
        },
        columnTitle: {
          height: 20,
          hidden: 0 /* FALSE */
        },
        selections: ["A2"],
        rightToLeft: 0 /* FALSE */,
        pluginMeta: {}
      }
    },
    namedRanges: [
      {
        namedRangeId: "named-rang",
        name: "namedRange",
        range: {
          sheetId: "sheet-0001",
          rangeData: {
            startRow: 0,
            startColumn: 0,
            endRow: 1,
            endColumn: 1
          }
        }
      }
    ]
  };

  // ../../packages/common-plugin-data/src/Sheets/Demo/DEFAULT_WORKBOOK_DATA_DEMO3.ts
  var richTextDemo2 = {
    id: "d",
    body: {
      blockElements: [
        {
          blockId: "oneParagraph",
          st: 0,
          ed: 15,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            elements: [
              {
                eId: "oneElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "Instructions:",
                  ts: {
                    cl: {
                      rgb: "rgb(92,92,92)"
                    }
                  }
                }
              },
              {
                eId: "breakElement",
                et: 2 /* PAGE_BREAK */,
                st: 0,
                ed: 0
              },
              {
                eId: "twoElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u2460Project division - Fill in the specific division of labor after the project is disassembled:",
                  ts: {
                    cl: {
                      rgb: "rgb(92,92,92)"
                    }
                  }
                }
              },
              {
                eId: "breakElement1",
                et: 2 /* PAGE_BREAK */,
                st: 0,
                ed: 0
              },
              {
                eId: "threeElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u2461Responsible Person - Enter the responsible person's name here:",
                  ts: {
                    cl: {
                      rgb: "rgb(92,92,92)"
                    }
                  }
                }
              },
              {
                eId: "breakElement2",
                et: 2 /* PAGE_BREAK */,
                st: 0,
                ed: 0
              },
              {
                eId: "fourElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u2462Date-The specific execution time of the project (detailed to the date of a certain month), and the gray color block marks the planned real-time time of the division of labor of the project (for example,",
                  ts: {
                    cl: {
                      rgb: "rgb(92,92,92)"
                    }
                  }
                }
              },
              {
                eId: "breakElement3",
                et: 2 /* PAGE_BREAK */,
                st: 0,
                ed: 0
              },
              {
                eId: "fiveElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "the specific execution time of [regional scene model arrangement and construction] is the 2 days marked in gray. ",
                  ts: {
                    cl: {
                      rgb: "rgb(92,92,92)"
                    }
                  }
                }
              }
            ],
            paragraphStyle: {
              spaceAbove: 10,
              lineSpacing: 1.2
            }
          }
        }
      ]
    },
    documentStyle: {
      pageSize: {
        width: Infinity,
        height: Infinity
      },
      marginTop: 0,
      marginBottom: 0,
      marginRight: 2,
      marginLeft: 2
    }
  };
  var DEFAULT_WORKBOOK_DATA_DEMO3 = {
    id: "workbook-01",
    theme: "default",
    locale: "en" /* EN */,
    creator: "univer",
    name: "universheet",
    skin: "default",
    socketUrl: "",
    socketEnable: 0 /* FALSE */,
    extensions: [],
    sheetOrder: [],
    pluginMeta: {},
    styles: {
      "1": {
        fs: 30,
        vt: 2,
        bl: 1,
        pd: {
          l: 5
        }
      },
      "2": {
        vt: 2,
        bl: 1,
        bg: {
          rgb: "rgb(255,226,102)"
        },
        pd: {
          l: 5
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          }
        }
      },
      "3": {
        vt: 2,
        bl: 1,
        bg: {
          rgb: "rgb(255,226,102)"
        },
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          }
        }
      },
      "4": {
        bl: 1,
        vt: 2,
        pd: {
          l: 5
        },
        bg: {
          rgb: "rgb(255,226,102)"
        },
        ht: 2
      },
      "5": {
        vt: 2,
        pd: {
          l: 5
        }
      },
      "6": {
        vt: 2,
        ht: 2,
        fs: 12,
        cl: {
          rgb: "rgb(1,136,251)"
        }
      },
      "7": {
        vt: 2,
        pd: {
          l: 5
        },
        bg: {
          rgb: "rgb(255,251,224)"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          }
        }
      },
      "8": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "rgb(1,136,251)"
        },
        pd: {
          l: 5
        },
        bg: {
          rgb: "rgb(255,251,224)"
        }
      },
      "9": {
        vt: 2,
        pd: {
          l: 25
        }
      },
      "10": {
        bg: {
          rgb: "#bf9000"
        },
        pd: {
          l: 5
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "11": {
        vt: 2,
        ht: 2,
        fs: 24,
        bg: {
          rgb: "rgb(183,83,119)"
        },
        cl: {
          rgb: "#fff"
        }
      },
      "12": {
        bg: {
          rgb: "rgb(248,237,241)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "13": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(244,186,112)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "14": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(248,237,241)"
        },
        bd: {
          b: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(218,170,186)"
            }
          }
        }
      },
      "15": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(246,131,131)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "16": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(207,98,170)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "17": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(172,135,188)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "18": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(97,170,206)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "19": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "#fff"
        },
        bg: {
          rgb: "rgb(244,186,112,0.5)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "20": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "#fff"
        },
        bg: {
          rgb: "rgb(246,131,131,0.5)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "21": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "#fff"
        },
        bg: {
          rgb: "rgb(207,98,170,0.5)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "22": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "#fff"
        },
        bg: {
          rgb: "rgb(172,135,188,0.5)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "23": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "#fff"
        },
        bg: {
          rgb: "rgb(97,170,206,0.5)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "24": {
        bg: {
          rgb: "#3d85c6"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "25": {
        bg: {
          rgb: "#c27ba0"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "26": {
        bg: {
          rgb: "rgb(224, 102, 102)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "27": {
        bg: {
          rgb: "#f90"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "28": {
        bg: {
          rgb: "#76a5af"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "29": {
        bg: {
          rgb: "#38761d"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "30": {
        vt: 2,
        ht: 2,
        fs: 30,
        bl: 1,
        bg: {
          rgb: "#6fa8dc"
        },
        cl: {
          rgb: "#fff"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "31": {
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "32": {
        vt: 2,
        tb: 3,
        bd: {
          t: null,
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "33": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "34": {
        vt: 2,
        bd: {
          t: null,
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "35": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "#6fa8dc"
        },
        cl: {
          rgb: "#fff"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "36": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "37": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "#6fa8dc"
        },
        fs: 14,
        cl: {
          rgb: "#fff"
        },
        // tr: {
        //     a: 90,
        //     v: 1,
        // },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "38": {
        vt: 2,
        tb: 3,
        bg: {
          rgb: "#6fa8dc"
        },
        cl: {
          rgb: "#fff"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "39": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "#6fa8dc"
        },
        cl: {
          rgb: "#fff"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "40": {
        vt: 2,
        ht: 2,
        fs: 24,
        cl: {
          rgb: "rgb(125,133,22)"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "41": {
        ht: 3,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "42": {
        vt: 2,
        cl: {
          rgb: "rgb(125,133,22)"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "43": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "44": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "45": {
        vt: 2,
        tb: 3,
        pd: {
          l: 10,
          r: 10
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "46": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "47": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "48": {
        vt: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "49": {
        vt: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "50": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "51": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "52": {
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "53": {
        ht: 2,
        vt: 2,
        tr: {
          a: 90,
          v: 1
        },
        cl: {
          rgb: "rgb(125,133,22)"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "54": {
        bd: {
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "55": {
        ht: 3,
        vt: 3,
        tb: 3,
        bd: {
          t: null,
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      }
    },
    timeZone: "GMT+8",
    createdTime: "2021-11-28 12:10:10",
    modifiedTime: "2021-11-29 12:10:10",
    appVersion: "3.0.0-alpha",
    lastModifiedBy: "univer",
    sheets: {
      "sheet-0001": {
        type: 0 /* GRID */,
        id: "sheet-0001",
        cellData: {
          "0": {
            "0": {
              s: "1",
              m: "A Schedule of Items"
            }
          },
          "1": {
            "0": {
              s: "2",
              m: "Division of Project"
            },
            "1": {
              s: "3",
              m: "Responsible Person"
            },
            "2": {
              s: "4",
              m: "Date"
            }
          },
          "2": {
            "0": {
              m: "General Project Manager",
              s: "5"
            },
            "1": {
              m: "@XXX",
              s: "6"
            },
            "2": {
              m: "March 1",
              s: "5"
            },
            "3": {
              m: "March 2",
              s: "5"
            },
            "4": {
              m: "March 3",
              s: "5"
            },
            "5": {
              m: "March 4",
              s: "5"
            },
            "6": {
              m: "March 5",
              s: "5"
            },
            "7": {
              m: "March 6",
              s: "5"
            },
            "8": {
              m: "March 7",
              s: "5"
            },
            "9": {
              m: "March 8",
              s: "5"
            },
            "10": {
              m: "March 9",
              s: "5"
            },
            "11": {
              m: "March 10",
              s: "5"
            },
            "12": {
              m: "March 11",
              s: "5"
            },
            "13": {
              m: "March 12",
              s: "5"
            },
            "14": {
              m: "March 13",
              s: "5"
            }
          },
          "3": {
            "0": {
              m: "1\u3001Responsible Person of Model Section",
              s: "7"
            },
            "1": {
              m: "@George",
              s: "8"
            }
          },
          "4": {
            "0": {
              m: "Advertisement Signboard",
              s: "9"
            },
            "1": {
              m: "@Paul",
              s: "6"
            },
            "4": {
              s: "10"
            },
            "5": {
              s: "10"
            },
            "6": {
              s: "10"
            },
            "7": {
              s: "10"
            },
            "8": {
              s: "10"
            },
            "9": {
              s: "10"
            },
            "10": {
              s: "10"
            }
          },
          "5": {
            "0": {
              m: "Transport Ready",
              s: "9"
            },
            "1": {
              m: "@George",
              s: "6"
            }
          },
          "6": {
            "0": {
              m: "2\u3001Head of Special Effects Section",
              s: "7"
            },
            "1": {
              m: "@Paul",
              s: "8"
            }
          },
          "7": {
            "0": {
              m: "Render Output Parameter Test",
              s: "9"
            },
            "1": {
              m: "@Paul",
              s: "6"
            },
            "3": {
              s: "25"
            },
            "4": {
              s: "25"
            },
            "5": {
              s: "25"
            },
            "6": {
              s: "25"
            },
            "7": {
              s: "25"
            },
            "8": {
              s: "25"
            },
            "9": {
              s: "25"
            }
          },
          "8": {
            "0": {
              m: "Camera Moving Mirror",
              s: "9"
            },
            "1": {
              m: "@Paul",
              s: "6"
            }
          },
          "9": {
            "0": {
              m: "3\u3001Responsible Person of Rendering Section",
              s: "7"
            },
            "1": {
              m: "@Jennifer",
              s: "8"
            }
          },
          "10": {
            "0": {
              m: "Scene Dynamic Element Design",
              s: "9"
            },
            "7": {
              s: "27"
            },
            "8": {
              s: "27"
            },
            "9": {
              s: "27"
            },
            "10": {
              s: "27"
            },
            "11": {
              s: "27"
            }
          },
          "11": {
            "0": {
              m: "Sky Map Selection",
              s: "9"
            }
          },
          "12": {
            "0": {
              m: "Reference Scenario Data Collection",
              s: "9"
            }
          },
          "13": {
            "0": {
              m: "Scene Dynamic Element Design",
              s: "9"
            },
            "2": {
              s: "29"
            },
            "3": {
              s: "29"
            },
            "4": {
              s: "29"
            },
            "5": {
              s: "29"
            },
            "6": {
              s: "29"
            },
            "7": {
              s: "29"
            }
          },
          "14": {
            "0": {
              p: richTextDemo2
            }
          }
        },
        name: "sheet0001",
        tabColor: "red",
        hidden: 0 /* FALSE */,
        freezeColumn: 1,
        rowCount: 15,
        columnCount: 15,
        freezeRow: 1,
        zoomRatio: 1,
        scrollTop: 200,
        scrollLeft: 100,
        defaultColumnWidth: 93,
        defaultRowHeight: 32,
        mergeData: [
          {
            startRow: 0,
            endRow: 0,
            startColumn: 0,
            endColumn: 14
          },
          {
            startRow: 1,
            endRow: 1,
            startColumn: 2,
            endColumn: 14
          },
          {
            startRow: 14,
            endRow: 14,
            startColumn: 0,
            endColumn: 14
          }
        ],
        rowData: {
          "0": {
            h: 70
          },
          "2": {
            h: 20
          },
          "3": {
            h: 20
          },
          "4": {
            h: 20
          },
          "5": {
            h: 20
          },
          "6": {
            h: 20
          },
          "7": {
            h: 20
          },
          "8": {
            h: 20
          },
          "9": {
            h: 20
          },
          "10": {
            h: 20
          },
          "11": {
            h: 20
          },
          "12": {
            h: 20
          },
          "13": {
            h: 20
          },
          "14": {
            h: 200
          }
        },
        columnData: {
          "0": {
            w: 250
          },
          "1": {
            w: 130
          },
          "2": {
            w: 60
          },
          "3": {
            w: 60
          },
          "4": {
            w: 60
          },
          "5": {
            w: 60
          },
          "6": {
            w: 60
          },
          "7": {
            w: 60
          },
          "8": {
            w: 60
          },
          "9": {
            w: 60
          },
          "10": {
            w: 60
          },
          "11": {
            w: 60
          },
          "12": {
            w: 60
          },
          "13": {
            w: 60
          },
          "14": {
            w: 60
          }
        },
        status: 1,
        showGridlines: 1,
        hideRow: [],
        hideColumn: [],
        rowTitle: {
          width: 46,
          hidden: 0 /* FALSE */
        },
        columnTitle: {
          height: 20,
          hidden: 0 /* FALSE */
        },
        selections: ["A2"],
        rightToLeft: 0 /* FALSE */,
        pluginMeta: {}
      }
    },
    namedRanges: [
      {
        namedRangeId: "named-rang",
        name: "namedRange",
        range: {
          sheetId: "sheet-0001",
          rangeData: {
            startRow: 0,
            startColumn: 0,
            endRow: 1,
            endColumn: 1
          }
        }
      }
    ]
  };

  // ../../packages/common-plugin-data/src/Sheets/Demo/DEFAULT_WORKBOOK_DATA_DEMO4.ts
  var richTextDemo12 = {
    id: "d",
    body: {
      blockElements: [
        {
          blockId: "oneParagraph",
          st: 0,
          ed: 15,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            elements: [
              {
                eId: "oneElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "No.",
                  ts: {
                    cl: {
                      rgb: "#000"
                    },
                    fs: 20
                  }
                }
              },
              {
                eId: "twoElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "2824163",
                  ts: {
                    cl: {
                      rgb: "rgb(255,0,0)"
                    },
                    fs: 20
                  }
                }
              }
            ]
          }
        }
      ]
    },
    documentStyle: {
      pageSize: {
        width: Infinity,
        height: Infinity
      },
      marginTop: 0,
      marginBottom: 0,
      marginRight: 2,
      marginLeft: 2
    }
  };
  var DEFAULT_WORKBOOK_DATA_DEMO4 = {
    id: "workbook-01",
    theme: "default",
    locale: "en" /* EN */,
    creator: "univer",
    name: "universheet",
    skin: "default",
    socketUrl: "",
    socketEnable: 0 /* FALSE */,
    extensions: [],
    sheetOrder: [],
    pluginMeta: {},
    styles: {
      "1": {
        fs: 30,
        vt: 2,
        bl: 1,
        pd: {
          l: 5
        }
      },
      "2": {
        vt: 2,
        bl: 1,
        bg: {
          rgb: "rgb(255,226,102)"
        },
        pd: {
          l: 5
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          }
        }
      },
      "3": {
        vt: 2,
        bl: 1,
        bg: {
          rgb: "rgb(255,226,102)"
        },
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          }
        }
      },
      "4": {
        bl: 1,
        vt: 2,
        pd: {
          l: 5
        },
        bg: {
          rgb: "rgb(255,226,102)"
        },
        ht: 2
      },
      "5": {
        vt: 2,
        pd: {
          l: 5
        }
      },
      "6": {
        vt: 2,
        ht: 2,
        fs: 12,
        cl: {
          rgb: "rgb(1,136,251)"
        }
      },
      "7": {
        vt: 2,
        pd: {
          l: 5
        },
        bg: {
          rgb: "rgb(255,251,224)"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          }
        }
      },
      "8": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "rgb(1,136,251)"
        },
        pd: {
          l: 5
        },
        bg: {
          rgb: "rgb(255,251,224)"
        }
      },
      "9": {
        vt: 2,
        pd: {
          l: 25
        }
      },
      "10": {
        bg: {
          rgb: "#bf9000"
        },
        pd: {
          l: 5
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "11": {
        vt: 2,
        ht: 2,
        fs: 24,
        bg: {
          rgb: "rgb(183,83,119)"
        },
        cl: {
          rgb: "#fff"
        }
      },
      "12": {
        bg: {
          rgb: "rgb(248,237,241)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "13": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(244,186,112)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "14": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(248,237,241)"
        },
        bd: {
          b: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(218,170,186)"
            }
          }
        }
      },
      "15": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(246,131,131)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "16": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(207,98,170)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "17": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(172,135,188)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "18": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "rgb(97,170,206)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "19": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "#fff"
        },
        bg: {
          rgb: "rgb(244,186,112,0.5)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "20": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "#fff"
        },
        bg: {
          rgb: "rgb(246,131,131,0.5)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "21": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "#fff"
        },
        bg: {
          rgb: "rgb(207,98,170,0.5)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "22": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "#fff"
        },
        bg: {
          rgb: "rgb(172,135,188,0.5)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "23": {
        vt: 2,
        ht: 2,
        cl: {
          rgb: "#fff"
        },
        bg: {
          rgb: "rgb(97,170,206,0.5)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "24": {
        bg: {
          rgb: "#3d85c6"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "25": {
        bg: {
          rgb: "#c27ba0"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "26": {
        bg: {
          rgb: "rgb(224, 102, 102)"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "27": {
        bg: {
          rgb: "#f90"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "28": {
        bg: {
          rgb: "#76a5af"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "29": {
        bg: {
          rgb: "#38761d"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "30": {
        vt: 2,
        ht: 2,
        fs: 30,
        bl: 1,
        bg: {
          rgb: "#6fa8dc"
        },
        cl: {
          rgb: "#fff"
        },
        bd: {
          t: null,
          l: null,
          r: null,
          b: null
        }
      },
      "31": {
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "32": {
        vt: 2,
        tb: 3,
        bd: {
          t: null,
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "33": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "34": {
        vt: 2,
        bd: {
          t: null,
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "35": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "#6fa8dc"
        },
        cl: {
          rgb: "#fff"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "36": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "37": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "#6fa8dc"
        },
        fs: 14,
        cl: {
          rgb: "#fff"
        },
        // tr: {
        //     a: 90,
        //     v: 1,
        // },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "38": {
        vt: 2,
        tb: 3,
        bg: {
          rgb: "#6fa8dc"
        },
        cl: {
          rgb: "#fff"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "39": {
        vt: 2,
        ht: 2,
        bg: {
          rgb: "#6fa8dc"
        },
        cl: {
          rgb: "#fff"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#000"
            }
          }
        }
      },
      "40": {
        vt: 2,
        ht: 2,
        fs: 24,
        cl: {
          rgb: "rgb(125,133,22)"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "41": {
        ht: 3,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "42": {
        vt: 2,
        cl: {
          rgb: "rgb(125,133,22)"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "43": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "44": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "45": {
        vt: 2,
        tb: 3,
        pd: {
          l: 10,
          r: 10
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "46": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "47": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "48": {
        vt: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "49": {
        vt: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "50": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "51": {
        vt: 2,
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          r: {
            s: 13 /* THICK */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(125,133,22)"
            }
          }
        }
      },
      "52": {
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "53": {
        ht: 2,
        vt: 2,
        tr: {
          a: 90,
          v: 1
        },
        cl: {
          rgb: "rgb(125,133,22)"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "54": {
        bd: {
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      },
      "55": {
        ht: 3,
        vt: 3,
        tb: 3,
        bd: {
          t: null,
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "#fff"
            }
          }
        }
      }
    },
    timeZone: "GMT+8",
    createdTime: "2021-11-28 12:10:10",
    modifiedTime: "2021-11-29 12:10:10",
    appVersion: "3.0.0-alpha",
    lastModifiedBy: "univer",
    sheets: {
      "sheet-0004": {
        type: 0 /* GRID */,
        id: "sheet-0004",
        name: "sheet0004",
        cellData: {
          "0": {
            "0": {
              s: "40"
            },
            "1": {
              m: "Travel Declaration Form",
              s: "40"
            },
            "8": {
              p: richTextDemo12,
              s: "41"
            },
            "10": {
              s: "52"
            }
          },
          "1": {
            "1": {
              m: "Department:",
              s: "42"
            },
            "6": {
              m: "Application Date:",
              s: "42"
            }
          },
          "2": {
            "1": {
              m: "Business Trip Employee",
              s: "43"
            },
            "2": {
              s: "46"
            },
            "3": {
              m: "Position",
              s: "46"
            },
            "4": {
              s: "46"
            },
            "6": {
              s: "46",
              m: "Entourage"
            },
            "7": {
              s: "47"
            },
            "10": {
              m: "Borrower write-off",
              s: "53"
            }
          },
          "3": {
            "1": {
              m: "Business Trip Place",
              s: "44"
            },
            "2": {
              m: "                      To                      To                      To",
              s: "48"
            }
          },
          "4": {
            "1": {
              m: "Amount",
              s: "44"
            },
            "2": {
              m: "(Capital)         \u4E07        \u4EDF        \u4F70        \u62FE        \u5143        \u89D2        \u5206",
              s: "49"
            },
            "7": {
              m: "(Lower) \xA5",
              s: "48"
            }
          },
          "5": {
            "1": {
              m: "Departure Time",
              s: "44"
            },
            "2": {
              s: "49"
            },
            "3": {
              m: "ETR",
              s: "50"
            },
            "5": {
              s: "50"
            },
            "8": {
              m: "Days",
              s: "50"
            },
            "9": {
              s: "48"
            }
          },
          "6": {
            "1": {
              m: "Reasons",
              s: "44"
            },
            "2": {
              s: "48"
            }
          },
          "7": {
            "1": {
              m: "Applicant For Travel",
              s: "44"
            },
            "2": {
              s: "50"
            },
            "3": {
              m: "Administrator",
              s: "50"
            },
            "4": {
              s: "50"
            },
            "6": {
              m: "Financial Manager",
              s: "50"
            },
            "7": {
              s: "50"
            },
            "9": {
              m: "Payee",
              s: "51"
            }
          },
          "8": {
            "1": {
              m: "Department Head",
              s: "44"
            },
            "2": {
              s: "50"
            },
            "3": {
              m: "Manager",
              s: "50"
            },
            "4": {
              s: "50"
            },
            "6": {
              m: "Cashier",
              s: "50"
            },
            "7": {
              s: "50"
            },
            "9": {
              s: "51"
            }
          },
          "9": {
            "1": {
              m: "Record: The loan is used exclusively for travel expenses, and the travel expenses will not be written off without a business trip application.",
              s: "45"
            }
          }
        },
        tabColor: "blue",
        hidden: 0 /* FALSE */,
        freezeColumn: 1,
        rowCount: 10,
        columnCount: 11,
        freezeRow: 1,
        zoomRatio: 1,
        scrollTop: 200,
        scrollLeft: 100,
        defaultColumnWidth: 93,
        defaultRowHeight: 40,
        mergeData: [
          {
            startRow: 0,
            endRow: 1,
            startColumn: 10,
            endColumn: 10
          },
          {
            startRow: 0,
            endRow: 9,
            startColumn: 0,
            endColumn: 0
          },
          {
            startRow: 0,
            endRow: 0,
            startColumn: 1,
            endColumn: 7
          },
          {
            startRow: 0,
            endRow: 0,
            startColumn: 8,
            endColumn: 9
          },
          {
            startRow: 1,
            endRow: 1,
            startColumn: 1,
            endColumn: 4
          },
          {
            startRow: 1,
            endRow: 1,
            startColumn: 6,
            endColumn: 9
          },
          {
            startRow: 2,
            endRow: 2,
            startColumn: 4,
            endColumn: 5
          },
          {
            startRow: 2,
            endRow: 2,
            startColumn: 7,
            endColumn: 9
          },
          {
            startRow: 3,
            endRow: 3,
            startColumn: 2,
            endColumn: 9
          },
          {
            startRow: 4,
            endRow: 4,
            startColumn: 2,
            endColumn: 6
          },
          {
            startRow: 4,
            endRow: 4,
            startColumn: 7,
            endColumn: 9
          },
          {
            startRow: 5,
            endRow: 5,
            startColumn: 3,
            endColumn: 4
          },
          {
            startRow: 5,
            endRow: 5,
            startColumn: 5,
            endColumn: 7
          },
          {
            startRow: 6,
            endRow: 6,
            startColumn: 2,
            endColumn: 9
          },
          {
            startRow: 7,
            endRow: 7,
            startColumn: 4,
            endColumn: 5
          },
          {
            startRow: 8,
            endRow: 8,
            startColumn: 7,
            endColumn: 8
          },
          {
            startRow: 8,
            endRow: 8,
            startColumn: 4,
            endColumn: 5
          },
          {
            startRow: 7,
            endRow: 7,
            startColumn: 7,
            endColumn: 8
          },
          {
            startRow: 9,
            endRow: 9,
            startColumn: 1,
            endColumn: 9
          },
          {
            startRow: 2,
            endRow: 9,
            startColumn: 10,
            endColumn: 10
          }
        ],
        rowData: {
          "0": {
            h: 50
          },
          "1": {
            h: 20
          },
          "6": {
            h: 150
          },
          "9": {
            h: 30
          }
        },
        columnData: {
          "0": {
            w: 20
          },
          "1": {
            w: 180
          },
          "2": {
            w: 120
          },
          "4": {
            w: 60
          },
          "5": {
            w: 60
          },
          "7": {
            w: 30
          },
          "8": {
            w: 90
          },
          "10": {
            w: 40
          }
        },
        status: 1,
        showGridlines: 0,
        hideRow: [],
        hideColumn: [],
        rowTitle: {
          width: 46,
          hidden: 0 /* FALSE */
        },
        columnTitle: {
          height: 20,
          hidden: 0 /* FALSE */
        },
        selections: ["A2"],
        rightToLeft: 0 /* FALSE */,
        pluginMeta: {}
      }
    },
    namedRanges: [
      {
        namedRangeId: "named-rang",
        name: "namedRange",
        range: {
          sheetId: "sheet-0001",
          rangeData: {
            startRow: 0,
            startColumn: 0,
            endRow: 1,
            endColumn: 1
          }
        }
      }
    ]
  };

  // ../../packages/common-plugin-data/src/Sheets/SLIDE_WORKBOOK_DATA.ts
  var SLIDE_WORKBOOK_DATA = {
    id: "workbook-01",
    theme: "default",
    locale: "en" /* EN */,
    creator: "univer",
    name: "universheet",
    skin: "default",
    socketUrl: "",
    socketEnable: 0 /* FALSE */,
    extensions: [],
    sheetOrder: ["sheet-0001"],
    pluginMeta: {},
    styles: {
      "1": {
        vt: 2,
        ht: 2,
        bl: 1,
        fs: 14,
        bg: {
          rgb: "rgb(105,126,146)"
        },
        cl: {
          rgb: "rgb(255,255,255)"
        }
      },
      "2": {
        vt: 2,
        ht: 2,
        bl: 1,
        fs: 20,
        bg: {
          rgb: "rgb(244,79,86)"
        },
        cl: {
          rgb: "rgb(255,255,255)"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          }
        }
      },
      "3": {
        vt: 2,
        bg: {
          rgb: "rgb(105,126,146)"
        },
        cl: {
          rgb: "rgb(255,255,255)"
        },
        fs: 14,
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          }
        }
      },
      "4": {
        fs: 12,
        vt: 2,
        pd: {
          l: 5
        },
        ht: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          }
        }
      },
      "5": {
        ht: 2,
        vt: 2,
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          }
        }
      },
      "6": {
        ht: 1,
        vt: 2,
        tb: 3,
        bg: {
          rgb: "rgba(244,79,86)"
        },
        cl: {
          rgb: "rgb(255,255,255)"
        },
        bd: {
          t: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          l: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          r: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          },
          b: {
            s: 1 /* THIN */,
            cl: {
              rgb: "rgb(217,217,217)"
            }
          }
        }
      }
    },
    timeZone: "GMT+8",
    createdTime: "2021-11-28 12:10:10",
    modifiedTime: "2021-11-29 12:10:10",
    appVersion: "3.0.0-alpha",
    lastModifiedBy: "univer",
    sheets: {
      "sheet-0001": {
        type: 0 /* GRID */,
        id: "sheet-0001",
        name: "sheet-0001",
        tabColor: "blue",
        hidden: 0 /* FALSE */,
        freezeColumn: 1,
        rowCount: 12,
        columnCount: 11,
        freezeRow: 1,
        zoomRatio: 1,
        scrollTop: 200,
        scrollLeft: 100,
        defaultColumnWidth: 93,
        defaultRowHeight: 40,
        cellData: {
          "1": {
            "1": {
              v: "Variants",
              s: "2"
            },
            "2": {
              v: "Platform",
              s: "2"
            },
            "3": {
              v: "UGC Buzz volume",
              s: "2"
            },
            "9": {
              p: PAGE5_RICHTEXT_1,
              s: "6"
            }
          },
          "2": {
            "3": {
              v: "Jul'21",
              s: "1"
            },
            "4": {
              v: "Aug'21",
              s: "1"
            },
            "5": {
              v: "Sep'21",
              s: "1"
            },
            "6": {
              v: "Oct'21",
              s: "1"
            },
            "7": {
              v: "Nov'21",
              s: "1"
            },
            "8": {
              v: "Dec'21",
              s: "1"
            }
          },
          "3": {
            "1": {
              v: "Eleva",
              s: "3"
            },
            "2": {
              v: "Amazon",
              s: "4"
            },
            "3": {
              v: "4",
              s: "5"
            },
            "4": {
              v: "145",
              s: "5"
            },
            "5": {
              v: "44",
              s: "5"
            },
            "6": {
              v: "20",
              s: "5"
            },
            "7": {
              v: "7",
              s: "5"
            },
            "8": {
              v: "12",
              s: "5"
            }
          },
          "4": {
            "2": {
              v: "Google",
              s: "4"
            },
            "3": {
              v: "2",
              s: "5"
            },
            "4": {
              v: "6",
              s: "5"
            },
            "5": {
              v: "5",
              s: "5"
            },
            "6": {
              v: "6",
              s: "5"
            },
            "7": {
              v: "12",
              s: "5"
            },
            "8": {
              v: "3113",
              s: "5"
            }
          },
          "5": {
            "2": {
              v: "Amazon",
              s: "4"
            },
            "3": {
              v: "14",
              s: "5"
            },
            "4": {
              v: "13",
              s: "5"
            },
            "5": {
              v: "6",
              s: "5"
            },
            "6": {
              v: "6",
              s: "5"
            },
            "7": {
              v: "11",
              s: "5"
            },
            "8": {
              v: "2",
              s: "5"
            }
          },
          "6": {
            "1": {
              v: "Similac",
              s: "3"
            },
            "2": {
              v: "SaleForce",
              s: "4"
            },
            "3": {
              v: "451",
              s: "5"
            },
            "4": {
              v: "255",
              s: "5"
            },
            "5": {
              v: "72",
              s: "5"
            },
            "6": {
              v: "23",
              s: "5"
            },
            "7": {
              v: "163",
              s: "5"
            },
            "8": {
              v: "22",
              s: "5"
            }
          },
          "7": {
            "2": {
              v: "Oracle",
              s: "4"
            },
            "3": {
              v: "0",
              s: "5"
            },
            "4": {
              v: "1",
              s: "5"
            },
            "5": {
              v: "1136",
              s: "5"
            },
            "6": {
              v: "11",
              s: "5"
            },
            "7": {
              v: "2",
              s: "5"
            },
            "8": {
              v: "1",
              s: "5"
            }
          },
          "8": {
            "2": {
              v: "Apple",
              s: "4"
            },
            "3": {
              v: "7",
              s: "5"
            },
            "4": {
              v: "2",
              s: "5"
            },
            "5": {
              v: "10",
              s: "5"
            },
            "6": {
              v: "5",
              s: "5"
            },
            "7": {
              v: "6",
              s: "5"
            },
            "8": {
              v: "3",
              s: "5"
            }
          },
          "9": {
            "1": {
              v: "TC",
              s: "3"
            },
            "2": {
              v: "IBM",
              s: "4"
            },
            "3": {
              v: "1",
              s: "5"
            },
            "4": {
              v: "12",
              s: "5"
            },
            "5": {
              v: "2",
              s: "5"
            },
            "6": {
              v: "1",
              s: "5"
            },
            "7": {
              v: "1",
              s: "5"
            },
            "8": {
              v: "1",
              s: "5"
            }
          },
          "10": {
            "2": {
              v: "Google",
              s: "4"
            },
            "3": {
              v: "26",
              s: "5"
            },
            "4": {
              v: "33",
              s: "5"
            },
            "5": {
              v: "33",
              s: "5"
            },
            "6": {
              v: "6",
              s: "5"
            },
            "7": {
              v: "22",
              s: "5"
            },
            "8": {
              v: "8",
              s: "5"
            }
          }
        },
        mergeData: [
          {
            startRow: 1,
            endRow: 2,
            startColumn: 1,
            endColumn: 1
          },
          {
            startRow: 1,
            endRow: 2,
            startColumn: 2,
            endColumn: 2
          },
          {
            startRow: 1,
            endRow: 1,
            startColumn: 3,
            endColumn: 8
          },
          {
            startRow: 3,
            endRow: 5,
            startColumn: 1,
            endColumn: 1
          },
          {
            startRow: 6,
            endRow: 8,
            startColumn: 1,
            endColumn: 1
          },
          {
            startRow: 9,
            endRow: 10,
            startColumn: 1,
            endColumn: 1
          },
          {
            startRow: 1,
            endRow: 10,
            startColumn: 9,
            endColumn: 10
          }
        ],
        rowData: {
          "0": {
            h: 20
          }
        },
        columnData: {
          "0": {
            w: 20
          },
          "2": {
            w: 120
          },
          "3": {
            w: 60
          },
          "4": {
            w: 60
          },
          "5": {
            w: 60
          },
          "6": {
            w: 60
          },
          "7": {
            w: 60
          },
          "8": {
            w: 60
          }
        },
        status: 1,
        showGridlines: 0,
        hideRow: [],
        hideColumn: [],
        rowTitle: {
          width: 46,
          hidden: 0 /* FALSE */
        },
        columnTitle: {
          height: 20,
          hidden: 0 /* FALSE */
        },
        selections: ["A2"],
        rightToLeft: 0 /* FALSE */,
        pluginMeta: {}
      }
    },
    namedRanges: [
      {
        namedRangeId: "named-rang",
        name: "namedRange",
        range: {
          sheetId: "sheet-0001",
          rangeData: {
            startRow: 0,
            startColumn: 0,
            endRow: 1,
            endColumn: 1
          }
        }
      }
    ]
  };

  // ../../packages/common-plugin-data/src/Docs/DEFAULT_DOCUMENT_DATA.ts
  var DEFAULT_DOCUMENT_DATA = {
    id: "d",
    drawings: {
      shapeTest1: {
        objectId: "shapeTest1",
        objectProperties: {
          title: "test shape",
          description: "test shape",
          size: {
            width: 100,
            height: 400
          },
          positionH: {
            relativeFrom: 1 /* COLUMN */,
            posOffset: 100
          },
          positionV: {
            relativeFrom: 6 /* PARAGRAPH */,
            posOffset: 160
          },
          angle: 0,
          imageProperties: {
            contentUrl: "https://cnbabylon.com/assets/img/agents.png"
          }
        },
        layoutType: 3 /* WRAP_SQUARE */,
        behindDoc: 0 /* FALSE */,
        wrapText: 0 /* BOTH_SIDES */
      }
    },
    lists: DEFAULT_LIST_TEST,
    body: {
      blockElements: [
        {
          blockId: "oneParagraph",
          st: 0,
          ed: 59,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            bullet: {
              listId: "testBullet",
              nestingLevel: 0,
              textStyle: {
                fs: 20
              }
            },
            elements: [
              {
                eId: "oneElement",
                st: 0,
                ed: 15,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u5728\u201C\u7B2C1\u9898\u201D\u5DE5\u4F5C\u8868\u4E2D\u5B8C\u6210\u4EE5\u4E0B\u64CD\u4F5C",
                  ts: {
                    fs: 12,
                    bg: {
                      rgb: "rgb(200,0,90)"
                    },
                    cl: {
                      rgb: "rgb(255,130,0)"
                    }
                  }
                }
              },
              {
                eId: "shapeTest1",
                et: 7 /* DRAWING */,
                st: 0,
                ed: 0
              },
              {
                eId: "smallSub",
                st: 16,
                ed: 17,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u4E0A\u6807",
                  ts: {
                    fs: 14,
                    bg: {
                      rgb: "rgb(2,128,2)"
                    },
                    cl: {
                      rgb: "rgb(0,1,55)"
                    },
                    va: 2 /* SUPERSCRIPT */
                  }
                }
              },
              {
                eId: "twoElement",
                st: 18,
                ed: 59,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u65E5\u671F\u5217\u5355\u5143\u683C\u6570\u636E\u9A8C\u8BC1\uFF0C\u9650\u5236\u53EA\u80FD\u8F93\u5165\u65E5\u671F\uFF08\u4ECB\u4E8E1949\u5E741\u67081\u65E5\u81F32099\u5E741\u67081\u65E5\uFF09",
                  ts: {
                    fs: 14,
                    bg: {
                      rgb: "rgb(90,128,255)"
                    },
                    cl: {
                      rgb: "rgb(0,1,255)"
                    }
                  }
                }
              }
            ]
          }
        },
        {
          blockId: "twoParagraph",
          st: 60,
          ed: 88,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            bullet: {
              listId: "testBullet",
              nestingLevel: 1,
              textStyle: {
                fs: 20
              }
            },
            elements: [
              {
                eId: "oneElement",
                st: 60,
                ed: 74,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u7EC6\u5316\u57CB\u70B9\u4E0A\u62A5\u94FE\u8DEF\u548C\u6307\u6807\u65B9\u6848\u68B3\u7406"
                }
              },
              {
                eId: "twoElement",
                st: 75,
                ed: 88,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u76EE\u524D\u901A\u8FC7\u6BCF\u65E5\u5B9A\u65F6\u4EFB\u52A1\u53D1\u9001\u62A5\u544A"
                }
              }
            ]
          }
        },
        {
          blockId: "threeParagraph",
          st: 89,
          ed: 230,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            bullet: {
              listId: "testBullet",
              nestingLevel: 0,
              textStyle: {
                fs: 20
              }
            },
            elements: [
              {
                eId: "oneElement",
                st: 89,
                ed: 138,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u81EA2018\u5E74\u9996\u5C4A\u8FDB\u535A\u4F1A\u4E3E\u529E\u4EE5\u6765\uFF0C\u8FDB\u535A\u4F1A\u5DF2\u7ECF\u6210\u4E3A\u5168\u7403\u65B0\u54C1\u7684\u9996\u53D1\u5730\u3001\u524D\u6CBF\u6280\u672F\u7684\u9996\u9009\u5730\u3001\u521B\u65B0\u670D\u52A1\u7684\u9996\u63A8\u5730\u3002"
                }
              },
              {
                eId: "twoElement",
                st: 139,
                ed: 230,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u4E2D\u56FD\u8FD9\u5341\u5E74\u201D\u5BF9\u5916\u5F00\u653E\u6210\u5C31\u5C55\u6E56\u5317\u5C55\u533A\u4E3B\u8981\u4EE5\u56FE\u6587\u3001\u56FE\u8868\u3001\u6570\u636E\u3001\u89C6\u9891\u3001\u4F01\u4E1A\u5C55\u54C1\u3001\u5B9E\u7269\u6A21\u578B\u3001\u5149\u7535\u79D1\u6280\u7B49\u4F53\u73B0\u6E56\u5317\u5341\u5E74\u5F00\u653E\u6210\u5C31\u3001\u91CD\u5927\u5F00\u653E\u5E73\u53F0\u53CA\u4EA7\u4E1A\u3002\u6E56\u5317\u7701\u5171\u8BA117\u5BB6\u4F01\u4E1A\u3001\u673A\u6784\u7684\u5C55\u54C1\u5C06\u5728\u8FD9\u4E00\u5C55\u533A\u5C55\u793A"
                }
              }
            ]
          }
        },
        {
          blockId: "fourParagraph",
          st: 231,
          ed: 322,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            bullet: {
              listId: "testBullet",
              nestingLevel: 1,
              textStyle: {
                fs: 20
              }
            },
            elements: [
              {
                eId: "oneElement",
                st: 231,
                ed: 286,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u56FD\u5BB6\u4E3B\u5E2D\u4E60\u8FD1\u5E73\u4EE5\u89C6\u9891\u65B9\u5F0F\u51FA\u5E2D\u5728\u4E0A\u6D77\u4E3E\u884C\u7684\u7B2C\u4E94\u5C4A\u4E2D\u56FD\u56FD\u9645\u8FDB\u53E3\u535A\u89C8\u4F1A\u5F00\u5E55\u5F0F\u5E76\u53D1\u8868\u9898\u4E3A\u300A\u5171\u521B\u5F00\u653E\u7E41\u8363\u7684\u7F8E\u597D\u672A\u6765\u300B\u7684\u81F4\u8F9E"
                }
              },
              {
                eId: "twoElement",
                st: 287,
                ed: 322,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u4E2D\u56FD\u5C06\u63A8\u52A8\u5404\u56FD\u5404\u65B9\u5171\u4EAB\u6DF1\u5316\u56FD\u9645\u5408\u4F5C\u673A\u9047\uFF0C\u5168\u9762\u6DF1\u5165\u53C2\u4E0E\u4E16\u754C\u8D38\u6613\u7EC4\u7EC7\u6539\u9769\u8C08\u5224"
                }
              }
            ]
          }
        },
        {
          blockId: "fiveParagraph",
          st: 323,
          ed: 400,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            bullet: {
              listId: "testBullet",
              nestingLevel: 2,
              textStyle: {
                fs: 20
              }
            },
            elements: [
              {
                eId: "oneElement",
                st: 323,
                ed: 360,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u4E2D\u56FD\u7537\u6392\u4E24\u540D\u73B0\u5F79\u56FD\u624B\u5F6D\u4E16\u5764\u548C\u5F20\u79C9\u9F99\u5206\u522B\u6548\u529B\u7684\u4E09\u5F97\u5229\u592A\u9633\u9E1F\u548C\u4E1C\u4EAC\u5927\u718A\u672C\u8F6E\u906D\u9047\u3002"
                }
              },
              {
                eId: "twoElement",
                st: 361,
                ed: 400,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "\u53CC\u65B9\u7ECF\u8FC7\u6FC0\u6218\uFF0C\u4E3B\u573A\u4F5C\u6218\u7684\u536B\u5195\u51A0\u519B\u4E09\u5F97\u5229\u6280\u9AD8\u4E00\u7B793-2\u9006\u8F6C\u51FB\u8D25\u5BF9\u624B\uFF0C\u529B\u593A\u7B2C3\u573A\u80DC\u5229"
                }
              }
            ]
          }
        },
        {
          blockId: "oneSectionBreak",
          st: 0,
          ed: 0,
          blockType: 2 /* SECTION_BREAK */,
          sectionBreak: {
            columnProperties: [
              {
                width: 200,
                paddingEnd: 20
              }
            ],
            columnSeparatorType: 1 /* NONE */,
            sectionType: 0 /* SECTION_TYPE_UNSPECIFIED */
            // textDirection: textDirectionDocument,
            // contentDirection: textDirection!,
          }
        }
      ]
    },
    documentStyle: {
      pageSize: {
        width: 594.3,
        height: 840.51
      },
      marginTop: 72,
      marginBottom: 72,
      marginRight: 90,
      marginLeft: 90
    }
  };

  // ../../packages/common-plugin-data/src/Docs/DEFAULT_DOCUMENT_DATA_EN.ts
  var DEFAULT_DOCUMENT_DATA_EN = {
    id: "d",
    drawings: {
      shapeTest1: {
        objectId: "shapeTest1",
        objectProperties: {
          title: "test shape",
          description: "test shape",
          size: {
            width: 1484 * 0.15,
            height: 864 * 0.15
          },
          positionH: {
            relativeFrom: 1 /* COLUMN */,
            posOffset: 130
          },
          positionV: {
            relativeFrom: 5 /* PAGE */,
            posOffset: 510
          },
          angle: 0,
          imageProperties: {
            contentUrl: "https://minio.cnbabylon.com/univer/slide/gartner-tech-2022.png"
          }
        },
        layoutType: 3 /* WRAP_SQUARE */,
        behindDoc: 0 /* FALSE */,
        wrapText: 0 /* BOTH_SIDES */
      },
      shapeTest2: {
        objectId: "shapeTest2",
        objectProperties: {
          title: "test shape",
          description: "test shape",
          size: {
            width: 2548 * 0.1,
            height: 2343 * 0.1
          },
          positionH: {
            relativeFrom: 1 /* COLUMN */,
            posOffset: 130
          },
          positionV: {
            relativeFrom: 5 /* PAGE */,
            posOffset: 200
          },
          angle: 0,
          imageProperties: {
            contentUrl: "https://minio.cnbabylon.com/univer/slide/hype-cycle-for-emerging-tech-2022.png"
          }
        },
        layoutType: 3 /* WRAP_SQUARE */,
        behindDoc: 0 /* FALSE */,
        wrapText: 0 /* BOTH_SIDES */
      }
    },
    lists: DEFAULT_LIST_TEST,
    body: {
      blockElements: [
        {
          blockId: "p1",
          st: 0,
          ed: 66,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            elements: [
              {
                eId: "e1",
                st: 0,
                ed: 66,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "What\u2019s New in the 2022 Gartner Hype Cycle for Emerging Technologies",
                  ts: {
                    bl: 1 /* TRUE */,
                    fs: 24,
                    cl: {
                      rgb: "rgb(0,40,86)"
                    }
                  }
                }
              }
            ]
          }
        },
        {
          blockId: "p2",
          st: 67,
          ed: 251,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            paragraphStyle: {
              spaceAbove: 20,
              indentFirstLine: 20
            },
            elements: [
              {
                eId: "e1",
                st: 67,
                ed: 251,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "Emerging technologies for 2022 fit into three main themes: evolving/expanding immersive experiences, accelerated artificial intelligence automation, and optimized technologist delivery.",
                  ts: {
                    fs: 18,
                    cl: {
                      rgb: "rgb(0,40,86)"
                    }
                  }
                }
              }
            ]
          }
        },
        {
          blockId: "p3",
          st: 252,
          ed: 401,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            paragraphStyle: {
              spaceAbove: 20,
              indentFirstLine: 20
            },
            elements: [
              {
                eId: "e1",
                st: 252,
                ed: 401,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "The 2022 Gartner Hype Cycle identifies 25 must-know emerging technologies designed to help enterprise architecture and technology innovation leaders: ",
                  ts: {
                    fs: 16
                  }
                }
              }
            ]
          }
        },
        {
          blockId: "p4",
          st: 402,
          ed: 429,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            bullet: {
              listId: "testBullet",
              nestingLevel: 0,
              textStyle: {
                fs: 20
              }
            },
            paragraphStyle: {
              lineSpacing: 1.5
            },
            elements: [
              {
                eId: "e1",
                st: 402,
                ed: 429,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "Expand immersive experiences",
                  ts: {
                    fs: 16
                  }
                }
              }
            ]
          }
        },
        {
          blockId: "p5",
          st: 430,
          ed: 479,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            bullet: {
              listId: "testBullet",
              nestingLevel: 0,
              textStyle: {
                fs: 20
              }
            },
            paragraphStyle: {
              lineSpacing: 1.5
            },
            elements: [
              {
                eId: "e1",
                st: 430,
                ed: 479,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "Accelerate artificial intelligence (AI) automation",
                  ts: {
                    fs: 16
                  }
                }
              }
            ]
          }
        },
        {
          blockId: "p6",
          st: 480,
          ed: 510,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            bullet: {
              listId: "testBullet",
              nestingLevel: 0,
              textStyle: {
                fs: 20
              }
            },
            paragraphStyle: {
              lineSpacing: 1.5
            },
            elements: [
              {
                eId: "e1",
                st: 480,
                ed: 510,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "Optimize technologist delivery ",
                  ts: {
                    fs: 16
                  }
                }
              }
            ]
          }
        },
        {
          blockId: "p7",
          st: 511,
          ed: 705,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            paragraphStyle: {
              indentFirstLine: 20
            },
            elements: [
              {
                eId: "e1",
                st: 511,
                ed: 672,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "These technologies are expected to greatly impact business and society over the next two to 10 years, but will especially enable CIOs and IT leaders to deliver on",
                  ts: {
                    fs: 16
                  }
                }
              },
              {
                eId: "e2",
                st: 673,
                ed: 705,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "digital business transformation. ",
                  ts: {
                    fs: 16,
                    cl: {
                      rgb: "rgb(0, 0, 211)"
                    },
                    bl: 1 /* TRUE */
                  }
                }
              }
            ]
          }
        },
        {
          blockId: "p8",
          st: 706,
          ed: 762,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            paragraphStyle: {
              spaceAbove: 20
            },
            elements: [
              {
                eId: "e1",
                st: 706,
                ed: 762,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "Three Hype Cycle themes to think about in 2022 and beyond",
                  ts: {
                    fs: 24,
                    cl: {
                      rgb: "rgb(255,255,255)"
                    },
                    bg: {
                      rgb: "rgb(0,40,86)"
                    }
                  }
                }
              }
            ]
          }
        },
        {
          blockId: "p9",
          st: 763,
          ed: 1233,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            paragraphStyle: {
              spaceAbove: 20,
              indentFirstLine: 20
            },
            elements: [
              {
                eId: "e1",
                st: 763,
                ed: 1233,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "The 2022 Gartner Hype Cycle features emerging technologies and distills insights from more than 2,000 technologies into a succinct high-potential set. Most technologies have multiple use cases but enterprise architecture and technology innovation leaders should prioritize those with the greatest potential benefit for their organization. (They will also need to launch a proof-of-concept project to demonstrate the feasibility of a technology for their target use case.)",
                  ts: {
                    fs: 16
                  }
                }
              },
              {
                eId: "shapeTest1",
                st: 0,
                ed: 0,
                et: 7 /* DRAWING */
              }
            ]
          }
        },
        {
          blockId: "oneSectionBreak",
          st: 0,
          ed: 0,
          blockType: 2 /* SECTION_BREAK */,
          sectionBreak: {
            columnProperties: [],
            columnSeparatorType: 1 /* NONE */,
            sectionType: 0 /* SECTION_TYPE_UNSPECIFIED */
            // textDirection: textDirectionDocument,
            // contentDirection: textDirection!,
          }
        },
        {
          blockId: "p10",
          st: 1206 + 28,
          ed: 1548 + 28,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            paragraphStyle: {
              indentFirstLine: 20
            },
            elements: [
              {
                eId: "e1",
                st: 1206 + 28,
                ed: 1548 + 28,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "The benefit of these technologies is that they provide individuals with more control over their identities and data, and expand their range of experiences into virtual venues and ecosystems that can be integrated with digital currencies. These technologies also provide new ways to reach customers to strengthen or open up new revenue streams.",
                  ts: {
                    fs: 16
                  }
                }
              }
            ]
          }
        },
        {
          blockId: "p11",
          st: 1549 + 28,
          ed: 1944 + 28,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            paragraphStyle: {
              indentFirstLine: 20
            },
            elements: [
              {
                eId: "e1",
                st: 1549 + 28,
                ed: 1944 + 28,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "Digital twin of the customer (DToC) is a dynamic virtual representation of a customer that simulates and learns to emulate and anticipate behavior. It can be used to modify and enhance the customer experience (CX) and support new digitalization efforts, products, services and opportunities. DToC will take five to 10 years until mainstream adoption but will be transformational to organizations.",
                  ts: {
                    fs: 16
                  }
                }
              }
            ]
          }
        },
        {
          blockId: "p12",
          st: 1945 + 28,
          ed: 2019 + 28,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            paragraphStyle: {
              indentFirstLine: 20
            },
            elements: [
              {
                eId: "e1",
                st: 1945 + 28,
                ed: 2019 + 28,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "Other critical technologies in immersive experiences include the following:",
                  ts: {
                    fs: 16
                  }
                }
              }
            ]
          }
        },
        {
          blockId: "p13",
          st: 2020 + 28,
          ed: 2250 + 28,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            paragraphStyle: {
              indentFirstLine: 20
            },
            bullet: {
              listId: "unorderedTest",
              nestingLevel: 0,
              textStyle: {
                fs: 20
              }
            },
            elements: [
              {
                eId: "e1",
                st: 2020 + 28,
                ed: 2042 + 28,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "Decentralized identity ",
                  ts: {
                    fs: 16,
                    cl: {
                      rgb: "rgb(0, 0, 211)"
                    },
                    bl: 1 /* TRUE */
                  }
                }
              },
              {
                eId: "e2",
                st: 2043 + 28,
                ed: 2250 + 28,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "(DCI) allows an entity (typically a human user) to control their own digital identity by leveraging technologies such as blockchain or other distributed ledger technologies (DLTs), along with digital wallets.",
                  ts: {
                    fs: 16
                  }
                }
              }
            ]
          }
        },
        {
          blockId: "p14",
          st: 2251 + 28,
          ed: 2393 + 28,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            paragraphStyle: {
              indentFirstLine: 20
            },
            bullet: {
              listId: "unorderedTest",
              nestingLevel: 0,
              textStyle: {
                fs: 20
              }
            },
            elements: [
              {
                eId: "e1",
                st: 2251 + 28,
                ed: 2265 + 28,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "Digital humans ",
                  ts: {
                    fs: 16,
                    cl: {
                      rgb: "rgb(0, 0, 211)"
                    },
                    bl: 1 /* TRUE */
                  }
                }
              },
              {
                eId: "e2",
                st: 2266 + 28,
                ed: 2393 + 28,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "are interactive, AI-driven representations that have some of the characteristics, personality, knowledge and mindset of a human.",
                  ts: {
                    fs: 16
                  }
                }
              }
            ]
          }
        },
        {
          blockId: "p15",
          st: 2394 + 28,
          ed: 2582 + 28,
          blockType: 0 /* PARAGRAPH */,
          paragraph: {
            paragraphStyle: {
              indentFirstLine: 20
            },
            bullet: {
              listId: "unorderedTest",
              nestingLevel: 0,
              textStyle: {
                fs: 20
              }
            },
            elements: [
              {
                eId: "e1",
                st: 2394 + 28,
                ed: 2422 + 28,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "Internal talent marketplaces ",
                  ts: {
                    fs: 16,
                    cl: {
                      rgb: "rgb(0, 0, 0)"
                    },
                    bl: 1 /* TRUE */
                  }
                }
              },
              {
                eId: "e2",
                st: 2423 + 28,
                ed: 2582 + 28,
                et: 0 /* TEXT_RUN */,
                tr: {
                  ct: "match internal employees and, in some cases, a pool of contingent workers, to time-boxed projects and various work opportunities, with no recruiter involvement.",
                  ts: {
                    fs: 16
                  }
                }
              }
            ]
          }
        },
        {
          blockId: "twoSectionBreak",
          st: 0,
          ed: 0,
          blockType: 2 /* SECTION_BREAK */,
          sectionBreak: {
            columnProperties: [
              {
                width: 200,
                paddingEnd: 5
              }
            ],
            columnSeparatorType: 1 /* NONE */,
            sectionType: 0 /* SECTION_TYPE_UNSPECIFIED */
            // textDirection: textDirectionDocument,
            // contentDirection: textDirection!,
          }
        }
      ]
    },
    documentStyle: {
      pageSize: {
        width: 594.3,
        height: 840.51
      },
      marginTop: 72,
      marginBottom: 72,
      marginRight: 90,
      marginLeft: 90
    }
  };

  // ../../packages/common-plugin-data/src/Slides/DefaultPages/Page1.ts
  var DEFAULT_FIRST_PAGE = {
    id: "cover_1",
    pageType: 0 /* SLIDE */,
    zIndex: 1,
    title: "cover",
    description: "this is first page, cover",
    pageBackgroundFill: {
      rgb: "rgb(255,255,255)"
    },
    pageElements: {
      background1: {
        id: "background1",
        zIndex: 0,
        left: 0,
        top: 0,
        width: 960,
        height: 540,
        title: "background",
        description: "",
        type: 1 /* IMAGE */,
        image: {
          imageProperties: {
            contentUrl: "https://minio.cnbabylon.com/univer/slide/Picture1.jpg"
          }
        }
      },
      mask1: {
        id: "mask1",
        zIndex: 1,
        left: 0,
        top: 0,
        width: 960,
        height: 540,
        title: "mask",
        description: "",
        type: 0 /* SHAPE */,
        shape: {
          shapeType: 2 /* RECTANGLE */,
          text: "",
          shapeProperties: {
            shapeBackgroundFill: {
              rgb: "rgba(0,0,0,0.7)"
            }
          }
        }
      },
      text1: {
        id: "text1",
        zIndex: 2,
        left: 300,
        top: 200,
        width: 400,
        height: 140,
        title: "mask",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "Univer slide",
          fs: 64,
          cl: {
            rgb: "rgb(244,79,86)"
          },
          bl: 1
        }
      },
      centerRect1: {
        id: "centerRect1",
        zIndex: 1,
        left: 378,
        top: 0,
        width: 204,
        height: 144,
        title: "mask",
        description: "",
        type: 0 /* SHAPE */,
        shape: {
          shapeType: 2 /* RECTANGLE */,
          text: "",
          shapeProperties: {
            shapeBackgroundFill: {
              rgb: "rgb(244,79,86)"
            }
          }
        }
      },
      year1: {
        id: "year1",
        zIndex: 2,
        left: 430,
        top: 42,
        width: 100,
        height: 40,
        title: "mask",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "2022",
          fs: 48,
          cl: {
            rgb: "rgb(255,255,255)"
          },
          bl: 1
        }
      },
      content1: {
        id: "content1",
        zIndex: 2,
        left: 80,
        top: 300,
        width: 780,
        height: 140,
        title: "mask",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "The concepts national income and national product have roughly the same value and can be used interchangeably if our interest is in their sum total which is measured as the market value of the total output of goods and services of an economy in a given period, usually a year.",
          fs: 14,
          cl: {
            rgb: "rgb(255,255,255)"
          },
          bl: 1
        }
      }
    }
  };

  // ../../packages/common-plugin-data/src/Slides/DefaultPages/Page2.ts
  var DEFAULT_SECOND_PAGE = {
    id: "catalog_1",
    pageType: 0 /* SLIDE */,
    zIndex: 2,
    title: "catalog",
    description: "this is second page, catalog",
    pageBackgroundFill: {
      rgb: "rgb(255,255,255)"
    },
    pageElements: {
      background1: {
        id: "background1",
        zIndex: 0,
        left: 0,
        top: 0,
        width: 960,
        height: 540,
        title: "background",
        description: "",
        type: 1 /* IMAGE */,
        image: {
          imageProperties: {
            contentUrl: "https://minio.cnbabylon.com/univer/slide/Picture1.jpg"
          }
        }
      },
      mask1: {
        id: "mask1",
        zIndex: 1,
        left: 0,
        top: 0,
        width: 960,
        height: 540,
        title: "mask",
        description: "",
        type: 0 /* SHAPE */,
        shape: {
          shapeType: 2 /* RECTANGLE */,
          text: "",
          shapeProperties: {
            shapeBackgroundFill: {
              rgb: "rgba(0,0,0,0.7)"
            }
          }
        }
      },
      text1: {
        id: "text1",
        zIndex: 3,
        left: 180,
        top: 240,
        width: 200,
        height: 40,
        title: "Catalog",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "Catalog",
          fs: 42,
          cl: {
            rgb: "rgb(255,255,255)"
          }
        }
      },
      centerRect1: {
        id: "centerRect1",
        zIndex: 2,
        left: 140,
        top: 168,
        width: 203,
        height: 203,
        title: "mask",
        description: "",
        type: 0 /* SHAPE */,
        shape: {
          shapeType: 2 /* RECTANGLE */,
          text: "",
          shapeProperties: {
            shapeBackgroundFill: {
              rgb: "rgb(244,79,86)"
            }
          }
        }
      },
      firstRect1: {
        id: "firstRect1",
        zIndex: 2,
        left: 547,
        top: 115,
        width: 44,
        height: 44,
        title: "index1",
        description: "",
        type: 0 /* SHAPE */,
        shape: {
          shapeType: 2 /* RECTANGLE */,
          text: "",
          shapeProperties: {
            shapeBackgroundFill: {
              rgb: "rgb(244,79,86)"
            }
          }
        }
      },
      secondRect1: {
        id: "secondRect1",
        zIndex: 2,
        left: 547,
        top: 210,
        width: 44,
        height: 44,
        title: "index2",
        description: "",
        type: 0 /* SHAPE */,
        shape: {
          shapeType: 2 /* RECTANGLE */,
          text: "",
          shapeProperties: {
            shapeBackgroundFill: {
              rgb: "rgb(244,79,86)"
            }
          }
        }
      },
      thirdRect1: {
        id: "thirdRect1",
        zIndex: 2,
        left: 547,
        top: 304,
        width: 44,
        height: 44,
        title: "index2",
        description: "",
        type: 0 /* SHAPE */,
        shape: {
          shapeType: 2 /* RECTANGLE */,
          text: "",
          shapeProperties: {
            shapeBackgroundFill: {
              rgb: "rgb(244,79,86)"
            }
          }
        }
      },
      forth1: {
        id: "forth1",
        zIndex: 2,
        left: 547,
        top: 397,
        width: 44,
        height: 44,
        title: "index2",
        description: "",
        type: 0 /* SHAPE */,
        shape: {
          shapeType: 2 /* RECTANGLE */,
          text: "",
          shapeProperties: {
            shapeBackgroundFill: {
              rgb: "rgb(244,79,86)"
            }
          }
        }
      },
      first_index1: {
        id: "first_index1",
        zIndex: 3,
        left: 557,
        top: 120,
        width: 44,
        height: 44,
        title: "mask",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "01",
          fs: 28,
          cl: {
            rgb: "rgb(255,255,255)"
          },
          bl: 1
        }
      },
      first_title1: {
        id: "first_title1",
        zIndex: 3,
        left: 610,
        top: 115,
        width: 248,
        height: 39,
        title: "mask",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "Strategic technology trends",
          fs: 20,
          cl: {
            rgb: "rgb(244,79,86)"
          },
          bl: 1
        }
      },
      first_detail1: {
        id: "first_detail1",
        zIndex: 3,
        left: 610,
        top: 140,
        width: 300,
        height: 39,
        title: "mask",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "How they impact business goals.",
          fs: 14,
          cl: {
            rgb: "rgb(255,255,255)"
          }
        }
      },
      second_index1: {
        id: "second_index1",
        zIndex: 3,
        left: 557,
        top: 215,
        width: 44,
        height: 44,
        title: "mask",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "02",
          fs: 28,
          cl: {
            rgb: "rgb(255,255,255)"
          },
          bl: 1
        }
      },
      second_title1: {
        id: "second_title1",
        zIndex: 3,
        left: 610,
        top: 210,
        width: 248,
        height: 39,
        title: "mask",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "Technical profile",
          fs: 20,
          cl: {
            rgb: "rgb(244,79,86)"
          },
          bl: 1
        }
      },
      second_detail1: {
        id: "second_detail1",
        zIndex: 3,
        left: 610,
        top: 235,
        width: 300,
        height: 39,
        title: "mask",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "What the technologies are and do.",
          fs: 14,
          cl: {
            rgb: "rgb(255,255,255)"
          }
        }
      },
      third_index1: {
        id: "third_index1",
        zIndex: 3,
        left: 557,
        top: 310,
        width: 44,
        height: 44,
        title: "mask",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "03",
          fs: 28,
          cl: {
            rgb: "rgb(255,255,255)"
          },
          bl: 1
        }
      },
      third_title1: {
        id: "third_title1",
        zIndex: 3,
        left: 610,
        top: 305,
        width: 248,
        height: 39,
        title: "mask",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "Opportunities",
          fs: 20,
          cl: {
            rgb: "rgb(244,79,86)"
          },
          bl: 1
        }
      },
      third_detail1: {
        id: "third_detail1",
        zIndex: 3,
        left: 610,
        top: 330,
        width: 300,
        height: 39,
        title: "mask",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "What benefits and outcomes they drive.",
          fs: 14,
          cl: {
            rgb: "rgb(255,255,255)"
          }
        }
      },
      forth_index1: {
        id: "forth_index1",
        zIndex: 3,
        left: 557,
        top: 405,
        width: 44,
        height: 44,
        title: "mask",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "04",
          fs: 28,
          cl: {
            rgb: "rgb(255,255,255)"
          },
          bl: 1
        }
      },
      forth_title1: {
        id: "forth_title1",
        zIndex: 3,
        left: 610,
        top: 400,
        width: 248,
        height: 39,
        title: "mask",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "Implementation steps",
          fs: 20,
          cl: {
            rgb: "rgb(244,79,86)"
          },
          bl: 1
        }
      },
      forth_detail1: {
        id: "forth_detail1",
        zIndex: 3,
        left: 610,
        top: 425,
        width: 300,
        height: 39,
        title: "mask",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "Action plans for implementation.",
          fs: 14,
          cl: {
            rgb: "rgb(255,255,255)"
          }
        }
      }
    }
  };

  // ../../packages/common-plugin-data/src/Slides/RichText/PAGE3_RICHTEXT_1.ts
  var PAGE3_RICHTEXT_1 = {
    id: "detailContent1",
    zIndex: 3,
    left: 53,
    top: 363,
    width: 273,
    height: 54,
    title: "detailContent1",
    description: "",
    type: 2 /* TEXT */,
    richText: {
      rich: {
        id: "d",
        lists: DEFAULT_LIST_TEST,
        body: {
          blockElements: [
            {
              blockId: "oneParagraph",
              st: 0,
              ed: 59,
              blockType: 0 /* PARAGRAPH */,
              paragraph: {
                bullet: {
                  listId: "testBullet",
                  nestingLevel: 0,
                  textStyle: {
                    fs: 20
                  }
                },
                paragraphStyle: {
                  spaceBelow: 15
                },
                elements: [
                  {
                    eId: "oneElement",
                    st: 0,
                    ed: 15,
                    et: 0 /* TEXT_RUN */,
                    tr: {
                      ct: "Digital Immune System",
                      ts: {
                        fs: 12
                      }
                    }
                  }
                ]
              }
            },
            {
              blockId: "twoParagraph",
              st: 0,
              ed: 59,
              blockType: 0 /* PARAGRAPH */,
              paragraph: {
                bullet: {
                  listId: "testBullet",
                  nestingLevel: 0,
                  textStyle: {
                    fs: 20
                  }
                },
                elements: [
                  {
                    eId: "oneElement",
                    st: 0,
                    ed: 15,
                    et: 0 /* TEXT_RUN */,
                    tr: {
                      ct: "Applied Observability",
                      ts: {
                        fs: 12
                      }
                    }
                  }
                ]
              }
            }
          ]
        },
        documentStyle: {
          pageSize: {
            width: void 0,
            height: void 0
          },
          marginTop: 2,
          marginBottom: 2,
          marginRight: 0,
          marginLeft: 0
        }
      }
    }
  };

  // ../../packages/common-plugin-data/src/Slides/RichText/PAGE3_RICHTEXT_2.ts
  var PAGE3_RICHTEXT_2 = {
    id: "detailContent2",
    zIndex: 3,
    left: 334,
    top: 363,
    width: 273,
    height: 120,
    title: "detailContent2",
    description: "",
    type: 2 /* TEXT */,
    richText: {
      rich: {
        id: "d",
        lists: DEFAULT_LIST_TEST,
        body: {
          blockElements: [
            {
              blockId: "oneParagraph",
              st: 0,
              ed: 59,
              blockType: 0 /* PARAGRAPH */,
              paragraph: {
                bullet: {
                  listId: "testBullet",
                  nestingLevel: 0,
                  textStyle: {
                    fs: 20
                  }
                },
                paragraphStyle: {
                  spaceBelow: 15
                },
                elements: [
                  {
                    eId: "oneElement",
                    st: 0,
                    ed: 15,
                    et: 0 /* TEXT_RUN */,
                    tr: {
                      ct: "combine SaaS, PaaS and IaaS with tailored",
                      ts: {
                        fs: 12
                      }
                    }
                  }
                ]
              }
            },
            {
              blockId: "twoParagraph",
              st: 0,
              ed: 59,
              blockType: 0 /* PARAGRAPH */,
              paragraph: {
                bullet: {
                  listId: "testBullet",
                  nestingLevel: 0,
                  textStyle: {
                    fs: 20
                  }
                },
                elements: [
                  {
                    eId: "oneElement",
                    st: 0,
                    ed: 15,
                    et: 0 /* TEXT_RUN */,
                    tr: {
                      ct: "provides a curated set of tools, capabilities and processes that are packaged for easy consumption by developers and end users",
                      ts: {
                        fs: 12
                      }
                    }
                  }
                ]
              }
            }
          ]
        },
        documentStyle: {
          pageSize: {
            width: void 0,
            height: void 0
          },
          marginTop: 2,
          marginBottom: 2,
          marginRight: 0,
          marginLeft: 0
        }
      }
    }
  };

  // ../../packages/common-plugin-data/src/Slides/RichText/PAGE3_RICHTEXT_3.ts
  var PAGE3_RICHTEXT_3 = {
    id: "detailContent3",
    zIndex: 3,
    left: 652,
    top: 363,
    width: 273,
    height: 130,
    title: "detailContent3",
    description: "",
    type: 2 /* TEXT */,
    richText: {
      rich: {
        id: "d",
        lists: DEFAULT_LIST_TEST,
        body: {
          blockElements: [
            {
              blockId: "oneParagraph",
              st: 0,
              ed: 59,
              blockType: 0 /* PARAGRAPH */,
              paragraph: {
                bullet: {
                  listId: "testBullet",
                  nestingLevel: 0,
                  textStyle: {
                    fs: 20
                  }
                },
                paragraphStyle: {
                  spaceBelow: 15
                },
                elements: [
                  {
                    eId: "oneElement",
                    st: 0,
                    ed: 15,
                    et: 0 /* TEXT_RUN */,
                    tr: {
                      ct: "SuperApps are more than composite applications that aggregate services.",
                      ts: {
                        fs: 12
                      }
                    }
                  }
                ]
              }
            },
            {
              blockId: "twoParagraph",
              st: 0,
              ed: 59,
              blockType: 0 /* PARAGRAPH */,
              paragraph: {
                bullet: {
                  listId: "testBullet",
                  nestingLevel: 0,
                  textStyle: {
                    fs: 20
                  }
                },
                elements: [
                  {
                    eId: "oneElement",
                    st: 0,
                    ed: 15,
                    et: 0 /* TEXT_RUN */,
                    tr: {
                      ct: "Adaptive AI allows for model behavior change post-deployment by using real-time feedback",
                      ts: {
                        fs: 12
                      }
                    }
                  }
                ]
              }
            }
          ]
        },
        documentStyle: {
          pageSize: {
            width: void 0,
            height: void 0
          },
          marginTop: 2,
          marginBottom: 2,
          marginRight: 0,
          marginLeft: 0
        }
      }
    }
  };

  // ../../packages/common-plugin-data/src/Slides/DefaultPages/Page3.ts
  var DEFAULT_THIRD_PAGE = {
    id: "strategic_1",
    pageType: 0 /* SLIDE */,
    zIndex: 1,
    title: "cover",
    description: "this is third page, strategic",
    pageBackgroundFill: {
      rgb: "rgb(255,255,255)"
    },
    pageElements: {
      background1: {
        id: "background1",
        zIndex: 1,
        left: 0,
        top: 0,
        width: 960,
        height: 540,
        title: "mask",
        description: "",
        type: 0 /* SHAPE */,
        shape: {
          shapeType: 2 /* RECTANGLE */,
          text: "",
          shapeProperties: {
            shapeBackgroundFill: {
              rgb: "rgba(237,237,237,1)"
            },
            outline: {
              outlineFill: {
                rgb: "rgba(198,198,198,1)"
              },
              weight: 1
            }
          }
        }
      },
      titleIcon1: {
        id: "titleIcon1",
        zIndex: 2,
        left: 48,
        top: 52,
        width: 117 * 0.3,
        height: 16 * 0.3,
        title: "title Icon",
        description: "",
        type: 1 /* IMAGE */,
        image: {
          imageProperties: {
            contentUrl: "https://minio.cnbabylon.com/univer/slide/title.png"
          }
        }
      },
      title1: {
        id: "title1",
        zIndex: 2,
        left: 44,
        top: 56,
        width: 454,
        height: 50,
        title: "mask",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "Strategic technology trends",
          fs: 32,
          cl: {
            rgb: "rgb(244,79,86)"
          }
        }
      },
      subTitle1: {
        id: "subTitle1",
        zIndex: 2,
        left: 44,
        top: 93,
        width: 889,
        height: 46,
        title: "subTitle",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "We expect the 2023 trends to impact enterprise strategies in the coming three years by enabling organizations to address four key priorities:",
          fs: 18,
          cl: {
            rgb: "rgb(127,127,127)"
          }
        }
      },
      chart1: {
        id: "chart1",
        zIndex: 2,
        left: 53,
        top: 214,
        width: 125,
        height: 58,
        title: "chart1",
        description: "",
        type: 0 /* SHAPE */,
        shape: {
          shapeType: 2 /* RECTANGLE */,
          text: "",
          shapeProperties: {
            shapeBackgroundFill: {
              rgb: "rgb(105,126,146)"
            }
          }
        }
      },
      chartTitle1: {
        id: "chartTitle1",
        zIndex: 3,
        left: 53,
        top: 186,
        width: 84,
        height: 28,
        title: "chartTitle1",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "Optimize",
          fs: 16,
          cl: {
            rgb: "rgb(127,127,127)"
          }
        }
      },
      chartNumber1: {
        id: "chartNumber1",
        zIndex: 3,
        left: 63,
        top: 230,
        width: 61,
        height: 36,
        title: "chartNumber1",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "20%",
          fs: 22,
          cl: {
            rgb: "rgb(255,255,255)"
          }
        }
      },
      chart2: {
        id: "chart2",
        zIndex: 2,
        left: 178,
        top: 214,
        width: 428,
        height: 58,
        title: "chart2",
        description: "",
        type: 0 /* SHAPE */,
        shape: {
          shapeType: 2 /* RECTANGLE */,
          text: "",
          shapeProperties: {
            shapeBackgroundFill: {
              rgb: "rgb(57,74,87)"
            }
          }
        }
      },
      chartTitle2: {
        id: "chartTitle2",
        zIndex: 3,
        left: 178,
        top: 186,
        width: 59,
        height: 28,
        title: "chartTitle2",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "Scale",
          fs: 16,
          cl: {
            rgb: "rgb(127,127,127)"
          }
        }
      },
      chartNumber2: {
        id: "chartNumber2",
        zIndex: 3,
        left: 188,
        top: 230,
        width: 61,
        height: 36,
        title: "chartNumber2",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "50%",
          fs: 22,
          cl: {
            rgb: "rgb(255,255,255)"
          }
        }
      },
      chart3: {
        id: "chart3",
        zIndex: 2,
        left: 605,
        top: 214,
        width: 302,
        height: 58,
        title: "chart3",
        description: "",
        type: 0 /* SHAPE */,
        shape: {
          shapeType: 2 /* RECTANGLE */,
          text: "",
          shapeProperties: {
            shapeBackgroundFill: {
              rgb: "rgb(244,79,86)"
            }
          }
        }
      },
      chartTitle3: {
        id: "chartTitle3",
        zIndex: 3,
        left: 605,
        top: 186,
        width: 74,
        height: 28,
        title: "chartTitle3",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "Scale",
          fs: 16,
          cl: {
            rgb: "rgb(127,127,127)"
          }
        }
      },
      chartNumber3: {
        id: "chartNumber3",
        zIndex: 3,
        left: 615,
        top: 230,
        width: 61,
        height: 36,
        title: "chartNumber3",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "30%",
          fs: 22,
          cl: {
            rgb: "rgb(255,255,255)"
          }
        }
      },
      detailTitle1: {
        id: "detailTitle1",
        zIndex: 3,
        left: 53,
        top: 326,
        width: 152,
        height: 28,
        title: "detailTitle1",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "Theme 1: Optimize",
          fs: 16,
          cl: {
            rgb: "rgb(244,79,86)"
          }
        }
      },
      detailContent1: PAGE3_RICHTEXT_1,
      detailTitle2: {
        id: "detailTitle2",
        zIndex: 3,
        left: 334,
        top: 326,
        width: 129,
        height: 28,
        title: "detailTitle2",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "Theme 2: Scale",
          fs: 16,
          cl: {
            rgb: "rgb(244,79,86)"
          }
        }
      },
      detailContent2: PAGE3_RICHTEXT_2,
      detailTitle3: {
        id: "detailTitle3",
        zIndex: 3,
        left: 652,
        top: 326,
        width: 143,
        height: 28,
        title: "detailTitle3",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "Theme 2: Scale",
          fs: 16,
          cl: {
            rgb: "rgb(244,79,86)"
          }
        }
      },
      detailContent3: PAGE3_RICHTEXT_3
    }
  };

  // ../../packages/common-plugin-data/src/Slides/DefaultPages/Page4.ts
  var worksheetConfig = SLIDE_WORKBOOK_DATA.sheets[SLIDE_WORKBOOK_DATA.sheetOrder[0]];
  var spreadStyles = SLIDE_WORKBOOK_DATA.styles;
  var DEFAULT_FORTH_PAGE = {
    id: "business_1",
    pageType: 0 /* SLIDE */,
    zIndex: 2,
    title: "business",
    description: "this is second page, business",
    pageBackgroundFill: {
      rgb: "rgb(255,255,255)"
    },
    pageElements: {
      background1: {
        id: "background1",
        zIndex: 1,
        left: 0,
        top: 0,
        width: 960,
        height: 540,
        title: "mask",
        description: "",
        type: 0 /* SHAPE */,
        shape: {
          shapeType: 2 /* RECTANGLE */,
          text: "",
          shapeProperties: {
            shapeBackgroundFill: {
              rgb: "rgba(237,237,237,1)"
            },
            outline: {
              outlineFill: {
                rgb: "rgba(198,198,198,1)"
              },
              weight: 1
            }
          }
        }
      },
      titleIcon1: {
        id: "titleIcon1",
        zIndex: 2,
        left: 48,
        top: 52,
        width: 117 * 0.3,
        height: 16 * 0.3,
        title: "title Icon",
        description: "",
        type: 1 /* IMAGE */,
        image: {
          imageProperties: {
            contentUrl: "https://minio.cnbabylon.com/univer/slide/title.png"
          }
        }
      },
      title1: {
        id: "title1",
        zIndex: 2,
        left: 44,
        top: 56,
        width: 454,
        height: 50,
        title: "mask",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "The Business Objectives",
          fs: 32,
          cl: {
            rgb: "rgb(244,79,86)"
          }
        }
      },
      subTitle1: {
        id: "subTitle1",
        zIndex: 2,
        left: 44,
        top: 93,
        width: 889,
        height: 46,
        title: "subTitle",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "What we hope to achieve in the short and long run",
          fs: 18,
          cl: {
            rgb: "rgb(127,127,127)"
          }
        }
      },
      spreadSheet1: {
        id: "table1",
        zIndex: 3,
        left: 30,
        top: 125,
        width: 900,
        height: 400,
        title: "table1",
        description: "",
        type: 3 /* SPREADSHEET */,
        spreadsheet: {
          worksheet: worksheetConfig,
          styles: spreadStyles
        }
      }
    }
  };

  // ../../packages/common-plugin-data/src/Slides/DefaultPages/Page5.ts
  var DEFAULT_FIFTH_PAGE = {
    id: "technology_1",
    pageType: 0 /* SLIDE */,
    zIndex: 2,
    title: "technology",
    description: "this is second page, technology",
    pageBackgroundFill: {
      rgb: "rgb(255,255,255)"
    },
    pageElements: {
      background1: {
        id: "background1",
        zIndex: 1,
        left: 0,
        top: 0,
        width: 960,
        height: 540,
        title: "mask",
        description: "",
        type: 0 /* SHAPE */,
        shape: {
          shapeType: 2 /* RECTANGLE */,
          text: "",
          shapeProperties: {
            shapeBackgroundFill: {
              rgb: "rgba(237,237,237,1)"
            },
            outline: {
              outlineFill: {
                rgb: "rgba(198,198,198,1)"
              },
              weight: 1
            }
          }
        }
      },
      titleIcon1: {
        id: "titleIcon1",
        zIndex: 2,
        left: 48,
        top: 52,
        width: 117 * 0.3,
        height: 16 * 0.3,
        title: "title Icon",
        description: "",
        type: 1 /* IMAGE */,
        image: {
          imageProperties: {
            contentUrl: "https://minio.cnbabylon.com/univer/slide/title.png"
          }
        }
      },
      title1: {
        id: "title1",
        zIndex: 2,
        left: 44,
        top: 56,
        width: 454,
        height: 50,
        title: "mask",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "Sustainable Technology",
          fs: 32,
          cl: {
            rgb: "rgb(244,79,86)"
          }
        }
      },
      subTitle1: {
        id: "subTitle1",
        zIndex: 2,
        left: 44,
        top: 93,
        width: 889,
        height: 46,
        title: "subTitle",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "Delivering technology alone will not be enough in 2023",
          fs: 18,
          cl: {
            rgb: "rgb(127,127,127)"
          }
        }
      },
      picture1: {
        id: "picture1",
        zIndex: 2,
        left: 53,
        top: 151,
        width: 258,
        height: 156,
        title: "title Icon",
        description: "",
        type: 1 /* IMAGE */,
        image: {
          imageProperties: {
            contentUrl: "https://minio.cnbabylon.com/univer/slide/P1.png"
          }
        }
      },
      picture2: {
        id: "picture2",
        zIndex: 2,
        left: 315,
        top: 151,
        width: 241,
        height: 156,
        title: "title Icon",
        description: "",
        type: 1 /* IMAGE */,
        image: {
          imageProperties: {
            contentUrl: "https://minio.cnbabylon.com/univer/slide/P2.png"
          }
        }
      },
      picture3: {
        id: "picture3",
        zIndex: 2,
        left: 53,
        top: 310,
        width: 258,
        height: 156,
        title: "title Icon",
        description: "",
        type: 1 /* IMAGE */,
        image: {
          imageProperties: {
            contentUrl: "https://minio.cnbabylon.com/univer/slide/P3.png"
          }
        }
      },
      picture4: {
        id: "picture4",
        zIndex: 2,
        left: 310,
        top: 315,
        width: 241,
        height: 156,
        title: "title Icon",
        description: "",
        type: 1 /* IMAGE */,
        image: {
          imageProperties: {
            contentUrl: "https://minio.cnbabylon.com/univer/slide/P4.jpg"
          }
        }
      },
      detailTitle1: {
        id: "detailTitle1",
        zIndex: 3,
        left: 580,
        top: 138,
        width: 75,
        height: 28,
        title: "detailTitle1",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "In short:",
          fs: 16,
          cl: {
            rgb: "rgb(244,79,86)"
          }
        }
      },
      detailContent1: {
        id: "detailContent1",
        zIndex: 3,
        left: 580,
        top: 167,
        width: 373,
        height: 81,
        title: "detailContent1",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "Investments in sustainable technology also have the potential to create greater operational resiliency and financial performance, while providing new avenues for growth.",
          fs: 12,
          cl: {
            rgb: "rgb(127,127,127)"
          }
        }
      },
      listTitle1: {
        id: "listTitle1",
        zIndex: 3,
        left: 580,
        top: 138,
        width: 75,
        height: 28,
        title: "listTitle1",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "In short:",
          fs: 16,
          cl: {
            rgb: "rgb(244,79,86)"
          }
        }
      },
      listTitlePicture1: {
        id: "listTitlePicture1",
        zIndex: 2,
        left: 572,
        top: 261,
        width: 53,
        height: 53,
        title: "title Icon",
        description: "",
        type: 1 /* IMAGE */,
        image: {
          imageProperties: {
            contentUrl: "https://minio.cnbabylon.com/univer/slide/icon1.png"
          }
        }
      },
      listContent1: {
        id: "listContent1",
        zIndex: 3,
        left: 637,
        top: 265,
        width: 309,
        height: 61,
        title: "listContent1",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "Gartner\u2019s Top 10 Strategic Technology Trends will help fulfill your business needs to optimize, scale or pioneer.",
          fs: 12,
          cl: {
            rgb: "rgb(127,127,127)"
          }
        }
      },
      listTitlePicture2: {
        id: "listTitlePicture2",
        zIndex: 2,
        left: 572,
        top: 341,
        width: 53,
        height: 53,
        title: "title Icon",
        description: "",
        type: 1 /* IMAGE */,
        image: {
          imageProperties: {
            contentUrl: "https://minio.cnbabylon.com/univer/slide/icon2.png"
          }
        }
      },
      listContent2: {
        id: "listContent2",
        zIndex: 3,
        left: 637,
        top: 345,
        width: 309,
        height: 61,
        title: "listContent2",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "The trends allow you to align your technology innovation with the future strategic objectives of your enterprise.",
          fs: 12,
          cl: {
            rgb: "rgb(127,127,127)"
          }
        }
      },
      listTitlePicture3: {
        id: "listTitlePicture3",
        zIndex: 2,
        left: 572,
        top: 421,
        width: 53,
        height: 53,
        title: "title Icon",
        description: "",
        type: 1 /* IMAGE */,
        image: {
          imageProperties: {
            contentUrl: "https://minio.cnbabylon.com/univer/slide/icon3.png"
          }
        }
      },
      listContent3: {
        id: "listContent3",
        zIndex: 3,
        left: 637,
        top: 425,
        width: 309,
        height: 61,
        title: "listContent3",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "Investments in sustainable technology provide operational and financial benefits, and can create growth opportunities.",
          fs: 12,
          cl: {
            rgb: "rgb(127,127,127)"
          }
        }
      }
    }
  };

  // ../../packages/common-plugin-data/src/Slides/DefaultPages/Page6.ts
  var DEFAULT_SIXTH_PAGE = {
    id: "richText_1",
    pageType: 0 /* SLIDE */,
    zIndex: 2,
    title: "business",
    description: "this is fix page, rich text",
    pageBackgroundFill: {
      rgb: "rgb(255,255,255)"
    },
    pageElements: {
      background1: {
        id: "background1",
        zIndex: 1,
        left: 0,
        top: 0,
        width: 960,
        height: 540,
        title: "mask",
        description: "",
        type: 0 /* SHAPE */,
        shape: {
          shapeType: 2 /* RECTANGLE */,
          text: "",
          shapeProperties: {
            shapeBackgroundFill: {
              rgb: "rgba(237,237,237,1)"
            },
            outline: {
              outlineFill: {
                rgb: "rgba(198,198,198,1)"
              },
              weight: 1
            }
          }
        }
      },
      titleIcon1: {
        id: "titleIcon1",
        zIndex: 2,
        left: 48,
        top: 52,
        width: 117 * 0.3,
        height: 16 * 0.3,
        title: "title Icon",
        description: "",
        type: 1 /* IMAGE */,
        image: {
          imageProperties: {
            contentUrl: "https://minio.cnbabylon.com/univer/slide/title.png"
          }
        }
      },
      title1: {
        id: "title1",
        zIndex: 2,
        left: 44,
        top: 56,
        width: 454,
        height: 50,
        title: "mask",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "The Work-like Editor",
          fs: 32,
          cl: {
            rgb: "rgb(244,79,86)"
          }
        }
      },
      subTitle1: {
        id: "subTitle1",
        zIndex: 2,
        left: 44,
        top: 93,
        width: 889,
        height: 46,
        title: "subTitle",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "Open source WYSIWYG editor built for the modern web",
          fs: 18,
          cl: {
            rgb: "rgb(127,127,127)"
          }
        }
      },
      document: {
        id: "table1",
        zIndex: 3,
        left: 30,
        top: 125,
        width: 900,
        height: 400,
        title: "table1",
        description: "",
        type: 4 /* DOCUMENT */,
        document: DEFAULT_DOCUMENT_DATA_EN
      }
    }
  };

  // ../../packages/common-plugin-data/src/Slides/UNLIMITED_SLIDE_DATA.ts
  function generateUnlimitedSlideData(ratio = 1, slideData) {
    const result = {
      id: "slide_unlimited",
      title: "UniverSlide",
      pageSize: {
        width: 960,
        height: 540
      },
      body: {
        pages: {
          unlimited_1: {
            id: "unlimited_1",
            pageType: 0 /* SLIDE */,
            zIndex: 1,
            title: "unlimited",
            description: "this is seven page, unlimited",
            pageBackgroundFill: {
              rgb: "rgb(255,255,255)"
            },
            pageElements: {
              background1: {
                id: "background1",
                zIndex: 0,
                left: 0,
                top: 0,
                width: 960,
                height: 540,
                title: "background",
                description: "",
                type: 1 /* IMAGE */,
                image: {
                  imageProperties: {
                    contentUrl: "https://minio.cnbabylon.com/univer/slide/Picture1.jpg"
                  }
                }
              },
              mask1: {
                id: "mask1",
                zIndex: 1,
                left: 0,
                top: 0,
                width: 960,
                height: 540,
                title: "mask",
                description: "",
                type: 0 /* SHAPE */,
                shape: {
                  shapeType: 2 /* RECTANGLE */,
                  text: "",
                  shapeProperties: {
                    shapeBackgroundFill: {
                      rgb: "rgba(0,0,0,0.7)"
                    }
                  }
                }
              },
              text1: {
                id: "text1",
                zIndex: 2,
                left: 300,
                top: 200,
                width: 400,
                height: 140,
                title: "mask",
                description: "",
                type: 2 /* TEXT */,
                richText: {
                  text: "Univer slide",
                  fs: 64,
                  cl: {
                    rgb: "rgb(244,79,86)"
                  },
                  bl: 1
                }
              },
              centerRect1: {
                id: "centerRect1",
                zIndex: 1,
                left: 378,
                top: 0,
                width: 204,
                height: 144,
                title: "mask",
                description: "",
                type: 0 /* SHAPE */,
                shape: {
                  shapeType: 2 /* RECTANGLE */,
                  text: "",
                  shapeProperties: {
                    shapeBackgroundFill: {
                      rgb: "rgb(244,79,86)"
                    }
                  }
                }
              },
              year1: {
                id: "year1",
                zIndex: 2,
                left: 430,
                top: 42,
                width: 100,
                height: 40,
                title: "mask",
                description: "",
                type: 2 /* TEXT */,
                richText: {
                  text: "2022",
                  fs: 48,
                  cl: {
                    rgb: "rgb(255,255,255)"
                  },
                  bl: 1
                }
              },
              content1: {
                id: "content1",
                zIndex: 2,
                left: 80,
                top: 300,
                width: 780,
                height: 140,
                title: "mask",
                description: "",
                type: 2 /* TEXT */,
                richText: {
                  text: "The concepts national income and national product have roughly the same value and can be used interchangeably if our interest is in their sum total which is measured as the market value of the total output of goods and services of an economy in a given period, usually a year.",
                  fs: 14,
                  cl: {
                    rgb: "rgb(255,255,255)"
                  },
                  bl: 1
                }
              }
            }
          },
          catalog_1: DEFAULT_SECOND_PAGE,
          strategic_1: DEFAULT_THIRD_PAGE,
          technology_1: DEFAULT_FIFTH_PAGE,
          richText_1: DEFAULT_SIXTH_PAGE,
          business_1: DEFAULT_FORTH_PAGE
        },
        pageOrder: ["unlimited_1", "catalog_1", "strategic_1", "technology_1", "richText_1", "business_1"]
      }
    };
    if (slideData) {
      result.body.pages.unlimited_1.pageElements.slide = {
        id: "slide",
        zIndex: 3,
        left: 960 * (1 - ratio) / 2,
        top: 540 * (1 - ratio) / 2,
        width: 960,
        height: 540,
        scaleX: ratio,
        scaleY: ratio,
        title: "slide",
        description: "",
        type: 5 /* SLIDE */,
        slide: slideData
      };
    }
    return result;
  }

  // ../../packages/common-plugin-data/src/Slides/DefaultPages/Page7.ts
  var DEFAULT_SEVEN_PAGE = {
    id: "unlimited_1",
    pageType: 0 /* SLIDE */,
    zIndex: 1,
    title: "unlimited",
    description: "this is seven page, unlimited",
    pageBackgroundFill: {
      rgb: "rgb(255,255,255)"
    },
    pageElements: {
      background1: {
        id: "background1",
        zIndex: 0,
        left: 0,
        top: 0,
        width: 960,
        height: 540,
        title: "background",
        description: "",
        type: 1 /* IMAGE */,
        image: {
          imageProperties: {
            contentUrl: "https://minio.cnbabylon.com/univer/slide/Picture1.jpg"
          }
        }
      },
      mask1: {
        id: "mask1",
        zIndex: 1,
        left: 0,
        top: 0,
        width: 960,
        height: 540,
        title: "mask",
        description: "",
        type: 0 /* SHAPE */,
        shape: {
          shapeType: 2 /* RECTANGLE */,
          text: "",
          shapeProperties: {
            shapeBackgroundFill: {
              rgb: "rgba(0,0,0,0.7)"
            }
          }
        }
      },
      text1: {
        id: "text1",
        zIndex: 2,
        left: 300,
        top: 200,
        width: 400,
        height: 140,
        title: "mask",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "Univer slide",
          fs: 64,
          cl: {
            rgb: "rgb(244,79,86)"
          },
          bl: 1
        }
      },
      centerRect1: {
        id: "centerRect1",
        zIndex: 1,
        left: 378,
        top: 0,
        width: 204,
        height: 144,
        title: "mask",
        description: "",
        type: 0 /* SHAPE */,
        shape: {
          shapeType: 2 /* RECTANGLE */,
          text: "",
          shapeProperties: {
            shapeBackgroundFill: {
              rgb: "rgb(244,79,86)"
            }
          }
        }
      },
      year1: {
        id: "year1",
        zIndex: 2,
        left: 430,
        top: 42,
        width: 100,
        height: 40,
        title: "mask",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "2022",
          fs: 48,
          cl: {
            rgb: "rgb(255,255,255)"
          },
          bl: 1
        }
      },
      content1: {
        id: "content1",
        zIndex: 2,
        left: 80,
        top: 300,
        width: 780,
        height: 140,
        title: "mask",
        description: "",
        type: 2 /* TEXT */,
        richText: {
          text: "The concepts national income and national product have roughly the same value and can be used interchangeably if our interest is in their sum total which is measured as the market value of the total output of goods and services of an economy in a given period, usually a year.",
          fs: 14,
          cl: {
            rgb: "rgb(255,255,255)"
          },
          bl: 1
        }
      },
      slide1: {
        id: "slide",
        zIndex: 3,
        left: 960 * (1 - 0.9) / 2,
        top: 540 * (1 - 0.9) / 2,
        width: 960,
        height: 540,
        scaleX: 0.9,
        scaleY: 0.9,
        title: "slide",
        description: "",
        type: 5 /* SLIDE */,
        slide: generateUnlimitedSlideData(
          0.9,
          generateUnlimitedSlideData(
            0.9,
            generateUnlimitedSlideData(
              0.9,
              generateUnlimitedSlideData(
                0.9,
                generateUnlimitedSlideData(
                  0.9,
                  generateUnlimitedSlideData(0.9, generateUnlimitedSlideData(0.9, generateUnlimitedSlideData(0.9, generateUnlimitedSlideData(0.9))))
                )
              )
            )
          )
        )
      }
    }
  };

  // src/main.tsx
  var univer = new Univer();
  univer.install(new RenderEngine());
  var universheet = UniverSheet.newInstance(DEFAULT_WORKBOOK_DATA_DEMO);
  univer.addUniverSheet(universheet);
  universheet.installPlugin(new SheetPlugin());
  univer.install(
    new SheetUIPlugin3({
      container: "universheet"
    })
  );
  FormulaPlugin.create(DEFAULT_FORMULA_DATA_DEMO1).installTo(universheet);
})();
/*! Bundled license information:

numeral/numeral.js:
  (*! @preserve
   * numeral.js
   * version : 2.0.6
   * author : Adam Draper
   * license : MIT
   * http://adamwdraper.github.com/Numeral-js/
   *)

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

reflect-metadata/Reflect.js:
  (*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

css-vars-ponyfill/dist/css-vars-ponyfill.esm.js:
  (*!
   * css-vars-ponyfill
   * v2.4.8
   * https://jhildenbiddle.github.io/css-vars-ponyfill/
   * (c) 2018-2022 John Hildenbiddle <http://hildenbiddle.com>
   * MIT license
   *)
  (*!
   * get-css-data
   * v2.1.0
   * https://github.com/jhildenbiddle/get-css-data
   * (c) 2018-2022 John Hildenbiddle <http://hildenbiddle.com>
   * MIT license
   *)
  (**
   * Gets CSS data from <style> and <link> nodes (including @imports), then
   * returns data in order processed by DOM. Allows specifying nodes to
   * include/exclude and filtering CSS data using RegEx.
   *
   * @preserve
   * @param {object}   [options] The options object
   * @param {object}   [options.rootElement=document] Root element to traverse for
   *                   <link> and <style> nodes.
   * @param {string}   [options.include] CSS selector matching <link> and <style>
   *                   nodes to include
   * @param {string}   [options.exclude] CSS selector matching <link> and <style>
   *                   nodes to exclude
   * @param {object}   [options.filter] Regular expression used to filter node CSS
   *                   data. Each block of CSS data is tested against the filter,
   *                   and only matching data is included.
   * @param {boolean}  [options.skipDisabled=true] Determines if disabled
   *                   stylesheets will be skipped while collecting CSS data.
   * @param {boolean}  [options.useCSSOM=false] Determines if CSS data will be
   *                   collected from a stylesheet's runtime values instead of its
   *                   text content. This is required to get accurate CSS data
   *                   when a stylesheet has been modified using the deleteRule()
   *                   or insertRule() methods because these modifications will
   *                   not be reflected in the stylesheet's text content.
   * @param {function} [options.onBeforeSend] Callback before XHR is sent. Passes
   *                   1) the XHR object, 2) source node reference, and 3) the
   *                   source URL as arguments.
   * @param {function} [options.onSuccess] Callback on each CSS node read. Passes
   *                   1) CSS text, 2) source node reference, and 3) the source
   *                   URL as arguments.
   * @param {function} [options.onError] Callback on each error. Passes 1) the XHR
   *                   object for inspection, 2) soure node reference, and 3) the
   *                   source URL that failed (either a <link> href or an @import)
   *                   as arguments
   * @param {function} [options.onComplete] Callback after all nodes have been
   *                   processed. Passes 1) concatenated CSS text, 2) an array of
   *                   CSS text in DOM order, and 3) an array of nodes in DOM
   *                   order as arguments.
   *
   * @example
   *
   *   getCssData({
   *     rootElement : document,
   *     include     : 'style,link[rel="stylesheet"]',
   *     exclude     : '[href="skip.css"]',
   *     filter      : /red/,
   *     skipDisabled: true,
   *     useCSSOM    : false,
   *     onBeforeSend(xhr, node, url) {
   *       // ...
   *     }
   *     onSuccess(cssText, node, url) {
   *       // ...
   *     }
   *     onError(xhr, node, url) {
   *       // ...
   *     },
   *     onComplete(cssText, cssArray, nodeArray) {
   *       // ...
   *     }
   *   });
   *)
  (**
   * Fetches, parses, and transforms CSS custom properties from specified
   * <style> and <link> elements into static values, then appends a new <style>
   * element with static values to the DOM to provide CSS custom property
   * compatibility for legacy browsers. Also provides a single interface for
   * live updates of runtime values in both modern and legacy browsers.
   *
   * @preserve
   * @param {object}   [options] Options object
   * @param {object}   [options.rootElement=document] Root element to traverse for
   *                   <link> and <style> nodes
   * @param {boolean}  [options.shadowDOM=false] Determines if shadow DOM <link>
   *                   and <style> nodes will be processed.
   * @param {string}   [options.include="style,link[rel=stylesheet]"] CSS selector
   *                   matching <link re="stylesheet"> and <style> nodes to
   *                   process
   * @param {string}   [options.exclude] CSS selector matching <link
   *                   rel="stylehseet"> and <style> nodes to exclude from those
   *                   matches by options.include
   * @param {object}   [options.variables] A map of custom property name/value
   *                   pairs. Property names can omit or include the leading
   *                   double-hyphen (), and values specified will override
   *                   previous values
   * @param {boolean}  [options.onlyLegacy=true] Determines if the ponyfill will
   *                   only generate legacy-compatible CSS in browsers that lack
   *                   native support (i.e., legacy browsers)
   * @param {boolean}  [options.preserveStatic=true] Determines if CSS
   *                   declarations that do not reference a custom property will
   *                   be preserved in the transformed CSS
   * @param {boolean}  [options.preserveVars=false] Determines if CSS custom
   *                   property declarations will be preserved in the transformed
   *                   CSS
   * @param {boolean}  [options.silent=false] Determines if warning and error
   *                   messages will be displayed on the console
   * @param {boolean}  [options.updateDOM=true] Determines if the ponyfill will
   *                   update the DOM after processing CSS custom properties
   * @param {boolean}  [options.updateURLs=true] Determines if relative url()
   *                   paths will be converted to absolute urls in external CSS
   * @param {boolean}  [options.watch=false] Determines if a MutationObserver will
   *                   be created that will execute the ponyfill when a <link> or
   *                   <style> DOM mutation is observed
   * @param {function} [options.onBeforeSend] Callback before XHR is sent. Passes
   *                   1) the XHR object, 2) source node reference, and 3) the
   *                   source URL as arguments
   * @param {function} [options.onError] Callback after a CSS parsing error has
   *                   occurred or an XHR request has failed. Passes 1) an error
   *                   message, and 2) source node reference, 3) xhr, and 4 url as
   *                   arguments.
   * @param {function} [options.onWarning] Callback after each CSS parsing warning
   *                   has occurred. Passes 1) a warning message as an argument.
   * @param {function} [options.onSuccess] Callback after CSS data has been
   *                   collected from each node and before CSS custom properties
   *                   have been transformed. Allows modifying the CSS data before
   *                   it is transformed by returning any string value (or false
   *                   to skip). Passes 1) CSS text, 2) source node reference, and
   *                   3) the source URL as arguments.
   * @param {function} [options.onComplete] Callback after all CSS has been
   *                   processed, legacy-compatible CSS has been generated, and
   *                   (optionally) the DOM has been updated. Passes 1) a CSS
   *                   string with CSS variable values resolved, 2) an array of
   *                   output <style> node references that have been appended to
   *                   the DOM, 3) an object containing all custom properies names
   *                   and values, and 4) the ponyfill execution time in
   *                   milliseconds.
   * @param {function} [options.onFinally] Callback in modern and legacy browsers
   *                   after the ponyfill has finished all tasks. Passes 1) a
   *                   boolean indicating if the last ponyfill call resulted in a
   *                   style change, 2) a boolean indicating if the current
   *                   browser provides native support for CSS custom properties,
   *                   and 3) the ponyfill execution time in milliseconds.
   * @example
   *
   *   cssVars({
   *     rootElement   : document,
   *     shadowDOM     : false,
   *     include       : 'style,link[rel="stylesheet"]',
   *     exclude       : '',
   *     variables     : {},
   *     onlyLegacy    : true,
   *     preserveStatic: true,
   *     preserveVars  : false,
   *     silent        : false,
   *     updateDOM     : true,
   *     updateURLs    : true,
   *     watch         : false,
   *     onBeforeSend(xhr, node, url) {},
   *     onError(message, node, xhr, url) {},
   *     onWarning(message) {},
   *     onSuccess(cssText, node, url) {},
   *     onComplete(cssText, styleNode, cssVariables, benchmark) {},
   *     onFinally(hasChanged, hasNativeSupport, benchmark)
   *   });
   *)
*/
